<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="simple life"><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification" content="pte8o83UGG"><title>openwrt Makefile scan.mk 详解 | LITREILY</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><script>var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?d55250b3059d32736607d30baa6e0ca2";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="LITREILY" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">LITREILY</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/notes/">笔记</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">openwrt Makefile scan.mk 详解</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/01/15/mk-scan/">2021-01-15</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/Embedded/">Embedded</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p><code>openwrt</code> 中的 <code>include/scan.mk</code> 用于扫描项目 <code>package</code>, <code>target</code> 目录信息，并将扫描结果存入 <code>tmp</code> 目录。这个扫描过程几乎是 openwrt 所有目标生成的前提。也就是说，无论使用 <code>make</code> 编译 <code>openwrt</code> 哪个部分的代码，都会通过 <code>scan.mk</code> 生成必要的临时文件，这是编译其它目录的大前提。</p>
<p>举例说明，我们指定编译某个 <code>package</code> 时，如 <code>package/utils/demo</code>，<code>make</code> 根据层层 <code>Makefile</code> 会去寻找该 <code>package</code> 的路径，而这个路径信息就是通过 <code>scan.mk</code> 扫描后存入了 <code>tmp</code> 目录。这样有什么好处呢? 我完全可以手动执行 <code>make package/utils/demo/compile</code> 不是吗？</p>
<p>的确如此，但是我们不可能每次都去写长串的路径，通过 <code>tmp</code> 目录的信息，不管 <code>package</code> 对应目录在哪， <code>package/demo</code> 也好， <code>package/utils/demo</code> 也罢， <code>package/utils/test/demo</code> 也无所谓，我们都可以执行 <code>make package/demo/compile</code> 进行编译，<code>make</code> 会根据 <code>tmp</code> 目录里保存的映射关系自动查找到对应目录，非常方便。</p>
<p><code>openwrt</code> 的 <code>Makefile</code> 体系非常庞大，通过首次生成 <code>package</code>、<code>target</code> 信息到 <code>tmp</code> 目录，可以简化编译流程，节省编译时间。这篇文章就来详细讲述一下 <code>scan.mk</code> 的扫描过程。</p>
<h2 id="prepare-tmpinfo"><a href="#prepare-tmpinfo" class="headerlink" title="prepare-tmpinfo"></a>prepare-tmpinfo</h2><p>在讲述 <code>scan.mk</code> 之前，我们需要知道 <code>scan.mk</code> 在哪里被调用到，答案是 <code>toplevel.mk</code> 的 <code>prepare-tmpinfo</code> 目标，这个目标几乎是 <code>toplevel.mk</code> 中其它目标都会包含的依赖项。<code>defconfig</code>, <code>oldconfig</code>, <code>menuconfig</code>, <code>prereq</code>, <code>config</code> 等都会依赖它。</p>
<p>顾名思义，<code>prepare-tmpinfo</code> 就是用来准备 <code>tmp</code> 信息的，它没有依赖项，<code>FORCE</code> 代表强制执行其指令。在它的指令中就会调用到 <code>scan.mk</code> 了。</p>
<pre><code class="makefile">prepare-tmpinfo: FORCE
    @+$(MAKE) -r -s staging_dir/host/.prereq-build $(PREP_MK)
    mkdir -p tmp/info
    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;
    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;
    for type in package target; do \
        f=tmp/.$$&#123;type&#125;info; t=tmp/.config-$$&#123;type&#125;.in; \
        [ &quot;$$t&quot; -nt &quot;$$f&quot; ] || ./scripts/$$&#123;type&#125;-metadata.pl $(_ignore) config &quot;$$f&quot; &gt; &quot;$$t&quot; || &#123; rm -f &quot;$$t&quot;; echo &quot;Failed to build $$t&quot;; false; break; &#125;; \
    done
    [ tmp/.config-feeds.in -nt tmp/.packageauxvars ] || ./scripts/feeds feed_config &gt; tmp/.config-feeds.in
    ./scripts/package-metadata.pl mk tmp/.packageinfo &gt; tmp/.packagedeps || &#123; rm -f tmp/.packagedeps; false; &#125;
    ./scripts/package-metadata.pl pkgaux tmp/.packageinfo &gt; tmp/.packageauxvars || &#123; rm -f tmp/.packageauxvars; false; &#125;
    ./scripts/package-metadata.pl usergroup tmp/.packageinfo &gt; tmp/.packageusergroup || &#123; rm -f tmp/.packageusergroup; false; &#125;
    touch $(TOPDIR)/tmp/.build
</code></pre>
<p>其中有两行调用了 <code>scan.mk</code>.</p>
<pre><code class="makefile">    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;
    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;
</code></pre>
<p>通过分析主 Makefile 和 include/verbose.mk 可以知道 <code>$(_SINGLE)$(NO_TRACE_MAKE)</code> 对应的是：</p>
<pre><code class="bash">export MAKEFLAGS= ;make V=ss
</code></pre>
<p>那么以上指令解析后就是：</p>
<pre><code class="bash">export MAKEFLAGS= ;make V=ss -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;
export MAKEFLAGS= ;make V=ss -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;
</code></pre>
<blockquote>
<p><strong>说明：</strong> make 的 <code>-s</code> 指令代表 silent， 会将所有输出都屏蔽掉，我们在分析的时候可以把 <code>-s</code> 去掉，并换成 <code>-d</code> ，这样可以看到更详细的 log.</p>
</blockquote>
<p>好啦，现在知道 scan.mk 的入口啦，就是 <code>prepare-tmpinfo</code> 的指令之一。那么我们怎么触发这两条指令呢？很简单，因为只要执行make就会调用这个依赖，我们可以通过 <code>make defconfig</code> 触发，为了获取更详细的信息，可以使用以下指令：</p>
<pre><code class="bash">make -d V=s DEBUG=dtlrv defconfig &gt; log 2&gt;&amp;1
</code></pre>
<p>这样就将编译信息保存到文件 log 中了，方便分析执行过程。<a href="https://www.litreily.top/2020/12/29/make-defconfig/">make defconfig</a> 的主要流程在之前已有文章单独讲述过，不再赘述，本文主要来分析</p>
<pre><code class="bash">make V=ss -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;
</code></pre>
<p>这条指令的执行过程，以深入理解 openwrt scan.mk 的扫描过程。</p>
<blockquote>
<p>当然，我们也可以直接调用以上指令，而不用 <code>make defconfig</code>, 只不过需要添加两个全局变量<br>-- <code>SCAN_COOKIE=&quot;123456&quot;</code><br>-- <code>TOPDIR=&quot;/home/litreily/openwrt&quot;</code></p>
</blockquote>
<pre><code class="bash">make V=ss -j1 -r -d -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot; SCAN_COOKIE=&quot;123456&quot; TOPDIR=&quot;/home/litreily/openwrt&quot;
</code></pre>
<p><code>scan.mk</code> 编译过程与使用 <code>make defconfig</code> 是类似的。</p>
<h2 id="scan-mk"><a href="#scan-mk" class="headerlink" title="scan.mk"></a>scan.mk</h2><p>进入正题，先附上完整的 <a target="_blank" rel="noopener" href="https://github.com/openwrt/openwrt/blob/master/include/scan.mk">scan.mk</a> , 源自 GitHub openwrt.</p>
<pre><code class="ruby">include $(TOPDIR)/include/verbose.mk
TMP_DIR:=$(TOPDIR)/tmp

all: $(TMP_DIR)/.$(SCAN_TARGET)

SCAN_TARGET ?= packageinfo
SCAN_NAME ?= package
SCAN_DIR ?= package
TARGET_STAMP:=$(TMP_DIR)/info/.files-$(SCAN_TARGET).stamp
FILELIST:=$(TMP_DIR)/info/.files-$(SCAN_TARGET)-$(SCAN_COOKIE)
OVERRIDELIST:=$(TMP_DIR)/info/.overrides-$(SCAN_TARGET)-$(SCAN_COOKIE)

export PATH:=$(TOPDIR)/staging_dir/host/bin:$(PATH)

define feedname
$(if $(patsubst feeds/%,,$(1)),,$(word 2,$(subst /, ,$(1))))
endef

ifeq ($(SCAN_NAME),target)
  SCAN_DEPS=image/Makefile profiles/*.mk $(TOPDIR)/include/kernel*.mk $(TOPDIR)/include/target.mk image/*.mk
else
  SCAN_DEPS=$(TOPDIR)/include/package*.mk
ifneq ($(call feedname,$(SCAN_DIR)),)
  SCAN_DEPS += $(TOPDIR)/feeds/$(call feedname,$(SCAN_DIR))/*.mk
endif
endif

ifeq ($(IS_TTY),1)
  ifneq ($(strip $(NO_COLOR)),1)
    define progress
        printf &quot;\033[M\r$(1)&quot; &gt;&amp;2;
    endef
  else
    define progress
        printf &quot;\r$(1)&quot; &gt;&amp;2;
    endef
  endif
else
  define progress
        :;
  endef
endif

define PackageDir
  $(TMP_DIR)/.$(SCAN_TARGET): $(TMP_DIR)/info/.$(SCAN_TARGET)-$(1)
  $(TMP_DIR)/info/.$(SCAN_TARGET)-$(1): $(SCAN_DIR)/$(2)/Makefile $(foreach DEP,$(DEPS_$(SCAN_DIR)/$(2)/Makefile) $(SCAN_DEPS),$(wildcard $(if $(filter /%,$(DEP)),$(DEP),$(SCAN_DIR)/$(2)/$(DEP))))
        &#123; \
                $$(call progress,Collecting $(SCAN_NAME) info: $(SCAN_DIR)/$(2)) \
                echo Source-Makefile: $(SCAN_DIR)/$(2)/Makefile; \
                $(if $(3),echo Override: $(3),true); \
                $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,$(2))&quot; -C $(SCAN_DIR)/$(2) $(SCAN_MAKEOPTS) 2&gt;/dev/null || &#123; \
                        mkdir -p &quot;$(TOPDIR)/logs/$(SCAN_DIR)/$(2)&quot;; \
                        $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,$(2))&quot; -C $(SCAN_DIR)/$(2) $(SCAN_MAKEOPTS) &gt; $(TOPDIR)/logs/$(SCAN_DIR)/$(2)/dump.txt 2&gt;&amp;1; \
                        $$(call progress,ERROR: please fix $(SCAN_DIR)/$(2)/Makefile - see logs/$(SCAN_DIR)/$(2)/dump.txt for details\n) \
                        rm -f $$@; \
                &#125;; \
                echo; \
        &#125; &gt; $$@.tmp
        mv $$@.tmp $$@
endef

$(OVERRIDELIST):
        rm -f $(TMP_DIR)/info/.overrides-$(SCAN_TARGET)-*
        touch $@

ifeq ($(SCAN_NAME),target)
  GREP_STRING=BuildTarget
else
  GREP_STRING=(Build/DefaultTargets|BuildPackage|KernelPackage)
endif

$(FILELIST): $(OVERRIDELIST)
        rm -f $(TMP_DIR)/info/.files-$(SCAN_TARGET)-*
        find -L $(SCAN_DIR) $(SCAN_EXTRA) -mindepth 1 $(if $(SCAN_DEPTH),-maxdepth $(SCAN_DEPTH)) -name Makefile | xargs grep -aHE &#39;call $(GREP_STRING)&#39; | sed -e &#39;s#^$(SCAN_DIR)/##&#39; -e &#39;s#/Makefile:.*##&#39; | uniq | awk -v of=$(OVERRIDELIST) -f include/scan.awk &gt; $@

$(TMP_DIR)/info/.files-$(SCAN_TARGET).mk: $(FILELIST)
        ( \
                cat $&lt; | awk &#39;&#123;print &quot;$(SCAN_DIR)/&quot; $$0 &quot;/Makefile&quot; &#125;&#39; | xargs grep -HE &#39;^ *SCAN_DEPS *= *&#39; | awk -F: &#39;&#123; gsub(/^.*DEPS *= */, &quot;&quot;, $$2); print &quot;DEPS_&quot; $$1 &quot;=&quot; $$2 &#125;&#39;; \
                awk -F/ -v deps=&quot;$$DEPS&quot; -v of=&quot;$(OVERRIDELIST)&quot; &#39; \
                BEGIN &#123; \
                        while (getline &lt; (of)) \
                                override[$$NF]=$$0; \
                        close(of) \
                &#125; \
                &#123; \
                        info=$$0; \
                        gsub(/\//, &quot;_&quot;, info); \
                        dir=$$0; \
                        pkg=&quot;&quot;; \
                        if($$NF in override) \
                                pkg=override[$$NF]; \
                        print &quot;$$(eval $$(call PackageDir,&quot; info &quot;,&quot; dir &quot;,&quot; pkg &quot;))&quot;; \
                &#125; &#39; &lt; $&lt;; \
                true; \
        ) &gt; $@.tmp
        mv $@.tmp $@

-include $(TMP_DIR)/info/.files-$(SCAN_TARGET).mk

$(TARGET_STAMP)::
        +( \
                $(NO_TRACE_MAKE) $(FILELIST); \
                MD5SUM=$$(cat $(FILELIST) $(OVERRIDELIST) | mkhash md5 | awk &#39;&#123;print $$1&#125;&#39;); \
                [ -f &quot;$@.$$MD5SUM&quot; ] || &#123; \
                        rm -f $@.*; \
                        touch $@.$$MD5SUM; \
                        touch $@; \
                &#125; \
        )

$(TMP_DIR)/.$(SCAN_TARGET): $(TARGET_STAMP)
        $(call progress,Collecting $(SCAN_NAME) info: merging...)
        -cat $(FILELIST) | awk &#39;&#123;gsub(/\//, &quot;_&quot;, $$0);print &quot;$(TMP_DIR)/info/.$(SCAN_TARGET)-&quot; $$0&#125;&#39; | xargs cat &gt; $@ 2&gt;/dev/null
        $(call progress,Collecting $(SCAN_NAME) info: done)
        echo

FORCE:
.PHONY: FORCE
.NOTPARALLEL:
</code></pre>
<h3 id="global-value"><a href="#global-value" class="headerlink" title="global value"></a>global value</h3><p>在分析全局变量之前，先来看下默认目标 <code>all</code>.</p>
<pre><code class="makefile">all: $(TMP_DIR)/.$(SCAN_TARGET)
</code></pre>
<p><code>$(TMP_DIR)</code> 对应根目录下的 tmp 目录，<code>SCAN_TARGET</code> 在调用 make 的时候有定义，此处为 <code>packageinfo</code>, 因此 <code>all</code> 为：</p>
<pre><code class="makefile">all: /home/litreily/openwrt/tmp/.packageinfo
</code></pre>
<p>也就是说，扫描的目标文件是 tmp 目录的 <code>.packageinfo</code>. 但是在生成该目标之前，<code>make</code> 会先 <code>include</code> 其它文件，如果 <code>include</code> 的文件不存在，则会先生成该文件，此处具体指代的是后续讲述的 <code>.files-packageinfo.mk</code>.</p>
<p>ok, 编译目标知道了，再来看看全局变量有哪些。</p>
<pre><code class="makefile">TMP_DIR:=$(TOPDIR)/tmp

all: $(TMP_DIR)/.$(SCAN_TARGET)

SCAN_TARGET ?= packageinfo
SCAN_NAME ?= package
SCAN_DIR ?= package
TARGET_STAMP:=$(TMP_DIR)/info/.files-$(SCAN_TARGET).stamp
FILELIST:=$(TMP_DIR)/info/.files-$(SCAN_TARGET)-$(SCAN_COOKIE)
OVERRIDELIST:=$(TMP_DIR)/info/.overrides-$(SCAN_TARGET)-$(SCAN_COOKIE)
</code></pre>
<p>其中 <code>SCAN_COOKIE</code> 是在 <code>toplevel.mk</code> 通过 <code>$(shell echo $$$$)</code> 得到的一个随机数，这里为 <code>2109133</code>. 其它变量可以根据传入的参数解析出来：</p>
<pre><code class="makefile">TMP_DIR:=/home/litreily/openwrt/tmp

all: /home/litreily/openwrt/tmp/.packageinfo

SCAN_TARGET ?= packageinfo
SCAN_NAME ?= package
SCAN_DIR ?= package
TARGET_STAMP:=/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp
FILELIST:=/home/litreily/openwrt/tmp/info/.files-packageinfo-2109133
OVERRIDELIST:=/home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133
</code></pre>
<p>其中，后面三个变量定义的是一些中间目标文件，是生成 <code>all</code> 目标必不可少的中间依赖文件。</p>
<h3 id="files-packageinfo-mk"><a href="#files-packageinfo-mk" class="headerlink" title=".files-packageinfo.mk"></a>.files-packageinfo.mk</h3><p>ok, 全局变量及目标已经确定了，那么 make 执行过程究竟是怎样的呢，在启用调试信息的情况下，可以通过 log 很清晰的看到执行流程。</p>
<ol>
<li>include <code>include/verbose.mk</code></li>
<li>include <code>tmp/info/.files-packageinfo.mk</code></li>
</ol>
<p>在读取 <code>verbose.mk</code> 后，会根据 <code>scan.mk</code> 执行剩下的 <code>include</code> 指令</p>
<pre><code class="makefile">-include $(TMP_DIR)/info/.files-$(SCAN_TARGET).mk
</code></pre>
<p>导入 <code>tmp/info/.file-packageinfo.mk</code> 文件，该文件默认不存在，所以前面有个 <code>-</code> 符号以确保文件不存在时能够正常执行。</p>
<p>下一步就是将该文件作为目标文件，查找其依赖。</p>
<pre><code class="makefile">$(TMP_DIR)/info/.files-$(SCAN_TARGET).mk: $(FILELIST)
        ( \
                cat $&lt; | awk &#39;&#123;print &quot;$(SCAN_DIR)/&quot; $$0 &quot;/Makefile&quot; &#125;&#39; | xargs grep -HE &#39;^ *SCAN_DEPS *= *&#39; | awk -F: &#39;&#123; gsub(/^.*DEPS *= */, &quot;&quot;, $$2); print &quot;DEPS_&quot; $$1 &quot;=&quot; $$2 &#125;&#39;; \
                awk -F/ -v deps=&quot;$$DEPS&quot; -v of=&quot;$(OVERRIDELIST)&quot; &#39; \
                BEGIN &#123; \
                        while (getline &lt; (of)) \
                                override[$$NF]=$$0; \
                        close(of) \
                &#125; \
                &#123; \
                        info=$$0; \
                        gsub(/\//, &quot;_&quot;, info); \
                        dir=$$0; \
                        pkg=&quot;&quot;; \
                        if($$NF in override) \
                                pkg=override[$$NF]; \
                        print &quot;$$(eval $$(call PackageDir,&quot; info &quot;,&quot; dir &quot;,&quot; pkg &quot;))&quot;; \
                &#125; &#39; &lt; $&lt;; \
                true; \
        ) &gt; $@.tmp
        mv $@.tmp $@
</code></pre>
<p>其依赖是 <code>$(FILELIST)</code>, 也就是 <code>tmp/info/.files-packageinfo-2109133</code>. 那么接着来看 <code>$(FILELIST)</code> 的依赖及其指令。</p>
<pre><code class="ruby">$(FILELIST): $(OVERRIDELIST)
        rm -f $(TMP_DIR)/info/.files-$(SCAN_TARGET)-*
        find -L $(SCAN_DIR) $(SCAN_EXTRA) -mindepth 1 $(if $(SCAN_DEPTH),-maxdepth $(SCAN_DEPTH)) -name Makefile | xargs grep -aHE &#39;call $(GREP_STRING)&#39; | sed -e &#39;s#^$(SCAN_DIR)/##&#39; -e &#39;s#/Makefile:.*##&#39; | uniq | awk -v of=$(OVERRIDELIST) -f include/scan.awk &gt; $@
</code></pre>
<p>可知其依赖文件是 <code>$(OVERRIDELIST)</code>, 也就是 <code>/home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133</code>. 而 <code>$(OVERRIDELIST)</code> 规则如下：</p>
<pre><code class="makefile">$(OVERRIDELIST):
        rm -f $(TMP_DIR)/info/.overrides-$(SCAN_TARGET)-*
        touch $@
</code></pre>
<p>该规则很简单，也就是删除旧的 <code>tmp/info/.overrides-packageinfo-*</code> 文件，并 touch 新的文件 <code>tmp/info/.overrides-packageinfo-2109133</code>.</p>
<p>那么执行完以上两条指令后，解析 <code>$(FILELIST)</code> 后的格式为：</p>
<pre><code class="ruby">/home/litreily/openwrt/tmp/info/.files-packageinfo-2109133: /home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133
        rm -f /home/litreily/openwrt/tmp/info/.files-packageinfo-*
        find -L package  -mindepth 1 -maxdepth 5 -name Makefile | xargs grep -aHE &#39;call (Build/DefaultTargets|BuildPackage|KernelPackage)&#39; | sed -e &#39;s#^package/##&#39; -e &#39;s#/Makefile:.*##&#39; | uniq | awk -v of=/home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133 -f include/scan.awk &gt; /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133
</code></pre>
<p>与 <code>$(OVERRIDELIST)</code> 类似，先把旧的 <code>tmp/info/.files-packageinfo-*</code> 删除，然后生成新的 <code>tmp/info/.files-packageinfo-2109133</code>. 生成文件用的就是上面的 <code>find</code> 指令了，该指令会查找 package 下 <code>1~5</code> 级目录内的所有 Makefile 文件</p>
<pre><code class="bash">find -L package -mindepth 1 -maxdepth 5 -name Makefile
</code></pre>
<p>然后根据关键词正则过滤包含 <code>call (Build/DefaultTargets|BuildPackage|KernelPackage)</code> 信息的 Makefile, 并通过 uniq 去掉重复项，使用 awk 指令结合 awk 脚本 <code>scan.awk</code> 过滤 <code>feeds</code> 相关的 <code>Makefile</code>, 最终将过滤后的 packageinfo 存入 <code>tmp/info/.files-packageinfo-2109133</code>。</p>
<pre><code class="makefile">base-files
boot/arm-trusted-firmware-mvebu
boot/arm-trusted-firmware-rockchip
boot/arm-trusted-firmware-sunxi
boot/at91bootstrap
boot/fconfig
#...
utils/ugps 
utils/usbmode
utils/util-linux
</code></pre>
<p>至此，<code>$(FILELIST)</code> 编译完成，依赖它的目标 <code>tmp/info/.file-packageinfo.mk</code> 可以继续执行对应的指令。把所有变量替换为具体的值，可以得到以下规则。</p>
<pre><code class="makefile">/home/litreily/openwrt/tmp/info/.file-packageinfo.mk: /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133
        ( \
                cat /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133 | awk &#39;&#123;print &quot;package/&quot; $0 &quot;/Makefile&quot; &#125;&#39; | xargs grep -HE &#39;^ *SCAN_DEPS *= *&#39; | awk -F: &#39;&#123; gsub(/^.*DEPS *= */, &quot;&quot;, $2); print &quot;DEPS_&quot; $1 &quot;=&quot; $2 &#125;&#39;; \
                awk -F/ -v deps=&quot;$DEPS&quot; -v of=&quot;/home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133&quot; &#39; \
                BEGIN &#123; \
                        while (getline &lt; (of)) \
                                override[$NF]=$0; \
                        close(of) \
                &#125; \
                &#123; \
                        info=$0; \
                        gsub(/\//, &quot;_&quot;, info); \
                        dir=$0; \
                        pkg=&quot;&quot;; \
                        if($NF in override) \
                                pkg=override[$NF]; \
                        print &quot;$(eval $(call PackageDir,&quot; info &quot;,&quot; dir &quot;,&quot; pkg &quot;))&quot;; \
                &#125; &#39; &lt; /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133; \
                true; \
        ) &gt; /home/litreily/openwrt/tmp/info/.file-packageinfo.mk.tmp
        mv /home/litreily/openwrt/tmp/info/.file-packageinfo.mk.tmp /home/litreily/openwrt/tmp/info/.file-packageinfo.mk
</code></pre>
<p>以上一堆操作的目的都是为了根据前面生成的 <code>$(FILELIST)</code> 去生成 <code>tmp/info/.file-packageinfo.mk</code>.</p>
<pre><code class="bash">cat /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133 | awk &#39;&#123;print &quot;package/&quot; $0 &quot;/Makefile&quot; &#125;&#39; | xargs grep -HE &#39;^ *SCAN_DEPS *= *&#39; | awk -F: &#39;&#123; gsub(/^.*DEPS *= */, &quot;&quot;, $2); print &quot;DEPS_&quot; $1 &quot;=&quot; $2 &#125;&#39;;
</code></pre>
<p>这一段脚本生成了 <code>tmp/info/.file-packageinfo.mk</code> 的前几行信息。</p>
<pre><code class="makefile">DEPS_package/firmware/linux-firmware/Makefile=*.mk
DEPS_package/kernel/linux/Makefile=modules/*.mk $(TOPDIR)/target/linux/*/modules.mk $(TOPDIR)/include/netfilter.mk
</code></pre>
<pre><code class="bash">&#123; \
        info=$0; \
        gsub(/\//, &quot;_&quot;, info); \
        dir=$0; \
        pkg=&quot;&quot;; \
        if($NF in override) \
                pkg=override[$NF]; \
        print &quot;$(eval $(call PackageDir,&quot; info &quot;,&quot; dir &quot;,&quot; pkg &quot;))&quot;; \
&#125; &#39; &lt; /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133; 
</code></pre>
<p>以上这段脚本则是根据 package 列表生成 <code>PackageDir</code> 信息列表，以 <code>boot/fconfig</code> 为例。经过以上 awk 变换后变为：</p>
<pre><code class="makefile">$(eval $(call PackageDir,boot_fconfig,boot/fconfig,))
</code></pre>
<p>最终生成的完成的 <code>tmp/info/.files-packageinfo.mk</code> 如下：</p>
<pre><code class="makefile">DEPS_package/firmware/linux-firmware/Makefile=*.mk
DEPS_package/kernel/linux/Makefile=modules/*.mk $(TOPDIR)/target/linux/*/modules.mk $(TOPDIR)/include/netfilter.mk
$(eval $(call PackageDir,base-files,base-files,))
$(eval $(call PackageDir,boot_arm-trusted-firmware-mvebu,boot/arm-trusted-firmware-mvebu,))
$(eval $(call PackageDir,boot_arm-trusted-firmware-rockchip,boot/arm-trusted-firmware-rockchip,))
$(eval $(call PackageDir,boot_arm-trusted-firmware-sunxi,boot/arm-trusted-firmware-sunxi,))
$(eval $(call PackageDir,boot_at91bootstrap,boot/at91bootstrap,))
$(eval $(call PackageDir,boot_fconfig,boot/fconfig,))
#...
$(eval $(call PackageDir,utils_ugps,utils/ugps,))
$(eval $(call PackageDir,utils_usbmode,utils/usbmode,))
$(eval $(call PackageDir,utils_util-linux,utils/util-linux,))
</code></pre>
<p>到此，<code>include $(TMP_DIR)/info/.files-$(SCAN_TARGET).mk</code> 就完成了. 该文件中每一项都调用了函数 <code>PackageDir</code>. 该函数是在 <code>scan.mk</code> 中定义的。</p>
<h3 id="PackageDir"><a href="#PackageDir" class="headerlink" title="PackageDir"></a>PackageDir</h3><p><code>PackageDir</code> 是 scan.mk 文件中的核心函数之一，用来生成 package, target 相关的编译规则。</p>
<pre><code class="makefile">define PackageDir
  $(TMP_DIR)/.$(SCAN_TARGET): $(TMP_DIR)/info/.$(SCAN_TARGET)-$(1)
  $(TMP_DIR)/info/.$(SCAN_TARGET)-$(1): $(SCAN_DIR)/$(2)/Makefile $(foreach DEP,$(DEPS_$(SCAN_DIR)/$(2)/Makefile) $(SCAN_DEPS),$(wildcard $(if $(filter /%,$(DEP)),$(DEP),$(SCAN_DIR)/$(2)/$(DEP))))
        &#123; \
                $$(call progress,Collecting $(SCAN_NAME) info: $(SCAN_DIR)/$(2)) \
                echo Source-Makefile: $(SCAN_DIR)/$(2)/Makefile; \
                $(if $(3),echo Override: $(3),true); \
                $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,$(2))&quot; -C $(SCAN_DIR)/$(2) $(SCAN_MAKEOPTS) 2&gt;/dev/null || &#123; \
                        mkdir -p &quot;$(TOPDIR)/logs/$(SCAN_DIR)/$(2)&quot;; \
                        $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,$(2))&quot; -C $(SCAN_DIR)/$(2) $(SCAN_MAKEOPTS) &gt; $(TOPDIR)/logs/$(SCAN_DIR)/$(2)/dump.txt 2&gt;&amp;1; \
                        $$(call progress,ERROR: please fix $(SCAN_DIR)/$(2)/Makefile - see logs/$(SCAN_DIR)/$(2)/dump.txt for details\n) \
                        rm -f $$@; \
                &#125;; \
                echo; \
        &#125; &gt; $$@.tmp
        mv $$@.tmp $$@
endef
</code></pre>
<p>举例说明，下面的语句中 <code>$(1)</code> 和 <code>$(2)</code> 都是 <code>base-files</code>, <code>$(3)</code> 为空。</p>
<pre><code class="makefile">$(eval $(call PackageDir,base-files,base-files,))
</code></pre>
<p>将变量替换后得到 <code>PackageDir</code>:</p>
<pre><code class="makefile">define PackageDir
  /home/litreily/openwrt/tmp/.packageinfo: /home/litreily/openwrt/tmp/info/.packageinfo-base-files
  /home/litreily/openwrt/tmp/info/.packageinfo-base-files: package/base-files/Makefile $(foreach DEP,$(DEPS_package/base-files/Makefile) /home/litreily/openwrt/include/package*.mk,$(wildcard $(if $(filter /%,$(DEP)),$(DEP),package/base-files/$(DEP))))
        &#123; \
                $(call progress,Collecting base-files info: package/base-files) \
                echo Source-Makefile: package/base-files/Makefile; \
                $(if ,echo Override: ,true); \
                $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,base-files)&quot; -C package/base-files $(SCAN_MAKEOPTS) 2&gt;/dev/null || &#123; \
                        mkdir -p &quot;/home/litreily/openwrt/logs/package/base-files&quot;; \
                        $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,base-files)&quot; -C package/base-files $(SCAN_MAKEOPTS) &gt; /home/litreily/openwrt/logs/package/base-files/dump.txt 2&gt;&amp;1; \
                        $(call progress,ERROR: please fix package/base-files/Makefile - see logs/package/base-files/dump.txt for details\n) \
                        rm -f $@; \
                &#125;; \
                echo; \
        &#125; &gt; $@.tmp
        mv $@.tmp $@
endef
</code></pre>
<p>注意到这里有定义两个目标。</p>
<ol>
<li>/home/litreily/openwrt/tmp/.packageinfo</li>
<li>/home/litreily/openwrt/tmp/info/.packageinfo-base-files</li>
</ol>
<blockquote>
<p><strong>注意</strong>: 其中第一个目标正好是 <code>all</code> 目标，并且其依赖是随之其后的 <code>.packageinfo-$(package)</code>. 所以目标 <code>all</code> 编译完成的前提之一就是所有 <code>.packageinfo-$(package)</code> 文件的生成。</p>
</blockquote>
<p>以 <code>base-files</code> 为例， 通过进一步解析简化，可以得到 <code>tmp/info/.packageinfo-base-files</code> 的规则如下：</p>
<pre><code class="makefile">/home/litreily/openwrt/tmp/info/.packageinfo-base-files: package/base-files/Makefile /home/litreily/openwrt/include/package-*.mk
      &#123; \
              $(call progress,Collecting base-files info: package/base-files) \
              echo Source-Makefile: package/base-files/Makefile; \
              make V=s --no-print-dir -r DUMP=1 FEED=&quot; -C package/base-files 2&gt;/dev/null \
      &#125; &gt; $@.tmp
      mv $@.tmp $@
</code></pre>
<p>其中包括打印 <code>Collecting base-files info: package/base-files</code> 这种log，同时会执行 make 子进程</p>
<pre><code class="bash">make V=s --no-print-dir -r DUMP=1 FEED=&quot; -C package/base-files 2&gt;/dev/null \
</code></pre>
<p>将信息写入 <code>tmp/info/.packageinfo-base-files</code>, 也就完成了目标的编译。</p>
<blockquote>
<p>这个 make 子进程的重点是 <code>DUMP=1</code> , <code>package/base-files/Makefile</code> 会根据该变量打印 <code>base-files</code> 相关信息到指定文件。具体要看该Makefile.</p>
</blockquote>
<p>针对 <code>base-files</code>, dump 出来的信息如下：</p>
<pre><code class="log">Source-Makefile: package/base-files/Makefile
Build-Depends: usign/host ucert/host

Package: base-files
Version: 246-
Depends: +libc +USE_GLIBC:librt +USE_GLIBC:libpthread +netifd +jsonfilter +SIGNED_PACKAGES:usign +SIGNED_PACKAGES:openwrt-keyring +NAND_SUPPORT:ubi-utils +fstools +fwtool
Conflicts: 
Menu-Depends: 
Provides: 
Section: base
Category: Base system
Title: Base filesystem for OpenWrt
Maintainer: 
Source: 
License: GPL-2.0
Type: ipkg
Description:  This package contains a base filesystem and system scripts for OpenWrt.
http://openwrt.org/

@@
</code></pre>
<p>说了这么多，<code>PackageDir</code> 函数何时调用呢？继续往后看。</p>
<h3 id="make-all"><a href="#make-all" class="headerlink" title="make all"></a>make all</h3><p><code>include</code> 相关依赖准备好后，make 开始解析默认目标 <code>all</code> 对应的依赖和指令，也就是 <code>tmp/.packageinfo</code> 目标。</p>
<pre><code class="makefile">$(TMP_DIR)/.$(SCAN_TARGET): $(TARGET_STAMP)
        $(call progress,Collecting $(SCAN_NAME) info: merging...)
        -cat $(FILELIST) | awk &#39;&#123;gsub(/\//, &quot;_&quot;, $$0);print &quot;$(TMP_DIR)/info/.$(SCAN_TARGET)-&quot; $$0&#125;&#39; | xargs cat &gt; $@ 2&gt;/dev/null
        $(call progress,Collecting $(SCAN_NAME) info: done)
        echo
</code></pre>
<p>其依赖为 <code>$(TARGET_STAMP)</code>. 当然它的依赖不止这一个，前面 <code>PackageDir</code> 定义的规则中包含的目标也都是它的依赖。下面先来看看 <code>$(TARGET_STAMP)</code>.</p>
<h4 id="TARGET-STAMP"><a href="#TARGET-STAMP" class="headerlink" title="TARGET_STAMP"></a>TARGET_STAMP</h4><p><code>$(TARGET_STAMP)</code> 对应值为 <code>/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp</code>, 其对应指令如下：</p>
<pre><code class="makefile">$(TARGET_STAMP)::
        +( \
                $(NO_TRACE_MAKE) $(FILELIST); \
                MD5SUM=$$(cat $(FILELIST) $(OVERRIDELIST) | mkhash md5 | awk &#39;&#123;print $$1&#125;&#39;); \
                [ -f &quot;$@.$$MD5SUM&quot; ] || &#123; \
                        rm -f $@.*; \
                        touch $@.$$MD5SUM; \
                        touch $@; \
                &#125; \
        )
</code></pre>
<p>变量替换后为：</p>
<pre><code class="makefile">/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp::
        +( \
                make V=ss /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133; \
                MD5SUM=$(cat /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133 /home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133 | mkhash md5 | awk &#39;&#123;print $1&#125;&#39;); \
                [ -f &quot;/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp.$MD5SUM&quot; ] || &#123; \
                        rm -f /home/litreily/openwrt/tmp/info/.files-packageinfo.stamp.*; \
                        touch /home/litreily/openwrt/tmp/info/.files-packageinfo.stamp.$MD5SUM; \
                        touch /home/litreily/openwrt/tmp/info/.files-packageinfo.stamp; \
                &#125; \
        )
</code></pre>
<p>其中 <code>make V=ss /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133</code> 又会启动一个新的子进程。</p>
<blockquote>
<p><strong>说明：</strong> 该子进程和 <code>make V=s</code> 一样，也会调用主Makefile，并导入 <code>toplevel.mk</code> 等Makefile，也就是说，如果缺少基本的编译工具或者依赖 (如 prepare-tmpinfo, .config 等)，这个子进程同样会和 <code>make V=s</code> 一样把所需依赖都生成一遍。但是不会完整编译项目。</p>
</blockquote>
<p><code>TARGET_STAMP</code> 目标主要是生成依赖工具和一个MD5文件。该子进程执行结束后，会计算生成一个 package 列表文件对应的 MD5 文件，并生成目标文件 <code>/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp</code>.</p>
<h4 id="packageinfo-package"><a href="#packageinfo-package" class="headerlink" title=".packageinfo-$(package)"></a>.packageinfo-$(package)</h4><p><code>TARGET_STAMP</code> 生成结束后，就开始调用 <code>tmp/info/.files-packageinfo.mk</code> 逐个生成 <code>tmp/info/.packageinfo-$(package)</code> 文件。这里也就是调用上述 <code>PackageDir</code> 的地方。</p>
<p>所有相关文件都存储在 <code>tmp/info/</code> 目录，文件名为 <code>.packageinfo-$(package)</code>, 每个文件保存的信息由各自目录的 Makefile 决定，前面已经给出了 <code>base-files</code> 目录 dump 出来的信息，主要是描述信息、DEPENDs信息等。</p>
<p>收集这些信息的时候，每个package都会打印一条log。</p>
<pre><code class="log">Collecting package info: package/base-files
Collecting package info: package/boot/arm-trusted-firmware-mvebu
Collecting package info: package/boot/arm-trusted-firmware-rockchip
Collecting package info: package/boot/arm-trusted-firmware-sunxi
#...
</code></pre>
<p>打印 log 使用的是 <code>progress</code> 函数，其定义如下：</p>
<pre><code class="makefile">ifeq ($(IS_TTY),1)
  ifneq ($(strip $(NO_COLOR)),1)
    define progress
    printf &quot;\033[M\r$(1)&quot; &gt;&amp;2;
    endef
  else
    define progress
    printf &quot;\r$(1)&quot; &gt;&amp;2;
    endef
  endif
else
  define progress
    :;
  endef
endif
</code></pre>
<p>实际上就是将 log 打印到 <code>stderr</code>, 也就是终端屏幕上，由于使用了 <code>\r</code> ，所以打印信息时会在同一行刷新，把它去掉就可以逐行打印了。</p>
<blockquote>
<p><strong>说明：</strong> 为什么 <code>TARGET_STAMP</code> 之后是生成 <code>.packageinfo-$(package)</code>? 这是因为在执行 <code>.packageinfo</code> 相关指令前，<code>scan.mk</code> 通过 include 导入了 <code>tmp/info/.files-packageinfo.mk</code> 文件, 该 Makefile 在导入的时候通过 <code>$(eval $(call PackageDir,base-files,base-files,))</code> 系列语句定义了 <code>.packageinfo</code> 的大量依赖，其依赖也就是这里提到的 <code>.packageinfo-$(package)</code>，所以，作为 <code>.packageinfo</code> 的依赖文件，当然要在执行目标指令前先生成。</p>
</blockquote>
<h4 id="packageinfo"><a href="#packageinfo" class="headerlink" title=".packageinfo"></a>.packageinfo</h4><p>目标 <code>all: tmp/.packageinfo</code>  的依赖文件都准备好后，继续来看目标 <code>all</code> 的编译规则：</p>
<pre><code class="makefile">/home/litreily/openwrt/tmp/.packageinfo: /home/litreily/openwrt/tmp/info/.files-packageinfo.stamp
        $(call progress,Collecting package info: merging...)
        -cat /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133 | awk &#39;&#123;gsub(/\//, &quot;_&quot;, $0);print &quot;/home/litreily/openwrt/tmp/info/.packageinfo-&quot; $0&#125;&#39; | xargs cat &gt; /home/litreily/openwrt/tmp/.packageinfo 2&gt;/dev/null
        $(call progress,Collecting package info: done)
        echo
</code></pre>
<p>以上指令其实很简单，就是将前面生成的 package 信息文件根据特定格式全部写入到目标文件 <code>.packageinfo</code> 中。同时使用 <code>progress</code> 函数打印相关信息。</p>
<pre><code class="log">Collecting package info: merging...
Collecting package info: done
</code></pre>
<p>言归正传，目标 <code>all</code> 在生成文件 <code>tmp/.packageinfo</code> 后就结束了，同样 <code>scan.mk</code> 的任务也完成了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细描述了 openwrt <code>scan.mk</code> 扫描过程，其目的是生成编译 package, target 所需的临时文件，将 package, target 相关的依赖信息、路径信息、描述信息存入文件，并保存在 tmp 目录。</p>
<p><code>openwrt</code> 的 <code>Makefile</code> 非常复杂，许多复杂对象的依赖和指令可能相互嵌套和递归调用，所以无法完全讲述清楚，本文旨在根据 <code>Makefile</code> 梳理编译流程，某些细节可能无法避免被遗漏。</p>
<p>学习过程中用到了以下的小技巧，也在此总结一下：</p>
<ol>
<li>某些嵌套的 <code>make</code> 指令隐藏了调试信息，可以修改该指令，替换或添加 <code>-d DEBUG=vltrd</code></li>
<li><code>openwrt</code> 的 <code>make</code> 大多调用了 <code>NO_TRACE_MAKE</code>, 所以可以直接在该变量定义处添加调试参数</li>
<li>使用 <code>$(warning info)</code> 打印调试信息可以帮助理解</li>
<li>include 指令前添加的 <code>-</code> 符号代表如果该文件暂时不存在可以继续执行，不必报错</li>
<li>有时候可以手动执行某些内嵌的 <code>make</code> 指令, 不过记得加上必要的全局变量，比如 <code>TOPDIR</code>, <code>SCAN_COOKIE</code> 等</li>
</ol>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">litreily</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/01/15/mk-scan/">https://www.litreily.top/2021/01/15/mk-scan/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://www.litreily.top">litreily的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tags"></i><a href="/tags/makefile/">makefile</a><a href="/tags/openwrt/">openwrt</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#prepare-tmpinfo"><span class="toc-number">1.</span> <span class="toc-text">prepare-tmpinfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scan-mk"><span class="toc-number">2.</span> <span class="toc-text">scan.mk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#global-value"><span class="toc-number">2.1.</span> <span class="toc-text">global value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#files-packageinfo-mk"><span class="toc-number">2.2.</span> <span class="toc-text">.files-packageinfo.mk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PackageDir"><span class="toc-number">2.3.</span> <span class="toc-text">PackageDir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make-all"><span class="toc-number">2.4.</span> <span class="toc-text">make all</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TARGET-STAMP"><span class="toc-number">2.4.1.</span> <span class="toc-text">TARGET_STAMP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#packageinfo-package"><span class="toc-number">2.4.2.</span> <span class="toc-text">.packageinfo-$(package)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#packageinfo"><span class="toc-number">2.4.3.</span> <span class="toc-text">.packageinfo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2021/01/29/qsdk/">&lt; 下载安装基于 openwrt 的 QSDK</a><a class="next" href="/2021/01/13/mk-subdir/">openwrt Makefile subdir.mk 详解 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1ecKy4yk4u1R7C4tScKbnyq9-gzGzoHsz',
  appKey:'uvA3xgqNW3q8TGR483lxXcpB',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">LITREILY</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>