<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="simple life"><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification" content="pte8o83UGG"><title>rk3399 ubuntu 休眠唤醒功能 | LITREILY</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><script>var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?d55250b3059d32736607d30baa6e0ca2";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="LITREILY" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">LITREILY</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/notes/">笔记</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">rk3399 ubuntu 休眠唤醒功能</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2024/05/31/rk3399-wol/">2024-05-31</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/Embedded/">Embedded</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了降低功耗，需要考虑使用系统的休眠唤醒功能。</p>
<h1 id="休眠方式"><a href="#休眠方式" class="headerlink" title="休眠方式"></a>休眠方式</h1><p>rk3399 休眠方式有两种,<code>mem</code>,<code>freeze</code>.</p>
<h2 id="内存待机-mem"><a href="#内存待机-mem" class="headerlink" title="内存待机 (mem)"></a>内存待机 (mem)</h2><p>在 mem 模式下，系统将所有设备状态保存到内存中，然后进入低功耗状态。唤醒后，系统从内存中恢复设备状态。内存待机模式通常称为 S3 睡眠模式。</p>
<h2 id="冻结-freeze"><a href="#冻结-freeze" class="headerlink" title="冻结 (freeze)"></a>冻结 (freeze)</h2><p>在 freeze 模式下，所有用户空间任务被冻结，所有设备进入低功耗状态，但 CPU 仍保持活跃。冻结模式更适用于在短时间内节省电能。<br>我们使用 <code>mem</code>模式进入休眠，指令如下：</p>
<pre><code class="bash">root@firefly:/sys/power# cat state
freeze mem
root@firefly:/sys/power# echo mem &gt; state
</code></pre>
<h1 id="USB-唤醒"><a href="#USB-唤醒" class="headerlink" title="USB 唤醒"></a>USB 唤醒</h1><h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><pre><code class="bash">&amp;rockchip_suspend &#123;
    status = &quot;okay&quot;;
    rockchip,sleep-debug-en = &lt;1&gt;;
    rockchip,sleep-mode-config = &lt;
        (0
        | RKPM_SLP_ARMPD
        | RKPM_SLP_PERILPPD
        | RKPM_SLP_DDR_RET
        | RKPM_SLP_PLLPD
        | RKPM_SLP_CENTER_PD
        | RKPM_SLP_AP_PWROFF
        )
    &gt;;
    rockchip,wakeup-config = &lt;
        (0
        | RKPM_GPIO_WKUP_EN
        | RKPM_USB_WKUP_EN
        | RKPM_USB_LINESTATE_WKUP_EN
        | RKPM_PWM_WKUP_EN
        )
    &gt;;
    rockchip,pwm-regulator-config = &lt;
        (0
        | PWM2_REGULATOR_EN
        )
    &gt;;
    rockchip,power-ctrl =
        &lt;&amp;gpio1 17 GPIO_ACTIVE_LOW&gt;,
        &lt;&amp;gpio1 14 GPIO_ACTIVE_HIGH&gt;;
&#125;;
</code></pre>
<h2 id="进入休眠"><a href="#进入休眠" class="headerlink" title="进入休眠"></a>进入休眠</h2><pre><code class="bash">root@firefly:/sys/power# cat state
freeze mem
root@firefly:/sys/power# echo mem &gt; state
INFO:    sleep mode config[0xde]:
INFO:           AP_PWROFF
INFO:           SLP_ARMPD
INFO:           SLP_PLLPD
INFO:           DDR_RET
INFO:           SLP_CENTER_PD
INFO:    wakeup source config[0x4884]:
INFO:           GPIO interrupt can wakeup system
INFO:           USBDEV detect can wakeup system
INFO:           PWM interrupt can wakeup system
INFO:    PWM CONFIG[0x4]:
INFO:           PWM: PWM2D_REGULATOR_EN
INFO:    APIOS info[0x0]:
INFO:           not config
INFO:    GPIO POWER INFO:
INFO:           GPIO1_C1
INFO:           GPIO1_B6
INFO:    PMU_MODE_CONG: 0x1466bf41
INFO:    RK3399 the wake up information:
INFO:    wake up status: 0x80
INFO:           USBDEV detect wakeup
</code></pre>
<h2 id="插拔-TypeC-USB-唤醒"><a href="#插拔-TypeC-USB-唤醒" class="headerlink" title="插拔 TypeC USB 唤醒"></a>插拔 TypeC USB 唤醒</h2><p>插拔 type C 线可以唤醒系统，唤醒后日志如下：</p>
<pre><code class="bash">INFO:    RK3399 the wake up information:
INFO:    wake up status: 0x80
INFO:           USBDEV detect wakeup
</code></pre>
<h2 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h2><p><strong>工作状态</strong>：12v 0.4A  4.8W<br><strong>休眠状态</strong>：12v 0.17A  2.03W</p>
<h1 id="以太网唤醒"><a href="#以太网唤醒" class="headerlink" title="以太网唤醒"></a>以太网唤醒</h1><h2 id="唤醒流程"><a href="#唤醒流程" class="headerlink" title="唤醒流程"></a>唤醒流程</h2><p><img src="/assets/rk3399/wol_1.png" alt="image.png"></p>
<p>以上流程图是realtek技术人员提供的资料，根据这个流程图可以知晓整个休眠唤醒的过程，以及涉及的PHY寄存器配置。</p>
<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>下面是基于RK提供的RTL8211E 测试脚本修改 的RTL8211F 测试脚本，寄存器配置与上述流程图基本吻合。</p>
<pre><code class="bash">#!/bin/bash

#***********************************************************************
#                       8211F配制
#        可以在不休眠情况下验证功能，如下几点需要手动修改：
#        1、寄存器路径可能不同： busybox find /sys/ -name phy_reg
#        2、网关可能不同:  ifconfig 自己确认修改
#        3、有可能MAC地址随机，统一固定成001122334455， magic tool也设置一样
#
#***************************************************************************


#######################################
#Into sleep mode initial WOL
#Reg31:0007
#       30:006E
#       21:1100
#       22:3322
#       23:5544
#       31:0007
#       30:006D
#       22:9FFF
#       21:1000
#       25:0001
#       31:0000
######################################
#MAC address 001122334455

function suspend()&#123;
# set INTB/PMEB pin
echo 31 0x0d40 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 22 0x20 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

# set mac 4e:78:eb:7b:3a:e2
echo 31 0x0d8c &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 16 0x784e &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 17 0x7beb &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 18 0xe23a &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
cat /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers

echo &quot;############################################################################&quot;

# set max packet length
echo 31 0x0d8a &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 17 0x9fff &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

# enable wol event
echo 31 0x0d8a &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 16 0x1000 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
#echo 16 0xffff &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

# disable rgmii pad
echo 31 0x0d8a &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 19 0x8002 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 31 0xa42 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5
&#125;

####################
#after wake
#Reg31:0007
#       30:006D
#       21:0000
#       22:9FFF
#       25:0000
#       31:0000
###################


function resume()&#123;

# disable wol event
echo 31 0x0d8a &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 16 0x0 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

# reset wol
echo 31 0x0d8a &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 17 0x1fff &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

# enable rgmii pad
echo 31 0x0d8a &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 19 0x2 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

# set INTB pin
echo 31 0x0d40 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 22 0x0 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5

echo 31 0xa42 &gt; /sys/devices/platform/fe300000.ethernet/mdio_bus/stmmac-0/stmmac-0:00/phy_registers
sleep 0.5
&#125;


case &quot;$1&quot; in
  start)
    echo -n &quot;suspend test:&quot;
    suspend
    echo &quot;done&quot;
    ;;
  stop)
    echo -n &quot;resume test:&quot;
    resume
    echo &quot;done&quot;

    ;;
  *)echo &quot;usage: $0 start | stop &quot;
    ;;
esac
exit 0
</code></pre>
<p>以上脚本用于测试RTL8211F芯片的唤醒功能，可以在不进休眠的情况下验证magic packet的唤醒功能。<br>执行 start 后，通过wakeonlan 工具发送magic packet, 然后测量中断引脚(gpio3_16)是否被拉低，如果被拉低说明脚本执行成功，phy芯片支持休眠唤醒，剩下的就是适配RK3399的驱动和dts. </p>
<h2 id="内核适配"><a href="#内核适配" class="headerlink" title="内核适配"></a>内核适配</h2><h3 id="DTS"><a href="#DTS" class="headerlink" title="DTS"></a>DTS</h3><p>dts 中需要配置以下内容：</p>
<ol>
<li>中断引脚gpio <code>wolirq-gpio</code>,根据原理图可知是 <code>gpio3_16</code></li>
<li>pinctrl 配置 <code>gmac_pmeb_gpios</code>,其实也是中断引脚的初始化配置</li>
<li><code>phy_reset</code>的复位时间调整为下拉50ms，上拉100ms，<strong>这个参数非常重要！！！</strong>默认值太小会导致唤醒后以太网复位失败，只能手动down，up eth0恢复。</li>
<li>休眠模式下使能 <code>vcc3v3_s3</code>电源，确保phy芯片及中断引脚电源域(VCC3V3_LAN) 保持供电，否则phy芯片无法接收魔术包，也就无法唤醒了。至于如何确定保留哪个电源域，需要将原理图以及<code>rk808 pmic</code>的dts配置对应起来。</li>
</ol>
<p><img src="/assets/rk3399/wol_2.png" alt="image.png"></p>
<p>下面就是根据以上需求配置后的DTS.</p>
<pre><code class="diff">--- a/arch/arm64/boot/dts/rockchip/rk3399-keenon-linux.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-keenon-linux.dts
@@ -428,11 +428,13 @@
     clock_in_out = &quot;input&quot;;
     snps,reset-gpio = &lt;&amp;gpio3 15 GPIO_ACTIVE_LOW&gt;;
     snps,reset-active-low;
-    snps,reset-delays-us = &lt;0 10000 50000&gt;;
+    /* delay time for phy reset cannot be too short, which may cause phy reset fail */
+    snps,reset-delays-us = &lt;0 50000 100000&gt;;
     assigned-clocks = &lt;&amp;cru SCLK_RMII_SRC&gt;;
     assigned-clock-parents = &lt;&amp;clkin_gmac&gt;;
+    wolirq-gpio = &lt;&amp;gpio3 16 GPIO_ACTIVE_LOW&gt;;
     pinctrl-names = &quot;default&quot;;
-    pinctrl-0 = &lt;&amp;rgmii_pins&gt;;
+    pinctrl-0 = &lt;&amp;rgmii_pins &amp;gmac_pmeb_gpios&gt;;
     tx_delay = &lt;0x2d&gt;;
     rx_delay = &lt;0x2b&gt;;
     status = &quot;okay&quot;;
@@ -671,7 +673,7 @@
                 regulator-boot-on;
                 regulator-name = &quot;vcc3v3_s3&quot;;
                 regulator-state-mem &#123;
-                    regulator-off-in-suspend;
+                    regulator-on-in-suspend;
                 &#125;;
             &#125;;
 
@@ -912,6 +914,12 @@
             rockchip,pins = &lt;1 2 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;;
         &#125;;
     &#125;;
+
+    gmac-wol &#123;
+        gmac_pmeb_gpios:  gmac-pmeb-gpios &#123;
+            rockchip,pins = &lt;3 16 RK_FUNC_GPIO &amp;pcfg_pull_none&gt;;
+        &#125;;
+    &#125;;
 &#125;;
 
 &amp;pwm0 &#123;
@@ -1128,3 +1136,35 @@
 &amp;target &#123;
     temperature = &lt;100000&gt;;
 &#125;;
+
+&amp;rockchip_suspend &#123;
+    /* disable rockchip_suspend which conflict with RTL8211F WOL feature */
+    status = &quot;disabled&quot;;
+    rockchip,sleep-debug-en = &lt;1&gt;;
+    rockchip,sleep-mode-config = &lt;
+        (0
+        | RKPM_SLP_ARMPD
+        | RKPM_SLP_PERILPPD
+        | RKPM_SLP_DDR_RET
+        | RKPM_SLP_PLLPD
+        | RKPM_SLP_CENTER_PD
+        | RKPM_SLP_AP_PWROFF
+        )
+    &gt;;
+    rockchip,wakeup-config = &lt;
+        (0
+        | RKPM_GPIO_WKUP_EN
+        | RKPM_USB_WKUP_EN
+        | RKPM_USB_LINESTATE_WKUP_EN
+        | RKPM_PWM_WKUP_EN
+        )
+    &gt;;
+    rockchip,pwm-regulator-config = &lt;
+        (0
+        | PWM2_REGULATOR_EN
+        )
+    &gt;;
+    rockchip,power-ctrl =
+        &lt;&amp;gpio1 17 GPIO_ACTIVE_LOW&gt;,
+        &lt;&amp;gpio1 14 GPIO_ACTIVE_HIGH&gt;;
+&#125;;
</code></pre>
<blockquote>
<p>说明：最后禁用的 <code>rockchip_suspend</code>也很关闭，保留是为了以后支持其它唤醒方式，禁掉是为了放在其它唤醒方式与网络唤醒功能产生冲突。经测试，<strong>在启用</strong><code>**rockchip_suspend**</code><strong>功能的情况下，以太网唤醒会失败！</strong></p>
</blockquote>
<h3 id="phy-amp-gmac-驱动"><a href="#phy-amp-gmac-驱动" class="headerlink" title="phy &amp; gmac 驱动"></a>phy &amp; gmac 驱动</h3><p>以下改动绝大部分源自RK提供的patch，其功能是添加 RTL8211E/RTL8211F phy芯片的网络唤醒功能，包括进入休眠以及退出休眠时的操作，并添加中断引脚的配置和处理函数，确保中断触发后能够唤醒系统。</p>
<pre><code class="diff">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -54,6 +54,7 @@
 #include &quot;dwmac-rk-tool.h&quot;
 #include &lt;linux/reset.h&gt;
 #include &lt;linux/of_mdio.h&gt;
+#include &lt;linux/gpio.h&gt;
 
 #define    STMMAC_ALIGN(x)        __ALIGN_KERNEL(x, SMP_CACHE_BYTES)
 
@@ -1793,6 +1794,16 @@ static int stmmac_hw_setup(struct net_device *dev, bool init_ptp)
     return 0;
 &#125;
 
+static irqreturn_t wol_io_isr(int irq, void *dev_id)
+&#123;
+    struct net_device *dev = (struct net_device *)dev_id;
+    struct stmmac_priv *priv = netdev_priv(dev);
+
+    printk(KERN_ERR &quot;keenon: enter wol_io_isr\n&quot;);
+    wake_lock_timeout(&amp;priv-&gt;plat-&gt;wol_wake_lock, msecs_to_jiffies(8000));
+    return IRQ_HANDLED;
+&#125;
+
 /**
  *  stmmac_open - open entry point of the driver
  *  @dev : pointer to the device structure.
@@ -1877,6 +1888,26 @@ static int stmmac_open(struct net_device *dev)
         &#125;
     &#125;
 
+    if (priv-&gt;plat-&gt;wolirq_io &gt; 0) &#123;
+        ret = devm_gpio_request(priv-&gt;device, priv-&gt;plat-&gt;wolirq_io, &quot;gmac_wol_io&quot;);
+        if (ret) &#123;
+            pr_err(&quot;%s: ERROR: failed to request WOL GPIO %d, err: %d\n&quot;,
+                   __func__, priv-&gt;plat-&gt;wolirq_io, ret);
+            goto lpiirq_error;
+        &#125;
+
+        priv-&gt;plat-&gt;wol_irq = gpio_to_irq(priv-&gt;plat-&gt;wolirq_io);
+        ret = devm_request_irq(priv-&gt;device, priv-&gt;plat-&gt;wol_irq, wol_io_isr,
+            IRQF_TRIGGER_FALLING, &quot;gmac_wol_io_irq&quot;, dev);
+        if (ret) &#123;
+            pr_err(&quot;%s: ERROR: request wol io irq fail: %d&quot;, __func__, ret);
+            devm_gpio_free(priv-&gt;device, priv-&gt;plat-&gt;wolirq_io);
+            goto lpiirq_error;
+        &#125;
+        disable_irq(priv-&gt;plat-&gt;wol_irq);
+        enable_irq_wake(priv-&gt;plat-&gt;wol_irq);
+    &#125;
+
     napi_enable(&amp;priv-&gt;napi);
     netif_start_queue(dev);
 
@@ -1938,6 +1969,12 @@ static int stmmac_release(struct net_device *dev)
     if (priv-&gt;lpi_irq &gt; 0)
         free_irq(priv-&gt;lpi_irq, dev);
 
+    if (priv-&gt;plat-&gt;wol_irq &gt; 0)
+        devm_free_irq(priv-&gt;device, priv-&gt;plat-&gt;wol_irq, dev);
+
+    if (priv-&gt;plat-&gt;wolirq_io &gt; 0)
+        devm_gpio_free(priv-&gt;device, priv-&gt;plat-&gt;wolirq_io);
+
     /* Stop TX/RX DMA and clear the descriptors */
     priv-&gt;hw-&gt;dma-&gt;stop_tx(priv-&gt;ioaddr);
     priv-&gt;hw-&gt;dma-&gt;stop_rx(priv-&gt;ioaddr);
@@ -3053,6 +3090,8 @@ int stmmac_dvr_probe(struct device *device,
     INIT_DELAYED_WORK(&amp;priv-&gt;scan_dwork, stmmac_scan_delayline_dwork);
 #endif
 
+    wake_lock_init(&amp;priv-&gt;plat-&gt;wol_wake_lock, WAKE_LOCK_SUSPEND, &quot;wol_wake_lock&quot;);
+
     return ret;
 
 error_netdev_register:
@@ -3119,6 +3158,8 @@ int stmmac_suspend(struct device *dev)
     struct net_device *ndev = dev_get_drvdata(dev);
     struct stmmac_priv *priv = netdev_priv(ndev);
 
+    enable_irq(priv-&gt;plat-&gt;wol_irq);
+
     if (!ndev || !netif_running(ndev))
         return 0;
 
@@ -3166,6 +3207,8 @@ int stmmac_resume(struct device *dev)
     struct net_device *ndev = dev_get_drvdata(dev);
     struct stmmac_priv *priv = netdev_priv(ndev);
 
+    disable_irq(priv-&gt;plat-&gt;wol_irq);
+
     if (!netif_running(ndev))
         return 0;
 
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -29,6 +29,7 @@
 #include &lt;linux/of_net.h&gt;
 #include &lt;linux/of_device.h&gt;
 #include &lt;linux/of_mdio.h&gt;
+#include &lt;linux/of_gpio.h&gt;
 
 #include &quot;stmmac.h&quot;
 #include &quot;stmmac_platform.h&quot;
@@ -109,6 +110,7 @@ stmmac_probe_config_dt(struct platform_device *pdev, const char **mac)
     struct device_node *np = pdev-&gt;dev.of_node;
     struct plat_stmmacenet_data *plat;
     struct stmmac_dma_cfg *dma_cfg;
+    enum of_gpio_flags flags;
 
     plat = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*plat), GFP_KERNEL);
     if (!plat)
@@ -117,6 +119,8 @@ stmmac_probe_config_dt(struct platform_device *pdev, const char **mac)
     *mac = of_get_mac_address(np);
     plat-&gt;interface = of_get_phy_mode(np);
 
+    plat-&gt;wolirq_io = of_get_named_gpio_flags(np, &quot;wolirq-gpio&quot;, 0, &amp;flags);
+
     /* Get max speed of operation from device tree */
     if (of_property_read_u32(np, &quot;max-speed&quot;, &amp;plat-&gt;max_speed))
         plat-&gt;max_speed = -1;
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -1232,8 +1232,70 @@ static int gen10g_config_init(struct phy_device *phydev)
 int genphy_suspend(struct phy_device *phydev)
 &#123;
     int value;
+    struct net_device * ndev = phydev-&gt;attached_dev;
 
     mutex_lock(&amp;phydev-&gt;lock);
+//#if RTL8211E
+#if 0
+    phy_write(phydev, 31, 0x07);
+    phy_write(phydev, 30, 0x6e);
+    phy_write(phydev, 21, ((u16)ndev-&gt;dev_addr[1] &lt;&lt; 8) + ndev-&gt;dev_addr[0]);
+    phy_write(phydev, 22, ((u16)ndev-&gt;dev_addr[3] &lt;&lt; 8) + ndev-&gt;dev_addr[2]);
+    phy_write(phydev, 23, ((u16)ndev-&gt;dev_addr[5] &lt;&lt; 8) + ndev-&gt;dev_addr[4]);
+
+    phy_write(phydev, 31, 0x07);
+    phy_write(phydev, 30, 0x6d);
+    phy_write(phydev, 22, 0x1fff);
+    value = phy_read(phydev, 22);
+
+    phy_write(phydev, 31, 0x07);
+    phy_write(phydev, 30, 0x6d);
+    phy_write(phydev, 21, 0x1000);
+    value = phy_read(phydev, 21);
+
+    phy_write(phydev, 31, 0x07);
+    phy_write(phydev, 30, 0x6d);
+    value =  phy_read(phydev, 25);
+    phy_write(phydev, 25, value | 0x1);
+
+    phy_write(phydev, 31, 0x0);
+#endif
+
+//#if RTL8211F
+#if 1
+    //set INTB pin
+    phy_write(phydev, 31, 0x0d40);
+    value = phy_read(phydev, 22);
+    phy_write(phydev, 22, value | BIT(5));
+
+    //set MAC address
+    if(ndev) &#123;
+        phy_write(phydev, 31, 0x0d8c);
+        phy_write(phydev, 16, ((u16)ndev-&gt;dev_addr[1] &lt;&lt; 8) + ndev-&gt;dev_addr[0]);
+        phy_write(phydev, 17, ((u16)ndev-&gt;dev_addr[3] &lt;&lt; 8) + ndev-&gt;dev_addr[2]);
+        phy_write(phydev, 18, ((u16)ndev-&gt;dev_addr[5] &lt;&lt; 8) + ndev-&gt;dev_addr[4]);
+    &#125; 
+
+    //set max packet length
+    phy_write(phydev, 31, 0x0d8a);
+    phy_write(phydev, 17, 0x9fff);
+
+    //enable wol event
+    phy_write(phydev, 31, 0x0d8a);
+    phy_write(phydev, 16, 0x1000);
+
+    //disable rgmii pad
+    phy_write(phydev, 31, 0x0d8a);
+    value = phy_read(phydev, 19);
+    phy_write(phydev, 19, value | BIT(15));
+
+    phy_write(phydev, 31, 0xa42);
+#endif
+    mutex_unlock(&amp;phydev-&gt;lock);
+
+    return 0;
+/*
+    mutex_lock(&amp;phydev-&gt;lock);
 
     value = phy_read(phydev, MII_BMCR);
     phy_write(phydev, MII_BMCR, value | BMCR_PDOWN);
@@ -1241,6 +1303,7 @@ int genphy_suspend(struct phy_device *phydev)
     mutex_unlock(&amp;phydev-&gt;lock);
 
     return 0;
+*/
 &#125;
 EXPORT_SYMBOL(genphy_suspend);
 
@@ -1253,6 +1316,59 @@ int genphy_resume(struct phy_device *phydev)
 &#123;
     int value;
 
+    if (phydev-&gt;suspended) &#123;
+        mutex_lock(&amp;phydev-&gt;lock);
+//#if RTL8211E
+#if 0
+        phy_write(phydev, 31, 0x07);
+        phy_write(phydev, 30, 0x6d);
+        phy_write(phydev, 21, 0x0);
+        value = phy_read(phydev, 21);
+
+        phy_write(phydev, 31, 0x07);
+        phy_write(phydev, 30, 0x6d);
+        value =  phy_read(phydev, 22);
+        phy_write(phydev, 22, value | BIT(15));
+        value = phy_read(phydev, 22);
+
+        phy_write(phydev, 31, 0x07);
+        phy_write(phydev, 30, 0x6d);
+        value =  phy_read(phydev, 25);
+        phy_write(phydev, 25, value &amp; (~(0x1)));
+
+        phy_write(phydev, 31, 0x0);
+#endif
+
+//#if RTL8211F
+#if 1
+        //disable wol event
+        phy_write(phydev, 31, 0x0d8a);
+        phy_write(phydev, 16, 0x0);
+
+        //reset wol
+        phy_write(phydev, 31, 0x0d8a);
+        value = phy_read(phydev, 17);
+        phy_write(phydev, 17, value &amp; (~BIT(15)));
+
+        //enable rgmii pad
+        phy_write(phydev, 31, 0x0d8a);
+        value = phy_read(phydev, 19);
+        phy_write(phydev, 19, value &amp; (~BIT(15)));
+
+        //set INTB pin
+        phy_write(phydev, 31, 0x0d40);
+        value = phy_read(phydev, 22);
+        phy_write(phydev, 22, value &amp; (~BIT(5)));
+
+        phy_write(phydev, 31, 0xa42);
+#endif
+        mutex_unlock(&amp;phydev-&gt;lock);
+
+        msleep(100);
+
+        return 0;
+    &#125;
+
     mutex_lock(&amp;phydev-&gt;lock);
 
     value = phy_read(phydev, MII_BMCR);
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -27,6 +27,7 @@
 #define __STMMAC_PLATFORM_DATA
 
 #include &lt;linux/platform_device.h&gt;
+#include &lt;linux/wakelock.h&gt;
 
 #define STMMAC_RX_COE_NONE    0
 #define STMMAC_RX_COE_TYPE1    1
@@ -123,5 +124,9 @@ struct plat_stmmacenet_data &#123;
     void (*exit)(struct platform_device *pdev, void *priv);
     void (*get_eth_addr)(void *priv, unsigned char *addr);
     void *bsp_priv;
+    int wolirq_io;
+    int wolirq_io_level;
+    int wol_irq;
+    struct wake_lock wol_wake_lock;
 &#125;;
 #endif
</code></pre>
<p>RK提供的patch无法直接实现休眠唤醒功能，其中包括编译错误问题，休眠时kernel crash导致休眠失败问题等。这些问题经过排查分析已经解决了，部分问题的说明见下文。以上就是最终实现网络唤醒的代码。</p>
<h2 id="唤醒工具"><a href="#唤醒工具" class="headerlink" title="唤醒工具"></a>唤醒工具</h2><p>根据系统平台的不同，休眠后的唤醒工具可以分为以下3类。</p>
<h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><p>如果是Ubuntu系统，可以使用 wakeonlan指令进行唤醒。</p>
<pre><code class="bash">sudo wakeonlan -i 192.168.64.255 4e:78:eb:7b:3a:e2
</code></pre>
<blockquote>
<p>注意：</p>
<ol>
<li>需要使用广播IP地址 <code>192.168.64.255</code>，否则唤醒会失败</li>
<li>udp包的端口号没有特殊要求，默认的9或者自定义的5555都可以唤醒</li>
<li>mac地址必须是phy芯片对应的网口</li>
</ol>
</blockquote>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>对于Android系统， 可以使用apk，比如 <code>Wake On Lan_v1.35_apkpure.com.apk</code>发送唤醒包，或者app内部实现wol数据包的组装和发送。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1404845/1717145788076-7d4c1c7c-e376-403a-83ee-885f18565878.png#averageHue=%23fbfcf7&clientId=u3e6a431f-345a-4&from=paste&height=832&id=u0b7af444&originHeight=832&originWidth=1282&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143463&status=done&style=none&taskId=u57eca1a9-fbe2-406b-a8ac-3895e786015&title=&width=1282" alt="pm-add-device.png"></p>
<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>对于windows系统，可以使用RK提供的 <code>Magic_Package (Wake On Lan).rar</code>, 或者下载 <code>wakeuppro</code>软件。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1404845/1717145770336-fc126d9b-7f41-43ee-82c4-8179be2923ae.png#averageHue=%23eeeeee&clientId=u3e6a431f-345a-4&from=paste&height=480&id=u47ea9c95&originHeight=480&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9702&status=done&style=none&taskId=uaaed2e19-c63f-4337-adda-f609686c7b6&title=&width=661" alt="wakeuppro.png"></p>
<h1 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h1><p>通常情况下，系统进入休眠后没有任何串口日志，哪怕异常也看不出，为了调试，可以在休眠前执行以下语句，将日志打印到串口。</p>
<pre><code class="bash">echo 7 4 1 7 &gt; /proc/sys/kernel/printk
echo N &gt; /sys/module/printk/parameters/console_suspend
echo 1 &gt; /sys/power/pm_print_times
echo mem &gt; /sys/power/state

# 合一
echo 7 4 1 7 &gt; /proc/sys/kernel/printk &amp;&amp; echo N &gt; /sys/module/printk/parameters/console_suspend &amp;&amp; echo 1 &gt; /sys/power/pm_print_times
</code></pre>
<h1 id="网络唤醒失败问题排查"><a href="#网络唤醒失败问题排查" class="headerlink" title="网络唤醒失败问题排查"></a>网络唤醒失败问题排查</h1><h2 id="进入休眠时异常"><a href="#进入休眠时异常" class="headerlink" title="进入休眠时异常"></a>进入休眠时异常</h2><pre><code class="bash">root@firefly:~# echo 7 4 1 7 &gt; /proc/sys/kernel/printk
root@firefly:~# echo N &gt; /sys/module/printk/parameters/console_suspend
root@firefly:~# echo 1 &gt; /sys/power/pm_print_times
root@firefly:~# cat /sys/power/pm_print_times
1
root@firefly:~# echo mem &gt; /sys/power/state
[  241.184074] PM: suspend entry 2024-04-15 11:47:06.000579232 UTC
[  241.184597] PM: Syncing filesystems ... done.
[  241.194766] Freezing user space processes ... (elapsed 0.004 seconds) done.
[  241.199524] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
[  241.203165] calling  1-1.4+ @ 6, parent: 1-1, cb: usb_dev_suspend
[  241.203283] calling  6-1+ @ 48, parent: usb6, cb: usb_dev_suspend
[  241.204271] call 1-1.4+ returned 0 after 13 usecs
[  241.204727] calling  3-1+ @ 6, parent: usb3, cb: usb_dev_suspend
[  241.205310] calling  input1+ @ 1317, parent: gpio-keys, cb: input_dev_suspend
[  241.205384] calling  5-1+ @ 151, parent: usb5, cb: usb_dev_suspend
[  241.206485] call input1+ returned 0 after 1 usecs
[  241.207033] calling  fe310000.dwmmc+ @ 1317, parent: platform, cb: pm_generic_suspend
[  241.207721] call fe310000.dwmmc+ returned 0 after 1 usecs
[  241.208355] calling  usb4+ @ 13725, parent: fe3a0000.usb, cb: usb_dev_suspend
[  241.208573] calling  1-1+ @ 153, parent: usb1, cb: usb_dev_suspend
[  241.210830] call 1-1+ returned 0 after 2200 usecs
[  241.247858] call 3-1+ returned 0 after 41593 usecs
[  241.258065] call usb4+ returned 0 after 47391 usecs
[  241.258648] calling  fe3a0000.usb+ @ 1317, parent: platform, cb: pm_generic_suspend
[  241.259369] call fe3a0000.usb+ returned 0 after 12 usecs
[  241.259965] calling  usb3+ @ 6, parent: fe380000.usb, cb: usb_dev_suspend
[  241.262173] call usb3+ returned 0 after 1576 usecs
[  241.262910] calling  fe380000.usb+ @ 1317, parent: platform, cb: pm_generic_suspend
[  241.273979] call fe380000.usb+ returned 0 after 10094 usecs
[  241.301011] call 5-1+ returned 0 after 93377 usecs
[  241.301601] calling  usb5+ @ 13725, parent: xhci-hcd.2.auto, cb: usb_dev_suspend
[  241.302654] call usb5+ returned 0 after 321 usecs
[  241.309006] call 6-1+ returned 0 after 103237 usecs
[  241.309521] calling  usb6+ @ 153, parent: xhci-hcd.2.auto, cb: usb_dev_suspend
[  241.310194] call usb6+ returned 0 after 27 usecs
[  241.310912] calling  xhci-hcd.2.auto+ @ 1317, parent: fe900000.dwc3, cb: platform_pm_suspend
[  241.311681] call xhci-hcd.2.auto+ returned 0 after 18 usecs
[  241.312190] calling  fe900000.dwc3+ @ 1317, parent: usb1, cb: platform_pm_suspend
[  241.312860] call fe900000.dwc3+ returned 0 after 8 usecs
[  241.313333] calling  usb1+ @ 1317, parent: platform, cb: pm_generic_suspend
[  241.313965] call usb1+ returned 0 after 15 usecs
[  241.314400] calling  xhci-hcd.1.auto+ @ 1317, parent: fe800000.dwc3, cb: platform_pm_suspend
[  241.315145] call xhci-hcd.1.auto+ returned 0 after 0 usecs
[  241.315640] calling  fe800000.dwc3+ @ 1317, parent: usb0, cb: platform_pm_suspend
[  241.316535] android_work: sent uevent USB_STATE=DISCONNECTED
[  241.317082] call fe800000.dwc3+ returned 0 after 761 usecs
[  241.317569] calling  usb0+ @ 1317, parent: platform, cb: pm_generic_suspend
[  241.318188] call usb0+ returned 0 after 1 usecs
[  241.318635] calling  ff9a0000.gpu+ @ 1317, parent: platform, cb: pm_generic_suspend
[  241.318689] calling  mmc1:0001+ @ 153, parent: mmc1, cb: mmc_bus_suspend
[  241.320126] call ff9a0000.gpu+ returned 0 after 218 usecs
[  241.320612] calling  ff7c0000.phy+ @ 1317, parent: platform, cb: pm_generic_suspend
[  241.321273] call mmc1:0001+ returned 0 after 2519 usecs
[  241.321749] call ff7c0000.phy+ returned 0 after 0 usecs
[  241.322225] calling  ff770000.syscon:usb2-phy@e450+ @ 1317, parent: ff770000.syscon, cb: pm_generic_suspend
[  241.323086] call ff770000.syscon:usb2-phy@e450+ returned 0 after 4 usecs
[  241.323687] calling  snd-soc-dummy+ @ 1317, parent: platform, cb: platform_pm_suspend
[  241.324379] call snd-soc-dummy+ returned 0 after 0 usecs
[  241.324870] calling  led_ctl+ @ 1317, parent: leds, cb: led_suspend
[  241.325425] call led_ctl+ returned 0 after 7 usecs
[  241.325875] calling  mmc1::+ @ 1317, parent: fe330000.sdhci, cb: led_suspend
[  241.326492] call mmc1::+ returned 0 after 0 usecs
[  241.326936] calling  cpufreq-dt+ @ 1317, parent: platform, cb: platform_pm_suspend
[  241.327599] call cpufreq-dt+ returned 0 after 0 usecs
[  241.328066] calling  input0+ @ 1317, parent: 4-0022, cb: input_dev_suspend
[  241.328669] call input0+ returned 0 after 1 usecs
[  241.329101] calling  4-0022+ @ 1317, parent: i2c-4, cb: fusb30x_pm_suspend
[  241.329710] call 4-0022+ returned 0 after 6 usecs
[  241.330142] calling  rk808-rtc+ @ 1317, parent: 0-001b, cb: platform_pm_suspend
[  241.330781] call rk808-rtc+ returned 0 after 0 usecs
[  241.331258] calling  rk808-regulator+ @ 1317, parent: 0-001b, cb: platform_pm_suspend
[  241.331950] call rk808-regulator+ returned 0 after 0 usecs
[  241.332436] calling  rk808-clkout+ @ 1317, parent: 0-001b, cb: platform_pm_suspend
[  241.333103] call rk808-clkout+ returned 0 after 0 usecs
[  241.333576] calling  0-001b+ @ 1317, parent: i2c-0, cb: rk808_suspend
[  241.334149] call 0-001b+ returned 0 after 1 usecs
[  241.334579] calling  rtc0+ @ 1317, parent: 0-0051, cb: rtc_suspend
[  241.335697] call rtc0+ returned 0 after 544 usecs
[  241.336195] calling  0-0051+ @ 1317, parent: i2c-0, cb: hym8563_suspend
[  241.336776] call 0-0051+ returned 0 after 0 usecs
[  241.337269] calling  stmmac-0:01+ @ 1317, parent: stmmac-0, cb: mdio_bus_suspend
[  241.337347] calling  usb2+ @ 153, parent: fe3e0000.usb, cb: usb_dev_suspend
[  241.337448] calling  usb1+ @ 48, parent: fe3c0000.usb, cb: usb_dev_suspend
[  241.337764] call usb1+ returned 0 after 306 usecs
[  241.339729] Unable to handle kernel NULL pointer dereference at virtual address 00000318
[  241.340442] pgd = ffffffc0eb940000
[  241.340743] [00000318] *pgd=00000000eb968003, *pud=00000000eb968003, *pmd=00000000eefdf003, *pte=0000000000000000
[  241.341667] Internal error: Oops: 96000007 [#1] SMP
[  241.342095] Modules linked in:
[  241.342374] CPU: 3 PID: 1317 Comm: bash Not tainted 4.4.194 #36
[  241.342893] Hardware name: Rockchip RK3399 Keenon Board (Linux Opensource) (DT)
[  241.343531] task: ffffffc0edfe4380 task.stack: ffffffc0eba70000
[  241.344052] PC is at genphy_suspend+0x68/0x180
[  241.344445] LR is at genphy_suspend+0x68/0x180
[  241.344835] pc : [&lt;ffffff80085d8fd4&gt;] lr : [&lt;ffffff80085d8fd4&gt;] pstate: 20000145
[  241.345480] sp : ffffffc0eba739a0
[  241.345773] x29: ffffffc0eba739a0 x28: ffffff8009237cf8
[  241.346247] x27: ffffffc0f12f00f0 x26: ffffff8008581c84
[  241.346720] x25: ffffff8009237000 x24: ffffff800951d688
[  241.347194] x23: ffffff8008f31183 x22: 000000382c8e9eb5
[  241.347669] x21: ffffff80085da2b4 x20: 0000000000000000
[  241.348142] x19: ffffffc0f12f0000 x18: ffffff8089365897
[  241.348616] x17: 0000000000000000 x16: 0000000000000000
[  241.349089] x15: 0000000000000000 x14: 0000000000052764
[  241.349562] x13: 000000000000000a x12: 0000000000000030
[  241.350037] x11: 00000000fffffffe x10: ffffff800936589f
[  241.350510] x9 : 0000000005f5e0ff x8 : ffffff800835b114
[  241.350984] x7 : ffffff800920e688 x6 : 0000000000069d0e
[  241.351459] x5 : 000000015dc9eef7 x4 : ffffff80085e0f38
[  241.351932] x3 : 00000000ffff264a x2 : 00000000ffff1a92
[  241.352405] x1 : 0000000000000000 x0 : 0000000000000000
[  241.352881]
[  241.352881] PC: 0xffffff80085d8f54:
...
[  241.466657]
[  241.466793] Process bash (pid: 1317, stack limit = 0xffffffc0eba70000)
[  241.467365] Stack: (0xffffffc0eba739a0 to 0xffffffc0eba74000)
...
[  241.510453] [&lt;ffffff80085d8fd4&gt;] genphy_suspend+0x68/0x180
[  241.510936] [&lt;ffffff80085d8dd4&gt;] phy_suspend+0x68/0x78
[  241.511390] [&lt;ffffff80085da300&gt;] mdio_bus_suspend+0x4c/0x60
[  241.511883] [&lt;ffffff8008581378&gt;] dpm_run_callback+0xa4/0x178
[  241.512381] [&lt;ffffff8008581b18&gt;] __device_suspend+0x190/0x2fc
[  241.512887] [&lt;ffffff80085839d4&gt;] dpm_suspend+0x268/0x2e8
[  241.513355] [&lt;ffffff8008583ee4&gt;] dpm_suspend_start+0x70/0x74
[  241.513856] [&lt;ffffff80080ea8c8&gt;] suspend_devices_and_enter+0x68/0x258
[  241.514421] [&lt;ffffff80080eaeb8&gt;] pm_suspend+0x400/0x548
[  241.514881] [&lt;ffffff80080e9314&gt;] state_store+0xb8/0xe0
[  241.515336] [&lt;ffffff80083ba2a4&gt;] kobj_attr_store+0x14/0x24
[  241.515821] [&lt;ffffff8008216c80&gt;] sysfs_kf_write+0x54/0x74
[  241.516296] [&lt;ffffff8008215cdc&gt;] kernfs_fop_write+0x120/0x17c
[  241.516803] [&lt;ffffff80081ab8e8&gt;] __vfs_write+0x48/0xe8
[  241.517256] [&lt;ffffff80081ac1b4&gt;] vfs_write+0xa8/0x15c
[  241.517702] [&lt;ffffff80081acb54&gt;] SyS_write+0x5c/0xb0
[  241.518141] [&lt;ffffff8008082f70&gt;] el0_svc_naked+0x24/0x28
[  241.518609] Code: 5281b183 f9400660 528003e2 940006c3 (f9418e80)
[  241.519145] ---[ end trace 89b1acabdee346a2 ]---
</code></pre>
<p>前期测试时发现休眠失败，经排查，发现是驱动执行到 <code>genphy_suspend</code>时出现空指针异常，进一步确认是配置mac地址时，变量<code>ndev</code>为空，因此后面加了一个空指针判断就好了。</p>
<pre><code class="bash">+    //set MAC address
+    if(ndev) &#123;
+        phy_write(phydev, 31, 0x0d8c);
+        phy_write(phydev, 16, ((u16)ndev-&gt;dev_addr[1] &lt;&lt; 8) + ndev-&gt;dev_addr[0]);
+        phy_write(phydev, 17, ((u16)ndev-&gt;dev_addr[3] &lt;&lt; 8) + ndev-&gt;dev_addr[2]);
+        phy_write(phydev, 18, ((u16)ndev-&gt;dev_addr[5] &lt;&lt; 8) + ndev-&gt;dev_addr[4]);
+    &#125; 
</code></pre>
<h2 id="中断信号无法拉低到0v"><a href="#中断信号无法拉低到0v" class="headerlink" title="中断信号无法拉低到0v"></a>中断信号无法拉低到0v</h2><p>这个问题也是很神奇，测试发现发送magic packet后，中断引脚确实被拉低了，但是只是从3.3v拉低到2v，而不是0v，导致中断触发失败。最终发现是这块板子的问题，换了一块就好了，怀疑是这块板子哪里短路或者损坏了。</p>
<h2 id="有中断触发但无法唤醒"><a href="#有中断触发但无法唤醒" class="headerlink" title="有中断触发但无法唤醒"></a>有中断触发但无法唤醒</h2><p>当中断信号问题解决后，发现还是无法唤醒，检查中断计数 <code>cat /proc/interrupts</code>是有新增的。<code>gmac_wol_io_irq</code>计数值有增加，说明正常触发了中断，但就是无法唤醒。</p>
<pre><code class="bash">root@firefly:/# cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5
 14:          0          0          0          0          0          0     GICv3  29 Edge      arch_timer
 15:     154130     126946     108949     115420      75167      80830     GICv3  30 Edge      arch_timer
 17:      23495      23295      22069      21663      23800      22967     GICv3 113 Level     rk_timer
 20:          0          0          0          0          0          0     GICv3  37 Level     ff6d0000.dma-controller
 21:          0          0          0          0          0          0     GICv3  38 Level     ff6d0000.dma-controller
 22:          0          0          0          0          0          0     GICv3  39 Level     ff6e0000.dma-controller
 23:          0          0          0          0          0          0     GICv3  40 Level     ff6e0000.dma-controller
 24:         27          0          0          0          0          0     GICv3  44 Level     eth0
 25:         45          0          0          0          0          0     GICv3  96 Level     dw-mci
 26:          0          0          0          0          0          0     GICv3  97 Level     dw-mci
 27:      15728          0          0          0          0          0     GICv3  43 Level     mmc1
 28:       5901          0          0          0          0          0     GICv3  58 Level     ehci_hcd:usb5
 29:          0          0          0          0          0          0     GICv3  60 Level     ohci_hcd:usb6
 30:        498          0          0          0          0          0     GICv3  62 Level     ehci_hcd:usb1
 31:          0          0          0          0          0          0     GICv3  64 Level     ohci_hcd:usb2
 32:          0          0          0          0          0          0     GICv3  94 Level     ff100000.saradc
 33:       6252          0          0          0          0          0     GICv3  89 Level     ff3c0000.i2c
 35:        239          0          0          0          0          0     GICv3 132 Level     serial
 36:          0          0          0          0          0          0     GICv3 129 Level     rockchip_thermal
 38:        693          0          0          0          0          0     GICv3  88 Level     ff3d0000.i2c
 40:          0          0          0          0          0          0     GICv3 148 Level     ff660000.rkvdec
 42:          0          0          0          0          0          0     GICv3  87 Level     rga
 44:         12          0          0          0          0          0     GICv3  51 Level     ff9a0000.gpu
 45:          1          0          0          0          0          0     GICv3  52 Level     ff9a0000.gpu
 46:          1          0          0          0          0          0     GICv3  53 Level     ff9a0000.gpu
 57:          0          0          0          0          0          0     gpio0   5 Edge      GPIO Key Power
 86:         10          0          0          0          0          0     gpio1   2 Level     fusb302
105:          0          0          0          0          0          0     gpio1  21 Level     rk808
164:          3          1          0          0          0          0     gpio3  16 Edge      gmac_wol_io_irq
212:          7          0          0          0          0          0     GICv3  63 Level     rockchip_usb2phy
213:       2882          0          0          0          0          0     GICv3 137 Level     dwc3
214:        232          0          0          0          0          0     GICv3 142 Level     xhci-hcd:usb3
224:          4          0          0          0          0          0     GICv3  59 Level     rockchip_usb2phy
225:          3          0          0          0          0          0     GICv3 135 Level     rockchip_usb2phy_bvalid
226:          3          0          0          0          0          0     GICv3 138 Level     rockchip_usb2phy
IPI0:    107703      97644      97952      92577      76656      83385       Rescheduling interrupts
IPI1:        23         55         35         44         54         58       Function call interrupts
IPI2:         0          0          0          0          0          0       CPU stop interrupts
IPI3:         0          0          0          0          0          0       CPU stop (for crash dump) interrupts
IPI4:       939       1047        913        986       1374       1455       Timer broadcast interrupts
IPI5:         8          6          4          3          0          1       IRQ work interrupts
IPI6:         0          0          0          0          0          0       CPU wake-up interrupts
</code></pre>
<p>最终尝试将 <code>rockchip_suspend</code>禁掉后就好了，至于为什么需要禁掉，目前RK没有给出明确答复，留意下就好。怀疑是两套唤醒机制会有冲突。</p>
<h2 id="唤醒后以太网无法使用"><a href="#唤醒后以太网无法使用" class="headerlink" title="唤醒后以太网无法使用"></a>唤醒后以太网无法使用</h2><p>好不容易把唤醒功能实现了，结果发现eth0无法正常使用，ping不通192.168.64.10， 而且会出现<code>NETDEV WATCHDOG</code></p>
<pre><code class="bash">[ 6034.474982] rk_gmac-dwmac fe300000.ethernet eth0: Link is Up - 100Mbps/Full - flow control off
[ 6042.778740] NETDEV WATCHDOG: eth0 (rk_gmac-dwmac): transmit queue 0 timed out
[ 6042.779391] ------------[ cut here ]------------
[ 6042.779795] WARNING: at net/sched/sch_generic.c:306
[ 6042.780221] Modules linked in:
[ 6042.780494]
[ 6042.780631] CPU: 4 PID: 0 Comm: swapper/4 Not tainted 4.4.194 #52
[ 6042.781163] Hardware name: Rockchip RK3399 Keenon Board (Linux Opensource) (DT)
[ 6042.781800] task: ffffffc0f1c5b600 task.stack: ffffffc0f1c74000
[ 6042.782326] PC is at dev_watchdog+0x1e4/0x234
[ 6042.782709] LR is at dev_watchdog+0x1e4/0x234
[ 6042.783090] pc : [&lt;ffffff8008a84f18&gt;] lr : [&lt;ffffff8008a84f18&gt;] pstate: 20000145
[ 6042.783734] sp : ffffffc0f6f2dde0
[ 6042.784024] x29: ffffffc0f6f2dde0 x28: ffffff800932a000
[ 6042.784496] x27: ffffffc0f6f2ded8 x26: 00000000ffffffff
[ 6042.784967] x25: 0000000000000004 x24: ffffffc0f1294880
[ 6042.785438] x23: 0000000000000001 x22: ffffff800932a000
[ 6042.785910] x21: ffffffc0f12c03e0 x20: 0000000000000000
[ 6042.786382] x19: ffffffc0f12c0000 x18: ffffff8089365897
[ 6042.786852] x17: 0000000000000000 x16: 0000000000000000
[ 6042.787323] x15: 0000000000000000 x14: 00000000000be1f4
[ 6042.787795] x13: 000000000000000a x12: 0000000000000030
[ 6042.788266] x11: 00000000fffffffe x10: ffffff800936589f
[ 6042.788738] x9 : 0000000005f5e0ff x8 : ffffff800835b114
[ 6042.789210] x7 : ffffff800920e688 x6 : 0000000000000051
[ 6042.789681] x5 : 0000000000000010 x4 : 0000000000000000
[ 6042.790152] x3 : 0000000000000000 x2 : 0000000000000040
[ 6042.790622] x1 : 0000000000000006 x0 : 0000000000000041
</code></pre>
<p>经RK指导，怀疑是唤醒后phy没有正常复位，但是测量信号发现是有进行复位的，不过复位时间很短，后来经过调整复位的上下拉时间解决。</p>
<pre><code class="bash">     snps,reset-gpio = &lt;&amp;gpio3 15 GPIO_ACTIVE_LOW&gt;;
     snps,reset-active-low;
-    snps,reset-delays-us = &lt;0 10000 50000&gt;;
+    /* delay time for phy reset cannot be too short, which may cause phy reset fail */
+    snps,reset-delays-us = &lt;0 50000 100000&gt;;
</code></pre>
<p>下面这是修改时间后的PHY_RESET信号。</p>
<p><img src="/assets/rk3399/wol_phy_reset.png" alt="phy_reset_0_50_100.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li>网络唤醒流程<ol>
<li>使用 <code>echo mem &gt; /sys/power/state</code>进入休眠状态</li>
<li>休眠时phy将中断引脚拉高，使能唤醒功能</li>
<li>发送 <code>magic packet</code>给phy芯片，phy芯片接收到后将中断引脚拉低</li>
<li>中断引脚下降沿触发中断，进行唤醒操作</li>
<li>唤醒后对phy进行复位，并禁止中断，配置phy寄存器</li>
</ol>
</li>
<li>以太网唤醒功能依赖于PHY芯片，RK3399 两个网口，只有eth0可以用于网络唤醒</li>
<li>注意休眠时保证phy芯片及中断引脚gpio的电源保持上电</li>
<li>注意rockchip_suspend 与 网络唤醒不能同时使用</li>
<li>注意mac地址配置时需要判空处理，否则会出现crash</li>
<li>注意示波器测量信号时防止引脚短接引起短路，损坏电路</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>RK redmine issue: <a target="_blank" rel="noopener" href="https://redmine.rock-chips.com/issues/474137">https://redmine.rock-chips.com/issues/474137</a> </li>
<li>Realtek WOL App Note: <a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2024/pdf/1404845/1717143018572-ad4082fe-8c4a-4452-b9f0-5701bd80ebc2.pdf?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2024/pdf/1404845/1717143018572-ad4082fe-8c4a-4452-b9f0-5701bd80ebc2.pdf%22,%22name%22:%22RTL8211F_Series_WOL_App_Note_1.5.pdf%22,%22size%22:2230894,%22ext%22:%22pdf%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u5aaa29df-11c5-4d1f-a4ea-d979ad7fbf3%22,%22taskType%22:%22upload%22,%22type%22:%22application/pdf%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22MoZUs%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">RTL8211F_Series_WOL_App_Note_1.5.pdf</a></li>
<li>wol测试脚本：<a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2024/sh/1404845/1717143085123-48f36c9c-84eb-448c-adcb-49f34c20385e.sh?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2024/sh/1404845/1717143085123-48f36c9c-84eb-448c-adcb-49f34c20385e.sh%22,%22name%22:%22wol_set_f_4e78eb7b3ae2.sh%22,%22size%22:4132,%22ext%22:%22sh%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u33231388-eb69-4897-a2ed-220e7a1d9d6%22,%22taskType%22:%22upload%22,%22type%22:%22text/x-sh%22,%22__spacing%22:%22both%22,%22id%22:%22u167d58d5%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">wol_set_f_4e78eb7b3ae2.sh</a></li>
</ul>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">litreily</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2024/05/31/rk3399-wol/">https://www.litreily.top/2024/05/31/rk3399-wol/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://www.litreily.top">litreily的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/Ubuntu/">Ubuntu</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">休眠方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%BE%85%E6%9C%BA-mem"><span class="toc-number">2.1.</span> <span class="toc-text">内存待机 (mem)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%BB%E7%BB%93-freeze"><span class="toc-number">2.2.</span> <span class="toc-text">冻结 (freeze)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#USB-%E5%94%A4%E9%86%92"><span class="toc-number">3.</span> <span class="toc-text">USB 唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">内核配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E4%BC%91%E7%9C%A0"><span class="toc-number">3.2.</span> <span class="toc-text">进入休眠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E6%8B%94-TypeC-USB-%E5%94%A4%E9%86%92"><span class="toc-number">3.3.</span> <span class="toc-text">插拔 TypeC USB 唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%80%97"><span class="toc-number">3.4.</span> <span class="toc-text">功耗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%94%A4%E9%86%92"><span class="toc-number">4.</span> <span class="toc-text">以太网唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">唤醒流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="toc-number">4.2.</span> <span class="toc-text">测试脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E9%80%82%E9%85%8D"><span class="toc-number">4.3.</span> <span class="toc-text">内核适配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DTS"><span class="toc-number">4.3.1.</span> <span class="toc-text">DTS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phy-amp-gmac-%E9%A9%B1%E5%8A%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">phy &amp; gmac 驱动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E5%B7%A5%E5%85%B7"><span class="toc-number">4.4.</span> <span class="toc-text">唤醒工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ubuntu"><span class="toc-number">4.4.1.</span> <span class="toc-text">ubuntu</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android"><span class="toc-number">4.4.2.</span> <span class="toc-text">Android</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows"><span class="toc-number">4.4.3.</span> <span class="toc-text">windows</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">调试方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%94%A4%E9%86%92%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">6.</span> <span class="toc-text">网络唤醒失败问题排查</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E4%BC%91%E7%9C%A0%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">6.1.</span> <span class="toc-text">进入休眠时异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%E6%97%A0%E6%B3%95%E6%8B%89%E4%BD%8E%E5%88%B00v"><span class="toc-number">6.2.</span> <span class="toc-text">中断信号无法拉低到0v</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%B8%AD%E6%96%AD%E8%A7%A6%E5%8F%91%E4%BD%86%E6%97%A0%E6%B3%95%E5%94%A4%E9%86%92"><span class="toc-number">6.3.</span> <span class="toc-text">有中断触发但无法唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E5%90%8E%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">唤醒后以太网无法使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2024/09/19/android10-ota/">&lt; RK3399 Android 10 系统OTA升级失败问题</a><a class="next" href="/2024/02/05/rk32-new-part/">RK3288 Android6 新增分区 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'1ecKy4yk4u1R7C4tScKbnyq9-gzGzoHsz',
  appKey:'uvA3xgqNW3q8TGR483lxXcpB',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2024 <a href="/." rel="nofollow">LITREILY</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>