<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LITREILY</title>
  <icon>https://www.gravatar.com/avatar/6ae20d989e9d976faf00ecc6d9bcfe82</icon>
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.litreily.top/"/>
  <updated>2020-12-15T12:32:21.604Z</updated>
  <id>https://www.litreily.top/</id>
  
  <author>
    <name>litreily</name>
    <email>707922098@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Setup PPTP and DNS server</title>
    <link href="https://www.litreily.top/2020/12/02/setup-pptp/"/>
    <id>https://www.litreily.top/2020/12/02/setup-pptp/</id>
    <published>2020-12-02T11:06:32.000Z</published>
    <updated>2020-12-15T12:32:21.604Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PPTP (Point to Point Tunneling Protocol) 点对点隧道协议，与PPPoE, L2TP 均属于 PPP(Point to Point Protocol) 点对点协议。这篇来记录下PPTP server的安装和配置过程。&lt;/p&gt;
&lt;h2 id=&quot;install-DHCP-server&quot;&gt;&lt;a href=&quot;#install-DHCP-server&quot; class=&quot;headerlink&quot; title=&quot;install DHCP server&quot;&gt;&lt;/a&gt;install DHCP server&lt;/h2&gt;&lt;p&gt;除了PPPoE外，PPTP 与 L2TP 都无法直接给client分配IP，需要使用dhcp server分配。所以在安装PPTP的同时，也要保证DHCP server也已安装。具体方法参考 &lt;a href=&quot;https://www.litreily.top/2020/01/17/dhcpd_server/&quot;&gt;Setup dhcpd/dhcpdv6 server&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;需要注意的是，在Ubuntu 20.10 版本中，网卡的静态IP管理模式与以往有所不同。在以往版本中，是修改 &lt;code&gt;/etc/network/interfaces&lt;/code&gt; 文件，但是在最新Ubuntu确不一样，最新版提出了一个叫 &lt;code&gt;netpl
      
    
    </summary>
    
      <category term="Network" scheme="https://www.litreily.top/categories/Network/"/>
    
    
      <category term="ubuntu" scheme="https://www.litreily.top/tags/ubuntu/"/>
    
      <category term="pptp" scheme="https://www.litreily.top/tags/pptp/"/>
    
      <category term="dns" scheme="https://www.litreily.top/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>openssl 验证证书有效性</title>
    <link href="https://www.litreily.top/2020/09/17/openssl/"/>
    <id>https://www.litreily.top/2020/09/17/openssl/</id>
    <published>2020-09-17T06:17:27.000Z</published>
    <updated>2020-09-18T12:10:23.062Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;OpenSSL is a robust, commercial-grade, and full-featured toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols. It is also a general-purpose cryptography library.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;openssl是非常强大的TLS/SSL协议相关的工具集，包含丰富的测试工具。 这篇文章来讲讲如何使用openssl工具集中的&lt;code&gt;s_client&lt;/code&gt;测试证书认证。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="https://www.litreily.top/categories/Network/"/>
    
      <category term="Security" scheme="https://www.litreily.top/categories/Network/Security/"/>
    
    
      <category term="openssl" scheme="https://www.litreily.top/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>python之给pdf添加页码</title>
    <link href="https://www.litreily.top/2020/08/13/python-pdf/"/>
    <id>https://www.litreily.top/2020/08/13/python-pdf/</id>
    <published>2020-08-13T08:56:37.000Z</published>
    <updated>2020-08-13T11:34:41.043Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写release note, 总感觉用&lt;code&gt;tex&lt;/code&gt;不太方便，特别是装&lt;code&gt;texlive&lt;/code&gt;占用大量空间，还有各种依赖问题，想着能不能用&lt;code&gt;markdown&lt;/code&gt;写更方便。实践证明，&lt;a href=&quot;https://typora.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;typora&lt;/a&gt;导出pdf的功能真的很棒，唯独一个不足之处就是生成的PDF不带&lt;strong&gt;页码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个虽然可以使用在线工具实现，或者使用Adobe、福昕的 pdf 编辑功能，但是很多情况，尤其是工作平台是不方便使用的。为此我想到了&lt;code&gt;Python&lt;/code&gt;，通过脚本把页码加上。&lt;/p&gt;
&lt;h2 id=&quot;安装Python库&quot;&gt;&lt;a href=&quot;#安装Python库&quot; class=&quot;headerlink&quot; title=&quot;安装Python库&quot;&gt;&lt;/a&gt;安装Python库&lt;/h2&gt;&lt;p&gt;首先需要安装两个依赖库，&lt;code&gt;PyPDF2&lt;/code&gt;以及&lt;code&gt;reportLab&lt;/code&gt;, &lt;code&gt;PyPDF2&lt;/code&gt;可以对PDF进行拆分、合并、删除、加密等操作；&lt;code&gt;reportlab&lt;/code&gt;则更是强大，看看下面的官方介绍。&lt;/p&gt;
&lt;blockqu
      
    
    </summary>
    
      <category term="Python" scheme="https://www.litreily.top/categories/Python/"/>
    
    
      <category term="pdf" scheme="https://www.litreily.top/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫8 - 爬取彼岸图网美图</title>
    <link href="https://www.litreily.top/2020/08/09/netbian/"/>
    <id>https://www.litreily.top/2020/08/09/netbian/</id>
    <published>2020-08-09T02:54:47.000Z</published>
    <updated>2020-08-11T10:28:13.625Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://pic.netbian.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彼岸图网&lt;/a&gt;收集了大量美图，是个不错的爬取对象。话不多说，直接上图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netbian/netbian.png&quot; alt=&quot;彼岸图网&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析站点&quot;&gt;&lt;a href=&quot;#分析站点&quot; class=&quot;headerlink&quot; title=&quot;分析站点&quot;&gt;&lt;/a&gt;分析站点&lt;/h2&gt;&lt;h3 id=&quot;分类列表&quot;&gt;&lt;a href=&quot;#分类列表&quot; class=&quot;headerlink&quot; title=&quot;分类列表&quot;&gt;&lt;/a&gt;分类列表&lt;/h3&gt;&lt;p&gt;爬取之前，自然要分析一波，这个站点的框架比较简单，从分类着手，共包含12个分类项。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;4K人物&lt;/li&gt;
&lt;li&gt;4K动漫&lt;/li&gt;
&lt;li&gt;4K动物&lt;/li&gt;
&lt;li&gt;4K宗教&lt;/li&gt;
&lt;li&gt;4K影视&lt;/li&gt;
&lt;li&gt;4K明星&lt;/li&gt;
&lt;li&gt;4K汽车&lt;/li&gt;
&lt;li&gt;4K游戏&lt;/li&gt;
&lt;li&gt;4K美女&lt;/li&gt;
&lt;li&gt;4K美食&lt;/li&gt;
&lt;li&gt;4K背景&lt;/li&gt;
&lt;li&gt;4K风景&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;名称都含有4K，但是获取原图是需要会员的，所以我这里获取的不是原图，而是详细页展示的大图。首先要获取的当
      
    
    </summary>
    
      <category term="Python" scheme="https://www.litreily.top/categories/Python/"/>
    
    
      <category term="spider" scheme="https://www.litreily.top/tags/spider/"/>
    
      <category term="xpath" scheme="https://www.litreily.top/tags/xpath/"/>
    
      <category term="pool" scheme="https://www.litreily.top/tags/pool/"/>
    
  </entry>
  
  <entry>
    <title>VPS搭建在线VSCode Server</title>
    <link href="https://www.litreily.top/2020/06/13/code-server/"/>
    <id>https://www.litreily.top/2020/06/13/code-server/</id>
    <published>2020-06-13T06:41:26.000Z</published>
    <updated>2020-06-13T08:03:49.353Z</updated>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VSCode-Server&quot;&gt;&lt;a href=&quot;#VSCode-Server&quot; class=&quot;headerlink&quot; title=&quot;VSCode Server&quot;&gt;&lt;/a&gt;VSCode Server&lt;/h2&gt;&lt;p&gt;VSCode(Visual Studio Code), 是我目前使用过的最好的编辑器，也应该是很多程序员的首选。然而很多人不知道的是，这款开发利器还有在线版，这包括GitHub即将推出的&lt;code&gt;Satellite&lt;/code&gt;, 也会搭载VSCode，那么如果我们想要搭建自己的在线开发环境呢？答案就是&lt;a href=&quot;https://github.com/cdr/code-server&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Code Server&lt;/a&gt;, 一款可以部署在个人服务器上的VSCode服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/vscode/pods-lg.png&quot; alt=&quot;pods logo&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;如果在本地，自然是无需搭建这个server的，我的选择是放在阿里云服务器上，对应的是Ubuntu系统，安装过程非常简单。&lt;/p&gt;
&lt;pre&gt;&lt;code clas
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="ubuntu" scheme="https://www.litreily.top/tags/ubuntu/"/>
    
      <category term="vps" scheme="https://www.litreily.top/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>Win10中使用ssh访问WSL</title>
    <link href="https://www.litreily.top/2020/05/08/putty-wsl/"/>
    <id>https://www.litreily.top/2020/05/08/putty-wsl/</id>
    <published>2020-05-08T14:31:20.000Z</published>
    <updated>2020-05-09T13:39:48.639Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;win10的WSL作为目前日常必备，实在是爱不释手，奈何默认终端界面实在一言难尽，尽管配色问题可以解决，但是字体问题导致ohmyzsh的很多图标无法正常显示，配置好&lt;a href=&quot;https://github.com/powerline/fonts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;powerline&lt;/a&gt;字体略有改善，但配合tmux使用又会出现乱码问题，实在难以忍受，于是准备通过ssh间接访问。&lt;/p&gt;
&lt;h2 id=&quot;配置ssh&quot;&gt;&lt;a href=&quot;#配置ssh&quot; class=&quot;headerlink&quot; title=&quot;配置ssh&quot;&gt;&lt;/a&gt;配置ssh&lt;/h2&gt;&lt;p&gt;重装&lt;code&gt;openssh-server&lt;/code&gt;, 如果自带的没问题也不用重装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;sudo apt remove openssh-server
sudo apt install openssh-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;# 服务端每分钟发送一次数据包给客户端，客户端回复即保持连接
ClientAliveInterval 60
# 客户端3次未响应则断开
ClientAli
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="ssh" scheme="https://www.litreily.top/tags/ssh/"/>
    
      <category term="putty" scheme="https://www.litreily.top/tags/putty/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核驱动解析 - UBI坏块预留大小</title>
    <link href="https://www.litreily.top/2020/05/07/ubi-driver/"/>
    <id>https://www.litreily.top/2020/05/07/ubi-driver/</id>
    <published>2020-05-07T01:21:29.000Z</published>
    <updated>2020-06-13T10:34:27.988Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在处理ubifs相关bug的过程中，学习了ubi驱动对坏块保留分区的处理方式，在此记录一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/linux/ubi-reserved-maps.png&quot; alt=&quot;ubi reserved mind maps&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h2&gt;&lt;h3 id=&quot;mtd&quot;&gt;&lt;a href=&quot;#mtd&quot; class=&quot;headerlink&quot; title=&quot;mtd&quot;&gt;&lt;/a&gt;mtd&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;mtd&lt;/strong&gt; 全称 memory technology device 内存技术设备，是用于访问内存设备(RAM, Flash)的Linux 子系统，在硬件层和用户空间之间提供抽象接口。&lt;/p&gt;
&lt;p&gt;在嵌入式linux设备中的&lt;code&gt;/dev/&lt;/code&gt;目录下有很多&lt;code&gt;/dev/mtdxx&lt;/code&gt;文件，这些文件对应的就是内存设备。比如，嵌入式设备的Nand Flash被划分为多个分区，每个分区对应一个&lt;code&gt;/dev/mtdxx&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;如下所示，&lt;code&gt;/dev/mtd0&lt;/code&gt;至&lt;code&gt;/dev/mtd10&lt;/code&gt;对
      
    
    </summary>
    
      <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
      <category term="C/C++" scheme="https://www.litreily.top/tags/C-C/"/>
    
      <category term="ubi" scheme="https://www.litreily.top/tags/ubi/"/>
    
      <category term="flash" scheme="https://www.litreily.top/tags/flash/"/>
    
  </entry>
  
  <entry>
    <title>Python之markdown转Chrome收藏夹</title>
    <link href="https://www.litreily.top/2020/05/03/md2bm/"/>
    <id>https://www.litreily.top/2020/05/03/md2bm/</id>
    <published>2020-05-03T08:49:25.000Z</published>
    <updated>2020-05-03T10:42:22.813Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上可以搜到很多chrome收藏夹转markdown文档的方法，却鲜有markdown文档转为Chrome收藏夹的方法，不过这种需求也确实不多。我之所以用到，是因为平常会用markdown文档收集一些网站，现在想要转换为Chrome收藏夹，方便访问。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;要实现这个功能倒也不难，因为Chrome的收藏夹本质上也是一个html文件，只不过有其固定的DOM结构而已，所以我们的实现思路很简单。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导出Chrome已有的收藏夹&lt;/li&gt;
&lt;li&gt;分析导出得到的html文件格式&lt;/li&gt;
&lt;li&gt;将自己需要转成Chrome收藏夹的markdown按相同格式转换为html文件&lt;/li&gt;
&lt;li&gt;在chrome中导入生成后的收藏夹&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;收藏夹的DOM结构&quot;&gt;&lt;a href=&quot;#收藏夹的DOM结构&quot; class=&quot;headerlink&quot; title=&quot;收藏夹的DOM结构&quot;&gt;&lt;/a&gt;收藏夹的DOM结构&lt;/h2&gt;&lt;p&gt;我导出了自己的收藏夹，取出其中一小部分为例进行分析，比较局部是可以反映整体的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!DOCTYPE NETSCAPE-B
      
    
    </summary>
    
      <category term="Python" scheme="https://www.litreily.top/categories/Python/"/>
    
    
      <category term="markdown" scheme="https://www.litreily.top/tags/markdown/"/>
    
      <category term="chrome" scheme="https://www.litreily.top/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>解锁网易云音乐灰色无版权歌曲</title>
    <link href="https://www.litreily.top/2020/05/03/netease/"/>
    <id>https://www.litreily.top/2020/05/03/netease/</id>
    <published>2020-05-03T01:11:39.000Z</published>
    <updated>2020-05-03T02:17:08.972Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于版权之争，网易云的很多歌曲都灰掉并且无法播放了，想要使其可以播放还是有办法的，万能的Google和Github让我找到了&lt;a href=&quot;https://github.com/nondanee/UnblockNeteaseMusic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;答案&lt;/a&gt;，直接上享用方法吧。&lt;/p&gt;
&lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个可以远程访问的服务器，比如vps，阿里云、腾讯云、...&lt;/li&gt;
&lt;li&gt;如果没有服务器，只能寻找别人搭建好的服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;搭建服务&quot;&gt;&lt;a href=&quot;#搭建服务&quot; class=&quot;headerlink&quot; title=&quot;搭建服务&quot;&gt;&lt;/a&gt;搭建服务&lt;/h2&gt;&lt;p&gt;在服务器端，首先安装依赖的工具&lt;code&gt;npx&lt;/code&gt;，如果有则忽略&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;sudo apt install npm
sudo npm i -g npx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后clone项目UnblockNeteaseMusic.git到本地&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;git cl
      
    
    </summary>
    
      <category term="Media" scheme="https://www.litreily.top/categories/Media/"/>
    
    
      <category term="music" scheme="https://www.litreily.top/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>lftp获取FTP Server端最新文件</title>
    <link href="https://www.litreily.top/2020/04/30/lftp_get/"/>
    <id>https://www.litreily.top/2020/04/30/lftp_get/</id>
    <published>2020-04-30T09:33:02.000Z</published>
    <updated>2020-04-30T11:47:40.692Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近解一个bug，要频繁编译和烧录FW，每次都要将image从远程的FTP server手动copy到本地，然后使用tftp进行烧录，实在不胜其烦。虽然上一篇&lt;a href=&quot;https://www.litreily.top/2020/04/27/tftp/&quot;&gt;简单实用的tftp烧录image脚本&lt;/a&gt;提高了烧录效率，但是每次将image拷贝到本地也是麻烦。&lt;/p&gt;
&lt;p&gt;这次，我依旧想到了WSL, 使用shell脚本还是更加方便快捷，思路很简单，检查server端的最新文件，得到文件名后使用lftp下载到本地。&lt;/p&gt;
&lt;h2 id=&quot;获取最新文件&quot;&gt;&lt;a href=&quot;#获取最新文件&quot; class=&quot;headerlink&quot; title=&quot;获取最新文件&quot;&gt;&lt;/a&gt;获取最新文件&lt;/h2&gt;&lt;p&gt;FTP Server文件存储方式是将每天的新数据归档到以当日日期命名的文件夹中，如今天&lt;code&gt;20200430&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;➜  lftp -u &amp;quot;username,password&amp;quot; ftp://1.2.3.4
lftp username@1.2.3.4:~&amp;gt; ls
04-27-20  02:03PM       &amp;lt;DIR&amp;gt;          20200427
04-29-20  05:3
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://www.litreily.top/tags/shell/"/>
    
      <category term="ftp" scheme="https://www.litreily.top/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>简单实用的tftp烧录image脚本</title>
    <link href="https://www.litreily.top/2020/04/27/tftp/"/>
    <id>https://www.litreily.top/2020/04/27/tftp/</id>
    <published>2020-04-27T11:21:03.000Z</published>
    <updated>2020-04-27T12:33:44.650Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;烧录FW image时，经常需要打开带有UI界面的tftp客户端，然后输入IP，选择FW image，然后点击写入，很是繁琐。&lt;/p&gt;
&lt;p&gt;为了简化这个过程，我决定使用shell script，在win10中自带WSL(windows subsystem for linux)，配合zsh食用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;#!/bin/zsh
# install to ~/bin/burnImage

[ &amp;quot;x$1&amp;quot; = &amp;quot;x&amp;quot;  ] &amp;amp;&amp;amp; echo &amp;quot;usage: ${0##*/} &amp;lt;imagefile&amp;gt;&amp;quot; &amp;amp;&amp;amp; exit 1

tftp 192.168.1.1 &amp;lt;&amp;lt;-EOF &amp;gt; /dev/null
    binary
    put $1
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;脚本使用&lt;code&gt;tftp&lt;/code&gt;连接tftp server 192.168.1.1, 然后进入&lt;code&gt;binary&lt;/code&gt;模式，最后将image文件&lt;code&gt;$1&lt;/code&gt;传输至server端。&lt;/p&gt;
&lt;p&gt;使用方法很简单，保证该文件&lt;code&gt;burnImage&lt;/code&gt;所在目录在环境变量&lt;code&gt;$PATH&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://www.litreily.top/tags/shell/"/>
    
      <category term="tftp" scheme="https://www.litreily.top/tags/tftp/"/>
    
  </entry>
  
  <entry>
    <title>NBNS客户端的C语言实现</title>
    <link href="https://www.litreily.top/2020/03/15/nbns_code/"/>
    <id>https://www.litreily.top/2020/03/15/nbns_code/</id>
    <published>2020-03-15T09:01:33.000Z</published>
    <updated>2020-06-13T10:34:27.988Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接上一篇&lt;a href=&quot;/2020/02/28/nbns/&quot;&gt;【网络协议详解1 - NBNS】&lt;/a&gt;对NBNS的介绍，这一篇将要讲述使用C语言如何实现一个NBNS客户端，用于向局域网内其它设备发送NBNS NODE STATUS QUERY，并将接收到的RESPONSE信息打印出来。其实也就是一个UDP socket的实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/network/udp-socket.png&quot; alt=&quot;UDP socket flowchart&quot;&gt;&lt;/p&gt;
&lt;p&gt;编写一个客户端，首先要清楚它要完成什么任务，进而确定完成任务的方法和步骤。其任务很简单，就是NBNS数据包的发送和接收，也就是一个简单的socket收发进程。实现主要分以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;组包&lt;/strong&gt;得到NBNS NODE STATUS QUERY&lt;/li&gt;
&lt;li&gt;发送NBNS NODE STATUS QUERY&lt;/li&gt;
&lt;li&gt;接收RESPONSE并解析&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;include-amp-define&quot;&gt;&lt;a href=&quot;#include-amp-define&quot; class=&quot;headerlink&quot; title=&quot;include &amp;amp; define&quot;&gt;&lt;/a&gt;include &amp;amp; define&lt;/
      
    
    </summary>
    
      <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
      <category term="C/C++" scheme="https://www.litreily.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>使用油猴脚本批量下载canvas图片</title>
    <link href="https://www.litreily.top/2020/03/15/canvas-dl/"/>
    <id>https://www.litreily.top/2020/03/15/canvas-dl/</id>
    <published>2020-03-15T09:01:33.000Z</published>
    <updated>2020-06-13T10:38:45.607Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;女友最近在网上下载一些北大网盘的pdf&lt;a href=&quot;https://disk.pku.edu.cn/#/link/3A7748E0466521E3E68A0CBA4C24DE20?gns=AE26ACF837E24D51B1EC40E0A80A5D23%2F7F0E54D7D92343B1B62031B1C41F2280&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文档&lt;/a&gt;，结果发现没有下载接口，另存为也只能存储单张图片。找我帮忙，这时候发现程序员男票的好处了哈。&lt;/p&gt;
&lt;h2 id=&quot;分析页面&quot;&gt;&lt;a href=&quot;#分析页面&quot; class=&quot;headerlink&quot; title=&quot;分析页面&quot;&gt;&lt;/a&gt;分析页面&lt;/h2&gt;&lt;p&gt;一开始想着使用Chrome调试工具看下pdf链接，发现这个网盘居然不是直接获取的pdf文件，而是使用js脚本动态渲染生成的，涨知识了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/canvas/pdf-js.png&quot; alt=&quot;pdf-combine js&quot;&gt;&lt;/p&gt;
&lt;p&gt;那看看是否可以以图片形式批量下载呢，结果查看pdf单页的html结构发现，这居然是个canvas!!!还不是普通图片，而是画布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/canvas/canvas.png&quot; alt=&quot;cancvs&quot;&gt;&lt;/p
      
    
    </summary>
    
      <category term="Tools" scheme="https://www.litreily.top/categories/Tools/"/>
    
    
      <category term="tampermonkey" scheme="https://www.litreily.top/tags/tampermonkey/"/>
    
  </entry>
  
  <entry>
    <title>网络协议详解1 - NBNS</title>
    <link href="https://www.litreily.top/2020/02/28/nbns/"/>
    <id>https://www.litreily.top/2020/02/28/nbns/</id>
    <published>2020-02-28T01:48:26.000Z</published>
    <updated>2020-06-13T10:32:42.143Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NetBIOS-简介&quot;&gt;&lt;a href=&quot;#NetBIOS-简介&quot; class=&quot;headerlink&quot; title=&quot;NetBIOS 简介&quot;&gt;&lt;/a&gt;NetBIOS 简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;NetBIOS&lt;/strong&gt;，Network Basic Input/Output System的缩写，一般指用于&lt;strong&gt;局域网&lt;/strong&gt;通信的一套API，相关RFC文档包括 &lt;a href=&quot;https://tools.ietf.org/html/rfc1001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 1001&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1002&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC 1002&lt;/a&gt;. RFC 1001主要对NetBIOS及相关协议和服务进行解释说明，RFC 1002给出了相关协议和服务的数据组包格式。&lt;/p&gt;
&lt;p&gt;NetBIOS提供三种软件服务：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Service Name&lt;/th&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;Protocol&lt;/th&gt;
&lt;th&gt;Short Name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NetBIOS Name service&lt;/td&gt;
&lt;td&gt;137&lt;/td&gt;
&lt;td&gt;UDP/TCP&lt;/td&gt;
&lt;td&gt;NBNS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NetBIOS Datagram&lt;/td&gt;
&lt;td&gt;138&lt;/td&gt;
&lt;td&gt;UDP&lt;/td&gt;
&lt;td&gt;NBND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NetBIOS Session service&lt;/td&gt;
&lt;td&gt;139&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;NBSS&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;本文主要描述最常见的&lt;code&gt;NBNS&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="https://www.litreily.top/categories/Network/"/>
    
      <category term="Protocol" scheme="https://www.litreily.top/categories/Network/Protocol/"/>
    
    
      <category term="wireshark" scheme="https://www.litreily.top/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Setup dhcpd/dhcpdv6 server</title>
    <link href="https://www.litreily.top/2020/01/17/dhcpd_server/"/>
    <id>https://www.litreily.top/2020/01/17/dhcpd_server/</id>
    <published>2020-01-17T13:36:16.000Z</published>
    <updated>2020-06-13T10:31:34.020Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;搭建DHCP server在许多网络应用中是非常必要的，尤其是测试IPv6相关的功能时，本文就来介绍下针对IPv4和IPv6该如何搭建DHCP server.&lt;/p&gt;
&lt;h2 id=&quot;Install-dhcpd-server&quot;&gt;&lt;a href=&quot;#Install-dhcpd-server&quot; class=&quot;headerlink&quot; title=&quot;Install dhcpd server&quot;&gt;&lt;/a&gt;Install dhcpd server&lt;/h2&gt;&lt;p&gt;首先通过&lt;code&gt;apt&lt;/code&gt;安装&lt;code&gt;isc-dhcp-server&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;sudo apt install isc-dhcp-server
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;Setup-dhcpd&quot;&gt;&lt;a href=&quot;#Setup-dhcpd&quot; class=&quot;headerlink&quot; title=&quot;Setup dhcpd&quot;&gt;&lt;/a&gt;Setup dhcpd&lt;/h2&gt;&lt;h3 id=&quot;Config-interfaces&quot;&gt;&lt;a href=&quot;#Config-interfaces&quot; class=&quot;headerlink&quot; title=&quot;Config interfaces&quot;&gt;&lt;/a&gt;Config interfaces&lt;/h3&gt;&lt;p&gt;通过&lt;code&gt;ifco
      
    
    </summary>
    
      <category term="Network" scheme="https://www.litreily.top/categories/Network/"/>
    
    
      <category term="ubuntu" scheme="https://www.litreily.top/tags/ubuntu/"/>
    
      <category term="dhcp" scheme="https://www.litreily.top/tags/dhcp/"/>
    
      <category term="ipv6" scheme="https://www.litreily.top/tags/ipv6/"/>
    
  </entry>
  
  <entry>
    <title>根据socket端口号查看进程信息</title>
    <link href="https://www.litreily.top/2020/01/15/socket_fd/"/>
    <id>https://www.litreily.top/2020/01/15/socket_fd/</id>
    <published>2020-01-15T11:28:56.000Z</published>
    <updated>2020-02-26T13:11:56.224Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据已知的一个端口号，以telnet默认端口号23为例，去查找系统中监听该端口号的进程，主要可以通过下面3种方式。&lt;/p&gt;
&lt;h2 id=&quot;netstat&quot;&gt;&lt;a href=&quot;#netstat&quot; class=&quot;headerlink&quot; title=&quot;netstat&quot;&gt;&lt;/a&gt;netstat&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;netstat&lt;/code&gt;可以查看系统网络状态，&lt;code&gt;-p&lt;/code&gt;参数可以显示对应的进程信息&lt;code&gt;pid/process&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ netstat -anp |grep &amp;quot;:23&amp;quot;
tcp        0      0 192.168.1.1:23          0.0.0.0:*               LISTEN      3698/utelnetd
tcp        0      0 192.168.1.1:23          192.168.1.10:10381      ESTABLISHED 3698/utelnetd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面的信息中可以看到两条信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监听23端口的进程是pid为&lt;code&gt;3698&lt;/code&gt;的&lt;code&gt;utelnetd&lt;/code&gt;&lt;/li&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="socket" scheme="https://www.litreily.top/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>awk &#39;!a[$0]++&#39;去重小技巧</title>
    <link href="https://www.litreily.top/2020/01/09/awk_dedup/"/>
    <id>https://www.litreily.top/2020/01/09/awk_dedup/</id>
    <published>2020-01-09T13:04:16.000Z</published>
    <updated>2020-02-26T13:11:56.223Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天碰到一个关于awk的去重用法，觉得挺有意思的，记录一下&lt;/p&gt;
&lt;h2 id=&quot;awk-按行去重&quot;&gt;&lt;a href=&quot;#awk-按行去重&quot; class=&quot;headerlink&quot; title=&quot;awk 按行去重&quot;&gt;&lt;/a&gt;awk 按行去重&lt;/h2&gt;&lt;p&gt;&lt;code&gt;awk &amp;#39;!a[$0]++&amp;#39; file&lt;/code&gt; 是个神奇的用法，通过它可以实现文件内容去重&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$0&lt;/code&gt;: 代表整行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a[]&lt;/code&gt;: 代表数组a,名称随意,首次调用时为空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;++&lt;/code&gt;:　与&lt;code&gt;C/C++&lt;/code&gt;中的&lt;code&gt;++&lt;/code&gt;一个含义，&lt;code&gt;i++&lt;/code&gt;先使用i后i自增1，&lt;code&gt;++i&lt;/code&gt;代表i先自增1然后被使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!&lt;/code&gt;: 代表取反&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以&lt;code&gt;a[$0]&lt;/code&gt;代表对当前行构建一个名为a的数组，首次构建后其值为0&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a[$0]++&lt;/code&gt;代表先使用&lt;code&gt;a[$0]&lt;/code&gt;的值，然后&lt;code&gt;a[$0]&lt;/code&gt;的值自增1。首次调用自然就是0,下次遇到重复的行就变为1，所以不加&lt;code&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://www.litreily.top/tags/shell/"/>
    
      <category term="awk" scheme="https://www.litreily.top/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>insmod内核模块提示Unknown Symbol问题处理</title>
    <link href="https://www.litreily.top/2019/11/07/unknown_symbol/"/>
    <id>https://www.litreily.top/2019/11/07/unknown_symbol/</id>
    <published>2019-11-07T02:19:26.000Z</published>
    <updated>2020-06-13T10:33:48.582Z</updated>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在调试内核crash问题时打开了&lt;code&gt;lockup&lt;/code&gt;相关的kernel CONFIG，重新编译FW后发现有个内核模块insmod失败&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;log&quot;&gt;[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol rcu_bh_lock_map (err 0)
[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol lock_acquire (err 0)
[Wed Nov 06 15:51:57.384 2019] ip6t_CONE: Unknown symbol lock_release (err 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手动使用&lt;code&gt;insmod&lt;/code&gt;重新加载也是提示相同的错误。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;原本这个问题是不存在的，出现的原因必然和启用的CONFIG相关，对比前后两个FW的&lt;cod
      
    
    </summary>
    
      <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
      <category term="IPv6" scheme="https://www.litreily.top/tags/IPv6/"/>
    
      <category term="kernel" scheme="https://www.litreily.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>openwrt swconfig stack trace分析</title>
    <link href="https://www.litreily.top/2019/11/06/swconfig_crash/"/>
    <id>https://www.litreily.top/2019/11/06/swconfig_crash/</id>
    <published>2019-11-06T11:04:20.000Z</published>
    <updated>2020-06-13T10:33:48.582Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接上一篇博客 &lt;a href=&quot;/2019/11/03/kernel_debug/&quot; title=&quot;watchdog bite导致系统重启问题的调试&quot;&gt;watchdog bite导致系统重启问题的调试&lt;/a&gt; ，打开调试功能后开始压力测试，在测试过程中发现DUT每隔2s打印一次以下异常信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;log&quot;&gt;BUG: sleeping function called from invalid context at kernel/locking/mutex.c:616
in_atomic(): 1, irqs_disabled(): 0, pid: 9465, name: swconfig
INFO: lockdep is turned off.
CPU: 2 PID: 9465 Comm: swconfig Tainted: P        W    3.14.77 #1
[&amp;lt;c021561c&amp;gt;] (unwind_backtrace) from [&amp;lt;c0211d44&amp;gt;] (show_stack+0x18/0x1c)
[&amp;lt;c0211d44&amp;gt;] (show_stack) from [&amp;lt;c062ea98&amp;gt;] (dump_stack+0x9c/0xd4)
[&amp;lt;c062ea98&amp;gt;] (du
      
    
    </summary>
    
      <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
      <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>watchdog bite导致系统重启问题的调试</title>
    <link href="https://www.litreily.top/2019/11/03/kernel_debug/"/>
    <id>https://www.litreily.top/2019/11/03/kernel_debug/</id>
    <published>2019-11-03T07:04:20.000Z</published>
    <updated>2020-01-14T13:33:20.000Z</updated>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景说明&quot;&gt;&lt;a href=&quot;#背景说明&quot; class=&quot;headerlink&quot; title=&quot;背景说明&quot;&gt;&lt;/a&gt;背景说明&lt;/h2&gt;&lt;p&gt;ST在做stress test过程中发现一个bug，DUT会在工作一段时间后重启，重启原因是&lt;code&gt;watchdog bite&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;txt&quot;&gt;[Thu Sep 26 09:21:59.734 2019] Watchdog bark! Now = 831425.568038
[Thu Sep 26 09:21:59.734 2019] Causing a watchdog bite!
[Thu Sep 26 09:21:59.734 2019] Configuring Watchdog Timer
[Thu Sep 26 09:21:59.734 2019] Wa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是无法确定根本原因是什么，是什么导致的死锁，让watchdog没办法在规定时间内bark。为此，我们需要启用相关的内核调试手段去获取相关信息，然后深入分析crashdump和console log。&lt;/p&gt;
&lt;h2 id=&quot;内核裁剪&quot;&gt;&lt;a href=&quot;#内核裁剪&quot; class=&quot;headerlink&quot; title=&quot;内核裁剪&quot;&gt;&lt;/a&gt;内核裁剪&lt;/h2&gt;&lt;h3 id=&quot;启用f
      
    
    </summary>
    
      <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
      <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
      <category term="ftrace" scheme="https://www.litreily.top/tags/ftrace/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫7 - 爬取表情包</title>
    <link href="https://www.litreily.top/2019/10/09/fabiaoqing/"/>
    <id>https://www.litreily.top/2019/10/09/fabiaoqing/</id>
    <published>2019-10-09T12:22:30.000Z</published>
    <updated>2020-08-09T03:13:30.510Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了逗女朋友开心，想找一堆表情包，那么作为一名程序员，自然是会想到用程序来完成这个事情，而Python爬虫就是一个非常好的方法。&lt;/p&gt;
&lt;p&gt;我先找到了一个专门发布表情包的网站，就叫做&lt;a href=&quot;https://www.fabiaoqing.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;发表情&lt;/a&gt;网，可以通过搜索关键词得到大量相关的表情包，下面对这个网站的爬取进行详细介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/emotion/fabiaoqing.png&quot; alt=&quot;fabiaoqing&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析站点&quot;&gt;&lt;a href=&quot;#分析站点&quot; class=&quot;headerlink&quot; title=&quot;分析站点&quot;&gt;&lt;/a&gt;分析站点&lt;/h2&gt;&lt;p&gt;为了不引起不适，我选择搜索“你好”，出来的结果是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/emotion/hello.png&quot; alt=&quot;hello&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到共有&lt;code&gt;688&lt;/code&gt;个相关的&lt;strong&gt;表情&lt;/strong&gt;，右侧的&lt;strong&gt;表情包&lt;/strong&gt;是分组形式的，不是我的爬取对象。我们只关注表情，在网页底部可以看到分页信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/emotion/page.p
      
    
    </summary>
    
      <category term="Python" scheme="https://www.litreily.top/categories/Python/"/>
    
    
      <category term="spider" scheme="https://www.litreily.top/tags/spider/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式设备在无法使用网络和USB的情况下如何进行文件传输</title>
    <link href="https://www.litreily.top/2019/09/12/minicom/"/>
    <id>https://www.litreily.top/2019/09/12/minicom/</id>
    <published>2019-09-12T06:22:30.000Z</published>
    <updated>2020-02-26T13:11:56.220Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;ST 测试时出现一个问题，路由器（采用&lt;a href=&quot;https://openwrt.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Openwrt&lt;/a&gt;系统）的console无法正常显示shell提示符，正常情况下是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;root@DeviceName:/#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的，出问题时是下面这样的，用户名不见了，设备名变成了none.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;@(none):/#
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://www.litreily.top/tags/shell/"/>
    
      <category term="tftp" scheme="https://www.litreily.top/tags/tftp/"/>
    
      <category term="nand" scheme="https://www.litreily.top/tags/nand/"/>
    
  </entry>
  
  <entry>
    <title>使用正则模糊匹配的ftp文件传输</title>
    <link href="https://www.litreily.top/2019/09/02/lftp/"/>
    <id>https://www.litreily.top/2019/09/02/lftp/</id>
    <published>2019-09-02T02:51:20.000Z</published>
    <updated>2020-06-14T03:49:36.006Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;通常而言，FTP传输过程中，客户端在完成账户认证后，需要指定具体的文件路径方能下载或删除服务器端的文件。但是在使用命令行指令去操作ftp数据时，如果每次都要输入完整的路径就太麻烦了，而且如果想要同时下载多个文件还需逐个执行下载指令，那有什么方法可以通过&lt;strong&gt;正则表达式&lt;/strong&gt;去完成模糊匹配和批量下载呢？本文就来介绍一下FTP数据传输的常用操作及正则匹配的实现方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/ftp/ftp.png&quot; alt=&quot;ftp diagram&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="shell" scheme="https://www.litreily.top/tags/shell/"/>
    
      <category term="ftp" scheme="https://www.litreily.top/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫6 - Scrapy爬取vmgirls</title>
    <link href="https://www.litreily.top/2019/08/09/vmgirls/"/>
    <id>https://www.litreily.top/2019/08/09/vmgirls/</id>
    <published>2019-08-09T12:09:10.000Z</published>
    <updated>2020-06-14T02:08:52.910Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天介绍一个妹子站点图片的爬取过程，站点&lt;a href=&quot;https://www.vmgirls.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;唯美女生&lt;/a&gt;。站点结构非常简单，单独用&lt;code&gt;requests&lt;/code&gt;库或者&lt;code&gt;scrapy&lt;/code&gt;框架都可以。本文介绍的是使用&lt;code&gt;scrapy&lt;/code&gt;框架爬取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/vmgirls/vmgirls.png&quot; alt=&quot;vmgirls&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.litreily.top/categories/Python/"/>
    
    
      <category term="spider" scheme="https://www.litreily.top/tags/spider/"/>
    
      <category term="girls" scheme="https://www.litreily.top/tags/girls/"/>
    
  </entry>
  
  <entry>
    <title>高效思维导图应用训练</title>
    <link href="https://www.litreily.top/2019/06/11/mind-map/"/>
    <id>https://www.litreily.top/2019/06/11/mind-map/</id>
    <published>2019-06-11T12:23:34.000Z</published>
    <updated>2020-06-14T02:10:14.495Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;上周在公司进行了一天的思维导图培训，感觉收获颇丰，有必要总结一下。&lt;/p&gt;
&lt;h2 id=&quot;思维导图概述&quot;&gt;&lt;a href=&quot;#思维导图概述&quot; class=&quot;headerlink&quot; title=&quot;思维导图概述&quot;&gt;&lt;/a&gt;思维导图概述&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;思维导图主要用于解决以下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;记不住&lt;/li&gt;
&lt;li&gt;理不清&lt;/li&gt;
&lt;li&gt;想不出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三个也是工作效能低下的主要原因。那究竟什么是思维导图呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;思维导图&lt;/strong&gt;是表达&lt;strong&gt;放射性思维&lt;/strong&gt;的图形思维工具。用&lt;strong&gt;图文&lt;/strong&gt;技巧，把各级主题关系用层级图表现，将关键词与图像、颜色等建立思维链接。用&lt;strong&gt;全脑机能&lt;/strong&gt;，使在科学与艺术、逻辑与想象间平衡，开启大脑潜能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://www.litreily.top/categories/Tools/"/>
    
    
      <category term="5W2H" scheme="https://www.litreily.top/tags/5W2H/"/>
    
      <category term="MECE" scheme="https://www.litreily.top/tags/MECE/"/>
    
  </entry>
  
  <entry>
    <title>哈希表的实现与常见操作</title>
    <link href="https://www.litreily.top/2019/05/24/hash-table/"/>
    <id>https://www.litreily.top/2019/05/24/hash-table/</id>
    <published>2019-05-24T12:00:00.000Z</published>
    <updated>2020-06-14T02:11:04.810Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前段时间基于数组和单链表以拉链法写了个哈希表，实现了基本的增删改查（&lt;code&gt;CRUD&lt;/code&gt;），以键值对的形式存储一些配置参数，便以此文记录一下。&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#define TABLE_SIZE 101
#define KEY_SIZE 32
#define VALUE_SIZE 128
#define BUF_SIZE 256

#define DATA_PATH &amp;quot;data.txt&amp;quot;

struct linklist {
    char key[KEY_SIZE];
    char val[VALUE_SIZE];
    struct linklist *next;
};
struct linklist *hashtbl[TABLE_SIZE];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
      <category term="C/C++" scheme="https://www.litreily.top/tags/C-C/"/>
    
      <category term="linux" scheme="https://www.litreily.top/tags/linux/"/>
    
      <category term="hash" scheme="https://www.litreily.top/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>git commit 工具 - commitizen</title>
    <link href="https://www.litreily.top/2019/03/12/commitizen/"/>
    <id>https://www.litreily.top/2019/03/12/commitizen/</id>
    <published>2019-03-12T13:39:10.000Z</published>
    <updated>2020-06-14T02:11:21.056Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;为了规范代码提交，最近学习了一下如何使用&lt;code&gt;commitizen&lt;/code&gt;进行commit提交，其实也很简单，这里简单做个介绍。&lt;/p&gt;
&lt;h2 id=&quot;commitizen-安装&quot;&gt;&lt;a href=&quot;#commitizen-安装&quot; class=&quot;headerlink&quot; title=&quot;commitizen 安装&quot;&gt;&lt;/a&gt;commitizen 安装&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npm install -g commitizen
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://www.litreily.top/categories/Tools/"/>
    
    
      <category term="git" scheme="https://www.litreily.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫5 - 爬取QQ空间相册</title>
    <link href="https://www.litreily.top/2019/03/03/qqzone/"/>
    <id>https://www.litreily.top/2019/03/03/qqzone/</id>
    <published>2019-03-03T10:34:20.000Z</published>
    <updated>2020-06-14T02:11:37.325Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自毕业后，就再也没有用过QQ，QQ空间里记录的是些并不精彩的青葱岁月，但好歹也是份回忆，近日想着学以致用，用&lt;code&gt;Python&lt;/code&gt;把QQ空间相册的所有照片爬取下来，以作备份。&lt;/p&gt;
&lt;h2 id=&quot;分析QQ空间&quot;&gt;&lt;a href=&quot;#分析QQ空间&quot; class=&quot;headerlink&quot; title=&quot;分析QQ空间&quot;&gt;&lt;/a&gt;分析QQ空间&lt;/h2&gt;&lt;h3 id=&quot;登录QQ空间&quot;&gt;&lt;a href=&quot;#登录QQ空间&quot; class=&quot;headerlink&quot; title=&quot;登录QQ空间&quot;&gt;&lt;/a&gt;登录QQ空间&lt;/h3&gt;&lt;p&gt;爬取第一步，分析站点，首先需要知道如何登录QQ空间。最初想法是用&lt;code&gt;requests&lt;/code&gt;库配置登录请求，模拟登录，但是不久便放弃了这一思路，请看下图↓&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/qqzone/login.png&quot; alt=&quot;login&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据登录按钮绑定的监听事件可以追踪到该按钮的点击事件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/qqzone/login_func.png&quot; alt=&quot;login function&quot;&gt;&lt;/p&gt;
&lt;p&gt;账号加密是必然的，但这一堆堆的代码真心不好解析，有耐心的勇士尽情一试！&lt;/p&gt;
&lt;p&gt;在排除这种登录方法后，选择&lt;code&gt;selenium&lt;/c
      
    
    </summary>
    
      <category term="Python" scheme="https://www.litreily.top/categories/Python/"/>
    
    
      <category term="spider" scheme="https://www.litreily.top/tags/spider/"/>
    
      <category term="qqzone" scheme="https://www.litreily.top/tags/qqzone/"/>
    
  </entry>
  
  <entry>
    <title>记一次Client无法获取IPv6地址问题的分析过程</title>
    <link href="https://www.litreily.top/2019/02/27/ipv6/"/>
    <id>https://www.litreily.top/2019/02/27/ipv6/</id>
    <published>2019-02-27T05:47:30.000Z</published>
    <updated>2020-06-13T10:33:48.579Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;近日SQA报了一个bug，对路由器经过6天左右的压力测试后，无论是有线设备还是无线设备都拿不到&lt;code&gt;IPv6&lt;/code&gt;地址了。经过层层分析发现可能是&lt;code&gt;kernel&lt;/code&gt;内存泄漏。本文便记录这一问题的分析过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
      <category term="IPv6" scheme="https://www.litreily.top/tags/IPv6/"/>
    
      <category term="router" scheme="https://www.litreily.top/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu开机自动挂载Windows系统中的磁盘分区</title>
    <link href="https://www.litreily.top/2019/02/17/mount/"/>
    <id>https://www.litreily.top/2019/02/17/mount/</id>
    <published>2019-02-17T12:39:57.000Z</published>
    <updated>2020-06-14T02:11:50.115Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本人电脑装有&lt;code&gt;ubuntu&lt;/code&gt;和&lt;code&gt;windows&lt;/code&gt;双系统，有时候需要在&lt;code&gt;ubuntu&lt;/code&gt;下使用&lt;code&gt;windows&lt;/code&gt;系统下的文件，每次手动挂载的话很麻烦，所以想让它开机自动挂载常用的&lt;code&gt;windows&lt;/code&gt;磁盘分区。&lt;/p&gt;
&lt;h2 id=&quot;查看分区&quot;&gt;&lt;a href=&quot;#查看分区&quot; class=&quot;headerlink&quot; title=&quot;查看分区&quot;&gt;&lt;/a&gt;查看分区&lt;/h2&gt;&lt;p&gt;在挂载windows磁盘前，需要知道每个磁盘的路径或&lt;code&gt;UUID&lt;/code&gt;，此时主要依靠&lt;code&gt;fdisk&lt;/code&gt;和&lt;code&gt;blkid&lt;/code&gt;两个指令，前一个指令获取分区信息，后一个指令获取&lt;code&gt;Block device&lt;/code&gt;块设备的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;$ sudo blkid
/dev/sda1: LABEL=&amp;quot;Win10&amp;quot; UUID=&amp;quot;C4A0E65EA0E65708&amp;quot; TYPE=&amp;quot;ntfs&amp;quot; PARTUUID=&amp;quot;6190c592-01&amp;quot;
/dev/sda2: UUID=&amp;quot;AE3C137D3C133FAF&amp;quot; TYPE=&amp;
      
    
    </summary>
    
      <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
      <category term="ubuntu" scheme="https://www.litreily.top/tags/ubuntu/"/>
    
      <category term="mount" scheme="https://www.litreily.top/tags/mount/"/>
    
  </entry>
  
</feed>
