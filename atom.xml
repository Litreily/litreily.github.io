<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LITREILY</title>
  <icon>https://www.gravatar.com/avatar/6ae20d989e9d976faf00ecc6d9bcfe82</icon>
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="https://www.litreily.top/atom.xml" rel="self"/>
  
  <link href="https://www.litreily.top/"/>
  <updated>2022-01-11T04:31:07.119Z</updated>
  <id>https://www.litreily.top/</id>
  
  <author>
    <name>litreily</name>
    <email>707922098@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RK3288 android 6.0 卡死在开机logo画面问题处理</title>
    <link href="https://www.litreily.top/2022/01/11/rk3288-hang/"/>
    <id>https://www.litreily.top/2022/01/11/rk3288-hang/</id>
    <published>2022-01-11T03:49:02.000Z</published>
    <updated>2022-01-11T04:31:07.119Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;烧录固件后，会概率性出现卡死在开机画面无法启动的问题，但是烧录新固件后会恢复正常。对比不同机型，发现只有带&lt;strong&gt;摄像头功能&lt;/strong&gt;的机型会有这个问题。&lt;/p&gt;
&lt;h2 id=&quot;Root-cause&quot;&gt;&lt;a href=&quot;#Root-cause&quot; class=&quot;headerlink&quot; title=&quot;Root cause&quot;&gt;&lt;/a&gt;Root cause&lt;/h2&gt;&lt;p&gt;经过大量测试和排查，发现卡死问题源自一个文件,  &lt;code&gt;/data/camera/media_profiles.xml&lt;/code&gt; , 这是一个空文件，删除后系统就正常启动了。&lt;/p&gt;
&lt;p&gt;通过使用 &lt;code&gt;logcat&lt;/code&gt; 结合系统源码发现，该文件是摄像头配置文件，如果为空会导致系统循环检测该文件，并尝试从中获取摄像头配置，但是由于文件为空，导致一直获取失败，最后陷入死循环。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cd /data/camera
$ ls
media_profiles.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过排查源码，发现系统在</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="android" scheme="https://www.litreily.top/tags/android/"/>
    
    <category term="rk3288" scheme="https://www.litreily.top/tags/rk3288/"/>
    
  </entry>
  
  <entry>
    <title>RK3288 android 6.0 user release 相关问题处理</title>
    <link href="https://www.litreily.top/2021/12/31/rk3288-security/"/>
    <id>https://www.litreily.top/2021/12/31/rk3288-security/</id>
    <published>2021-12-31T02:58:22.000Z</published>
    <updated>2021-12-31T03:45:28.968Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;之前一直用的 &lt;code&gt;userdebug&lt;/code&gt; 版本，默认 &lt;code&gt;adb root&lt;/code&gt; 或者使用 &lt;code&gt;su&lt;/code&gt; 即可获取 root 权限。目前基于安全考虑，固件发布需要使用 &lt;code&gt;user&lt;/code&gt; 版本配置，很多功能都需要重新测试，下面对 &lt;code&gt;RK3288&lt;/code&gt; &lt;code&gt;user&lt;/code&gt; 发布版本遇到的问题进行总结。&lt;/p&gt;
&lt;h2 id=&quot;编译固件&quot;&gt;&lt;a href=&quot;#编译固件&quot; class=&quot;headerlink&quot; title=&quot;编译固件&quot;&gt;&lt;/a&gt;编译固件&lt;/h2&gt;&lt;p&gt;首先是编译固件，将原先的 &lt;code&gt;rk3288-userdebug&lt;/code&gt; 改为 &lt;code&gt;rk3288-user&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;./FFTools/make.sh -d rk3288-tb_8846 -j16 -l rk3288-user
./FFTools/mkupdate/mkupdate.sh -l rk3288-user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是 firefly 官方 wiki 文档对 &lt;code&gt;user&lt;/code&gt;, &lt;code&gt;userdebug&lt;/code&gt;, &lt;code&gt;eng&lt;/code&gt; 版本的对比。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="android" scheme="https://www.litreily.top/tags/android/"/>
    
    <category term="rk3288" scheme="https://www.litreily.top/tags/rk3288/"/>
    
  </entry>
  
  <entry>
    <title>RK3288 android 6.0 user release 获取 root 权限</title>
    <link href="https://www.litreily.top/2021/12/30/rk3288-su/"/>
    <id>https://www.litreily.top/2021/12/30/rk3288-su/</id>
    <published>2021-12-30T02:22:18.000Z</published>
    <updated>2021-12-31T03:01:24.994Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;编译 RK3288 &lt;code&gt;user&lt;/code&gt; 版本后，固件不会安装su，也就无法使用root权限，导致很多功能无法调试，非常不便。&lt;/p&gt;
&lt;p&gt;为此，我想办法把 su 重新加到系统里了。&lt;/p&gt;
&lt;h2 id=&quot;准备su&quot;&gt;&lt;a href=&quot;#准备su&quot; class=&quot;headerlink&quot; title=&quot;准备su&quot;&gt;&lt;/a&gt;准备su&lt;/h2&gt;&lt;p&gt;先使用 &lt;code&gt;userdebug&lt;/code&gt; 模式编译系统，将 &lt;code&gt;out/target/product/rk3288/system/xbin/su&lt;/code&gt; 保存到别的地方，因为改用 &lt;code&gt;user&lt;/code&gt; 模式编译后会覆盖掉。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;mkdir ~/backup
cp out/target/product/rk3288/system/xbin/su ~/backup/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;删除-su-Android-mk&quot;&gt;&lt;a href=&quot;#删除-su-Android-mk&quot; class=&quot;headerlink&quot; title=&quot;删除 su Android.mk&quot;&gt;&lt;/a&gt;删除 su Android.mk&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;rm system/extras/su/Andro</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="android" scheme="https://www.litreily.top/tags/android/"/>
    
    <category term="rk3288" scheme="https://www.litreily.top/tags/rk3288/"/>
    
  </entry>
  
  <entry>
    <title>RK3399 新设计工控机配置指南</title>
    <link href="https://www.litreily.top/2021/12/20/rk3399-dts/"/>
    <id>https://www.litreily.top/2021/12/20/rk3399-dts/</id>
    <published>2021-12-20T06:20:20.000Z</published>
    <updated>2021-12-21T06:13:50.773Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;用时两周，总算将新的 RK3399 工控机配置好了，期间遇到各种坑，在此记录一二。&lt;/p&gt;
&lt;h2 id=&quot;RK3399-工控机硬件配置&quot;&gt;&lt;a href=&quot;#RK3399-工控机硬件配置&quot; class=&quot;headerlink&quot; title=&quot;RK3399 工控机硬件配置&quot;&gt;&lt;/a&gt;RK3399 工控机硬件配置&lt;/h2&gt;&lt;p&gt;首先看下硬件配置。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;接口&lt;/th&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;TypeC&lt;/td&gt;
&lt;td&gt;1个&lt;/td&gt;
&lt;td&gt;OTG 口，可用于烧录固件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USB3.0&lt;/td&gt;
&lt;td&gt;4个&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USB2.0&lt;/td&gt;
&lt;td&gt;2个&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RTC芯片 hym8563&lt;/td&gt;
&lt;td&gt;1个&lt;/td&gt;
&lt;td&gt;用于RTC时钟存储&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SD&lt;/td&gt;
&lt;td&gt;1个&lt;/td&gt;
&lt;td&gt;可插入SD/TF 卡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HDMI&lt;/td&gt;
&lt;td&gt;1个&lt;/td&gt;
&lt;td&gt;可接显示器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="linux" scheme="https://www.litreily.top/tags/linux/"/>
    
    <category term="rk3399" scheme="https://www.litreily.top/tags/rk3399/"/>
    
  </entry>
  
  <entry>
    <title>RK3288 android 6.0 内置系统应用</title>
    <link href="https://www.litreily.top/2021/10/27/system-app/"/>
    <id>https://www.litreily.top/2021/10/27/system-app/</id>
    <published>2021-10-27T11:02:51.000Z</published>
    <updated>2021-10-27T11:29:45.567Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;安卓系统的内置应用可分为以下两大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可卸载的普通应用&lt;/li&gt;
&lt;li&gt;不可卸载的系统应用，可以在首次烧录后自启动&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;可卸载应用&quot;&gt;&lt;a href=&quot;#可卸载应用&quot; class=&quot;headerlink&quot; title=&quot;可卸载应用&quot;&gt;&lt;/a&gt;可卸载应用&lt;/h2&gt;&lt;p&gt;对于可卸载应用，其内置很简单，只需要将apk文件放置在指定目录即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;cp My_application.apk device/rockchip/rk3288/preinstall_del/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;不可卸载应用&quot;&gt;&lt;a href=&quot;#不可卸载应用&quot; class=&quot;headerlink&quot; title=&quot;不可卸载应用&quot;&gt;&lt;/a&gt;不可卸载应用&lt;/h2&gt;&lt;p&gt;针对不可卸载的系统应用，复杂一些，需要放置在 &lt;code&gt;packages/apps&lt;/code&gt; 目录，具体操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;apk_file=My_application.apk
install_dir=packages/apps/$&amp;#123;apk_file&amp;#125;
mkdir $&amp;#123;install_dir&amp;#125;
cp $&amp;#123;ap</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="linux" scheme="https://www.litreily.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>解压并更新 ramdisk.img 或 initrd.img</title>
    <link href="https://www.litreily.top/2021/07/31/ramdisk/"/>
    <id>https://www.litreily.top/2021/07/31/ramdisk/</id>
    <published>2021-07-31T06:03:20.000Z</published>
    <updated>2021-07-31T06:18:36.245Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;ramdisk.img&lt;/code&gt; 或者 &lt;code&gt;initrd.img&lt;/code&gt; 是类似的，都是一个小型的文件系统。在系统启动过程中起到引导的作用，内核通过它来启动真正的根文件系统。&lt;/p&gt;
&lt;p&gt;有时候需要修改并更新这个文件，下面以&lt;code&gt;ramdisk.img&lt;/code&gt; 为例进行说明。&lt;/p&gt;
&lt;h2 id=&quot;解压-ramdisk-img&quot;&gt;&lt;a href=&quot;#解压-ramdisk-img&quot; class=&quot;headerlink&quot; title=&quot;解压 ramdisk.img&quot;&gt;&lt;/a&gt;解压 ramdisk.img&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ramdisk.img&lt;/code&gt; 其实是一个&lt;code&gt;gz&lt;/code&gt;格式的压缩包，可以通过 &lt;code&gt;gzip -d&lt;/code&gt; 或者 &lt;code&gt;gunzip&lt;/code&gt; 解压，不过需要注意的是 &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;gunzip&lt;/code&gt; 会检查文件名后缀，所以需要先将后缀更新为 &lt;code&gt;.gz&lt;/code&gt;. 下面将其解压至新建的 &lt;code&gt;root&lt;/code&gt; 目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cp ramdisk.img ramdisk.gz
$ gzip -d ramdisk.gz
$ mkdir root
</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="linux" scheme="https://www.litreily.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>RK3288 android 6.0 移植 gt9xx 驱动</title>
    <link href="https://www.litreily.top/2021/07/16/gt9xx-drvier/"/>
    <id>https://www.litreily.top/2021/07/16/gt9xx-drvier/</id>
    <published>2021-07-16T05:49:36.000Z</published>
    <updated>2021-07-31T06:02:19.453Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;平台：RK3288&lt;/li&gt;
&lt;li&gt;系统：Android 6.0&lt;/li&gt;
&lt;li&gt;需求：触摸屏驱动移植&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;驱动移植&quot;&gt;&lt;a href=&quot;#驱动移植&quot; class=&quot;headerlink&quot; title=&quot;驱动移植&quot;&gt;&lt;/a&gt;驱动移植&lt;/h2&gt;&lt;p&gt;先从厂商获取驱动程序 gt9xx_v2.8.0.2.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;gt9xx_v2.8.0.2
├── dtsi
│   ├── gt9xx_dts.txt
│   ├── pinctrl_mtk.txt
│   └── pinctrl_qcom.txt
├── goodix_tool.c
├── gt9xx.c
├── gt9xx.h
├── gt9xx_update.c
├── Kconfig
└── Makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建目录 &lt;code&gt;drivers/input/touchscreen/gt9xx_v2.8.0.2/&lt;/code&gt; ,将以上 &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.h&lt;/code&gt;, 及 &lt;code&gt;Makefile&lt;/cod</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="android" scheme="https://www.litreily.top/tags/android/"/>
    
    <category term="rk3288" scheme="https://www.litreily.top/tags/rk3288/"/>
    
  </entry>
  
  <entry>
    <title>RK3288 android 6.0 同时打开两个摄像头</title>
    <link href="https://www.litreily.top/2021/07/12/dual-camera/"/>
    <id>https://www.litreily.top/2021/07/12/dual-camera/</id>
    <published>2021-07-12T10:02:15.000Z</published>
    <updated>2021-07-12T10:32:17.355Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;平台: RK3288&lt;/li&gt;
&lt;li&gt;系统: Android 6.0&lt;/li&gt;
&lt;li&gt;需求: 同时打开两个摄像头&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;业务需求，要支持同时打开多个摄像头，期间遇到一些问题，在这里记录下。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;h3 id=&quot;支持多摄像头&quot;&gt;&lt;a href=&quot;#支持多摄像头&quot; class=&quot;headerlink&quot; title=&quot;支持多摄像头&quot;&gt;&lt;/a&gt;支持多摄像头&lt;/h3&gt;&lt;p&gt;首先，Android系统默认只支持同时打开一个摄像头，并且最大只识别两个摄像头。所以，为了支持多摄像头，需要修改摄像头相关的 &lt;code&gt;HAL&lt;/code&gt; 层。&lt;/p&gt;
&lt;p&gt;这个我参考 &lt;a href=&quot;https://www.programmersought.com/article/12481783276/&quot;&gt;[AndroidO] [RK3399] Support 4 way camera preview&lt;/a&gt; 解决了。patch 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code c</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="android" scheme="https://www.litreily.top/tags/android/"/>
    
    <category term="rk3288" scheme="https://www.litreily.top/tags/rk3288/"/>
    
  </entry>
  
  <entry>
    <title>RK3288 android 6.0 实现 lvds + edp 双屏异显</title>
    <link href="https://www.litreily.top/2021/06/18/dual-lcd/"/>
    <id>https://www.litreily.top/2021/06/18/dual-lcd/</id>
    <published>2021-06-18T08:23:15.000Z</published>
    <updated>2021-06-18T08:51:19.610Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;rk3288&lt;/code&gt; 默认支持 edp+hdmi 双屏显示，或者 lvds + hdmi, 但不支持 &lt;code&gt;lvds&lt;/code&gt; + &lt;code&gt;edp&lt;/code&gt; 双屏异显。业务要求，需要使用RK3288 Android 6.0 系统，支持 &lt;code&gt;lvds&lt;/code&gt;, &lt;code&gt;edp&lt;/code&gt; 两种接口的双屏异显。本文介绍具体的实现方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平台: RK3288&lt;/li&gt;
&lt;li&gt;系统: Android 6.0&lt;/li&gt;
&lt;li&gt;屏幕: LVDS(7 inch 1024x600), edp(11 inch 1920x1080)&lt;/li&gt;
&lt;li&gt;需求: LVDS (Primary) + edp (EXTEND) 双屏异显&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt; 主屏副屏的切换只要修改dts相关参数即可，&lt;code&gt;lvds&lt;/code&gt; &lt;code&gt;edp&lt;/code&gt; 主副互换比较简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;kernel&quot;&gt;&lt;a href=&quot;#kernel&quot; class=&quot;headerlink&quot; title=&quot;kernel&quot;&gt;&lt;/a&gt;kernel&lt;/h2&gt;&lt;p&gt;首先修改 &lt;code&gt;kernel&lt;/code&gt;, 这里参考了博客&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="android" scheme="https://www.litreily.top/tags/android/"/>
    
    <category term="rk3288" scheme="https://www.litreily.top/tags/rk3288/"/>
    
  </entry>
  
  <entry>
    <title>解决Ubuntu 18.04 minicom 不支持 1500000 波特率的问题</title>
    <link href="https://www.litreily.top/2021/05/28/cp210x/"/>
    <id>https://www.litreily.top/2021/05/28/cp210x/</id>
    <published>2021-05-28T03:26:15.000Z</published>
    <updated>2021-05-28T03:31:18.046Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近使用 &lt;code&gt;Ubuntu 18.04&lt;/code&gt; 作为台式机的办公系统，需要使用串口调试功能，于是安装了 &lt;code&gt;minicom&lt;/code&gt;, 但是配置波特率的时候发现无法配置高于 &lt;code&gt;1000000&lt;/code&gt; 以上波特率。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ sudo stty -F /dev/ttyUSB0 1500000
stty: /dev/ttyUSB0: unable to perform all requested operations
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="ubuntu" scheme="https://www.litreily.top/tags/ubuntu/"/>
    
    <category term="usb" scheme="https://www.litreily.top/tags/usb/"/>
    
  </entry>
  
  <entry>
    <title>基于 IPQ807x 编译 QSDK</title>
    <link href="https://www.litreily.top/2021/02/07/qsdk-compile/"/>
    <id>https://www.litreily.top/2021/02/07/qsdk-compile/</id>
    <published>2021-02-07T06:19:04.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;接上一篇 &lt;a href=&quot;https://www.litreily.top/2021/01/29/qsdk/&quot;&gt;下载安装基于 openwrt 的 QSDK&lt;/a&gt;,  这一篇来讲下编译 &lt;code&gt;QSDK&lt;/code&gt; 的步骤以及遇到的问题及其处理方法。&lt;/p&gt;
&lt;p&gt;正常步骤，是下面这样的，根据设备类型选择 config 文件，生成 .config, 然后完整编译。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;cp qca/configs/qsdk/ipq_open.config .config
echo  CONFIG_TARGET_ipq_ipq807x_64=y  &amp;gt;&amp;gt; .config
echo CONFIG_TARGET_ipq_ipq807x_64_QSDK_Open=y  &amp;gt;&amp;gt; .config

make package/symlinks
make defconfig
make V=s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;make V=s&lt;/code&gt; 之前的指令都能正常通过，但是编译过程中就可能出现各种情况，比如缺少编译工具等。&lt;/p&gt;
&lt;h2 id=&quot;依赖工具&quot;&gt;&lt;a href=&quot;#依赖工具&quot; class=&quot;headerlink&quot; title=&quot;依赖工具&quot;&gt;&lt;/a&gt;依赖工具&lt;/h2&gt;&lt;p&gt;每个人的编译环境可能</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
    <category term="qsdk" scheme="https://www.litreily.top/tags/qsdk/"/>
    
  </entry>
  
  <entry>
    <title>下载安装基于 openwrt 的 QSDK</title>
    <link href="https://www.litreily.top/2021/01/29/qsdk/"/>
    <id>https://www.litreily.top/2021/01/29/qsdk/</id>
    <published>2021-01-29T09:29:56.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;QSDK&lt;/code&gt; - QCA Software Development Kits, 基于 openwrt 加入了 QCA 相关的代码库，可以用于使用 qualcomm 芯片的路由器固件开发。本文讲述如何获取 QSDK.&lt;/p&gt;
&lt;p&gt;我们通常会使用 &lt;code&gt;git clone&lt;/code&gt; 获取开源项目的代码，比如 github, gitlab, coding 等平台，但是 &lt;code&gt;QSDK&lt;/code&gt; 并不存放于这些平台，而是有它自己的维护站点，并且需要通过 &lt;code&gt;repo&lt;/code&gt; 和 &lt;code&gt;git&lt;/code&gt; 共同完成仓库文件的 &lt;code&gt;clone&lt;/code&gt;, 下面来看看吧。&lt;/p&gt;
&lt;h2 id=&quot;install-repo&quot;&gt;&lt;a href=&quot;#install-repo&quot; class=&quot;headerlink&quot; title=&quot;install repo&quot;&gt;&lt;/a&gt;install repo&lt;/h2&gt;&lt;p&gt;首先来安装 &lt;code&gt;repo&lt;/code&gt; 工具，这其实是个 &lt;code&gt;Python&lt;/code&gt; 脚本.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;curl https://storage.googleapis.com/git-repo-downloads/repo -o repo
chmod +x</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
    <category term="qsdk" scheme="https://www.litreily.top/tags/qsdk/"/>
    
  </entry>
  
  <entry>
    <title>openwrt Makefile scan.mk 详解</title>
    <link href="https://www.litreily.top/2021/01/15/mk-scan/"/>
    <id>https://www.litreily.top/2021/01/15/mk-scan/</id>
    <published>2021-01-15T08:22:51.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;openwrt&lt;/code&gt; 中的 &lt;code&gt;include/scan.mk&lt;/code&gt; 用于扫描项目 &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;target&lt;/code&gt; 目录信息，并将扫描结果存入 &lt;code&gt;tmp&lt;/code&gt; 目录。这个扫描过程几乎是 openwrt 所有目标生成的前提。也就是说，无论使用 &lt;code&gt;make&lt;/code&gt; 编译 &lt;code&gt;openwrt&lt;/code&gt; 哪个部分的代码，都会通过 &lt;code&gt;scan.mk&lt;/code&gt; 生成必要的临时文件，这是编译其它目录的大前提。&lt;/p&gt;
&lt;p&gt;举例说明，我们指定编译某个 &lt;code&gt;package&lt;/code&gt; 时，如 &lt;code&gt;package/utils/demo&lt;/code&gt;，&lt;code&gt;make&lt;/code&gt; 根据层层 &lt;code&gt;Makefile&lt;/code&gt; 会去寻找该 &lt;code&gt;package&lt;/code&gt; 的路径，而这个路径信息就是通过 &lt;code&gt;scan.mk&lt;/code&gt; 扫描后存入了 &lt;code&gt;tmp&lt;/code&gt; 目录。这样有什么好处呢? 我完全可以手动执行 &lt;code&gt;make package/utils/demo/compile&lt;/code&gt; 不是吗？&lt;/p&gt;
&lt;p&gt;的确如此，但是我们不可能每次都去写长串的路径，通过 &lt;code&gt;</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="makefile" scheme="https://www.litreily.top/tags/makefile/"/>
    
    <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>openwrt Makefile subdir.mk 详解</title>
    <link href="https://www.litreily.top/2021/01/13/mk-subdir/"/>
    <id>https://www.litreily.top/2021/01/13/mk-subdir/</id>
    <published>2021-01-13T08:25:37.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;之前讲述了 openwrt Makefile 的&lt;a href=&quot;https://www.litreily.top/2020/12/30/openwrt-mkfile/&quot;&gt;整体框架&lt;/a&gt;，主要包括主 Makefile 的描述，，最后简单描述了 &lt;code&gt;subdir.mk&lt;/code&gt; , 本文就来详细剖析这个文件。&lt;/p&gt;
&lt;p&gt;但是在解析 &lt;code&gt;subdir.mk&lt;/code&gt; 之前，先来看两个 Makefile, &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;debug.mk&lt;/code&gt;: 这也是主 Makefile 引入的第一个 .mk 文件，这里定义的调试函数在 &lt;code&gt;subdir.mk&lt;/code&gt; 中被调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target/Makefile&lt;/code&gt;: 这是调用到 &lt;code&gt;subdir.mk&lt;/code&gt; 的首个 Makefile, 本文将以此为例进行说明&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;debug-mk&quot;&gt;&lt;a href=&quot;#debug-mk&quot; class=&quot;headerlink&quot; title=&quot;debug.mk&quot;&gt;&lt;/a&gt;debug.mk&lt;/h2&gt;&lt;p&gt;&lt;code&gt;debug.mk&lt;/code&gt; 定义了几个调试函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;co</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="makefile" scheme="https://www.litreily.top/tags/makefile/"/>
    
    <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>openwrt Makefile 框架分析</title>
    <link href="https://www.litreily.top/2020/12/30/openwrt-mkfile/"/>
    <id>https://www.litreily.top/2020/12/30/openwrt-mkfile/</id>
    <published>2020-12-30T00:49:20.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;openwrt repo: &lt;a href=&quot;https://github.com/openwrt/openwrt&quot;&gt;https://github.com/openwrt/openwrt&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;整体框架&quot;&gt;&lt;a href=&quot;#整体框架&quot; class=&quot;headerlink&quot; title=&quot;整体框架&quot;&gt;&lt;/a&gt;整体框架&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/openwrt/openwrt_arch.png&quot; alt=&quot;openwrt arch&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首行为buildroot默认目录&lt;ul&gt;
&lt;li&gt;config: 配置文件&lt;/li&gt;
&lt;li&gt;include: openwrt 的 Makefile 文件&lt;/li&gt;
&lt;li&gt;package: 各个软件包的Makefile, patches等文件&lt;/li&gt;
&lt;li&gt;scripts: openwrt 包管理相关的 perl 脚本&lt;/li&gt;
&lt;li&gt;target: 用于编译 kernel 和 firmware 的相关文件&lt;/li&gt;
&lt;li&gt;toolchain: 包含用于获取 kernel headers, C lib, bin-utils, compiler, debugger 的指令&lt;/li&gt;
&lt;li&gt;tools: 包含编译时所需的一些工具，如automake, autoco</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="makefile" scheme="https://www.litreily.top/tags/makefile/"/>
    
    <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>openwrt make defconfig 详解</title>
    <link href="https://www.litreily.top/2020/12/29/make-defconfig/"/>
    <id>https://www.litreily.top/2020/12/29/make-defconfig/</id>
    <published>2020-12-29T01:47:32.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;对于 linux kernel，有几个常用 make 指令用于生成 .config 文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make oldconfig&lt;/li&gt;
&lt;li&gt;make menuconfig&lt;/li&gt;
&lt;li&gt;make defconfig&lt;/li&gt;
&lt;li&gt;make config&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么这些指令具体执行了什么操作呢，针对 openwrt 来看下吧。&lt;/p&gt;
&lt;h2 id=&quot;主-Makefile&quot;&gt;&lt;a href=&quot;#主-Makefile&quot; class=&quot;headerlink&quot; title=&quot;主 Makefile&quot;&gt;&lt;/a&gt;主 Makefile&lt;/h2&gt;&lt;p&gt;在 buildroot 执行 make，首先会访问仓库根目录的主 &lt;a href=&quot;https://github.com/openwrt/openwrt/blob/master/Makefile&quot;&gt;Makefile&lt;/a&gt;，其中有个 ifneq 判断如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;makefile&quot;&gt;ifneq ($(OPENWRT_BUILD),1)
  _SINGLE=export MAKEFLAGS=$(space);

  override OPENWRT_BUILD=1
  export OPENWRT_BUILD
  GREP_OPTIONS=
  expor</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="makefile" scheme="https://www.litreily.top/tags/makefile/"/>
    
    <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
  </entry>
  
  <entry>
    <title>lua 高级特性</title>
    <link href="https://www.litreily.top/2020/12/25/lua-adv/"/>
    <id>https://www.litreily.top/2020/12/25/lua-adv/</id>
    <published>2020-12-25T02:08:01.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;这一篇来记录下 lua 的某些高级特性，以便在实际应用中得心应手。&lt;/p&gt;
&lt;h2 id=&quot;模块和包&quot;&gt;&lt;a href=&quot;#模块和包&quot; class=&quot;headerlink&quot; title=&quot;模块和包&quot;&gt;&lt;/a&gt;模块和包&lt;/h2&gt;&lt;p&gt;为了方便代码复用和扩展，可以使用 table 实现模块 module，在模块中封装通用代码。把同类型的函数放在一个文件中，然后在其它脚本中调用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lua&quot;&gt;module = &amp;#123;&amp;#125;

module.version = &amp;quot;V0.1&amp;quot;
module.author = &amp;quot;litreily&amp;quot;

function module.func1 ()
    function-body
end

function module.func2 ()
    function-body
end

return module
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在其它文件通过 require 导入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lua&quot;&gt;require (&amp;quot;module&amp;quot;)
-- or
require &amp;quot;module&amp;quot;

print(module.version)
module.func1()

-- or
loc</summary>
      
    
    
    
    <category term="Language" scheme="https://www.litreily.top/categories/Language/"/>
    
    <category term="Lua" scheme="https://www.litreily.top/categories/Language/Lua/"/>
    
    
    <category term="lua" scheme="https://www.litreily.top/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua 基本语法</title>
    <link href="https://www.litreily.top/2020/12/24/lua-basic/"/>
    <id>https://www.litreily.top/2020/12/24/lua-basic/</id>
    <published>2020-12-24T03:19:14.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;h3 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;lua&quot;&gt;-- single line comment

--[[
    mutil line comments
]]
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Language" scheme="https://www.litreily.top/categories/Language/"/>
    
    <category term="Lua" scheme="https://www.litreily.top/categories/Language/Lua/"/>
    
    
    <category term="lua" scheme="https://www.litreily.top/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua 语言的基本使用</title>
    <link href="https://www.litreily.top/2020/12/23/lua/"/>
    <id>https://www.litreily.top/2020/12/23/lua/</id>
    <published>2020-12-23T01:07:51.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;在联网状态下，Ubuntu可以直接apt安装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;sudo apt install lua
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是不直接联网的服务器，并且没有root权限的情况下，需要先在联网PC上下载后导入，再编译安装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;wget http://www.lua.org/ftp/lua-5.1.5.tar.gz
# copy lua-5.1.5.tar.gz to server by scp or ftp
tar -xvf lua-5.1.5.tar.gz
cd lua-5.1.5
sed -i &amp;#39;s/\/usr\/local/~\/bin\/local/&amp;#39; Makefile
make generic
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认安装目录是&lt;code&gt;/usr/local&lt;/code&gt;, 如果没有root权限，需要修改Makefile，将其改为指定目录(~/bin/local)，上面通过sed修改。&lt;/p&gt;
&lt;p&gt;值得注意的是，Lua 如果按 make linux 编</summary>
      
    
    
    
    <category term="Language" scheme="https://www.litreily.top/categories/Language/"/>
    
    <category term="Lua" scheme="https://www.litreily.top/categories/Language/Lua/"/>
    
    
    <category term="lua" scheme="https://www.litreily.top/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>使用 gdb 解析 ppp driver crash log</title>
    <link href="https://www.litreily.top/2020/12/17/gdb-kernel/"/>
    <id>https://www.litreily.top/2020/12/17/gdb-kernel/</id>
    <published>2020-12-17T06:04:28.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;由于项目整合，经过一次大版本升级后的项目，继承了大家族中许多新的特性，然而在正常功能测试中崩溃了，而且还是kernel crash, 会导致reboot的那种。本文就此问题重现、调试分析过程予以归纳总结。&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;PPTP 拨号上网模式下，Router 在添加特定静态路由后crash. 添加路由的原因在本文讨论内容中不重要，因此略过。&lt;/p&gt;
&lt;h2 id=&quot;问题再现&quot;&gt;&lt;a href=&quot;#问题再现&quot; class=&quot;headerlink&quot; title=&quot;问题再现&quot;&gt;&lt;/a&gt;问题再现&lt;/h2&gt;&lt;p&gt;实际测试过程中寻找重现方法耗时较长，经过大量实验后简化如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接 WAN Port&lt;/li&gt;
&lt;li&gt;PPTP 拨号上网&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;拨号成功后，查看 &lt;code&gt;WAN&lt;/code&gt; 口及 &lt;code&gt;ppp0&lt;/code&gt; 的 IP.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;root@model:$ ifconfig brwan
brwan     Link encap:Ethernet  HWaddr 00:13:2F:34:42:59
          inet</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="openwrt" scheme="https://www.litreily.top/tags/openwrt/"/>
    
    <category term="gdb" scheme="https://www.litreily.top/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Setup PPTP and DNS server</title>
    <link href="https://www.litreily.top/2020/12/02/setup-pptp/"/>
    <id>https://www.litreily.top/2020/12/02/setup-pptp/</id>
    <published>2020-12-02T11:06:32.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;PPTP (Point to Point Tunneling Protocol) 点对点隧道协议，与PPPoE, L2TP 均属于 PPP(Point to Point Protocol) 点对点协议。这篇来记录下PPTP server的安装和配置过程。&lt;/p&gt;
&lt;h2 id=&quot;install-DHCP-server&quot;&gt;&lt;a href=&quot;#install-DHCP-server&quot; class=&quot;headerlink&quot; title=&quot;install DHCP server&quot;&gt;&lt;/a&gt;install DHCP server&lt;/h2&gt;&lt;p&gt;除了PPPoE外，PPTP 与 L2TP 都无法直接给client分配IP，需要使用dhcp server分配。所以在安装PPTP的同时，也要保证DHCP server也已安装。具体方法参考 &lt;a href=&quot;https://www.litreily.top/2020/01/17/dhcpd_server/&quot;&gt;Setup dhcpd/dhcpdv6 server&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;需要注意的是，在Ubuntu 20.10 版本中，网卡的静态IP管理模式与以往有所不同。在以往版本中，是修改 &lt;code&gt;/etc/network/interfaces&lt;/code&gt; 文件，但是在最新Ubuntu确不一样，最新版提出了一个叫 &lt;code&gt;netpl</summary>
      
    
    
    
    <category term="Network" scheme="https://www.litreily.top/categories/Network/"/>
    
    
    <category term="ubuntu" scheme="https://www.litreily.top/tags/ubuntu/"/>
    
    <category term="pptp" scheme="https://www.litreily.top/tags/pptp/"/>
    
    <category term="dns" scheme="https://www.litreily.top/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>openssl 验证证书有效性</title>
    <link href="https://www.litreily.top/2020/09/17/openssl/"/>
    <id>https://www.litreily.top/2020/09/17/openssl/</id>
    <published>2020-09-17T06:17:27.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;OpenSSL is a robust, commercial-grade, and full-featured toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols. It is also a general-purpose cryptography library.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;openssl是非常强大的TLS/SSL协议相关的工具集，包含丰富的测试工具。 这篇文章来讲讲如何使用openssl工具集中的&lt;code&gt;s_client&lt;/code&gt;测试证书认证。&lt;/p&gt;</summary>
    
    
    
    <category term="Network" scheme="https://www.litreily.top/categories/Network/"/>
    
    <category term="Security" scheme="https://www.litreily.top/categories/Network/Security/"/>
    
    
    <category term="openssl" scheme="https://www.litreily.top/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>python之给pdf添加页码</title>
    <link href="https://www.litreily.top/2020/08/13/python-pdf/"/>
    <id>https://www.litreily.top/2020/08/13/python-pdf/</id>
    <published>2020-08-13T08:56:37.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;最近写release note, 总感觉用&lt;code&gt;tex&lt;/code&gt;不太方便，特别是装&lt;code&gt;texlive&lt;/code&gt;占用大量空间，还有各种依赖问题，想着能不能用&lt;code&gt;markdown&lt;/code&gt;写更方便。实践证明，&lt;a href=&quot;https://typora.io/&quot;&gt;typora&lt;/a&gt;导出pdf的功能真的很棒，唯独一个不足之处就是生成的PDF不带&lt;strong&gt;页码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个虽然可以使用在线工具实现，或者使用Adobe、福昕的 pdf 编辑功能，但是很多情况，尤其是工作平台是不方便使用的。为此我想到了&lt;code&gt;Python&lt;/code&gt;，通过脚本把页码加上。&lt;/p&gt;
&lt;h2 id=&quot;安装Python库&quot;&gt;&lt;a href=&quot;#安装Python库&quot; class=&quot;headerlink&quot; title=&quot;安装Python库&quot;&gt;&lt;/a&gt;安装Python库&lt;/h2&gt;&lt;p&gt;首先需要安装两个依赖库，&lt;code&gt;PyPDF2&lt;/code&gt;以及&lt;code&gt;reportLab&lt;/code&gt;, &lt;code&gt;PyPDF2&lt;/code&gt;可以对PDF进行拆分、合并、删除、加密等操作；&lt;code&gt;reportlab&lt;/code&gt;则更是强大，看看下面的官方介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We build solutions to g</summary>
      
    
    
    
    <category term="Language" scheme="https://www.litreily.top/categories/Language/"/>
    
    <category term="Python" scheme="https://www.litreily.top/categories/Language/Python/"/>
    
    
    <category term="pdf" scheme="https://www.litreily.top/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫8 - 爬取彼岸图网美图</title>
    <link href="https://www.litreily.top/2020/08/09/netbian/"/>
    <id>https://www.litreily.top/2020/08/09/netbian/</id>
    <published>2020-08-09T02:54:47.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://pic.netbian.com/&quot;&gt;彼岸图网&lt;/a&gt;收集了大量美图，是个不错的爬取对象。话不多说，直接上图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netbian/netbian.png&quot; alt=&quot;彼岸图网&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析站点&quot;&gt;&lt;a href=&quot;#分析站点&quot; class=&quot;headerlink&quot; title=&quot;分析站点&quot;&gt;&lt;/a&gt;分析站点&lt;/h2&gt;&lt;h3 id=&quot;分类列表&quot;&gt;&lt;a href=&quot;#分类列表&quot; class=&quot;headerlink&quot; title=&quot;分类列表&quot;&gt;&lt;/a&gt;分类列表&lt;/h3&gt;&lt;p&gt;爬取之前，自然要分析一波，这个站点的框架比较简单，从分类着手，共包含12个分类项。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;4K人物&lt;/li&gt;
&lt;li&gt;4K动漫&lt;/li&gt;
&lt;li&gt;4K动物&lt;/li&gt;
&lt;li&gt;4K宗教&lt;/li&gt;
&lt;li&gt;4K影视&lt;/li&gt;
&lt;li&gt;4K明星&lt;/li&gt;
&lt;li&gt;4K汽车&lt;/li&gt;
&lt;li&gt;4K游戏&lt;/li&gt;
&lt;li&gt;4K美女&lt;/li&gt;
&lt;li&gt;4K美食&lt;/li&gt;
&lt;li&gt;4K背景&lt;/li&gt;
&lt;li&gt;4K风景&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;名称都含有4K，但是获取原图是需要会员的，所以我这里获取的不是原图，而是详细页展示的大图。首先要获取的当然是分类页面的网址，看下面的DOM.&lt;/p&gt;
&lt;p&gt;&lt;img </summary>
      
    
    
    
    <category term="Language" scheme="https://www.litreily.top/categories/Language/"/>
    
    <category term="Python" scheme="https://www.litreily.top/categories/Language/Python/"/>
    
    
    <category term="spider" scheme="https://www.litreily.top/tags/spider/"/>
    
    <category term="xpath" scheme="https://www.litreily.top/tags/xpath/"/>
    
    <category term="pool" scheme="https://www.litreily.top/tags/pool/"/>
    
  </entry>
  
  <entry>
    <title>VPS搭建在线VSCode Server</title>
    <link href="https://www.litreily.top/2020/06/13/code-server/"/>
    <id>https://www.litreily.top/2020/06/13/code-server/</id>
    <published>2020-06-13T06:41:26.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;VSCode-Server&quot;&gt;&lt;a href=&quot;#VSCode-Server&quot; class=&quot;headerlink&quot; title=&quot;VSCode Server&quot;&gt;&lt;/a&gt;VSCode Server&lt;/h2&gt;&lt;p&gt;VSCode(Visual Studio Code), 是我目前使用过的最好的编辑器，也应该是很多程序员的首选。然而很多人不知道的是，这款开发利器还有在线版，这包括GitHub即将推出的&lt;code&gt;Satellite&lt;/code&gt;, 也会搭载VSCode，那么如果我们想要搭建自己的在线开发环境呢？答案就是&lt;a href=&quot;https://github.com/cdr/code-server&quot;&gt;Code Server&lt;/a&gt;, 一款可以部署在个人服务器上的VSCode服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/vscode/pods-lg.png&quot; alt=&quot;pods logo&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;如果在本地，自然是无需搭建这个server的，我的选择是放在阿里云服务器上，对应的是Ubuntu系统，安装过程非常简单。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;curl -fsSL https://code</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
    <category term="ubuntu" scheme="https://www.litreily.top/tags/ubuntu/"/>
    
    <category term="vps" scheme="https://www.litreily.top/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>Win10中使用ssh访问WSL</title>
    <link href="https://www.litreily.top/2020/05/08/putty-wsl/"/>
    <id>https://www.litreily.top/2020/05/08/putty-wsl/</id>
    <published>2020-05-08T14:31:20.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;win10的WSL作为目前日常必备，实在是爱不释手，奈何默认终端界面实在一言难尽，尽管配色问题可以解决，但是字体问题导致ohmyzsh的很多图标无法正常显示，配置好&lt;a href=&quot;https://github.com/powerline/fonts&quot;&gt;powerline&lt;/a&gt;字体略有改善，但配合tmux使用又会出现乱码问题，实在难以忍受，于是准备通过ssh间接访问。&lt;/p&gt;
&lt;h2 id=&quot;配置ssh&quot;&gt;&lt;a href=&quot;#配置ssh&quot; class=&quot;headerlink&quot; title=&quot;配置ssh&quot;&gt;&lt;/a&gt;配置ssh&lt;/h2&gt;&lt;p&gt;重装&lt;code&gt;openssh-server&lt;/code&gt;, 如果自带的没问题也不用重装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;sudo apt remove openssh-server
sudo apt install openssh-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;# 服务端每分钟发送一次数据包给客户端，客户端回复即保持连接
ClientAliveInterval 60
# 客户端3次未响应则断开
ClientAliveCountMax 3

# 开启密码认证，拒绝空密码
Pa</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
    <category term="ssh" scheme="https://www.litreily.top/tags/ssh/"/>
    
    <category term="putty" scheme="https://www.litreily.top/tags/putty/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核驱动解析 - UBI坏块预留大小</title>
    <link href="https://www.litreily.top/2020/05/07/ubi-driver/"/>
    <id>https://www.litreily.top/2020/05/07/ubi-driver/</id>
    <published>2020-05-07T01:21:29.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;在处理ubifs相关bug的过程中，学习了ubi驱动对坏块保留分区的处理方式，在此记录一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/linux/ubi-reserved-maps.png&quot; alt=&quot;ubi reserved mind maps&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h2&gt;&lt;h3 id=&quot;mtd&quot;&gt;&lt;a href=&quot;#mtd&quot; class=&quot;headerlink&quot; title=&quot;mtd&quot;&gt;&lt;/a&gt;mtd&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;mtd&lt;/strong&gt; 全称 memory technology device 内存技术设备，是用于访问内存设备(RAM, Flash)的Linux 子系统，在硬件层和用户空间之间提供抽象接口。&lt;/p&gt;
&lt;p&gt;在嵌入式linux设备中的&lt;code&gt;/dev/&lt;/code&gt;目录下有很多&lt;code&gt;/dev/mtdxx&lt;/code&gt;文件，这些文件对应的就是内存设备。比如，嵌入式设备的Nand Flash被划分为多个分区，每个分区对应一个&lt;code&gt;/dev/mtdxx&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;如下所示，&lt;code&gt;/dev/mtd0&lt;/code&gt;至&lt;code&gt;/dev/mtd10&lt;/code&gt;对</summary>
      
    
    
    
    <category term="Embedded" scheme="https://www.litreily.top/categories/Embedded/"/>
    
    
    <category term="C/C++" scheme="https://www.litreily.top/tags/C-C/"/>
    
    <category term="ubi" scheme="https://www.litreily.top/tags/ubi/"/>
    
    <category term="flash" scheme="https://www.litreily.top/tags/flash/"/>
    
  </entry>
  
  <entry>
    <title>Python之markdown转Chrome收藏夹</title>
    <link href="https://www.litreily.top/2020/05/03/md2bm/"/>
    <id>https://www.litreily.top/2020/05/03/md2bm/</id>
    <published>2020-05-03T08:49:25.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;网上可以搜到很多chrome收藏夹转markdown文档的方法，却鲜有markdown文档转为Chrome收藏夹的方法，不过这种需求也确实不多。我之所以用到，是因为平常会用markdown文档收集一些网站，现在想要转换为Chrome收藏夹，方便访问。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;要实现这个功能倒也不难，因为Chrome的收藏夹本质上也是一个html文件，只不过有其固定的DOM结构而已，所以我们的实现思路很简单。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导出Chrome已有的收藏夹&lt;/li&gt;
&lt;li&gt;分析导出得到的html文件格式&lt;/li&gt;
&lt;li&gt;将自己需要转成Chrome收藏夹的markdown按相同格式转换为html文件&lt;/li&gt;
&lt;li&gt;在chrome中导入生成后的收藏夹&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;收藏夹的DOM结构&quot;&gt;&lt;a href=&quot;#收藏夹的DOM结构&quot; class=&quot;headerlink&quot; title=&quot;收藏夹的DOM结构&quot;&gt;&lt;/a&gt;收藏夹的DOM结构&lt;/h2&gt;&lt;p&gt;我导出了自己的收藏夹，取出其中一小部分为例进行分析，比较局部是可以反映整体的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!DOCTYPE NETSCAPE-B</summary>
      
    
    
    
    <category term="Language" scheme="https://www.litreily.top/categories/Language/"/>
    
    <category term="Python" scheme="https://www.litreily.top/categories/Language/Python/"/>
    
    
    <category term="markdown" scheme="https://www.litreily.top/tags/markdown/"/>
    
    <category term="chrome" scheme="https://www.litreily.top/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>解锁网易云音乐灰色无版权歌曲</title>
    <link href="https://www.litreily.top/2020/05/03/netease/"/>
    <id>https://www.litreily.top/2020/05/03/netease/</id>
    <published>2020-05-03T01:11:39.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;由于版权之争，网易云的很多歌曲都灰掉并且无法播放了，想要使其可以播放还是有办法的，万能的Google和Github让我找到了&lt;a href=&quot;https://github.com/nondanee/UnblockNeteaseMusic&quot;&gt;答案&lt;/a&gt;，直接上享用方法吧。&lt;/p&gt;
&lt;h2 id=&quot;前提条件&quot;&gt;&lt;a href=&quot;#前提条件&quot; class=&quot;headerlink&quot; title=&quot;前提条件&quot;&gt;&lt;/a&gt;前提条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个可以远程访问的服务器，比如vps，阿里云、腾讯云、...&lt;/li&gt;
&lt;li&gt;如果没有服务器，只能寻找别人搭建好的服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;搭建服务&quot;&gt;&lt;a href=&quot;#搭建服务&quot; class=&quot;headerlink&quot; title=&quot;搭建服务&quot;&gt;&lt;/a&gt;搭建服务&lt;/h2&gt;&lt;p&gt;在服务器端，首先安装依赖的工具&lt;code&gt;npx&lt;/code&gt;，如果有则忽略&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;sudo apt install npm
sudo npm i -g npx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后clone项目UnblockNeteaseMusic.git到本地&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;git clone git@github.com:nondanee/Unb</summary>
      
    
    
    
    <category term="Media" scheme="https://www.litreily.top/categories/Media/"/>
    
    
    <category term="music" scheme="https://www.litreily.top/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>lftp获取FTP Server端最新文件</title>
    <link href="https://www.litreily.top/2020/04/30/lftp_get/"/>
    <id>https://www.litreily.top/2020/04/30/lftp_get/</id>
    <published>2020-04-30T09:33:02.000Z</published>
    <updated>2021-05-28T03:12:11.503Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;最近解一个bug，要频繁编译和烧录FW，每次都要将image从远程的FTP server手动copy到本地，然后使用tftp进行烧录，实在不胜其烦。虽然上一篇&lt;a href=&quot;https://www.litreily.top/2020/04/27/tftp/&quot;&gt;简单实用的tftp烧录image脚本&lt;/a&gt;提高了烧录效率，但是每次将image拷贝到本地也是麻烦。&lt;/p&gt;
&lt;p&gt;这次，我依旧想到了WSL, 使用shell脚本还是更加方便快捷，思路很简单，检查server端的最新文件，得到文件名后使用lftp下载到本地。&lt;/p&gt;
&lt;h2 id=&quot;获取最新文件&quot;&gt;&lt;a href=&quot;#获取最新文件&quot; class=&quot;headerlink&quot; title=&quot;获取最新文件&quot;&gt;&lt;/a&gt;获取最新文件&lt;/h2&gt;&lt;p&gt;FTP Server文件存储方式是将每天的新数据归档到以当日日期命名的文件夹中，如今天&lt;code&gt;20200430&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;➜  lftp -u &amp;quot;username,password&amp;quot; ftp://1.2.3.4
lftp username@1.2.3.4:~&amp;gt; ls
04-27-20  02:03PM       &amp;lt;DIR&amp;gt;          20200427
04-29-20  05:3</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.litreily.top/categories/Linux/"/>
    
    
    <category term="shell" scheme="https://www.litreily.top/tags/shell/"/>
    
    <category term="ftp" scheme="https://www.litreily.top/tags/ftp/"/>
    
  </entry>
  
</feed>
